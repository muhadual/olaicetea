var nb = Object.defineProperty;
var rb = (a, e, t) => e in a ? nb(a, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : a[e] = t;
var ti = (a, e, t) => (rb(a, typeof e != "symbol" ? e + "" : e, t),
t);
(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
        s(i);
    new MutationObserver(i => {
        for (const n of i)
            if (n.type === "childList")
                for (const r of n.addedNodes)
                    r.tagName === "LINK" && r.rel === "modulepreload" && s(r)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function t(i) {
        const n = {};
        return i.integrity && (n.integrity = i.integrity),
        i.referrerPolicy && (n.referrerPolicy = i.referrerPolicy),
        i.crossOrigin === "use-credentials" ? n.credentials = "include" : i.crossOrigin === "anonymous" ? n.credentials = "omit" : n.credentials = "same-origin",
        n
    }
    function s(i) {
        if (i.ep)
            return;
        i.ep = !0;
        const n = t(i);
        fetch(i.href, n)
    }
}
)();
function ab(a) {
    if (a && !(typeof window > "u")) {
        var e = document.createElement("style");
        return e.setAttribute("type", "text/css"),
        e.innerHTML = a,
        document.head.appendChild(e),
        a
    }
}
function fo(a, e) {
    var t = a.__state.conversionName.toString()
      , s = Math.round(a.r)
      , i = Math.round(a.g)
      , n = Math.round(a.b)
      , r = a.a
      , o = Math.round(a.h)
      , l = a.s.toFixed(1)
      , c = a.v.toFixed(1);
    if (e || t === "THREE_CHAR_HEX" || t === "SIX_CHAR_HEX") {
        for (var d = a.hex.toString(16); d.length < 6; )
            d = "0" + d;
        return "#" + d
    } else {
        if (t === "CSS_RGB")
            return "rgb(" + s + "," + i + "," + n + ")";
        if (t === "CSS_RGBA")
            return "rgba(" + s + "," + i + "," + n + "," + r + ")";
        if (t === "HEX")
            return "0x" + a.hex.toString(16);
        if (t === "RGB_ARRAY")
            return "[" + s + "," + i + "," + n + "]";
        if (t === "RGBA_ARRAY")
            return "[" + s + "," + i + "," + n + "," + r + "]";
        if (t === "RGB_OBJ")
            return "{r:" + s + ",g:" + i + ",b:" + n + "}";
        if (t === "RGBA_OBJ")
            return "{r:" + s + ",g:" + i + ",b:" + n + ",a:" + r + "}";
        if (t === "HSV_OBJ")
            return "{h:" + o + ",s:" + l + ",v:" + c + "}";
        if (t === "HSVA_OBJ")
            return "{h:" + o + ",s:" + l + ",v:" + c + ",a:" + r + "}"
    }
    return "unknown format"
}
var Hg = Array.prototype.forEach
  , cl = Array.prototype.slice
  , Y = {
    BREAK: {},
    extend: function(e) {
        return this.each(cl.call(arguments, 1), function(t) {
            var s = this.isObject(t) ? Object.keys(t) : [];
            s.forEach((function(i) {
                this.isUndefined(t[i]) || (e[i] = t[i])
            }
            ).bind(this))
        }, this),
        e
    },
    defaults: function(e) {
        return this.each(cl.call(arguments, 1), function(t) {
            var s = this.isObject(t) ? Object.keys(t) : [];
            s.forEach((function(i) {
                this.isUndefined(e[i]) && (e[i] = t[i])
            }
            ).bind(this))
        }, this),
        e
    },
    compose: function() {
        var e = cl.call(arguments);
        return function() {
            for (var t = cl.call(arguments), s = e.length - 1; s >= 0; s--)
                t = [e[s].apply(this, t)];
            return t[0]
        }
    },
    each: function(e, t, s) {
        if (e) {
            if (Hg && e.forEach && e.forEach === Hg)
                e.forEach(t, s);
            else if (e.length === e.length + 0) {
                var i = void 0
                  , n = void 0;
                for (i = 0,
                n = e.length; i < n; i++)
                    if (i in e && t.call(s, e[i], i) === this.BREAK)
                        return
            } else
                for (var r in e)
                    if (t.call(s, e[r], r) === this.BREAK)
                        return
        }
    },
    defer: function(e) {
        setTimeout(e, 0)
    },
    debounce: function(e, t, s) {
        var i = void 0;
        return function() {
            var n = this
              , r = arguments;
            function o() {
                i = null,
                s || e.apply(n, r)
            }
            var l = s || !i;
            clearTimeout(i),
            i = setTimeout(o, t),
            l && e.apply(n, r)
        }
    },
    toArray: function(e) {
        return e.toArray ? e.toArray() : cl.call(e)
    },
    isUndefined: function(e) {
        return e === void 0
    },
    isNull: function(e) {
        return e === null
    },
    isNaN: function(a) {
        function e(t) {
            return a.apply(this, arguments)
        }
        return e.toString = function() {
            return a.toString()
        }
        ,
        e
    }(function(a) {
        return isNaN(a)
    }),
    isArray: Array.isArray || function(a) {
        return a.constructor === Array
    }
    ,
    isObject: function(e) {
        return e === Object(e)
    },
    isNumber: function(e) {
        return e === e + 0
    },
    isString: function(e) {
        return e === e + ""
    },
    isBoolean: function(e) {
        return e === !1 || e === !0
    },
    isFunction: function(e) {
        return e instanceof Function
    }
}
  , ob = [{
    litmus: Y.isString,
    conversions: {
        THREE_CHAR_HEX: {
            read: function(e) {
                var t = e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
                return t === null ? !1 : {
                    space: "HEX",
                    hex: parseInt("0x" + t[1].toString() + t[1].toString() + t[2].toString() + t[2].toString() + t[3].toString() + t[3].toString(), 0)
                }
            },
            write: fo
        },
        SIX_CHAR_HEX: {
            read: function(e) {
                var t = e.match(/^#([A-F0-9]{6})$/i);
                return t === null ? !1 : {
                    space: "HEX",
                    hex: parseInt("0x" + t[1].toString(), 0)
                }
            },
            write: fo
        },
        CSS_RGB: {
            read: function(e) {
                var t = e.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
                return t === null ? !1 : {
                    space: "RGB",
                    r: parseFloat(t[1]),
                    g: parseFloat(t[2]),
                    b: parseFloat(t[3])
                }
            },
            write: fo
        },
        CSS_RGBA: {
            read: function(e) {
                var t = e.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
                return t === null ? !1 : {
                    space: "RGB",
                    r: parseFloat(t[1]),
                    g: parseFloat(t[2]),
                    b: parseFloat(t[3]),
                    a: parseFloat(t[4])
                }
            },
            write: fo
        }
    }
}, {
    litmus: Y.isNumber,
    conversions: {
        HEX: {
            read: function(e) {
                return {
                    space: "HEX",
                    hex: e,
                    conversionName: "HEX"
                }
            },
            write: function(e) {
                return e.hex
            }
        }
    }
}, {
    litmus: Y.isArray,
    conversions: {
        RGB_ARRAY: {
            read: function(e) {
                return e.length !== 3 ? !1 : {
                    space: "RGB",
                    r: e[0],
                    g: e[1],
                    b: e[2]
                }
            },
            write: function(e) {
                return [e.r, e.g, e.b]
            }
        },
        RGBA_ARRAY: {
            read: function(e) {
                return e.length !== 4 ? !1 : {
                    space: "RGB",
                    r: e[0],
                    g: e[1],
                    b: e[2],
                    a: e[3]
                }
            },
            write: function(e) {
                return [e.r, e.g, e.b, e.a]
            }
        }
    }
}, {
    litmus: Y.isObject,
    conversions: {
        RGBA_OBJ: {
            read: function(e) {
                return Y.isNumber(e.r) && Y.isNumber(e.g) && Y.isNumber(e.b) && Y.isNumber(e.a) ? {
                    space: "RGB",
                    r: e.r,
                    g: e.g,
                    b: e.b,
                    a: e.a
                } : !1
            },
            write: function(e) {
                return {
                    r: e.r,
                    g: e.g,
                    b: e.b,
                    a: e.a
                }
            }
        },
        RGB_OBJ: {
            read: function(e) {
                return Y.isNumber(e.r) && Y.isNumber(e.g) && Y.isNumber(e.b) ? {
                    space: "RGB",
                    r: e.r,
                    g: e.g,
                    b: e.b
                } : !1
            },
            write: function(e) {
                return {
                    r: e.r,
                    g: e.g,
                    b: e.b
                }
            }
        },
        HSVA_OBJ: {
            read: function(e) {
                return Y.isNumber(e.h) && Y.isNumber(e.s) && Y.isNumber(e.v) && Y.isNumber(e.a) ? {
                    space: "HSV",
                    h: e.h,
                    s: e.s,
                    v: e.v,
                    a: e.a
                } : !1
            },
            write: function(e) {
                return {
                    h: e.h,
                    s: e.s,
                    v: e.v,
                    a: e.a
                }
            }
        },
        HSV_OBJ: {
            read: function(e) {
                return Y.isNumber(e.h) && Y.isNumber(e.s) && Y.isNumber(e.v) ? {
                    space: "HSV",
                    h: e.h,
                    s: e.s,
                    v: e.v
                } : !1
            },
            write: function(e) {
                return {
                    h: e.h,
                    s: e.s,
                    v: e.v
                }
            }
        }
    }
}]
  , dl = void 0
  , Ic = void 0
  , em = function() {
    Ic = !1;
    var e = arguments.length > 1 ? Y.toArray(arguments) : arguments[0];
    return Y.each(ob, function(t) {
        if (t.litmus(e))
            return Y.each(t.conversions, function(s, i) {
                if (dl = s.read(e),
                Ic === !1 && dl !== !1)
                    return Ic = dl,
                    dl.conversionName = i,
                    dl.conversion = s,
                    Y.BREAK
            }),
            Y.BREAK
    }),
    Ic
}
  , Wg = void 0
  , jd = {
    hsv_to_rgb: function(e, t, s) {
        var i = Math.floor(e / 60) % 6
          , n = e / 60 - Math.floor(e / 60)
          , r = s * (1 - t)
          , o = s * (1 - n * t)
          , l = s * (1 - (1 - n) * t)
          , c = [[s, l, r], [o, s, r], [r, s, l], [r, o, s], [l, r, s], [s, r, o]][i];
        return {
            r: c[0] * 255,
            g: c[1] * 255,
            b: c[2] * 255
        }
    },
    rgb_to_hsv: function(e, t, s) {
        var i = Math.min(e, t, s)
          , n = Math.max(e, t, s)
          , r = n - i
          , o = void 0
          , l = void 0;
        if (n !== 0)
            l = r / n;
        else
            return {
                h: NaN,
                s: 0,
                v: 0
            };
        return e === n ? o = (t - s) / r : t === n ? o = 2 + (s - e) / r : o = 4 + (e - t) / r,
        o /= 6,
        o < 0 && (o += 1),
        {
            h: o * 360,
            s: l,
            v: n / 255
        }
    },
    rgb_to_hex: function(e, t, s) {
        var i = this.hex_with_component(0, 2, e);
        return i = this.hex_with_component(i, 1, t),
        i = this.hex_with_component(i, 0, s),
        i
    },
    component_from_hex: function(e, t) {
        return e >> t * 8 & 255
    },
    hex_with_component: function(e, t, s) {
        return s << (Wg = t * 8) | e & ~(255 << Wg)
    }
}
  , lb = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(a) {
    return typeof a
}
: function(a) {
    return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
}
  , bi = function(a, e) {
    if (!(a instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
  , Ti = function() {
    function a(e, t) {
        for (var s = 0; s < t.length; s++) {
            var i = t[s];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(e, i.key, i)
        }
    }
    return function(e, t, s) {
        return t && a(e.prototype, t),
        s && a(e, s),
        e
    }
}()
  , hr = function a(e, t, s) {
    e === null && (e = Function.prototype);
    var i = Object.getOwnPropertyDescriptor(e, t);
    if (i === void 0) {
        var n = Object.getPrototypeOf(e);
        return n === null ? void 0 : a(n, t, s)
    } else {
        if ("value"in i)
            return i.value;
        var r = i.get;
        return r === void 0 ? void 0 : r.call(s)
    }
}
  , vr = function(a, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    a.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: a,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }),
    e && (Object.setPrototypeOf ? Object.setPrototypeOf(a, e) : a.__proto__ = e)
}
  , Sr = function(a, e) {
    if (!a)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : a
}
  , Ft = function() {
    function a() {
        if (bi(this, a),
        this.__state = em.apply(this, arguments),
        this.__state === !1)
            throw new Error("Failed to interpret color arguments");
        this.__state.a = this.__state.a || 1
    }
    return Ti(a, [{
        key: "toString",
        value: function() {
            return fo(this)
        }
    }, {
        key: "toHexString",
        value: function() {
            return fo(this, !0)
        }
    }, {
        key: "toOriginal",
        value: function() {
            return this.__state.conversion.write(this)
        }
    }]),
    a
}();
function m_(a, e, t) {
    Object.defineProperty(a, e, {
        get: function() {
            return this.__state.space === "RGB" ? this.__state[e] : (Ft.recalculateRGB(this, e, t),
            this.__state[e])
        },
        set: function(i) {
            this.__state.space !== "RGB" && (Ft.recalculateRGB(this, e, t),
            this.__state.space = "RGB"),
            this.__state[e] = i
        }
    })
}
function __(a, e) {
    Object.defineProperty(a, e, {
        get: function() {
            return this.__state.space === "HSV" ? this.__state[e] : (Ft.recalculateHSV(this),
            this.__state[e])
        },
        set: function(s) {
            this.__state.space !== "HSV" && (Ft.recalculateHSV(this),
            this.__state.space = "HSV"),
            this.__state[e] = s
        }
    })
}
Ft.recalculateRGB = function(a, e, t) {
    if (a.__state.space === "HEX")
        a.__state[e] = jd.component_from_hex(a.__state.hex, t);
    else if (a.__state.space === "HSV")
        Y.extend(a.__state, jd.hsv_to_rgb(a.__state.h, a.__state.s, a.__state.v));
    else
        throw new Error("Corrupted color state")
}
;
Ft.recalculateHSV = function(a) {
    var e = jd.rgb_to_hsv(a.r, a.g, a.b);
    Y.extend(a.__state, {
        s: e.s,
        v: e.v
    }),
    Y.isNaN(e.h) ? Y.isUndefined(a.__state.h) && (a.__state.h = 0) : a.__state.h = e.h
}
;
Ft.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"];
m_(Ft.prototype, "r", 2);
m_(Ft.prototype, "g", 1);
m_(Ft.prototype, "b", 0);
__(Ft.prototype, "h");
__(Ft.prototype, "s");
__(Ft.prototype, "v");
Object.defineProperty(Ft.prototype, "a", {
    get: function() {
        return this.__state.a
    },
    set: function(e) {
        this.__state.a = e
    }
});
Object.defineProperty(Ft.prototype, "hex", {
    get: function() {
        return this.__state.space !== "HEX" && (this.__state.hex = jd.rgb_to_hex(this.r, this.g, this.b),
        this.__state.space = "HEX"),
        this.__state.hex
    },
    set: function(e) {
        this.__state.space = "HEX",
        this.__state.hex = e
    }
});
var wa = function() {
    function a(e, t) {
        bi(this, a),
        this.initialValue = e[t],
        this.domElement = document.createElement("div"),
        this.object = e,
        this.property = t,
        this.__onChange = void 0,
        this.__onFinishChange = void 0
    }
    return Ti(a, [{
        key: "onChange",
        value: function(t) {
            return this.__onChange = t,
            this
        }
    }, {
        key: "onFinishChange",
        value: function(t) {
            return this.__onFinishChange = t,
            this
        }
    }, {
        key: "setValue",
        value: function(t) {
            return this.object[this.property] = t,
            this.__onChange && this.__onChange.call(this, t),
            this.updateDisplay(),
            this
        }
    }, {
        key: "getValue",
        value: function() {
            return this.object[this.property]
        }
    }, {
        key: "updateDisplay",
        value: function() {
            return this
        }
    }, {
        key: "isModified",
        value: function() {
            return this.initialValue !== this.getValue()
        }
    }]),
    a
}()
  , hb = {
    HTMLEvents: ["change"],
    MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
    KeyboardEvents: ["keydown"]
}
  , pS = {};
Y.each(hb, function(a, e) {
    Y.each(a, function(t) {
        pS[t] = e
    })
});
var cb = /(\d+(\.\d+)?)px/;
function Ai(a) {
    if (a === "0" || Y.isUndefined(a))
        return 0;
    var e = a.match(cb);
    return Y.isNull(e) ? 0 : parseFloat(e[1])
}
var G = {
    makeSelectable: function(e, t) {
        e === void 0 || e.style === void 0 || (e.onselectstart = t ? function() {
            return !1
        }
        : function() {}
        ,
        e.style.MozUserSelect = t ? "auto" : "none",
        e.style.KhtmlUserSelect = t ? "auto" : "none",
        e.unselectable = t ? "on" : "off")
    },
    makeFullscreen: function(e, t, s) {
        var i = s
          , n = t;
        Y.isUndefined(n) && (n = !0),
        Y.isUndefined(i) && (i = !0),
        e.style.position = "absolute",
        n && (e.style.left = 0,
        e.style.right = 0),
        i && (e.style.top = 0,
        e.style.bottom = 0)
    },
    fakeEvent: function(e, t, s, i) {
        var n = s || {}
          , r = pS[t];
        if (!r)
            throw new Error("Event type " + t + " not supported.");
        var o = document.createEvent(r);
        switch (r) {
        case "MouseEvents":
            {
                var l = n.x || n.clientX || 0
                  , c = n.y || n.clientY || 0;
                o.initMouseEvent(t, n.bubbles || !1, n.cancelable || !0, window, n.clickCount || 1, 0, 0, l, c, !1, !1, !1, !1, 0, null);
                break
            }
        case "KeyboardEvents":
            {
                var d = o.initKeyboardEvent || o.initKeyEvent;
                Y.defaults(n, {
                    cancelable: !0,
                    ctrlKey: !1,
                    altKey: !1,
                    shiftKey: !1,
                    metaKey: !1,
                    keyCode: void 0,
                    charCode: void 0
                }),
                d(t, n.bubbles || !1, n.cancelable, window, n.ctrlKey, n.altKey, n.shiftKey, n.metaKey, n.keyCode, n.charCode);
                break
            }
        default:
            {
                o.initEvent(t, n.bubbles || !1, n.cancelable || !0);
                break
            }
        }
        Y.defaults(o, i),
        e.dispatchEvent(o)
    },
    bind: function(e, t, s, i) {
        var n = i || !1;
        return e.addEventListener ? e.addEventListener(t, s, n) : e.attachEvent && e.attachEvent("on" + t, s),
        G
    },
    unbind: function(e, t, s, i) {
        var n = i || !1;
        return e.removeEventListener ? e.removeEventListener(t, s, n) : e.detachEvent && e.detachEvent("on" + t, s),
        G
    },
    addClass: function(e, t) {
        if (e.className === void 0)
            e.className = t;
        else if (e.className !== t) {
            var s = e.className.split(/ +/);
            s.indexOf(t) === -1 && (s.push(t),
            e.className = s.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""))
        }
        return G
    },
    removeClass: function(e, t) {
        if (t)
            if (e.className === t)
                e.removeAttribute("class");
            else {
                var s = e.className.split(/ +/)
                  , i = s.indexOf(t);
                i !== -1 && (s.splice(i, 1),
                e.className = s.join(" "))
            }
        else
            e.className = void 0;
        return G
    },
    hasClass: function(e, t) {
        return new RegExp("(?:^|\\s+)" + t + "(?:\\s+|$)").test(e.className) || !1
    },
    getWidth: function(e) {
        var t = getComputedStyle(e);
        return Ai(t["border-left-width"]) + Ai(t["border-right-width"]) + Ai(t["padding-left"]) + Ai(t["padding-right"]) + Ai(t.width)
    },
    getHeight: function(e) {
        var t = getComputedStyle(e);
        return Ai(t["border-top-width"]) + Ai(t["border-bottom-width"]) + Ai(t["padding-top"]) + Ai(t["padding-bottom"]) + Ai(t.height)
    },
    getOffset: function(e) {
        var t = e
          , s = {
            left: 0,
            top: 0
        };
        if (t.offsetParent)
            do
                s.left += t.offsetLeft,
                s.top += t.offsetTop,
                t = t.offsetParent;
            while (t);
        return s
    },
    isActive: function(e) {
        return e === document.activeElement && (e.type || e.href)
    }
}
  , mS = function(a) {
    vr(e, a);
    function e(t, s) {
        bi(this, e);
        var i = Sr(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, s))
          , n = i;
        i.__prev = i.getValue(),
        i.__checkbox = document.createElement("input"),
        i.__checkbox.setAttribute("type", "checkbox");
        function r() {
            n.setValue(!n.__prev)
        }
        return G.bind(i.__checkbox, "change", r, !1),
        i.domElement.appendChild(i.__checkbox),
        i.updateDisplay(),
        i
    }
    return Ti(e, [{
        key: "setValue",
        value: function(s) {
            var i = hr(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, s);
            return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()),
            this.__prev = this.getValue(),
            i
        }
    }, {
        key: "updateDisplay",
        value: function() {
            return this.getValue() === !0 ? (this.__checkbox.setAttribute("checked", "checked"),
            this.__checkbox.checked = !0,
            this.__prev = !0) : (this.__checkbox.checked = !1,
            this.__prev = !1),
            hr(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
        }
    }]),
    e
}(wa)
  , db = function(a) {
    vr(e, a);
    function e(t, s, i) {
        bi(this, e);
        var n = Sr(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, s))
          , r = i
          , o = n;
        if (n.__select = document.createElement("select"),
        Y.isArray(r)) {
            var l = {};
            Y.each(r, function(c) {
                l[c] = c
            }),
            r = l
        }
        return Y.each(r, function(c, d) {
            var h = document.createElement("option");
            h.innerHTML = d,
            h.setAttribute("value", c),
            o.__select.appendChild(h)
        }),
        n.updateDisplay(),
        G.bind(n.__select, "change", function() {
            var c = this.options[this.selectedIndex].value;
            o.setValue(c)
        }),
        n.domElement.appendChild(n.__select),
        n
    }
    return Ti(e, [{
        key: "setValue",
        value: function(s) {
            var i = hr(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, s);
            return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()),
            i
        }
    }, {
        key: "updateDisplay",
        value: function() {
            return G.isActive(this.__select) ? this : (this.__select.value = this.getValue(),
            hr(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this))
        }
    }]),
    e
}(wa)
  , ub = function(a) {
    vr(e, a);
    function e(t, s) {
        bi(this, e);
        var i = Sr(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, s))
          , n = i;
        function r() {
            n.setValue(n.__input.value)
        }
        function o() {
            n.__onFinishChange && n.__onFinishChange.call(n, n.getValue())
        }
        return i.__input = document.createElement("input"),
        i.__input.setAttribute("type", "text"),
        G.bind(i.__input, "keyup", r),
        G.bind(i.__input, "change", r),
        G.bind(i.__input, "blur", o),
        G.bind(i.__input, "keydown", function(l) {
            l.keyCode === 13 && this.blur()
        }),
        i.updateDisplay(),
        i.domElement.appendChild(i.__input),
        i
    }
    return Ti(e, [{
        key: "updateDisplay",
        value: function() {
            return G.isActive(this.__input) || (this.__input.value = this.getValue()),
            hr(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
        }
    }]),
    e
}(wa);
function Xg(a) {
    var e = a.toString();
    return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0
}
var _S = function(a) {
    vr(e, a);
    function e(t, s, i) {
        bi(this, e);
        var n = Sr(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, s))
          , r = i || {};
        return n.__min = r.min,
        n.__max = r.max,
        n.__step = r.step,
        Y.isUndefined(n.__step) ? n.initialValue === 0 ? n.__impliedStep = 1 : n.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(n.initialValue)) / Math.LN10)) / 10 : n.__impliedStep = n.__step,
        n.__precision = Xg(n.__impliedStep),
        n
    }
    return Ti(e, [{
        key: "setValue",
        value: function(s) {
            var i = s;
            return this.__min !== void 0 && i < this.__min ? i = this.__min : this.__max !== void 0 && i > this.__max && (i = this.__max),
            this.__step !== void 0 && i % this.__step !== 0 && (i = Math.round(i / this.__step) * this.__step),
            hr(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, i)
        }
    }, {
        key: "min",
        value: function(s) {
            return this.__min = s,
            this
        }
    }, {
        key: "max",
        value: function(s) {
            return this.__max = s,
            this
        }
    }, {
        key: "step",
        value: function(s) {
            return this.__step = s,
            this.__impliedStep = s,
            this.__precision = Xg(s),
            this
        }
    }]),
    e
}(wa);
function fb(a, e) {
    var t = Math.pow(10, e);
    return Math.round(a * t) / t
}
var $d = function(a) {
    vr(e, a);
    function e(t, s, i) {
        bi(this, e);
        var n = Sr(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, s, i));
        n.__truncationSuspended = !1;
        var r = n
          , o = void 0;
        function l() {
            var p = parseFloat(r.__input.value);
            Y.isNaN(p) || r.setValue(p)
        }
        function c() {
            r.__onFinishChange && r.__onFinishChange.call(r, r.getValue())
        }
        function d() {
            c()
        }
        function h(p) {
            var _ = o - p.clientY;
            r.setValue(r.getValue() + _ * r.__impliedStep),
            o = p.clientY
        }
        function u() {
            G.unbind(window, "mousemove", h),
            G.unbind(window, "mouseup", u),
            c()
        }
        function f(p) {
            G.bind(window, "mousemove", h),
            G.bind(window, "mouseup", u),
            o = p.clientY
        }
        return n.__input = document.createElement("input"),
        n.__input.setAttribute("type", "text"),
        G.bind(n.__input, "change", l),
        G.bind(n.__input, "blur", d),
        G.bind(n.__input, "mousedown", f),
        G.bind(n.__input, "keydown", function(p) {
            p.keyCode === 13 && (r.__truncationSuspended = !0,
            this.blur(),
            r.__truncationSuspended = !1,
            c())
        }),
        n.updateDisplay(),
        n.domElement.appendChild(n.__input),
        n
    }
    return Ti(e, [{
        key: "updateDisplay",
        value: function() {
            return this.__input.value = this.__truncationSuspended ? this.getValue() : fb(this.getValue(), this.__precision),
            hr(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
        }
    }]),
    e
}(_S);
function jg(a, e, t, s, i) {
    return s + (i - s) * ((a - e) / (t - e))
}
var tm = function(a) {
    vr(e, a);
    function e(t, s, i, n, r) {
        bi(this, e);
        var o = Sr(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, s, {
            min: i,
            max: n,
            step: r
        }))
          , l = o;
        o.__background = document.createElement("div"),
        o.__foreground = document.createElement("div"),
        G.bind(o.__background, "mousedown", c),
        G.bind(o.__background, "touchstart", u),
        G.addClass(o.__background, "slider"),
        G.addClass(o.__foreground, "slider-fg");
        function c(_) {
            document.activeElement.blur(),
            G.bind(window, "mousemove", d),
            G.bind(window, "mouseup", h),
            d(_)
        }
        function d(_) {
            _.preventDefault();
            var m = l.__background.getBoundingClientRect();
            return l.setValue(jg(_.clientX, m.left, m.right, l.__min, l.__max)),
            !1
        }
        function h() {
            G.unbind(window, "mousemove", d),
            G.unbind(window, "mouseup", h),
            l.__onFinishChange && l.__onFinishChange.call(l, l.getValue())
        }
        function u(_) {
            _.touches.length === 1 && (G.bind(window, "touchmove", f),
            G.bind(window, "touchend", p),
            f(_))
        }
        function f(_) {
            var m = _.touches[0].clientX
              , g = l.__background.getBoundingClientRect();
            l.setValue(jg(m, g.left, g.right, l.__min, l.__max))
        }
        function p() {
            G.unbind(window, "touchmove", f),
            G.unbind(window, "touchend", p),
            l.__onFinishChange && l.__onFinishChange.call(l, l.getValue())
        }
        return o.updateDisplay(),
        o.__background.appendChild(o.__foreground),
        o.domElement.appendChild(o.__background),
        o
    }
    return Ti(e, [{
        key: "updateDisplay",
        value: function() {
            var s = (this.getValue() - this.__min) / (this.__max - this.__min);
            return this.__foreground.style.width = s * 100 + "%",
            hr(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
        }
    }]),
    e
}(_S)
  , gS = function(a) {
    vr(e, a);
    function e(t, s, i) {
        bi(this, e);
        var n = Sr(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, s))
          , r = n;
        return n.__button = document.createElement("div"),
        n.__button.innerHTML = i === void 0 ? "Fire" : i,
        G.bind(n.__button, "click", function(o) {
            return o.preventDefault(),
            r.fire(),
            !1
        }),
        G.addClass(n.__button, "button"),
        n.domElement.appendChild(n.__button),
        n
    }
    return Ti(e, [{
        key: "fire",
        value: function() {
            this.__onChange && this.__onChange.call(this),
            this.getValue().call(this.object),
            this.__onFinishChange && this.__onFinishChange.call(this, this.getValue())
        }
    }]),
    e
}(wa)
  , sm = function(a) {
    vr(e, a);
    function e(t, s) {
        bi(this, e);
        var i = Sr(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, s));
        i.__color = new Ft(i.getValue()),
        i.__temp = new Ft(0);
        var n = i;
        i.domElement = document.createElement("div"),
        G.makeSelectable(i.domElement, !1),
        i.__selector = document.createElement("div"),
        i.__selector.className = "selector",
        i.__saturation_field = document.createElement("div"),
        i.__saturation_field.className = "saturation-field",
        i.__field_knob = document.createElement("div"),
        i.__field_knob.className = "field-knob",
        i.__field_knob_border = "2px solid ",
        i.__hue_knob = document.createElement("div"),
        i.__hue_knob.className = "hue-knob",
        i.__hue_field = document.createElement("div"),
        i.__hue_field.className = "hue-field",
        i.__input = document.createElement("input"),
        i.__input.type = "text",
        i.__input_textShadow = "0 1px 1px ",
        G.bind(i.__input, "keydown", function(_) {
            _.keyCode === 13 && h.call(this)
        }),
        G.bind(i.__input, "blur", h),
        G.bind(i.__selector, "mousedown", function() {
            G.addClass(this, "drag").bind(window, "mouseup", function() {
                G.removeClass(n.__selector, "drag")
            })
        }),
        G.bind(i.__selector, "touchstart", function() {
            G.addClass(this, "drag").bind(window, "touchend", function() {
                G.removeClass(n.__selector, "drag")
            })
        });
        var r = document.createElement("div");
        Y.extend(i.__selector.style, {
            width: "122px",
            height: "102px",
            padding: "3px",
            backgroundColor: "#222",
            boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
        }),
        Y.extend(i.__field_knob.style, {
            position: "absolute",
            width: "12px",
            height: "12px",
            border: i.__field_knob_border + (i.__color.v < .5 ? "#fff" : "#000"),
            boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
            borderRadius: "12px",
            zIndex: 1
        }),
        Y.extend(i.__hue_knob.style, {
            position: "absolute",
            width: "15px",
            height: "2px",
            borderRight: "4px solid #fff",
            zIndex: 1
        }),
        Y.extend(i.__saturation_field.style, {
            width: "100px",
            height: "100px",
            border: "1px solid #555",
            marginRight: "3px",
            display: "inline-block",
            cursor: "pointer"
        }),
        Y.extend(r.style, {
            width: "100%",
            height: "100%",
            background: "none"
        }),
        $g(r, "top", "rgba(0,0,0,0)", "#000"),
        Y.extend(i.__hue_field.style, {
            width: "15px",
            height: "100px",
            border: "1px solid #555",
            cursor: "ns-resize",
            position: "absolute",
            top: "3px",
            right: "3px"
        }),
        mb(i.__hue_field),
        Y.extend(i.__input.style, {
            outline: "none",
            textAlign: "center",
            color: "#fff",
            border: 0,
            fontWeight: "bold",
            textShadow: i.__input_textShadow + "rgba(0,0,0,0.7)"
        }),
        G.bind(i.__saturation_field, "mousedown", o),
        G.bind(i.__saturation_field, "touchstart", o),
        G.bind(i.__field_knob, "mousedown", o),
        G.bind(i.__field_knob, "touchstart", o),
        G.bind(i.__hue_field, "mousedown", l),
        G.bind(i.__hue_field, "touchstart", l);
        function o(_) {
            f(_),
            G.bind(window, "mousemove", f),
            G.bind(window, "touchmove", f),
            G.bind(window, "mouseup", c),
            G.bind(window, "touchend", c)
        }
        function l(_) {
            p(_),
            G.bind(window, "mousemove", p),
            G.bind(window, "touchmove", p),
            G.bind(window, "mouseup", d),
            G.bind(window, "touchend", d)
        }
        function c() {
            G.unbind(window, "mousemove", f),
            G.unbind(window, "touchmove", f),
            G.unbind(window, "mouseup", c),
            G.unbind(window, "touchend", c),
            u()
        }
        function d() {
            G.unbind(window, "mousemove", p),
            G.unbind(window, "touchmove", p),
            G.unbind(window, "mouseup", d),
            G.unbind(window, "touchend", d),
            u()
        }
        function h() {
            var _ = em(this.value);
            _ !== !1 ? (n.__color.__state = _,
            n.setValue(n.__color.toOriginal())) : this.value = n.__color.toString()
        }
        function u() {
            n.__onFinishChange && n.__onFinishChange.call(n, n.__color.toOriginal())
        }
        i.__saturation_field.appendChild(r),
        i.__selector.appendChild(i.__field_knob),
        i.__selector.appendChild(i.__saturation_field),
        i.__selector.appendChild(i.__hue_field),
        i.__hue_field.appendChild(i.__hue_knob),
        i.domElement.appendChild(i.__input),
        i.domElement.appendChild(i.__selector),
        i.updateDisplay();
        function f(_) {
            _.type.indexOf("touch") === -1 && _.preventDefault();
            var m = n.__saturation_field.getBoundingClientRect()
              , g = _.touches && _.touches[0] || _
              , v = g.clientX
              , x = g.clientY
              , S = (v - m.left) / (m.right - m.left)
              , w = 1 - (x - m.top) / (m.bottom - m.top);
            return w > 1 ? w = 1 : w < 0 && (w = 0),
            S > 1 ? S = 1 : S < 0 && (S = 0),
            n.__color.v = w,
            n.__color.s = S,
            n.setValue(n.__color.toOriginal()),
            !1
        }
        function p(_) {
            _.type.indexOf("touch") === -1 && _.preventDefault();
            var m = n.__hue_field.getBoundingClientRect()
              , g = _.touches && _.touches[0] || _
              , v = g.clientY
              , x = 1 - (v - m.top) / (m.bottom - m.top);
            return x > 1 ? x = 1 : x < 0 && (x = 0),
            n.__color.h = x * 360,
            n.setValue(n.__color.toOriginal()),
            !1
        }
        return i
    }
    return Ti(e, [{
        key: "updateDisplay",
        value: function() {
            var s = em(this.getValue());
            if (s !== !1) {
                var i = !1;
                Y.each(Ft.COMPONENTS, function(o) {
                    if (!Y.isUndefined(s[o]) && !Y.isUndefined(this.__color.__state[o]) && s[o] !== this.__color.__state[o])
                        return i = !0,
                        {}
                }, this),
                i && Y.extend(this.__color.__state, s)
            }
            Y.extend(this.__temp.__state, this.__color.__state),
            this.__temp.a = 1;
            var n = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0
              , r = 255 - n;
            Y.extend(this.__field_knob.style, {
                marginLeft: 100 * this.__color.s - 7 + "px",
                marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                backgroundColor: this.__temp.toHexString(),
                border: this.__field_knob_border + "rgb(" + n + "," + n + "," + n + ")"
            }),
            this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + "px",
            this.__temp.s = 1,
            this.__temp.v = 1,
            $g(this.__saturation_field, "left", "#fff", this.__temp.toHexString()),
            this.__input.value = this.__color.toString(),
            Y.extend(this.__input.style, {
                backgroundColor: this.__color.toHexString(),
                color: "rgb(" + n + "," + n + "," + n + ")",
                textShadow: this.__input_textShadow + "rgba(" + r + "," + r + "," + r + ",.7)"
            })
        }
    }]),
    e
}(wa)
  , pb = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
function $g(a, e, t, s) {
    a.style.background = "",
    Y.each(pb, function(i) {
        a.style.cssText += "background: " + i + "linear-gradient(" + e + ", " + t + " 0%, " + s + " 100%); "
    })
}
function mb(a) {
    a.style.background = "",
    a.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);",
    a.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",
    a.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",
    a.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",
    a.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"
}
var _b = {
    load: function(e, t) {
        var s = t || document
          , i = s.createElement("link");
        i.type = "text/css",
        i.rel = "stylesheet",
        i.href = e,
        s.getElementsByTagName("head")[0].appendChild(i)
    },
    inject: function(e, t) {
        var s = t || document
          , i = document.createElement("style");
        i.type = "text/css",
        i.innerHTML = e;
        var n = s.getElementsByTagName("head")[0];
        try {
            n.appendChild(i)
        } catch {}
    }
}
  , gb = `<div id="dg-save" class="dg dialogue">

  Here's the new load parameter for your <code>GUI</code>'s constructor:

  <textarea id="dg-new-constructor"></textarea>

  <div id="dg-save-locally">

    <input id="dg-local-storage" type="checkbox"/> Automatically save
    values to <code>localStorage</code> on exit.

    <div id="dg-local-explain">The values saved to <code>localStorage</code> will
      override those passed to <code>dat.GUI</code>'s constructor. This makes it
      easier to work incrementally, but <code>localStorage</code> is fragile,
      and your friends may not see the same values you do.

    </div>

  </div>

</div>`
  , yb = function(e, t) {
    var s = e[t];
    return Y.isArray(arguments[2]) || Y.isObject(arguments[2]) ? new db(e,t,arguments[2]) : Y.isNumber(s) ? Y.isNumber(arguments[2]) && Y.isNumber(arguments[3]) ? Y.isNumber(arguments[4]) ? new tm(e,t,arguments[2],arguments[3],arguments[4]) : new tm(e,t,arguments[2],arguments[3]) : Y.isNumber(arguments[4]) ? new $d(e,t,{
        min: arguments[2],
        max: arguments[3],
        step: arguments[4]
    }) : new $d(e,t,{
        min: arguments[2],
        max: arguments[3]
    }) : Y.isString(s) ? new ub(e,t) : Y.isFunction(s) ? new gS(e,t,"") : Y.isBoolean(s) ? new mS(e,t) : null
};
function vb(a) {
    setTimeout(a, 1e3 / 60)
}
var Sb = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || vb
  , xb = function() {
    function a() {
        bi(this, a),
        this.backgroundElement = document.createElement("div"),
        Y.extend(this.backgroundElement.style, {
            backgroundColor: "rgba(0,0,0,0.8)",
            top: 0,
            left: 0,
            display: "none",
            zIndex: "1000",
            opacity: 0,
            WebkitTransition: "opacity 0.2s linear",
            transition: "opacity 0.2s linear"
        }),
        G.makeFullscreen(this.backgroundElement),
        this.backgroundElement.style.position = "fixed",
        this.domElement = document.createElement("div"),
        Y.extend(this.domElement.style, {
            position: "fixed",
            display: "none",
            zIndex: "1001",
            opacity: 0,
            WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
            transition: "transform 0.2s ease-out, opacity 0.2s linear"
        }),
        document.body.appendChild(this.backgroundElement),
        document.body.appendChild(this.domElement);
        var e = this;
        G.bind(this.backgroundElement, "click", function() {
            e.hide()
        })
    }
    return Ti(a, [{
        key: "show",
        value: function() {
            var t = this;
            this.backgroundElement.style.display = "block",
            this.domElement.style.display = "block",
            this.domElement.style.opacity = 0,
            this.domElement.style.webkitTransform = "scale(1.1)",
            this.layout(),
            Y.defer(function() {
                t.backgroundElement.style.opacity = 1,
                t.domElement.style.opacity = 1,
                t.domElement.style.webkitTransform = "scale(1)"
            })
        }
    }, {
        key: "hide",
        value: function() {
            var t = this
              , s = function i() {
                t.domElement.style.display = "none",
                t.backgroundElement.style.display = "none",
                G.unbind(t.domElement, "webkitTransitionEnd", i),
                G.unbind(t.domElement, "transitionend", i),
                G.unbind(t.domElement, "oTransitionEnd", i)
            };
            G.bind(this.domElement, "webkitTransitionEnd", s),
            G.bind(this.domElement, "transitionend", s),
            G.bind(this.domElement, "oTransitionEnd", s),
            this.backgroundElement.style.opacity = 0,
            this.domElement.style.opacity = 0,
            this.domElement.style.webkitTransform = "scale(1.1)"
        }
    }, {
        key: "layout",
        value: function() {
            this.domElement.style.left = window.innerWidth / 2 - G.getWidth(this.domElement) / 2 + "px",
            this.domElement.style.top = window.innerHeight / 2 - G.getHeight(this.domElement) / 2 + "px"
        }
    }]),
    a
}()
  , wb = ab(`.dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}
`);
_b.inject(wb);
var qg = "dg"
  , Yg = 72
  , Kg = 20
  , dh = "Default"
  , Ul = function() {
    try {
        return !!window.localStorage
    } catch {
        return !1
    }
}()
  , ql = void 0
  , Zg = !0
  , oo = void 0
  , Nf = !1
  , yS = []
  , tt = function a(e) {
    var t = this
      , s = e || {};
    this.domElement = document.createElement("div"),
    this.__ul = document.createElement("ul"),
    this.domElement.appendChild(this.__ul),
    G.addClass(this.domElement, qg),
    this.__folders = {},
    this.__controllers = [],
    this.__rememberedObjects = [],
    this.__rememberedObjectIndecesToControllers = [],
    this.__listening = [],
    s = Y.defaults(s, {
        closeOnTop: !1,
        autoPlace: !0,
        width: a.DEFAULT_WIDTH
    }),
    s = Y.defaults(s, {
        resizable: s.autoPlace,
        hideable: s.autoPlace
    }),
    Y.isUndefined(s.load) ? s.load = {
        preset: dh
    } : s.preset && (s.load.preset = s.preset),
    Y.isUndefined(s.parent) && s.hideable && yS.push(this),
    s.resizable = Y.isUndefined(s.parent) && s.resizable,
    s.autoPlace && Y.isUndefined(s.scrollable) && (s.scrollable = !0);
    var i = Ul && localStorage.getItem(lo(this, "isLocal")) === "true"
      , n = void 0
      , r = void 0;
    if (Object.defineProperties(this, {
        parent: {
            get: function() {
                return s.parent
            }
        },
        scrollable: {
            get: function() {
                return s.scrollable
            }
        },
        autoPlace: {
            get: function() {
                return s.autoPlace
            }
        },
        closeOnTop: {
            get: function() {
                return s.closeOnTop
            }
        },
        preset: {
            get: function() {
                return t.parent ? t.getRoot().preset : s.load.preset
            },
            set: function(u) {
                t.parent ? t.getRoot().preset = u : s.load.preset = u,
                Eb(this),
                t.revert()
            }
        },
        width: {
            get: function() {
                return s.width
            },
            set: function(u) {
                s.width = u,
                rm(t, u)
            }
        },
        name: {
            get: function() {
                return s.name
            },
            set: function(u) {
                s.name = u,
                r && (r.innerHTML = s.name)
            }
        },
        closed: {
            get: function() {
                return s.closed
            },
            set: function(u) {
                s.closed = u,
                s.closed ? G.addClass(t.__ul, a.CLASS_CLOSED) : G.removeClass(t.__ul, a.CLASS_CLOSED),
                this.onResize(),
                t.__closeButton && (t.__closeButton.innerHTML = u ? a.TEXT_OPEN : a.TEXT_CLOSED)
            }
        },
        load: {
            get: function() {
                return s.load
            }
        },
        useLocalStorage: {
            get: function() {
                return i
            },
            set: function(u) {
                Ul && (i = u,
                u ? G.bind(window, "unload", n) : G.unbind(window, "unload", n),
                localStorage.setItem(lo(t, "isLocal"), u))
            }
        }
    }),
    Y.isUndefined(s.parent)) {
        if (this.closed = s.closed || !1,
        G.addClass(this.domElement, a.CLASS_MAIN),
        G.makeSelectable(this.domElement, !1),
        Ul && i) {
            t.useLocalStorage = !0;
            var o = localStorage.getItem(lo(this, "gui"));
            o && (s.load = JSON.parse(o))
        }
        this.__closeButton = document.createElement("div"),
        this.__closeButton.innerHTML = a.TEXT_CLOSED,
        G.addClass(this.__closeButton, a.CLASS_CLOSE_BUTTON),
        s.closeOnTop ? (G.addClass(this.__closeButton, a.CLASS_CLOSE_TOP),
        this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (G.addClass(this.__closeButton, a.CLASS_CLOSE_BOTTOM),
        this.domElement.appendChild(this.__closeButton)),
        G.bind(this.__closeButton, "click", function() {
            t.closed = !t.closed
        })
    } else {
        s.closed === void 0 && (s.closed = !0);
        var l = document.createTextNode(s.name);
        G.addClass(l, "controller-name"),
        r = g_(t, l);
        var c = function(u) {
            return u.preventDefault(),
            t.closed = !t.closed,
            !1
        };
        G.addClass(this.__ul, a.CLASS_CLOSED),
        G.addClass(r, "title"),
        G.bind(r, "click", c),
        s.closed || (this.closed = !1)
    }
    s.autoPlace && (Y.isUndefined(s.parent) && (Zg && (oo = document.createElement("div"),
    G.addClass(oo, qg),
    G.addClass(oo, a.CLASS_AUTO_PLACE_CONTAINER),
    document.body.appendChild(oo),
    Zg = !1),
    oo.appendChild(this.domElement),
    G.addClass(this.domElement, a.CLASS_AUTO_PLACE)),
    this.parent || rm(t, s.width)),
    this.__resizeHandler = function() {
        t.onResizeDebounced()
    }
    ,
    G.bind(window, "resize", this.__resizeHandler),
    G.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler),
    G.bind(this.__ul, "transitionend", this.__resizeHandler),
    G.bind(this.__ul, "oTransitionEnd", this.__resizeHandler),
    this.onResize(),
    s.resizable && Cb(this),
    n = function() {
        Ul && localStorage.getItem(lo(t, "isLocal")) === "true" && localStorage.setItem(lo(t, "gui"), JSON.stringify(t.getSaveObject()))
    }
    ,
    this.saveToLocalStorageIfPossible = n;
    function d() {
        var h = t.getRoot();
        h.width += 1,
        Y.defer(function() {
            h.width -= 1
        })
    }
    s.parent || d()
};
tt.toggleHide = function() {
    Nf = !Nf,
    Y.each(yS, function(a) {
        a.domElement.style.display = Nf ? "none" : ""
    })
}
;
tt.CLASS_AUTO_PLACE = "a";
tt.CLASS_AUTO_PLACE_CONTAINER = "ac";
tt.CLASS_MAIN = "main";
tt.CLASS_CONTROLLER_ROW = "cr";
tt.CLASS_TOO_TALL = "taller-than-window";
tt.CLASS_CLOSED = "closed";
tt.CLASS_CLOSE_BUTTON = "close-button";
tt.CLASS_CLOSE_TOP = "close-top";
tt.CLASS_CLOSE_BOTTOM = "close-bottom";
tt.CLASS_DRAG = "drag";
tt.DEFAULT_WIDTH = 245;
tt.TEXT_CLOSED = "Close Controls";
tt.TEXT_OPEN = "Open Controls";
tt._keydownHandler = function(a) {
    document.activeElement.type !== "text" && (a.which === Yg || a.keyCode === Yg) && tt.toggleHide()
}
;
G.bind(window, "keydown", tt._keydownHandler, !1);
Y.extend(tt.prototype, {
    add: function(e, t) {
        return Yl(this, e, t, {
            factoryArgs: Array.prototype.slice.call(arguments, 2)
        })
    },
    addColor: function(e, t) {
        return Yl(this, e, t, {
            color: !0
        })
    },
    remove: function(e) {
        this.__ul.removeChild(e.__li),
        this.__controllers.splice(this.__controllers.indexOf(e), 1);
        var t = this;
        Y.defer(function() {
            t.onResize()
        })
    },
    destroy: function() {
        if (this.parent)
            throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
        this.autoPlace && oo.removeChild(this.domElement);
        var e = this;
        Y.each(this.__folders, function(t) {
            e.removeFolder(t)
        }),
        G.unbind(window, "keydown", tt._keydownHandler, !1),
        Qg(this)
    },
    addFolder: function(e) {
        if (this.__folders[e] !== void 0)
            throw new Error('You already have a folder in this GUI by the name "' + e + '"');
        var t = {
            name: e,
            parent: this
        };
        t.autoPlace = this.autoPlace,
        this.load && this.load.folders && this.load.folders[e] && (t.closed = this.load.folders[e].closed,
        t.load = this.load.folders[e]);
        var s = new tt(t);
        this.__folders[e] = s;
        var i = g_(this, s.domElement);
        return G.addClass(i, "folder"),
        s
    },
    removeFolder: function(e) {
        this.__ul.removeChild(e.domElement.parentElement),
        delete this.__folders[e.name],
        this.load && this.load.folders && this.load.folders[e.name] && delete this.load.folders[e.name],
        Qg(e);
        var t = this;
        Y.each(e.__folders, function(s) {
            e.removeFolder(s)
        }),
        Y.defer(function() {
            t.onResize()
        })
    },
    open: function() {
        this.closed = !1
    },
    close: function() {
        this.closed = !0
    },
    hide: function() {
        this.domElement.style.display = "none"
    },
    show: function() {
        this.domElement.style.display = ""
    },
    onResize: function() {
        var e = this.getRoot();
        if (e.scrollable) {
            var t = G.getOffset(e.__ul).top
              , s = 0;
            Y.each(e.__ul.childNodes, function(i) {
                e.autoPlace && i === e.__save_row || (s += G.getHeight(i))
            }),
            window.innerHeight - t - Kg < s ? (G.addClass(e.domElement, tt.CLASS_TOO_TALL),
            e.__ul.style.height = window.innerHeight - t - Kg + "px") : (G.removeClass(e.domElement, tt.CLASS_TOO_TALL),
            e.__ul.style.height = "auto")
        }
        e.__resize_handle && Y.defer(function() {
            e.__resize_handle.style.height = e.__ul.offsetHeight + "px"
        }),
        e.__closeButton && (e.__closeButton.style.width = e.width + "px")
    },
    onResizeDebounced: Y.debounce(function() {
        this.onResize()
    }, 50),
    remember: function() {
        if (Y.isUndefined(ql) && (ql = new xb,
        ql.domElement.innerHTML = gb),
        this.parent)
            throw new Error("You can only call remember on a top level GUI.");
        var e = this;
        Y.each(Array.prototype.slice.call(arguments), function(t) {
            e.__rememberedObjects.length === 0 && Tb(e),
            e.__rememberedObjects.indexOf(t) === -1 && e.__rememberedObjects.push(t)
        }),
        this.autoPlace && rm(this, this.width)
    },
    getRoot: function() {
        for (var e = this; e.parent; )
            e = e.parent;
        return e
    },
    getSaveObject: function() {
        var e = this.load;
        return e.closed = this.closed,
        this.__rememberedObjects.length > 0 && (e.preset = this.preset,
        e.remembered || (e.remembered = {}),
        e.remembered[this.preset] = Lc(this)),
        e.folders = {},
        Y.each(this.__folders, function(t, s) {
            e.folders[s] = t.getSaveObject()
        }),
        e
    },
    save: function() {
        this.load.remembered || (this.load.remembered = {}),
        this.load.remembered[this.preset] = Lc(this),
        im(this, !1),
        this.saveToLocalStorageIfPossible()
    },
    saveAs: function(e) {
        this.load.remembered || (this.load.remembered = {},
        this.load.remembered[dh] = Lc(this, !0)),
        this.load.remembered[e] = Lc(this),
        this.preset = e,
        nm(this, e, !0),
        this.saveToLocalStorageIfPossible()
    },
    revert: function(e) {
        Y.each(this.__controllers, function(t) {
            this.getRoot().load.remembered ? vS(e || this.getRoot(), t) : t.setValue(t.initialValue),
            t.__onFinishChange && t.__onFinishChange.call(t, t.getValue())
        }, this),
        Y.each(this.__folders, function(t) {
            t.revert(t)
        }),
        e || im(this.getRoot(), !1)
    },
    listen: function(e) {
        var t = this.__listening.length === 0;
        this.__listening.push(e),
        t && SS(this.__listening)
    },
    updateDisplay: function() {
        Y.each(this.__controllers, function(e) {
            e.updateDisplay()
        }),
        Y.each(this.__folders, function(e) {
            e.updateDisplay()
        })
    }
});
function g_(a, e, t) {
    var s = document.createElement("li");
    return e && s.appendChild(e),
    t ? a.__ul.insertBefore(s, t) : a.__ul.appendChild(s),
    a.onResize(),
    s
}
function Qg(a) {
    G.unbind(window, "resize", a.__resizeHandler),
    a.saveToLocalStorageIfPossible && G.unbind(window, "unload", a.saveToLocalStorageIfPossible)
}
function im(a, e) {
    var t = a.__preset_select[a.__preset_select.selectedIndex];
    e ? t.innerHTML = t.value + "*" : t.innerHTML = t.value
}
function bb(a, e, t) {
    if (t.__li = e,
    t.__gui = a,
    Y.extend(t, {
        options: function(r) {
            if (arguments.length > 1) {
                var o = t.__li.nextElementSibling;
                return t.remove(),
                Yl(a, t.object, t.property, {
                    before: o,
                    factoryArgs: [Y.toArray(arguments)]
                })
            }
            if (Y.isArray(r) || Y.isObject(r)) {
                var l = t.__li.nextElementSibling;
                return t.remove(),
                Yl(a, t.object, t.property, {
                    before: l,
                    factoryArgs: [r]
                })
            }
        },
        name: function(r) {
            return t.__li.firstElementChild.firstElementChild.innerHTML = r,
            t
        },
        listen: function() {
            return t.__gui.listen(t),
            t
        },
        remove: function() {
            return t.__gui.remove(t),
            t
        }
    }),
    t instanceof tm) {
        var s = new $d(t.object,t.property,{
            min: t.__min,
            max: t.__max,
            step: t.__step
        });
        Y.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], function(n) {
            var r = t[n]
              , o = s[n];
            t[n] = s[n] = function() {
                var l = Array.prototype.slice.call(arguments);
                return o.apply(s, l),
                r.apply(t, l)
            }
        }),
        G.addClass(e, "has-slider"),
        t.domElement.insertBefore(s.domElement, t.domElement.firstElementChild)
    } else if (t instanceof $d) {
        var i = function(r) {
            if (Y.isNumber(t.__min) && Y.isNumber(t.__max)) {
                var o = t.__li.firstElementChild.firstElementChild.innerHTML
                  , l = t.__gui.__listening.indexOf(t) > -1;
                t.remove();
                var c = Yl(a, t.object, t.property, {
                    before: t.__li.nextElementSibling,
                    factoryArgs: [t.__min, t.__max, t.__step]
                });
                return c.name(o),
                l && c.listen(),
                c
            }
            return r
        };
        t.min = Y.compose(i, t.min),
        t.max = Y.compose(i, t.max)
    } else
        t instanceof mS ? (G.bind(e, "click", function() {
            G.fakeEvent(t.__checkbox, "click")
        }),
        G.bind(t.__checkbox, "click", function(n) {
            n.stopPropagation()
        })) : t instanceof gS ? (G.bind(e, "click", function() {
            G.fakeEvent(t.__button, "click")
        }),
        G.bind(e, "mouseover", function() {
            G.addClass(t.__button, "hover")
        }),
        G.bind(e, "mouseout", function() {
            G.removeClass(t.__button, "hover")
        })) : t instanceof sm && (G.addClass(e, "color"),
        t.updateDisplay = Y.compose(function(n) {
            return e.style.borderLeftColor = t.__color.toString(),
            n
        }, t.updateDisplay),
        t.updateDisplay());
    t.setValue = Y.compose(function(n) {
        return a.getRoot().__preset_select && t.isModified() && im(a.getRoot(), !0),
        n
    }, t.setValue)
}
function vS(a, e) {
    var t = a.getRoot()
      , s = t.__rememberedObjects.indexOf(e.object);
    if (s !== -1) {
        var i = t.__rememberedObjectIndecesToControllers[s];
        if (i === void 0 && (i = {},
        t.__rememberedObjectIndecesToControllers[s] = i),
        i[e.property] = e,
        t.load && t.load.remembered) {
            var n = t.load.remembered
              , r = void 0;
            if (n[a.preset])
                r = n[a.preset];
            else if (n[dh])
                r = n[dh];
            else
                return;
            if (r[s] && r[s][e.property] !== void 0) {
                var o = r[s][e.property];
                e.initialValue = o,
                e.setValue(o)
            }
        }
    }
}
function Yl(a, e, t, s) {
    if (e[t] === void 0)
        throw new Error('Object "' + e + '" has no property "' + t + '"');
    var i = void 0;
    if (s.color)
        i = new sm(e,t);
    else {
        var n = [e, t].concat(s.factoryArgs);
        i = yb.apply(a, n)
    }
    s.before instanceof wa && (s.before = s.before.__li),
    vS(a, i),
    G.addClass(i.domElement, "c");
    var r = document.createElement("span");
    G.addClass(r, "property-name"),
    r.innerHTML = i.property;
    var o = document.createElement("div");
    o.appendChild(r),
    o.appendChild(i.domElement);
    var l = g_(a, o, s.before);
    return G.addClass(l, tt.CLASS_CONTROLLER_ROW),
    i instanceof sm ? G.addClass(l, "color") : G.addClass(l, lb(i.getValue())),
    bb(a, l, i),
    a.__controllers.push(i),
    i
}
function lo(a, e) {
    return document.location.href + "." + e
}
function nm(a, e, t) {
    var s = document.createElement("option");
    s.innerHTML = e,
    s.value = e,
    a.__preset_select.appendChild(s),
    t && (a.__preset_select.selectedIndex = a.__preset_select.length - 1)
}
function Jg(a, e) {
    e.style.display = a.useLocalStorage ? "block" : "none"
}
function Tb(a) {
    var e = a.__save_row = document.createElement("li");
    G.addClass(a.domElement, "has-save"),
    a.__ul.insertBefore(e, a.__ul.firstChild),
    G.addClass(e, "save-row");
    var t = document.createElement("span");
    t.innerHTML = "&nbsp;",
    G.addClass(t, "button gears");
    var s = document.createElement("span");
    s.innerHTML = "Save",
    G.addClass(s, "button"),
    G.addClass(s, "save");
    var i = document.createElement("span");
    i.innerHTML = "New",
    G.addClass(i, "button"),
    G.addClass(i, "save-as");
    var n = document.createElement("span");
    n.innerHTML = "Revert",
    G.addClass(n, "button"),
    G.addClass(n, "revert");
    var r = a.__preset_select = document.createElement("select");
    if (a.load && a.load.remembered ? Y.each(a.load.remembered, function(h, u) {
        nm(a, u, u === a.preset)
    }) : nm(a, dh, !1),
    G.bind(r, "change", function() {
        for (var h = 0; h < a.__preset_select.length; h++)
            a.__preset_select[h].innerHTML = a.__preset_select[h].value;
        a.preset = this.value
    }),
    e.appendChild(r),
    e.appendChild(t),
    e.appendChild(s),
    e.appendChild(i),
    e.appendChild(n),
    Ul) {
        var o = document.getElementById("dg-local-explain")
          , l = document.getElementById("dg-local-storage")
          , c = document.getElementById("dg-save-locally");
        c.style.display = "block",
        localStorage.getItem(lo(a, "isLocal")) === "true" && l.setAttribute("checked", "checked"),
        Jg(a, o),
        G.bind(l, "change", function() {
            a.useLocalStorage = !a.useLocalStorage,
            Jg(a, o)
        })
    }
    var d = document.getElementById("dg-new-constructor");
    G.bind(d, "keydown", function(h) {
        h.metaKey && (h.which === 67 || h.keyCode === 67) && ql.hide()
    }),
    G.bind(t, "click", function() {
        d.innerHTML = JSON.stringify(a.getSaveObject(), void 0, 2),
        ql.show(),
        d.focus(),
        d.select()
    }),
    G.bind(s, "click", function() {
        a.save()
    }),
    G.bind(i, "click", function() {
        var h = prompt("Enter a new preset name.");
        h && a.saveAs(h)
    }),
    G.bind(n, "click", function() {
        a.revert()
    })
}
function Cb(a) {
    var e = void 0;
    a.__resize_handle = document.createElement("div"),
    Y.extend(a.__resize_handle.style, {
        width: "6px",
        marginLeft: "-3px",
        height: "200px",
        cursor: "ew-resize",
        position: "absolute"
    });
    function t(n) {
        return n.preventDefault(),
        a.width += e - n.clientX,
        a.onResize(),
        e = n.clientX,
        !1
    }
    function s() {
        G.removeClass(a.__closeButton, tt.CLASS_DRAG),
        G.unbind(window, "mousemove", t),
        G.unbind(window, "mouseup", s)
    }
    function i(n) {
        return n.preventDefault(),
        e = n.clientX,
        G.addClass(a.__closeButton, tt.CLASS_DRAG),
        G.bind(window, "mousemove", t),
        G.bind(window, "mouseup", s),
        !1
    }
    G.bind(a.__resize_handle, "mousedown", i),
    G.bind(a.__closeButton, "mousedown", i),
    a.domElement.insertBefore(a.__resize_handle, a.domElement.firstElementChild)
}
function rm(a, e) {
    a.domElement.style.width = e + "px",
    a.__save_row && a.autoPlace && (a.__save_row.style.width = e + "px"),
    a.__closeButton && (a.__closeButton.style.width = e + "px")
}
function Lc(a, e) {
    var t = {};
    return Y.each(a.__rememberedObjects, function(s, i) {
        var n = {}
          , r = a.__rememberedObjectIndecesToControllers[i];
        Y.each(r, function(o, l) {
            n[l] = e ? o.initialValue : o.getValue()
        }),
        t[i] = n
    }),
    t
}
function Eb(a) {
    for (var e = 0; e < a.__preset_select.length; e++)
        a.__preset_select[e].value === a.preset && (a.__preset_select.selectedIndex = e)
}
function SS(a) {
    a.length !== 0 && Sb.call(window, function() {
        SS(a)
    }),
    Y.each(a, function(e) {
        e.updateDisplay()
    })
}
const B = Object.freeze({
    GAME_CODE: "purusgames-beat-blader-3d-001",
    GAME_WIDTH: 1920,
    GAME_HEIGHT: 1080,
    DEBUG_ON: !1,
    DEBUG_BOX_COLLIDER: !1,
    DEBUG_SHOW_AREA: !1,
    DEBUG_SHOW_PATH: !1,
    DEBUG_DRAW_KILLAREA: !1,
    DEBUG_UI: !1,
    CHEAT_AUTO_PLAY: !1,
    START_WITH_AUTO_PLAY: !1,
    SOUND_ENABLED: !0,
    SHOW_GAME_TAG: !1,
    PLATFORM_ANDROID: "android",
    PLATFORM_IOS: "ios",
    SCENE_PLAY: "Play",
    SCENE_ENDCARD: "EndCard",
    SCENE_HOME: "HomeScene",
    SCENE_TRANSITION: "TransitionScene",
    SCREEN_SPIN: "Spin",
    SCREEN_TUTORIAL: "Tutorial",
    SCREEN_PLAY: "Play",
    SCREEN_PAUSE: "Pause",
    SCREEN_ENDCARD: "EndCard",
    SCREEN_LOSE: "Lose",
    SCREEN_WIN: "Win",
    SCREEN_RESULT: "Result ",
    SCREEN_HOME: "HomeScreen",
    SCREEN_REVIVE: "Revive",
    SCREEN_SHOP: "Shop",
    SCREEN_REWARD: "Reward",
    GAME_LIFE: 2,
    GAME_SPEED: 35,
    BOX_SCORE: 1,
    SPIN_ANGLE: -2340,
    SPIN_DURATION: 3,
    SPIN_LOAD_DELAY: 1.25,
    LOSE_DELAY: 2,
    CAMERA_X: 0,
    CAMERA_Y: 5.7,
    CAMERA_Z: -6.5,
    CAMERA_ROTATE_X: -32,
    CAMERA_ROTATE_Y: 180,
    CAMERA_ROTATE_Z: 0,
    CAMERA_FOV: 90,
    DEFAULT_COLOR: "yellow",
    SIN_WAVE_SPEED: 20,
    VISUALIZER_SPEED: 4,
    VISUALIZER_JUMP_SPEED: 10,
    VISUALIZER_RETURN_SPEED: 5,
    WAVE_HEIGHT: .5,
    VISUALIZER_MAX_HEIGHT: 2.5,
    VISUALIZER_MIN_HEIGHT: 1,
    VISUALIZER_OFFSET: 2,
    VISUALIZER_ENABLE_TIME: .2,
    SHOP_WEAPON: "weapon",
    SHOP_SKIN: "skin",
    SHOP_THEME: "theme",
    SHOP_SONG: "song",
    CLOUD_SPAWN_Z: 100,
    CLOUD_SPAWN_GAP: 4.5,
    REVERT_TIME: 1,
    GAME_SETTING_KEY: {
        VIBRATION: "vibration"
    },
    STORAGE: {
        CLEAR_ON_START: !1,
        KEY_SETTING: "setting",
        KEY_CURRENT_SONG: "current_song",
        KEY_DEFAULT_SONG: "song002",
        KEY_SONGS_UNLOCKED: "songs_unlocked",
        WEAPON: "weapon",
        KEY_SKIN_UNLOCKED: "skin_unlocked",
        KEY_CURRENT_SKIN: "current_skin",
        KEY_DEFAULT_SKIN: "skin_001",
        KEY_CURRENT_WEAPON: "current_weapon",
        KEY_WEAPON_UNLOCKED: "weapon_unlocked",
        KEY_DEFAULT_WEAPON: "weapon_001",
        KEY_CURRENT_THEME: "current_theme",
        KEY_DEFAULT_THEME: "theme_01",
        KEY_THEMES_UNLOCKED: "themes_unlocked",
        GAME_PLAY_HISTORY: "game_play_history",
        KEY_CURRENCY: "currency",
        DEFAULT_CURRENCY: 0
    }
})
  , Ab = "GpuTimings"
  , Mb = "1.68.2"
  , Pb = "581ec4b"
  , Rb = ["undefined", "number", "string", "boolean"]
  , Ib = {
    "[object Array]": "array",
    "[object Object]": "object",
    "[object Function]": "function",
    "[object Date]": "date",
    "[object RegExp]": "regexp",
    "[object Float32Array]": "float32array"
};
function ey(a) {
    if (a === null)
        return "null";
    const e = typeof a;
    return Rb.includes(e) ? e : Ib[Object.prototype.toString.call(a)]
}
function or(a, e) {
    for (const t in e) {
        const s = e[t];
        ey(s) === "object" ? a[t] = or({}, s) : ey(s) === "array" ? a[t] = or([], s) : a[t] = s
    }
    return a
}
class Uh {
    static set(e, t=!0) {}
    static get(e) {
        return Uh._traceChannels.has(e)
    }
}
Uh._traceChannels = new Set;
Uh.stack = !1;
class Lb {
    constructor(e, t, s, i, n=!1) {
        this.handler = void 0,
        this.name = void 0,
        this.callback = void 0,
        this.scope = void 0,
        this._once = void 0,
        this._removed = !1,
        this.handler = e,
        this.name = t,
        this.callback = s,
        this.scope = i,
        this._once = n
    }
    off() {
        this._removed || this.handler.off(this.name, this.callback, this.scope)
    }
    on(e, t, s=this) {
        return this.handler._addCallback(e, t, s, !1)
    }
    once(e, t, s=this) {
        return this.handler._addCallback(e, t, s, !0)
    }
    set removed(e) {
        e && (this._removed = !0)
    }
    get removed() {
        return this._removed
    }
}
class fe {
    constructor() {
        this._callbacks = new Map,
        this._callbackActive = new Map
    }
    initEventHandler() {
        this._callbacks = new Map,
        this._callbackActive = new Map
    }
    _addCallback(e, t, s, i) {
        if (this._callbacks.has(e) || this._callbacks.set(e, []),
        this._callbackActive.has(e)) {
            const r = this._callbackActive.get(e);
            r && r === this._callbacks.get(e) && this._callbackActive.set(e, r.slice())
        }
        const n = new Lb(this,e,t,s,i);
        return this._callbacks.get(e).push(n),
        n
    }
    on(e, t, s=this) {
        return this._addCallback(e, t, s, !1)
    }
    once(e, t, s=this) {
        return this._addCallback(e, t, s, !0)
    }
    off(e, t, s) {
        if (e)
            this._callbackActive.has(e) && this._callbackActive.get(e) === this._callbacks.get(e) && this._callbackActive.set(e, this._callbackActive.get(e).slice());
        else
            for (const [i,n] of this._callbackActive)
                this._callbacks.has(i) && this._callbacks.get(i) === n && this._callbackActive.set(i, n.slice());
        if (e)
            if (t) {
                const i = this._callbacks.get(e);
                if (!i)
                    return this;
                for (let n = 0; n < i.length; n++)
                    i[n].callback === t && (s && i[n].scope !== s || (i[n].removed = !0,
                    i.splice(n, 1),
                    n--));
                i.length === 0 && this._callbacks.delete(e)
            } else {
                const i = this._callbacks.get(e);
                if (i) {
                    for (let n = 0; n < i.length; n++)
                        i[n].removed = !0;
                    this._callbacks.delete(e)
                }
            }
        else {
            for (const i of this._callbacks.values())
                for (let n = 0; n < i.length; n++)
                    i[n].removed = !0;
            this._callbacks.clear()
        }
        return this
    }
    fire(e, t, s, i, n, r, o, l, c) {
        if (!e)
            return this;
        const d = this._callbacks.get(e);
        if (!d)
            return this;
        let h;
        this._callbackActive.has(e) ? this._callbackActive.get(e) !== d && (h = d.slice()) : this._callbackActive.set(e, d);
        for (let u = 0; (h || this._callbackActive.get(e)) && u < (h || this._callbackActive.get(e)).length; u++) {
            const f = (h || this._callbackActive.get(e))[u];
            if (f.callback && (f.callback.call(f.scope, t, s, i, n, r, o, l, c),
            f._once)) {
                const p = this._callbacks.get(e)
                  , _ = p ? p.indexOf(f) : -1;
                if (_ !== -1) {
                    this._callbackActive.get(e) === p && this._callbackActive.set(e, this._callbackActive.get(e).slice());
                    const m = this._callbacks.get(e);
                    if (!m)
                        continue;
                    m[_].removed = !0,
                    m.splice(_, 1),
                    m.length === 0 && this._callbacks.delete(e)
                }
            }
        }
        return h || this._callbackActive.delete(e),
        this
    }
    hasEvent(e) {
        var t;
        return !!((t = this._callbacks.get(e)) != null && t.length)
    }
}
const y_ = {
    attach(a) {
        const e = y_;
        return a._addCallback = e._addCallback,
        a.on = e.on,
        a.off = e.off,
        a.fire = e.fire,
        a.once = e.once,
        a.hasEvent = e.hasEvent,
        fe.prototype.initEventHandler.call(a),
        a
    },
    _addCallback: fe.prototype._addCallback,
    on: fe.prototype.on,
    off: fe.prototype.off,
    fire: fe.prototype.fire,
    once: fe.prototype.once,
    hasEvent: fe.prototype.hasEvent
}
  , Db = {
    create() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(a) {
            const e = Math.random() * 16 | 0;
            return (a === "x" ? e : e & 3 | 8).toString(16)
        })
    }
}
  , ye = {
    delimiter: "/",
    join(...a) {
        let e = a[0];
        for (let t = 0; t < a.length - 1; t++) {
            const s = a[t]
              , i = a[t + 1];
            if (i[0] === ye.delimiter) {
                e = i;
                continue
            }
            s && i && s[s.length - 1] !== ye.delimiter && i[0] !== ye.delimiter ? e += ye.delimiter + i : e += i
        }
        return e
    },
    normalize(a) {
        const e = a.startsWith(ye.delimiter)
          , t = a.endsWith(ye.delimiter)
          , s = a.split("/");
        let i = ""
          , n = [];
        for (let r = 0; r < s.length; r++)
            if (s[r] !== "" && s[r] !== ".") {
                if (s[r] === ".." && n.length > 0) {
                    n = n.slice(0, n.length - 2);
                    continue
                }
                r > 0 && n.push(ye.delimiter),
                n.push(s[r])
            }
        return i = n.join(""),
        !e && i[0] === ye.delimiter && (i = i.slice(1)),
        t && i[i.length - 1] !== ye.delimiter && (i += ye.delimiter),
        i
    },
    split(a) {
        const e = a.lastIndexOf(ye.delimiter);
        return e !== -1 ? [a.substring(0, e), a.substring(e + 1)] : ["", a]
    },
    getBasename(a) {
        return ye.split(a)[1]
    },
    getDirectory(a) {
        return ye.split(a)[0]
    },
    getExtension(a) {
        const e = a.split("?")[0].split(".").pop();
        return e !== a ? "." + e : ""
    },
    isRelativePath(a) {
        return a.charAt(0) !== "/" && a.match(/:\/\//) === null
    },
    extractPath(a) {
        let e = "";
        const t = a.split("/");
        let s = 0;
        if (t.length > 1)
            if (ye.isRelativePath(a))
                if (t[0] === ".")
                    for (s = 0; s < t.length - 1; ++s)
                        e += s === 0 ? t[s] : "/" + t[s];
                else if (t[0] === "..")
                    for (s = 0; s < t.length - 1; ++s)
                        e += s === 0 ? t[s] : "/" + t[s];
                else
                    for (e = ".",
                    s = 0; s < t.length - 1; ++s)
                        e += "/" + t[s];
            else
                for (s = 0; s < t.length - 1; ++s)
                    e += s === 0 ? t[s] : "/" + t[s];
        return e
    }
}
  , Ob = () => {
    let a = !1;
    try {
        const e = Object.defineProperty({}, "passive", {
            get: function() {
                return a = !0,
                !1
            }
        });
        window.addEventListener("testpassive", null, e),
        window.removeEventListener("testpassive", null, e)
    } catch {}
    return a
}
  , Li = typeof navigator < "u" ? navigator.userAgent : ""
  , So = typeof window < "u" ? "browser" : "node"
  , ul = /android/i.test(Li) ? "android" : /ip([ao]d|hone)/i.test(Li) ? "ios" : /windows/i.test(Li) ? "windows" : /mac os/i.test(Li) ? "osx" : /linux/i.test(Li) ? "linux" : /cros/i.test(Li) ? "cros" : null
  , Fb = So !== "browser" ? null : /(Chrome\/|Chromium\/|Edg.*\/)/.test(Li) ? "chrome" : /Safari\//.test(Li) ? "safari" : /Firefox\//.test(Li) ? "firefox" : "other"
  , Bb = /xbox/i.test(Li)
  , kb = So === "browser" && ("ontouchstart"in window || "maxTouchPoints"in navigator && navigator.maxTouchPoints > 0)
  , Nb = So === "browser" && (!!navigator.getGamepads || !!navigator.webkitGetGamepads)
  , Ub = typeof Worker < "u"
  , zb = Ob()
  , Le = {
    name: ul,
    environment: So,
    global: So === "browser" ? window : global,
    browser: So === "browser",
    desktop: ["windows", "osx", "linux", "cros"].includes(ul),
    mobile: ["android", "ios"].includes(ul),
    ios: ul === "ios",
    android: ul === "android",
    xbox: Bb,
    gamepads: Nb,
    touch: kb,
    workers: Ub,
    passiveEvents: zb,
    browserName: Fb
}
  , xS = "abcdefghijklmnopqrstuvwxyz"
  , wS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  , Vb = xS + wS
  , am = 55296
  , bS = 56319
  , ty = 56320
  , Gb = 57343
  , Hb = 8205
  , sy = 127462
  , iy = 127487
  , Wb = 127995
  , Xb = 127999
  , jb = 8400
  , $b = 8447
  , om = 65024
  , lm = 65039;
function hm(a, e=0) {
    const t = a.length;
    if (e < 0 || e >= t)
        return null;
    const s = a.charCodeAt(e);
    if (t > 1 && s >= am && s <= bS) {
        const i = a.charCodeAt(e + 1);
        if (i >= ty && i <= Gb)
            return {
                code: (s - am) * 1024 + i - ty + 65536,
                long: !0
            }
    }
    return {
        code: s,
        long: !1
    }
}
function er(a, e, t) {
    if (!a)
        return !1;
    const s = hm(a);
    if (s) {
        const i = s.code;
        return i >= e && i <= t
    }
    return !1
}
function qb(a, e) {
    if (e === a.length - 1)
        return 1;
    if (er(a[e], am, bS)) {
        const t = a.substring(e, e + 2)
          , s = a.substring(e + 2, e + 4);
        return er(s, Wb, Xb) || er(t, sy, iy) && er(s, sy, iy) ? 4 : er(s, om, lm) ? 3 : 2
    }
    return er(a[e + 1], om, lm) ? 2 : 1
}
const Rd = {
    ASCII_LOWERCASE: xS,
    ASCII_UPPERCASE: wS,
    ASCII_LETTERS: Vb,
    format(a, ...e) {
        for (let t = 0; t < e.length; t++)
            a = a.replace(`{${t}}`, e[t]);
        return a
    },
    getCodePoint(a, e) {
        const t = hm(a, e);
        return t && t.code
    },
    getCodePoints(a) {
        if (typeof a != "string")
            throw new TypeError("Not a string");
        let e = 0;
        const t = [];
        let s;
        for (; s = hm(a, e); )
            t.push(s.code),
            e += s.long ? 2 : 1;
        return t
    },
    getSymbols(a) {
        if (typeof a != "string")
            throw new TypeError("Not a string");
        let e = 0;
        const t = a.length
          , s = [];
        let i = 0, n;
        for (; e < t; ) {
            if (i += qb(a, e + i),
            n = a[e + i],
            er(n, jb, $b) && (n = a[e + i++]),
            er(n, om, lm) && (n = a[e + i++]),
            n && n.charCodeAt(0) === Hb) {
                n = a[e + i++];
                continue
            }
            const r = a.substring(e, e + i);
            s.push(r),
            e += i,
            i = 0
        }
        return s
    },
    fromCodePoint() {
        const a = [];
        let e, t, s;
        for (let i = 0; i < arguments.length; ++i)
            e = Number(arguments[i]),
            t = e - 65536,
            s = e > 65535 ? [(t >> 10) + 55296, t % 1024 + 56320] : [e],
            a.push(String.fromCharCode.apply(null, s));
        return a.join("")
    }
};
class Yb {
    constructor() {
        this._list = [],
        this._index = {}
    }
    push(e, t) {
        if (this._index[e])
            throw Error("Key already in index " + e);
        const s = this._list.push(t) - 1;
        this._index[e] = s
    }
    has(e) {
        return this._index[e] !== void 0
    }
    get(e) {
        const t = this._index[e];
        return t !== void 0 ? this._list[t] : null
    }
    remove(e) {
        const t = this._index[e];
        if (t !== void 0) {
            this._list.splice(t, 1),
            delete this._index[e];
            for (e in this._index) {
                const s = this._index[e];
                s > t && (this._index[e] = s - 1)
            }
            return !0
        }
        return !1
    }
    list() {
        return this._list
    }
    clear() {
        this._list.length = 0;
        for (const e in this._index)
            delete this._index[e]
    }
}
const Kb = a => {
    const e = {};
    let t = e;
    return () => (t === e && (t = a()),
    t)
}
;
class os {
    static loadScript(e, t) {
        const s = document.createElement("script");
        s.setAttribute("src", e),
        s.onload = () => {
            t(null)
        }
        ,
        s.onerror = () => {
            t(`Failed to load script='${e}'`)
        }
        ,
        document.body.appendChild(s)
    }
    static loadWasm(e, t, s) {
        const i = os.wasmSupported() && t.glueUrl && t.wasmUrl ? t.glueUrl : t.fallbackUrl;
        i ? os.loadScript(i, n => {
            if (n)
                s(n, null);
            else {
                const r = window[e];
                window[e] = void 0,
                r({
                    locateFile: () => t.wasmUrl,
                    onAbort: () => {
                        s("wasm module aborted.")
                    }
                }).then(o => {
                    s(null, o)
                }
                )
            }
        }
        ) : s("No supported wasm modules found.", null)
    }
    static getModule(e) {
        return os.modules.hasOwnProperty(e) || (os.modules[e] = {
            config: null,
            initializing: !1,
            instance: null,
            callbacks: []
        }),
        os.modules[e]
    }
    static initialize(e, t) {
        if (t.initializing)
            return;
        const s = t.config;
        (s.glueUrl || s.wasmUrl || s.fallbackUrl) && (t.initializing = !0,
        os.loadWasm(e, s, (i, n) => {
            i ? s.errorHandler ? s.errorHandler(i) : console.error(`failed to initialize module=${e} error=${i}`) : (t.instance = n,
            t.callbacks.forEach(r => {
                r(n)
            }
            ))
        }
        ))
    }
}
os.modules = {};
os.wasmSupported = Kb( () => {
    try {
        if (typeof WebAssembly == "object" && typeof WebAssembly.instantiate == "function") {
            const a = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0));
            if (a instanceof WebAssembly.Module)
                return new WebAssembly.Instance(a)instanceof WebAssembly.Instance
        }
    } catch {}
    return !1
}
);
class TS {
    static setConfig(e, t) {
        const s = os.getModule(e);
        s.config = t,
        s.callbacks.length > 0 && os.initialize(e, s)
    }
    static getConfig(e) {
        var t;
        return (t = os.modules) == null || (t = t[e]) == null ? void 0 : t.config
    }
    static getInstance(e, t) {
        const s = os.getModule(e);
        s.instance ? t(s.instance) : (s.callbacks.push(t),
        s.config && os.initialize(e, s))
    }
}
class CS {
    constructor(e) {
        this.arraybuffer = e,
        this.dataView = new DataView(e),
        this.offset = 0,
        this.stack = []
    }
    get remainingBytes() {
        return this.dataView.byteLength - this.offset
    }
    reset(e=0) {
        this.offset = e
    }
    skip(e) {
        this.offset += e
    }
    align(e) {
        this.offset = this.offset + e - 1 & ~(e - 1)
    }
    _inc(e) {
        return this.offset += e,
        this.offset - e
    }
    readChar() {
        return String.fromCharCode(this.dataView.getUint8(this.offset++))
    }
    readChars(e) {
        let t = "";
        for (let s = 0; s < e; ++s)
            t += this.readChar();
        return t
    }
    readU8() {
        return this.dataView.getUint8(this.offset++)
    }
    readU16() {
        return this.dataView.getUint16(this._inc(2), !0)
    }
    readU32() {
        return this.dataView.getUint32(this._inc(4), !0)
    }
    readU64() {
        return this.readU32() + 2 ** 32 * this.readU32()
    }
    readU32be() {
        return this.dataView.getUint32(this._inc(4), !1)
    }
    readArray(e) {
        for (let t = 0; t < e.length; ++t)
            e[t] = this.readU8()
    }
    readLine() {
        const e = this.dataView;
        let t = "";
        for (; !(this.offset >= e.byteLength); ) {
            const s = String.fromCharCode(this.readU8());
            if (s === `
`)
                break;
            t += s
        }
        return t
    }
}
class qd {
    constructor(e) {
        this.items = [],
        this.length = 0,
        this.loopIndex = -1,
        this._sortBy = void 0,
        this._sortHandler = void 0,
        this._sortBy = e.sortBy,
        this._sortHandler = this._doSort.bind(this)
    }
    _binarySearch(e) {
        let t = 0
          , s = this.items.length - 1;
        const i = e[this._sortBy];
        let n, r;
        for (; t <= s; )
            n = Math.floor((t + s) / 2),
            r = this.items[n][this._sortBy],
            r <= i ? t = n + 1 : r > i && (s = n - 1);
        return t
    }
    _doSort(e, t) {
        const s = this._sortBy;
        return e[s] - t[s]
    }
    insert(e) {
        const t = this._binarySearch(e);
        this.items.splice(t, 0, e),
        this.length++,
        this.loopIndex >= t && this.loopIndex++
    }
    append(e) {
        this.items.push(e),
        this.length++
    }
    remove(e) {
        const t = this.items.indexOf(e);
        t < 0 || (this.items.splice(t, 1),
        this.length--,
        this.loopIndex >= t && this.loopIndex--)
    }
    sort() {
        const e = this.loopIndex >= 0 ? this.items[this.loopIndex] : null;
        this.items.sort(this._sortHandler),
        e !== null && (this.loopIndex = this.items.indexOf(e))
    }
}
class zh extends fe {
    constructor(e) {
        super(),
        this._index = {},
        this._list = [],
        this._parent = e
    }
    add() {
        let e = !1;
        const t = this._processArguments(arguments, !0);
        if (!t.length)
            return e;
        for (let s = 0; s < t.length; s++)
            this._index[t[s]] || (e = !0,
            this._index[t[s]] = !0,
            this._list.push(t[s]),
            this.fire("add", t[s], this._parent));
        return e && this.fire("change", this._parent),
        e
    }
    remove() {
        let e = !1;
        if (!this._list.length)
            return e;
        const t = this._processArguments(arguments, !0);
        if (!t.length)
            return e;
        for (let s = 0; s < t.length; s++)
            this._index[t[s]] && (e = !0,
            delete this._index[t[s]],
            this._list.splice(this._list.indexOf(t[s]), 1),
            this.fire("remove", t[s], this._parent));
        return e && this.fire("change", this._parent),
        e
    }
    clear() {
        if (!this._list.length)
            return;
        const e = this._list.slice(0);
        this._list = [],
        this._index = {};
        for (let t = 0; t < e.length; t++)
            this.fire("remove", e[t], this._parent);
        this.fire("change", this._parent)
    }
    has() {
        return this._list.length ? this._has(this._processArguments(arguments)) : !1
    }
    _has(e) {
        if (!this._list.length || !e.length)
            return !1;
        for (let t = 0; t < e.length; t++)
            if (e[t].length === 1) {
                if (this._index[e[t][0]])
                    return !0
            } else {
                let s = !0;
                for (let i = 0; i < e[t].length; i++)
                    if (!this._index[e[t][i]]) {
                        s = !1;
                        break
                    }
                if (s)
                    return !0
            }
        return !1
    }
    list() {
        return this._list.slice(0)
    }
    _processArguments(e, t) {
        const s = [];
        let i = [];
        if (!e || !e.length)
            return s;
        for (let n = 0; n < e.length; n++)
            if (e[n]instanceof Array) {
                t || (i = []);
                for (let r = 0; r < e[n].length; r++)
                    typeof e[n][r] == "string" && (t ? s.push(e[n][r]) : i.push(e[n][r]));
                !t && i.length && s.push(i)
            } else
                typeof e[n] == "string" && (t ? s.push(e[n]) : s.push([e[n]]));
        return s
    }
    get size() {
        return this._list.length
    }
}
zh.EVENT_ADD = "add";
zh.EVENT_REMOVE = "remove";
zh.EVENT_CHANGE = "change";
const Hi = typeof window < "u" && window.performance && window.performance.now ? performance.now.bind(performance) : Date.now
  , Zb = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
class Uf {
    constructor(e) {
        this.scheme = void 0,
        this.authority = void 0,
        this.path = void 0,
        this.query = void 0,
        this.fragment = void 0;
        const t = e.match(Zb);
        this.scheme = t[2],
        this.authority = t[4],
        this.path = t[5],
        this.query = t[7],
        this.fragment = t[9]
    }
    toString() {
        let e = "";
        return this.scheme && (e += this.scheme + ":"),
        this.authority && (e += "//" + this.authority),
        e += this.path,
        this.query && (e += "?" + this.query),
        this.fragment && (e += "#" + this.fragment),
        e
    }
    getQuery() {
        const e = {};
        if (this.query) {
            const t = decodeURIComponent(this.query).split("&");
            for (const s of t) {
                const i = s.split("=");
                e[i[0]] = i[1]
            }
        }
        return e
    }
    setQuery(e) {
        let t = "";
        for (const s in e)
            e.hasOwnProperty(s) && (t !== "" && (t += "&"),
            t += encodeURIComponent(s) + "=" + encodeURIComponent(e[s]));
        this.query = t
    }
}
const Qb = 0
  , uh = 1
  , ny = 2
  , Jb = 3
  , Kl = 4
  , eT = 5
  , W = {
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,
    clamp(a, e, t) {
        return a >= t ? t : a <= e ? e : a
    },
    intToBytes24(a) {
        const e = a >> 16 & 255
          , t = a >> 8 & 255
          , s = a & 255;
        return [e, t, s]
    },
    intToBytes32(a) {
        const e = a >> 24 & 255
          , t = a >> 16 & 255
          , s = a >> 8 & 255
          , i = a & 255;
        return [e, t, s, i]
    },
    bytesToInt24(a, e, t) {
        return a.length && (t = a[2],
        e = a[1],
        a = a[0]),
        a << 16 | e << 8 | t
    },
    bytesToInt32(a, e, t, s) {
        return a.length && (s = a[3],
        t = a[2],
        e = a[1],
        a = a[0]),
        (a << 24 | e << 16 | t << 8 | s) >>> 0
    },
    lerp(a, e, t) {
        return a + (e - a) * W.clamp(t, 0, 1)
    },
    lerpAngle(a, e, t) {
        return e - a > 180 && (e -= 360),
        e - a < -180 && (e += 360),
        W.lerp(a, e, W.clamp(t, 0, 1))
    },
    powerOfTwo(a) {
        return a !== 0 && !(a & a - 1)
    },
    nextPowerOfTwo(a) {
        return a--,
        a |= a >> 1,
        a |= a >> 2,
        a |= a >> 4,
        a |= a >> 8,
        a |= a >> 16,
        a++,
        a
    },
    nearestPowerOfTwo(a) {
        return Math.pow(2, Math.round(Math.log(a) / Math.log(2)))
    },
    random(a, e) {
        const t = e - a;
        return Math.random() * t + a
    },
    smoothstep(a, e, t) {
        return t <= a ? 0 : t >= e ? 1 : (t = (t - a) / (e - a),
        t * t * (3 - 2 * t))
    },
    smootherstep(a, e, t) {
        return t <= a ? 0 : t >= e ? 1 : (t = (t - a) / (e - a),
        t * t * t * (t * (t * 6 - 15) + 10))
    },
    roundUp(a, e) {
        return e === 0 ? a : Math.ceil(a / e) * e
    },
    between(a, e, t, s) {
        const i = Math.min(e, t)
          , n = Math.max(e, t);
        return s ? a >= i && a <= n : a > i && a < n
    }
};
var Zi;
class z {
    constructor(e=0, t=0, s=0, i=1) {
        this.r = void 0,
        this.g = void 0,
        this.b = void 0,
        this.a = void 0;
        const n = e.length;
        n === 3 || n === 4 ? (this.r = e[0],
        this.g = e[1],
        this.b = e[2],
        this.a = e[3] !== void 0 ? e[3] : 1) : (this.r = e,
        this.g = t,
        this.b = s,
        this.a = i)
    }
    clone() {
        const e = this.constructor;
        return new e(this.r,this.g,this.b,this.a)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this.a = e.a,
        this
    }
    equals(e) {
        return this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a
    }
    set(e, t, s, i=1) {
        return this.r = e,
        this.g = t,
        this.b = s,
        this.a = i,
        this
    }
    lerp(e, t, s) {
        return this.r = e.r + s * (t.r - e.r),
        this.g = e.g + s * (t.g - e.g),
        this.b = e.b + s * (t.b - e.b),
        this.a = e.a + s * (t.a - e.a),
        this
    }
    fromString(e) {
        const t = parseInt(e.replace("#", "0x"), 16);
        let s;
        return e.length > 7 ? s = W.intToBytes32(t) : (s = W.intToBytes24(t),
        s[3] = 255),
        this.set(s[0] / 255, s[1] / 255, s[2] / 255, s[3] / 255),
        this
    }
    toString(e) {
        let t = "#" + (16777216 + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255)).toString(16).slice(1);
        if (e === !0) {
            const s = Math.round(this.a * 255).toString(16);
            this.a < 16 / 255 ? t += "0" + s : t += s
        }
        return t
    }
}
Zi = z;
z.BLACK = Object.freeze(new Zi(0,0,0,1));
z.BLUE = Object.freeze(new Zi(0,0,1,1));
z.CYAN = Object.freeze(new Zi(0,1,1,1));
z.GRAY = Object.freeze(new Zi(.5,.5,.5,1));
z.GREEN = Object.freeze(new Zi(0,1,0,1));
z.MAGENTA = Object.freeze(new Zi(1,0,1,1));
z.RED = Object.freeze(new Zi(1,0,0,1));
z.WHITE = Object.freeze(new Zi(1,1,1,1));
z.YELLOW = Object.freeze(new Zi(1,1,0,1));
class ES {
    constructor(e, t=0) {
        this._curve = void 0,
        this._left = -1 / 0,
        this._right = 1 / 0,
        this._recip = 0,
        this._p0 = 0,
        this._p1 = 0,
        this._m0 = 0,
        this._m1 = 0,
        this._curve = e,
        this._reset(t)
    }
    evaluate(e, t=!1) {
        (t || e < this._left || e >= this._right) && this._reset(e);
        let s;
        const i = this._curve.type;
        if (i === eT)
            s = this._p0;
        else {
            const n = this._recip === 0 ? 0 : (e - this._left) * this._recip;
            i === Qb ? s = W.lerp(this._p0, this._p1, n) : i === uh ? s = W.lerp(this._p0, this._p1, n * n * (3 - 2 * n)) : s = this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, n)
        }
        return s
    }
    _reset(e) {
        const t = this._curve.keys
          , s = t.length;
        if (!s)
            this._left = -1 / 0,
            this._right = 1 / 0,
            this._recip = 0,
            this._p0 = this._p1 = this._m0 = this._m1 = 0;
        else if (e < t[0][0])
            this._left = -1 / 0,
            this._right = t[0][0],
            this._recip = 0,
            this._p0 = this._p1 = t[0][1],
            this._m0 = this._m1 = 0;
        else if (e >= t[s - 1][0])
            this._left = t[s - 1][0],
            this._right = 1 / 0,
            this._recip = 0,
            this._p0 = this._p1 = t[s - 1][1],
            this._m0 = this._m1 = 0;
        else {
            let i = 0;
            for (; e >= t[i + 1][0]; )
                i++;
            this._left = t[i][0],
            this._right = t[i + 1][0];
            const n = 1 / (this._right - this._left);
            this._recip = isFinite(n) ? n : 0,
            this._p0 = t[i][1],
            this._p1 = t[i + 1][1],
            this._isHermite() && this._calcTangents(t, i)
        }
    }
    _isHermite() {
        return this._curve.type === ny || this._curve.type === Jb || this._curve.type === Kl
    }
    _calcTangents(e, t) {
        let s;
        const i = e[t]
          , n = e[t + 1];
        let r;
        if (t === 0 ? s = [e[0][0] + (e[0][0] - e[1][0]), e[0][1] + (e[0][1] - e[1][1])] : s = e[t - 1],
        t === e.length - 2 ? r = [e[t + 1][0] + (e[t + 1][0] - e[t][0]), e[t + 1][1] + (e[t + 1][1] - e[t][1])] : r = e[t + 2],
        this._curve.type === Kl) {
            const o = 2 * (n[0] - i[0]) / (n[0] - s[0])
              , l = 2 * (n[0] - i[0]) / (r[0] - i[0]);
            this._m0 = this._curve.tension * (isFinite(o) ? o : 0) * (n[1] - s[1]),
            this._m1 = this._curve.tension * (isFinite(l) ? l : 0) * (r[1] - i[1])
        } else {
            const o = (n[0] - i[0]) / (i[0] - s[0])
              , l = (n[0] - i[0]) / (r[0] - n[0])
              , c = i[1] + (s[1] - i[1]) * (isFinite(o) ? o : 0)
              , d = n[1] + (r[1] - n[1]) * (isFinite(l) ? l : 0)
              , h = this._curve.type === ny ? .5 : this._curve.tension;
            this._m0 = h * (n[1] - c),
            this._m1 = h * (d - i[1])
        }
    }
    _evaluateHermite(e, t, s, i, n) {
        const r = n * n
          , o = n + n
          , l = 1 - n
          , c = l * l;
        return e * ((1 + o) * c) + s * (n * c) + t * (r * (3 - o)) + i * (r * (n - 1))
    }
}
class Ot {
    constructor(e) {
        if (this.keys = [],
        this.type = uh,
        this.tension = .5,
        this._eval = new ES(this),
        e)
            for (let t = 0; t < e.length - 1; t += 2)
                this.keys.push([e[t], e[t + 1]]);
        this.sort()
    }
    get length() {
        return this.keys.length
    }
    add(e, t) {
        const s = this.keys
          , i = s.length;
        let n = 0;
        for (; n < i && !(s[n][0] > e); n++)
            ;
        const r = [e, t];
        return this.keys.splice(n, 0, r),
        r
    }
    get(e) {
        return this.keys[e]
    }
    sort() {
        this.keys.sort(function(e, t) {
            return e[0] - t[0]
        })
    }
    value(e) {
        return this._eval.evaluate(e, !0)
    }
    closest(e) {
        const t = this.keys
          , s = t.length;
        let i = 2
          , n = null;
        for (let r = 0; r < s; r++) {
            const o = Math.abs(e - t[r][0]);
            if (i >= o)
                i = o,
                n = t[r];
            else
                break
        }
        return n
    }
    clone() {
        const e = new this.constructor;
        return e.keys = or(e.keys, this.keys),
        e.type = this.type,
        e.tension = this.tension,
        e
    }
    quantize(e) {
        e = Math.max(e, 2);
        const t = new Float32Array(e)
          , s = 1 / (e - 1);
        t[0] = this._eval.evaluate(0, !0);
        for (let i = 1; i < e; i++)
            t[i] = this._eval.evaluate(s * i);
        return t
    }
    quantizeClamped(e, t, s) {
        const i = this.quantize(e);
        for (let n = 0; n < i.length; ++n)
            i[n] = Math.min(s, Math.max(t, i[n]));
        return i
    }
}
class Qt {
    constructor() {
        if (this.curves = [],
        this._type = uh,
        arguments.length > 1)
            for (let e = 0; e < arguments.length; e++)
                this.curves.push(new Ot(arguments[e]));
        else if (arguments.length === 0)
            this.curves.push(new Ot);
        else {
            const e = arguments[0];
            if (typeof e == "number")
                for (let t = 0; t < e; t++)
                    this.curves.push(new Ot);
            else
                for (let t = 0; t < e.length; t++)
                    this.curves.push(new Ot(e[t]))
        }
    }
    get length() {
        return this.curves.length
    }
    set type(e) {
        this._type = e;
        for (let t = 0; t < this.curves.length; t++)
            this.curves[t].type = e
    }
    get type() {
        return this._type
    }
    get(e) {
        return this.curves[e]
    }
    value(e, t=[]) {
        const s = this.curves.length;
        t.length = s;
        for (let i = 0; i < s; i++)
            t[i] = this.curves[i].value(e);
        return t
    }
    clone() {
        const e = new this.constructor;
        e.curves = [];
        for (let t = 0; t < this.curves.length; t++)
            e.curves.push(this.curves[t].clone());
        return e._type = this._type,
        e
    }
    quantize(e) {
        e = Math.max(e, 2);
        const t = this.curves.length
          , s = new Float32Array(e * t)
          , i = 1 / (e - 1);
        for (let n = 0; n < t; n++) {
            const r = new ES(this.curves[n]);
            for (let o = 0; o < e; o++)
                s[o * t + n] = r.evaluate(i * o)
        }
        return s
    }
    quantizeClamped(e, t, s) {
        const i = this.quantize(e);
        for (let n = 0; n < i.length; ++n)
            i[n] = Math.min(s, Math.max(t, i[n]));
        return i
    }
}
const zf = 1 / 255
  , AS = new Float32Array(1)
  , tT = new Int32Array(AS.buffer);
class Ge {
    static float2Half(e) {
        AS[0] = e;
        const t = tT[0];
        let s = t >> 16 & 32768
          , i = t >> 12 & 2047;
        const n = t >> 23 & 255;
        return n < 103 ? s : n > 142 ? (s |= 31744,
        s |= (n === 255 ? 0 : 1) && t & 8388607,
        s) : n < 113 ? (i |= 2048,
        s |= (i >> 114 - n) + (i >> 113 - n & 1),
        s) : (s |= n - 112 << 10 | i >> 1,
        s += i & 1,
        s)
    }
    static float2Bytes(e, t, s, i) {
        const n = 255 * e % 1;
        if (t[s + 0] = Math.round((e % 1 - zf * n) * 255),
        i > 1) {
            const r = 65025 * e % 1;
            if (t[s + 1] = Math.round((n - zf * r) * 255),
            i > 2) {
                const o = 16581375 * e % 1;
                t[s + 2] = Math.round((r - zf * o) * 255),
                i > 3 && (t[s + 3] = Math.round(o * 255))
            }
        }
    }
    static float2BytesRange(e, t, s, i, n, r) {
        e = W.clamp((e - i) / (n - i), 0, 1),
        Ge.float2Bytes(e, t, s, r)
    }
    static float2MantissaExponent(e, t, s, i) {
        const n = Math.floor(Math.log2(Math.abs(e))) + 1;
        e /= Math.pow(2, n),
        Ge.float2BytesRange(e, t, s, -1, 1, i - 1),
        t[s + i - 1] = Math.round(n + 127)
    }
}
var In;
class y {
    constructor(e=0, t=0, s=0) {
        this.x = void 0,
        this.y = void 0,
        this.z = void 0,
        e.length === 3 ? (this.x = e[0],
        this.y = e[1],
        this.z = e[2]) : (this.x = e,
        this.y = t,
        this.z = s)
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    add2(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addScaled(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    clone() {
        const e = this.constructor;
        return new e(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    cross(e, t) {
        const s = e.x
          , i = e.y
          , n = e.z
          , r = t.x
          , o = t.y
          , l = t.z;
        return this.x = i * l - o * n,
        this.y = n * r - l * s,
        this.z = s * o - r * i,
        this
    }
    distance(e) {
        const t = this.x - e.x
          , s = this.y - e.y
          , i = this.z - e.z;
        return Math.sqrt(t * t + s * s + i * i)
    }
    div(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    div2(e, t) {
        return this.x = e.x / t.x,
        this.y = e.y / t.y,
        this.z = e.z / t.z,
        this
    }
    divScalar(e) {
        return this.x /= e,
        this.y /= e,
        this.z /= e,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    equals(e) {
        return this.x === e.x && this.y === e.y && this.z === e.z
    }
    equalsApprox(e, t=1e-6) {
        return Math.abs(this.x - e.x) < t && Math.abs(this.y - e.y) < t && Math.abs(this.z - e.z) < t
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    lerp(e, t, s) {
        return this.x = e.x + s * (t.x - e.x),
        this.y = e.y + s * (t.y - e.y),
        this.z = e.z + s * (t.z - e.z),
        this
    }
    mul(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    mul2(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    mulScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    normalize(e=this) {
        const t = e.x * e.x + e.y * e.y + e.z * e.z;
        if (t > 0) {
            const s = 1 / Math.sqrt(t);
            this.x = e.x * s,
            this.y = e.y * s,
            this.z = e.z * s
        }
        return this
    }
    floor(e=this) {
        return this.x = Math.floor(e.x),
        this.y = Math.floor(e.y),
        this.z = Math.floor(e.z),
        this
    }
    ceil(e=this) {
        return this.x = Math.ceil(e.x),
        this.y = Math.ceil(e.y),
        this.z = Math.ceil(e.z),
        this
    }
    round(e=this) {
        return this.x = Math.round(e.x),
        this.y = Math.round(e.y),
        this.z = Math.round(e.z),
        this
    }
    min(e) {
        return e.x < this.x && (this.x = e.x),
        e.y < this.y && (this.y = e.y),
        e.z < this.z && (this.z = e.z),
        this
    }
    max(e) {
        return e.x > this.x && (this.x = e.x),
        e.y > this.y && (this.y = e.y),
        e.z > this.z && (this.z = e.z),
        this
    }
    project(e) {
        const t = this.x * e.x + this.y * e.y + this.z * e.z
          , s = e.x * e.x + e.y * e.y + e.z * e.z
          , i = t / s;
        return this.x = e.x * i,
        this.y = e.y * i,
        this.z = e.z * i,
        this
    }
    set(e, t, s) {
        return this.x = e,
        this.y = t,
        this.z = s,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    sub2(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    toString() {
        return `[${this.x}, ${this.y}, ${this.z}]`
    }
}
In = y;
y.ZERO = Object.freeze(new In(0,0,0));
y.ONE = Object.freeze(new In(1,1,1));
y.UP = Object.freeze(new In(0,1,0));
y.DOWN = Object.freeze(new In(0,-1,0));
y.RIGHT = Object.freeze(new In(1,0,0));
y.LEFT = Object.freeze(new In(-1,0,0));
y.FORWARD = Object.freeze(new In(0,0,-1));
y.BACK = Object.freeze(new In(0,0,1));
var v_;
class Ci {
    constructor() {
        this.data = new Float32Array(9),
        this.data[0] = this.data[4] = this.data[8] = 1
    }
    clone() {
        const e = this.constructor;
        return new e().copy(this)
    }
    copy(e) {
        const t = e.data
          , s = this.data;
        return s[0] = t[0],
        s[1] = t[1],
        s[2] = t[2],
        s[3] = t[3],
        s[4] = t[4],
        s[5] = t[5],
        s[6] = t[6],
        s[7] = t[7],
        s[8] = t[8],
        this
    }
    set(e) {
        const t = this.data;
        return t[0] = e[0],
        t[1] = e[1],
        t[2] = e[2],
        t[3] = e[3],
        t[4] = e[4],
        t[5] = e[5],
        t[6] = e[6],
        t[7] = e[7],
        t[8] = e[8],
        this
    }
    equals(e) {
        const t = this.data
          , s = e.data;
        return t[0] === s[0] && t[1] === s[1] && t[2] === s[2] && t[3] === s[3] && t[4] === s[4] && t[5] === s[5] && t[6] === s[6] && t[7] === s[7] && t[8] === s[8]
    }
    isIdentity() {
        const e = this.data;
        return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 0 && e[4] === 1 && e[5] === 0 && e[6] === 0 && e[7] === 0 && e[8] === 1
    }
    setIdentity() {
        const e = this.data;
        return e[0] = 1,
        e[1] = 0,
        e[2] = 0,
        e[3] = 0,
        e[4] = 1,
        e[5] = 0,
        e[6] = 0,
        e[7] = 0,
        e[8] = 1,
        this
    }
    toString() {
        return "[" + this.data.join(", ") + "]"
    }
    transpose(e=this) {
        const t = e.data
          , s = this.data;
        if (t === s) {
            let i;
            i = t[1],
            s[1] = t[3],
            s[3] = i,
            i = t[2],
            s[2] = t[6],
            s[6] = i,
            i = t[5],
            s[5] = t[7],
            s[7] = i
        } else
            s[0] = t[0],
            s[1] = t[3],
            s[2] = t[6],
            s[3] = t[1],
            s[4] = t[4],
            s[5] = t[7],
            s[6] = t[2],
            s[7] = t[5],
            s[8] = t[8];
        return this
    }
    setFromMat4(e) {
        const t = e.data
          , s = this.data;
        return s[0] = t[0],
        s[1] = t[1],
        s[2] = t[2],
        s[3] = t[4],
        s[4] = t[5],
        s[5] = t[6],
        s[6] = t[8],
        s[7] = t[9],
        s[8] = t[10],
        this
    }
    invertMat4(e) {
        const t = e.data
          , s = t[0]
          , i = t[1]
          , n = t[2]
          , r = t[4]
          , o = t[5]
          , l = t[6]
          , c = t[8]
          , d = t[9]
          , h = t[10]
          , u = h * o - l * d
          , f = -h * i + n * d
          , p = l * i - n * o
          , _ = -h * r + l * c
          , m = h * s - n * c
          , g = -l * s + n * r
          , v = d * r - o * c
          , x = -d * s + i * c
          , S = o * s - i * r
          , w = s * u + i * _ + n * v;
        if (w === 0)
            this.setIdentity();
        else {
            const T = 1 / w
              , b = this.data;
            b[0] = u * T,
            b[1] = f * T,
            b[2] = p * T,
            b[3] = _ * T,
            b[4] = m * T,
            b[5] = g * T,
            b[6] = v * T,
            b[7] = x * T,
            b[8] = S * T
        }
        return this
    }
    transformVector(e, t=new y) {
        const s = this.data
          , i = e.x
          , n = e.y
          , r = e.z;
        return t.x = i * s[0] + n * s[3] + r * s[6],
        t.y = i * s[1] + n * s[4] + r * s[7],
        t.z = i * s[2] + n * s[5] + r * s[8],
        t
    }
}
v_ = Ci;
Ci.IDENTITY = Object.freeze(new v_);
Ci.ZERO = Object.freeze(new v_().set([0, 0, 0, 0, 0, 0, 0, 0, 0]));
var ba;
class P {
    constructor(e=0, t=0) {
        this.x = void 0,
        this.y = void 0,
        e.length === 2 ? (this.x = e[0],
        this.y = e[1]) : (this.x = e,
        this.y = t)
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    add2(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addScaled(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    clone() {
        const e = this.constructor;
        return new e(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    distance(e) {
        const t = this.x - e.x
          , s = this.y - e.y;
        return Math.sqrt(t * t + s * s)
    }
    div(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    div2(e, t) {
        return this.x = e.x / t.x,
        this.y = e.y / t.y,
        this
    }
    divScalar(e) {
        return this.x /= e,
        this.y /= e,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    equals(e) {
        return this.x === e.x && this.y === e.y
    }
    equalsApprox(e, t=1e-6) {
        return Math.abs(this.x - e.x) < t && Math.abs(this.y - e.y) < t
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    lerp(e, t, s) {
        return this.x = e.x + s * (t.x - e.x),
        this.y = e.y + s * (t.y - e.y),
        this
    }
    mul(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    mul2(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this
    }
    mulScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    normalize(e=this) {
        const t = e.x * e.x + e.y * e.y;
        if (t > 0) {
            const s = 1 / Math.sqrt(t);
            this.x = e.x * s,
            this.y = e.y * s
        }
        return this
    }
    rotate(e) {
        const t = Math.atan2(this.x, this.y) + e * W.DEG_TO_RAD
          , s = Math.sqrt(this.x * this.x + this.y * this.y);
        return this.x = Math.sin(t) * s,
        this.y = Math.cos(t) * s,
        this
    }
    angle() {
        return Math.atan2(this.x, this.y) * W.RAD_TO_DEG
    }
    angleTo(e) {
        return Math.atan2(this.x * e.y + this.y * e.x, this.x * e.x + this.y * e.y) * W.RAD_TO_DEG
    }
    floor(e=this) {
        return this.x = Math.floor(e.x),
        this.y = Math.floor(e.y),
        this
    }
    ceil(e=this) {
        return this.x = Math.ceil(e.x),
        this.y = Math.ceil(e.y),
        this
    }
    round(e=this) {
        return this.x = Math.round(e.x),
        this.y = Math.round(e.y),
        this
    }
    min(e) {
        return e.x < this.x && (this.x = e.x),
        e.y < this.y && (this.y = e.y),
        this
    }
    max(e) {
        return e.x > this.x && (this.x = e.x),
        e.y > this.y && (this.y = e.y),
        this
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    sub2(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    toString() {
        return `[${this.x}, ${this.y}]`
    }
    static angleRad(e, t) {
        return Math.atan2(e.x * t.y - e.y * t.x, e.x * t.x + e.y * t.y)
    }
}
ba = P;
P.ZERO = Object.freeze(new ba(0,0));
P.ONE = Object.freeze(new ba(1,1));
P.UP = Object.freeze(new ba(0,1));
P.DOWN = Object.freeze(new ba(0,-1));
P.RIGHT = Object.freeze(new ba(1,0));
P.LEFT = Object.freeze(new ba(-1,0));
var S_;
class M {
    constructor(e=0, t=0, s=0, i=0) {
        this.x = void 0,
        this.y = void 0,
        this.z = void 0,
        this.w = void 0,
        e.length === 4 ? (this.x = e[0],
        this.y = e[1],
        this.z = e[2],
        this.w = e[3]) : (this.x = e,
        this.y = t,
        this.z = s,
        this.w = i)
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    add2(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addScaled(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    clone() {
        const e = this.constructor;
        return new e(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w,
        this
    }
    div(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this.w /= e.w,
        this
    }
    div2(e, t) {
        return this.x = e.x / t.x,
        this.y = e.y / t.y,
        this.z = e.z / t.z,
        this.w = e.w / t.w,
        this
    }
    divScalar(e) {
        return this.x /= e,
        this.y /= e,
        this.z /= e,
        this.w /= e,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    equals(e) {
        return this.x === e.x && this.y === e.y && this.z === e.z && this.w === e.w
    }
    equalsApprox(e, t=1e-6) {
        return Math.abs(this.x - e.x) < t && Math.abs(this.y - e.y) < t && Math.abs(this.z - e.z) < t && Math.abs(this.w - e.w) < t
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    lerp(e, t, s) {
        return this.x = e.x + s * (t.x - e.x),
        this.y = e.y + s * (t.y - e.y),
        this.z = e.z + s * (t.z - e.z),
        this.w = e.w + s * (t.w - e.w),
        this
    }
    mul(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    mul2(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this.w = e.w * t.w,
        this
    }
    mulScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    normalize(e=this) {
        const t = e.x * e.x + e.y * e.y + e.z * e.z + e.w * e.w;
        if (t > 0) {
            const s = 1 / Math.sqrt(t);
            this.x = e.x * s,
            this.y = e.y * s,
            this.z = e.z * s,
            this.w = e.w * s
        }
        return this
    }
    floor(e=this) {
        return this.x = Math.floor(e.x),
        this.y = Math.floor(e.y),
        this.z = Math.floor(e.z),
        this.w = Math.floor(e.w),
        this
    }
    ceil(e=this) {
        return this.x = Math.ceil(e.x),
        this.y = Math.ceil(e.y),
        this.z = Math.ceil(e.z),
        this.w = Math.ceil(e.w),
        this
    }
    round(e=this) {
        return this.x = Math.round(e.x),
        this.y = Math.round(e.y),
        this.z = Math.round(e.z),
        this.w = Math.round(e.w),
        this
    }
    min(e) {
        return e.x < this.x && (this.x = e.x),
        e.y < this.y && (this.y = e.y),
        e.z < this.z && (this.z = e.z),
        e.w < this.w && (this.w = e.w),
        this
    }
    max(e) {
        return e.x > this.x && (this.x = e.x),
        e.y > this.y && (this.y = e.y),
        e.z > this.z && (this.z = e.z),
        e.w > this.w && (this.w = e.w),
        this
    }
    set(e, t, s, i) {
        return this.x = e,
        this.y = t,
        this.z = s,
        this.w = i,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    sub2(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    toString() {
        return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`
    }
}
S_ = M;
M.ZERO = Object.freeze(new S_(0,0,0,0));
M.ONE = Object.freeze(new S_(1,1,1,1));
var x_;
const fl = new P
  , si = new y
  , Mi = new y
  , Pi = new y
  , Dc = new y;
class ee {
    constructor() {
        this.data = new Float32Array(16),
        this.data[0] = this.data[5] = this.data[10] = this.data[15] = 1
    }
    static _getPerspectiveHalfSize(e, t, s, i, n) {
        n ? (e.x = i * Math.tan(t * Math.PI / 360),
        e.y = e.x / s) : (e.y = i * Math.tan(t * Math.PI / 360),
        e.x = e.y * s)
    }
    add2(e, t) {
        const s = e.data
          , i = t.data
          , n = this.data;
        return n[0] = s[0] + i[0],
        n[1] = s[1] + i[1],
        n[2] = s[2] + i[2],
        n[3] = s[3] + i[3],
        n[4] = s[4] + i[4],
        n[5] = s[5] + i[5],
        n[6] = s[6] + i[6],
        n[7] = s[7] + i[7],
        n[8] = s[8] + i[8],
        n[9] = s[9] + i[9],
        n[10] = s[10] + i[10],
        n[11] = s[11] + i[11],
        n[12] = s[12] + i[12],
        n[13] = s[13] + i[13],
        n[14] = s[14] + i[14],
        n[15] = s[15] + i[15],
        this
    }
    add(e) {
        return this.add2(this, e)
    }
    clone() {
        const e = this.constructor;
        return new e().copy(this)
    }
    copy(e) {
        const t = e.data
          , s = this.data;
        return s[0] = t[0],
        s[1] = t[1],
        s[2] = t[2],
        s[3] = t[3],
        s[4] = t[4],
        s[5] = t[5],
        s[6] = t[6],
        s[7] = t[7],
        s[8] = t[8],
        s[9] = t[9],
        s[10] = t[10],
        s[11] = t[11],
        s[12] = t[12],
        s[13] = t[13],
        s[14] = t[14],
        s[15] = t[15],
        this
    }
    equals(e) {
        const t = this.data
          , s = e.data;
        return t[0] === s[0] && t[1] === s[1] && t[2] === s[2] && t[3] === s[3] && t[4] === s[4] && t[5] === s[5] && t[6] === s[6] && t[7] === s[7] && t[8] === s[8] && t[9] === s[9] && t[10] === s[10] && t[11] === s[11] && t[12] === s[12] && t[13] === s[13] && t[14] === s[14] && t[15] === s[15]
    }
    isIdentity() {
        const e = this.data;
        return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 0 && e[4] === 0 && e[5] === 1 && e[6] === 0 && e[7] === 0 && e[8] === 0 && e[9] === 0 && e[10] === 1 && e[11] === 0 && e[12] === 0 && e[13] === 0 && e[14] === 0 && e[15] === 1
    }
    mul2(e, t) {
        const s = e.data
          , i = t.data
          , n = this.data
          , r = s[0]
          , o = s[1]
          , l = s[2]
          , c = s[3]
          , d = s[4]
          , h = s[5]
          , u = s[6]
          , f = s[7]
          , p = s[8]
          , _ = s[9]
          , m = s[10]
          , g = s[11]
          , v = s[12]
          , x = s[13]
          , S = s[14]
          , w = s[15];
        let T, b, E, C;
        return T = i[0],
        b = i[1],
        E = i[2],
        C = i[3],
        n[0] = r * T + d * b + p * E + v * C,
        n[1] = o * T + h * b + _ * E + x * C,
        n[2] = l * T + u * b + m * E + S * C,
        n[3] = c * T + f * b + g * E + w * C,
        T = i[4],
        b = i[5],
        E = i[6],
        C = i[7],
        n[4] = r * T + d * b + p * E + v * C,
        n[5] = o * T + h * b + _ * E + x * C,
        n[6] = l * T + u * b + m * E + S * C,
        n[7] = c * T + f * b + g * E + w * C,
        T = i[8],
        b = i[9],
        E = i[10],
        C = i[11],
        n[8] = r * T + d * b + p * E + v * C,
        n[9] = o * T + h * b + _ * E + x * C,
        n[10] = l * T + u * b + m * E + S * C,
        n[11] = c * T + f * b + g * E + w * C,
        T = i[12],
        b = i[13],
        E = i[14],
        C = i[15],
        n[12] = r * T + d * b + p * E + v * C,
        n[13] = o * T + h * b + _ * E + x * C,
        n[14] = l * T + u * b + m * E + S * C,
        n[15] = c * T + f * b + g * E + w * C,
        this
    }
    mulAffine2(e, t) {
        const s = e.data
          , i = t.data
          , n = this.data
          , r = s[0]
          , o = s[1]
          , l = s[2]
          , c = s[4]
          , d = s[5]
          , h = s[6]
          , u = s[8]
          , f = s[9]
          , p = s[10]
          , _ = s[12]
          , m = s[13]
          , g = s[14];
        let v, x, S;
        return v = i[0],
        x = i[1],
        S = i[2],
        n[0] = r * v + c * x + u * S,
        n[1] = o * v + d * x + f * S,
        n[2] = l * v + h * x + p * S,
        n[3] = 0,
        v = i[4],
        x = i[5],
        S = i[6],
        n[4] = r * v + c * x + u * S,
        n[5] = o * v + d * x + f * S,
        n[6] = l * v + h * x + p * S,
        n[7] = 0,
        v = i[8],
        x = i[9],
        S = i[10],
        n[8] = r * v + c * x + u * S,
        n[9] = o * v + d * x + f * S,
        n[10] = l * v + h * x + p * S,
        n[11] = 0,
        v = i[12],
        x = i[13],
        S = i[14],
        n[12] = r * v + c * x + u * S + _,
        n[13] = o * v + d * x + f * S + m,
        n[14] = l * v + h * x + p * S + g,
        n[15] = 1,
        this
    }
    mul(e) {
        return this.mul2(this, e)
    }
    transformPoint(e, t=new y) {
        const s = this.data
          , i = e.x
          , n = e.y
          , r = e.z;
        return t.x = i * s[0] + n * s[4] + r * s[8] + s[12],
        t.y = i * s[1] + n * s[5] + r * s[9] + s[13],
        t.z = i * s[2] + n * s[6] + r * s[10] + s[14],
        t
    }
    transformVector(e, t=new y) {
        const s = this.data
          , i = e.x
          , n = e.y
          , r = e.z;
        return t.x = i * s[0] + n * s[4] + r * s[8],
        t.y = i * s[1] + n * s[5] + r * s[9],
        t.z = i * s[2] + n * s[6] + r * s[10],
        t
    }
    transformVec4(e, t=new M) {
        const s = this.data
          , i = e.x
          , n = e.y
          , r = e.z
          , o = e.w;
        return t.x = i * s[0] + n * s[4] + r * s[8] + o * s[12],
        t.y = i * s[1] + n * s[5] + r * s[9] + o * s[13],
        t.z = i * s[2] + n * s[6] + r * s[10] + o * s[14],
        t.w = i * s[3] + n * s[7] + r * s[11] + o * s[15],
        t
    }
    setLookAt(e, t, s) {
        Pi.sub2(e, t).normalize(),
        Mi.copy(s).normalize(),
        si.cross(Mi, Pi).normalize(),
        Mi.cross(Pi, si);
        const i = this.data;
        return i[0] = si.x,
        i[1] = si.y,
        i[2] = si.z,
        i[3] = 0,
        i[4] = Mi.x,
        i[5] = Mi.y,
        i[6] = Mi.z,
        i[7] = 0,
        i[8] = Pi.x,
        i[9] = Pi.y,
        i[10] = Pi.z,
        i[11] = 0,
        i[12] = e.x,
        i[13] = e.y,
        i[14] = e.z,
        i[15] = 1,
        this
    }
    setFrustum(e, t, s, i, n, r) {
        const o = 2 * n
          , l = t - e
          , c = i - s
          , d = r - n
          , h = this.data;
        return h[0] = o / l,
        h[1] = 0,
        h[2] = 0,
        h[3] = 0,
        h[4] = 0,
        h[5] = o / c,
        h[6] = 0,
        h[7] = 0,
        h[8] = (t + e) / l,
        h[9] = (i + s) / c,
        h[10] = (-r - n) / d,
        h[11] = -1,
        h[12] = 0,
        h[13] = 0,
        h[14] = -o * r / d,
        h[15] = 0,
        this
    }
    setPerspective(e, t, s, i, n) {
        return ee._getPerspectiveHalfSize(fl, e, t, s, n),
        this.setFrustum(-fl.x, fl.x, -fl.y, fl.y, s, i)
    }
    setOrtho(e, t, s, i, n, r) {
        const o = this.data;
        return o[0] = 2 / (t - e),
        o[1] = 0,
        o[2] = 0,
        o[3] = 0,
        o[4] = 0,
        o[5] = 2 / (i - s),
        o[6] = 0,
        o[7] = 0,
        o[8] = 0,
        o[9] = 0,
        o[10] = -2 / (r - n),
        o[11] = 0,
        o[12] = -(t + e) / (t - e),
        o[13] = -(i + s) / (i - s),
        o[14] = -(r + n) / (r - n),
        o[15] = 1,
        this
    }
    setFromAxisAngle(e, t) {
        t *= W.DEG_TO_RAD;
        const s = e.x
          , i = e.y
          , n = e.z
          , r = Math.cos(t)
          , o = Math.sin(t)
          , l = 1 - r
          , c = l * s
          , d = l * i
          , h = this.data;
        return h[0] = c * s + r,
        h[1] = c * i + o * n,
        h[2] = c * n - o * i,
        h[3] = 0,
        h[4] = c * i - o * n,
        h[5] = d * i + r,
        h[6] = d * n + o * s,
        h[7] = 0,
        h[8] = c * n + o * i,
        h[9] = d * n - s * o,
        h[10] = l * n * n + r,
        h[11] = 0,
        h[12] = 0,
        h[13] = 0,
        h[14] = 0,
        h[15] = 1,
        this
    }
    setTranslate(e, t, s) {
        const i = this.data;
        return i[0] = 1,
        i[1] = 0,
        i[2] = 0,
        i[3] = 0,
        i[4] = 0,
        i[5] = 1,
        i[6] = 0,
        i[7] = 0,
        i[8] = 0,
        i[9] = 0,
        i[10] = 1,
        i[11] = 0,
        i[12] = e,
        i[13] = t,
        i[14] = s,
        i[15] = 1,
        this
    }
    setScale(e, t, s) {
        const i = this.data;
        return i[0] = e,
        i[1] = 0,
        i[2] = 0,
        i[3] = 0,
        i[4] = 0,
        i[5] = t,
        i[6] = 0,
        i[7] = 0,
        i[8] = 0,
        i[9] = 0,
        i[10] = s,
        i[11] = 0,
        i[12] = 0,
        i[13] = 0,
        i[14] = 0,
        i[15] = 1,
        this
    }
    setViewport(e, t, s, i) {
        const n = this.data;
        return n[0] = s * .5,
        n[1] = 0,
        n[2] = 0,
        n[3] = 0,
        n[4] = 0,
        n[5] = i * .5,
        n[6] = 0,
        n[7] = 0,
        n[8] = 0,
        n[9] = 0,
        n[10] = .5,
        n[11] = 0,
        n[12] = e + s * .5,
        n[13] = t + i * .5,
        n[14] = .5,
        n[15] = 1,
        this
    }
    setReflection(e, t) {
        const s = e.x
          , i = e.y
          , n = e.z
          , r = this.data;
        return r[0] = 1 - 2 * s * s,
        r[1] = -2 * s * i,
        r[2] = -2 * s * n,
        r[3] = 0,
        r[4] = -2 * s * i,
        r[5] = 1 - 2 * i * i,
        r[6] = -2 * i * n,
        r[7] = 0,
        r[8] = -2 * s * n,
        r[9] = -2 * i * n,
        r[10] = 1 - 2 * n * n,
        r[11] = 0,
        r[12] = -2 * s * t,
        r[13] = -2 * i * t,
        r[14] = -2 * n * t,
        r[15] = 1,
        this
    }
    invert(e=this) {
        const t = e.data
          , s = t[0]
          , i = t[1]
          , n = t[2]
          , r = t[3]
          , o = t[4]
          , l = t[5]
          , c = t[6]
          , d = t[7]
          , h = t[8]
          , u = t[9]
          , f = t[10]
          , p = t[11]
          , _ = t[12]
          , m = t[13]
          , g = t[14]
          , v = t[15]
          , x = s * l - i * o
          , S = s * c - n * o
          , w = s * d - r * o
          , T = i * c - n * l
          , b = i * d - r * l
          , E = n * d - r * c
          , C = h * m - u * _
          , R = h * g - f * _
          , F = h * v - p * _
          , L = u * g - f * m
          , U = u * v - p * m
          , I = f * v - p * g
          , O = x * I - S * U + w * L + T * F - b * R + E * C;
        if (O === 0)
            this.setIdentity();
        else {
            const D = 1 / O
              , A = this.data;
            A[0] = (l * I - c * U + d * L) * D,
            A[1] = (-i * I + n * U - r * L) * D,
            A[2] = (m * E - g * b + v * T) * D,
            A[3] = (-u * E + f * b - p * T) * D,
            A[4] = (-o * I + c * F - d * R) * D,
            A[5] = (s * I - n * F + r * R) * D,
            A[6] = (-_ * E + g * w - v * S) * D,
            A[7] = (h * E - f * w + p * S) * D,
            A[8] = (o * U - l * F + d * C) * D,
            A[9] = (-s * U + i * F - r * C) * D,
            A[10] = (_ * b - m * w + v * x) * D,
            A[11] = (-h * b + u * w - p * x) * D,
            A[12] = (-o * L + l * R - c * C) * D,
            A[13] = (s * L - i * R + n * C) * D,
            A[14] = (-_ * T + m * S - g * x) * D,
            A[15] = (h * T - u * S + f * x) * D
        }
        return this
    }
    set(e) {
        const t = this.data;
        return t[0] = e[0],
        t[1] = e[1],
        t[2] = e[2],
        t[3] = e[3],
        t[4] = e[4],
        t[5] = e[5],
        t[6] = e[6],
        t[7] = e[7],
        t[8] = e[8],
        t[9] = e[9],
        t[10] = e[10],
        t[11] = e[11],
        t[12] = e[12],
        t[13] = e[13],
        t[14] = e[14],
        t[15] = e[15],
        this
    }
    setIdentity() {
        const e = this.data;
        return e[0] = 1,
        e[1] = 0,
        e[2] = 0,
        e[3] = 0,
        e[4] = 0,
        e[5] = 1,
        e[6] = 0,
        e[7] = 0,
        e[8] = 0,
        e[9] = 0,
        e[10] = 1,
        e[11] = 0,
        e[12] = 0,
        e[13] = 0,
        e[14] = 0,
        e[15] = 1,
        this
    }
    setTRS(e, t, s) {
        const i = t.x
          , n = t.y
          , r = t.z
          , o = t.w
          , l = s.x
          , c = s.y
          , d = s.z
          , h = i + i
          , u = n + n
          , f = r + r
          , p = i * h
          , _ = i * u
          , m = i * f
          , g = n * u
          , v = n * f
          , x = r * f
          , S = o * h
          , w = o * u
          , T = o * f
          , b = this.data;
        return b[0] = (1 - (g + x)) * l,
        b[1] = (_ + T) * l,
        b[2] = (m - w) * l,
        b[3] = 0,
        b[4] = (_ - T) * c,
        b[5] = (1 - (p + x)) * c,
        b[6] = (v + S) * c,
        b[7] = 0,
        b[8] = (m + w) * d,
        b[9] = (v - S) * d,
        b[10] = (1 - (p + g)) * d,
        b[11] = 0,
        b[12] = e.x,
        b[13] = e.y,
        b[14] = e.z,
        b[15] = 1,
        this
    }
    transpose(e=this) {
        const t = e.data
          , s = this.data;
        if (t === s) {
            let i;
            i = t[1],
            s[1] = t[4],
            s[4] = i,
            i = t[2],
            s[2] = t[8],
            s[8] = i,
            i = t[3],
            s[3] = t[12],
            s[12] = i,
            i = t[6],
            s[6] = t[9],
            s[9] = i,
            i = t[7],
            s[7] = t[13],
            s[13] = i,
            i = t[11],
            s[11] = t[14],
            s[14] = i
        } else
            s[0] = t[0],
            s[1] = t[4],
            s[2] = t[8],
            s[3] = t[12],
            s[4] = t[1],
            s[5] = t[5],
            s[6] = t[9],
            s[7] = t[13],
            s[8] = t[2],
            s[9] = t[6],
            s[10] = t[10],
            s[11] = t[14],
            s[12] = t[3],
            s[13] = t[7],
            s[14] = t[11],
            s[15] = t[15];
        return this
    }
    getTranslation(e=new y) {
        return e.set(this.data[12], this.data[13], this.data[14])
    }
    getX(e=new y) {
        return e.set(this.data[0], this.data[1], this.data[2])
    }
    getY(e=new y) {
        return e.set(this.data[4], this.data[5], this.data[6])
    }
    getZ(e=new y) {
        return e.set(this.data[8], this.data[9], this.data[10])
    }
    getScale(e=new y) {
        return this.getX(si),
        this.getY(Mi),
        this.getZ(Pi),
        e.set(si.length(), Mi.length(), Pi.length()),
        e
    }
    get scaleSign() {
        return this.getX(si),
        this.getY(Mi),
        this.getZ(Pi),
        si.cross(si, Mi),
        si.dot(Pi) < 0 ? -1 : 1
    }
    setFromEulerAngles(e, t, s) {
        e *= W.DEG_TO_RAD,
        t *= W.DEG_TO_RAD,
        s *= W.DEG_TO_RAD;
        const i = Math.sin(-e)
          , n = Math.cos(-e)
          , r = Math.sin(-t)
          , o = Math.cos(-t)
          , l = Math.sin(-s)
          , c = Math.cos(-s)
          , d = this.data;
        return d[0] = o * c,
        d[1] = -o * l,
        d[2] = r,
        d[3] = 0,
        d[4] = n * l + c * i * r,
        d[5] = n * c - i * r * l,
        d[6] = -o * i,
        d[7] = 0,
        d[8] = i * l - n * c * r,
        d[9] = c * i + n * r * l,
        d[10] = n * o,
        d[11] = 0,
        d[12] = 0,
        d[13] = 0,
        d[14] = 0,
        d[15] = 1,
        this
    }
    getEulerAngles(e=new y) {
        this.getScale(Dc);
        const t = Dc.x
          , s = Dc.y
          , i = Dc.z;
        if (t === 0 || s === 0 || i === 0)
            return e.set(0, 0, 0);
        const n = this.data
          , r = Math.asin(-n[2] / t)
          , o = Math.PI * .5;
        let l, c;
        return r < o ? r > -o ? (l = Math.atan2(n[6] / s, n[10] / i),
        c = Math.atan2(n[1] / t, n[0] / t)) : (c = 0,
        l = -Math.atan2(n[4] / s, n[5] / s)) : (c = 0,
        l = Math.atan2(n[4] / s, n[5] / s)),
        e.set(l, r, c).mulScalar(W.RAD_TO_DEG)
    }
    toString() {
        return "[" + this.data.join(", ") + "]"
    }
}
x_ = ee;
ee.IDENTITY = Object.freeze(new x_);
ee.ZERO = Object.freeze(new x_().set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));
var w_;
class ne {
    constructor(e=0, t=0, s=0, i=1) {
        this.x = void 0,
        this.y = void 0,
        this.z = void 0,
        this.w = void 0,
        e.length === 4 ? (this.x = e[0],
        this.y = e[1],
        this.z = e[2],
        this.w = e[3]) : (this.x = e,
        this.y = t,
        this.z = s,
        this.w = i)
    }
    clone() {
        const e = this.constructor;
        return new e(this.x,this.y,this.z,this.w)
    }
    conjugate(e=this) {
        return this.x = e.x * -1,
        this.y = e.y * -1,
        this.z = e.z * -1,
        this.w = e.w,
        this
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w,
        this
    }
    equals(e) {
        return this.x === e.x && this.y === e.y && this.z === e.z && this.w === e.w
    }
    equalsApprox(e, t=1e-6) {
        return Math.abs(this.x - e.x) < t && Math.abs(this.y - e.y) < t && Math.abs(this.z - e.z) < t && Math.abs(this.w - e.w) < t
    }
    getAxisAngle(e) {
        let t = Math.acos(this.w) * 2;
        const s = Math.sin(t / 2);
        return s !== 0 ? (e.x = this.x / s,
        e.y = this.y / s,
        e.z = this.z / s,
        (e.x < 0 || e.y < 0 || e.z < 0) && (e.x *= -1,
        e.y *= -1,
        e.z *= -1,
        t *= -1)) : (e.x = 1,
        e.y = 0,
        e.z = 0),
        t * W.RAD_TO_DEG
    }
    getEulerAngles(e=new y) {
        let t, s, i;
        const n = this.x
          , r = this.y
          , o = this.z
          , l = this.w
          , c = 2 * (l * r - n * o);
        return c <= -.99999 ? (t = 2 * Math.atan2(n, l),
        s = -Math.PI / 2,
        i = 0) : c >= .99999 ? (t = 2 * Math.atan2(n, l),
        s = Math.PI / 2,
        i = 0) : (t = Math.atan2(2 * (l * n + r * o), 1 - 2 * (n * n + r * r)),
        s = Math.asin(c),
        i = Math.atan2(2 * (l * o + n * r), 1 - 2 * (r * r + o * o))),
        e.set(t, s, i).mulScalar(W.RAD_TO_DEG)
    }
    invert(e=this) {
        return this.conjugate(e).normalize()
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    mul(e) {
        const t = this.x
          , s = this.y
          , i = this.z
          , n = this.w
          , r = e.x
          , o = e.y
          , l = e.z
          , c = e.w;
        return this.x = n * r + t * c + s * l - i * o,
        this.y = n * o + s * c + i * r - t * l,
        this.z = n * l + i * c + t * o - s * r,
        this.w = n * c - t * r - s * o - i * l,
        this
    }
    mul2(e, t) {
        const s = e.x
          , i = e.y
          , n = e.z
          , r = e.w
          , o = t.x
          , l = t.y
          , c = t.z
          , d = t.w;
        return this.x = r * o + s * d + i * c - n * l,
        this.y = r * l + i * d + n * o - s * c,
        this.z = r * c + n * d + s * l - i * o,
        this.w = r * d - s * o - i * l - n * c,
        this
    }
    normalize(e=this) {
        let t = e.length();
        return t === 0 ? (this.x = this.y = this.z = 0,
        this.w = 1) : (t = 1 / t,
        this.x = e.x * t,
        this.y = e.y * t,
        this.z = e.z * t,
        this.w = e.w * t),
        this
    }
    set(e, t, s, i) {
        return this.x = e,
        this.y = t,
        this.z = s,
        this.w = i,
        this
    }
    setFromAxisAngle(e, t) {
        t *= .5 * W.DEG_TO_RAD;
        const s = Math.sin(t)
          , i = Math.cos(t);
        return this.x = s * e.x,
        this.y = s * e.y,
        this.z = s * e.z,
        this.w = i,
        this
    }
    setFromEulerAngles(e, t, s) {
        if (e instanceof y) {
            const h = e;
            e = h.x,
            t = h.y,
            s = h.z
        }
        const i = .5 * W.DEG_TO_RAD;
        e *= i,
        t *= i,
        s *= i;
        const n = Math.sin(e)
          , r = Math.cos(e)
          , o = Math.sin(t)
          , l = Math.cos(t)
          , c = Math.sin(s)
          , d = Math.cos(s);
        return this.x = n * l * d - r * o * c,
        this.y = r * o * d + n * l * c,
        this.z = r * l * c - n * o * d,
        this.w = r * l * d + n * o * c,
        this
    }
    setFromMat4(e) {
        let t, s, i, n, r, o, l, c, d, h, u, f, p, _;
        if (e = e.data,
        t = e[0],
        s = e[1],
        i = e[2],
        n = e[4],
        r = e[5],
        o = e[6],
        l = e[8],
        c = e[9],
        d = e[10],
        f = t * t + s * s + i * i,
        f === 0)
            return this;
        if (f = 1 / Math.sqrt(f),
        p = n * n + r * r + o * o,
        p === 0)
            return this;
        if (p = 1 / Math.sqrt(p),
        _ = l * l + c * c + d * d,
        _ === 0)
            return this;
        _ = 1 / Math.sqrt(_),
        t *= f,
        s *= f,
        i *= f,
        n *= p,
        r *= p,
        o *= p,
        l *= _,
        c *= _,
        d *= _;
        const m = t + r + d;
        return m >= 0 ? (h = Math.sqrt(m + 1),
        this.w = h * .5,
        h = .5 / h,
        this.x = (o - c) * h,
        this.y = (l - i) * h,
        this.z = (s - n) * h) : t > r ? t > d ? (u = t - (r + d) + 1,
        u = Math.sqrt(u),
        this.x = u * .5,
        u = .5 / u,
        this.w = (o - c) * u,
        this.y = (s + n) * u,
        this.z = (i + l) * u) : (u = d - (t + r) + 1,
        u = Math.sqrt(u),
        this.z = u * .5,
        u = .5 / u,
        this.w = (s - n) * u,
        this.x = (l + i) * u,
        this.y = (c + o) * u) : r > d ? (u = r - (d + t) + 1,
        u = Math.sqrt(u),
        this.y = u * .5,
        u = .5 / u,
        this.w = (l - i) * u,
        this.z = (o + c) * u,
        this.x = (n + s) * u) : (u = d - (t + r) + 1,
        u = Math.sqrt(u),
        this.z = u * .5,
        u = .5 / u,
        this.w = (s - n) * u,
        this.x = (l + i) * u,
        this.y = (c + o) * u),
        this
    }
    setFromDirections(e, t) {
        const s = 1 + e.dot(t);
        return s < Number.EPSILON ? Math.abs(e.x) > Math.abs(e.y) ? (this.x = -e.z,
        this.y = 0,
        this.z = e.x,
        this.w = 0) : (this.x = 0,
        this.y = -e.z,
        this.z = e.y,
        this.w = 0) : (this.x = e.y * t.z - e.z * t.y,
        this.y = e.z * t.x - e.x * t.z,
        this.z = e.x * t.y - e.y * t.x,
        this.w = s),
        this.normalize()
    }
    slerp(e, t, s) {
        const i = e.x
          , n = e.y
          , r = e.z
          , o = e.w;
        let l = t.x
          , c = t.y
          , d = t.z
          , h = t.w
          , u = o * h + i * l + n * c + r * d;
        if (u < 0 && (h = -h,
        l = -l,
        c = -c,
        d = -d,
        u = -u),
        Math.abs(u) >= 1)
            return this.w = o,
            this.x = i,
            this.y = n,
            this.z = r,
            this;
        const f = Math.acos(u)
          , p = Math.sqrt(1 - u * u);
        if (Math.abs(p) < .001)
            return this.w = o * .5 + h * .5,
            this.x = i * .5 + l * .5,
            this.y = n * .5 + c * .5,
            this.z = r * .5 + d * .5,
            this;
        const _ = Math.sin((1 - s) * f) / p
          , m = Math.sin(s * f) / p;
        return this.w = o * _ + h * m,
        this.x = i * _ + l * m,
        this.y = n * _ + c * m,
        this.z = r * _ + d * m,
        this
    }
    transformVector(e, t=new y) {
        const s = e.x
          , i = e.y
          , n = e.z
          , r = this.x
          , o = this.y
          , l = this.z
          , c = this.w
          , d = c * s + o * n - l * i
          , h = c * i + l * s - r * n
          , u = c * n + r * i - o * s
          , f = -r * s - o * i - l * n;
        return t.x = d * c + f * -r + h * -l - u * -o,
        t.y = h * c + f * -o + u * -r - d * -l,
        t.z = u * c + f * -l + d * -o - h * -r,
        t
    }
    toString() {
        return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`
    }
}
w_ = ne;
ne.IDENTITY = Object.freeze(new w_(0,0,0,1));
ne.ZERO = Object.freeze(new w_(0,0,0,0));
const Oa = new y
  , Fa = new y
  , ry = new y
  , ay = new y
  , sT = new y;
class Pe {
    constructor(e=new y, t=new y(.5,.5,.5)) {
        this.center = void 0,
        this.halfExtents = void 0,
        this._min = new y,
        this._max = new y,
        this.center = e,
        this.halfExtents = t
    }
    add(e) {
        const t = this.center
          , s = t.x
          , i = t.y
          , n = t.z
          , r = this.halfExtents
          , o = r.x
          , l = r.y
          , c = r.z;
        let d = s - o
          , h = s + o
          , u = i - l
          , f = i + l
          , p = n - c
          , _ = n + c;
        const m = e.center
          , g = m.x
          , v = m.y
          , x = m.z
          , S = e.halfExtents
          , w = S.x
          , T = S.y
          , b = S.z
          , E = g - w
          , C = g + w
          , R = v - T
          , F = v + T
          , L = x - b
          , U = x + b;
        E < d && (d = E),
        C > h && (h = C),
        R < u && (u = R),
        F > f && (f = F),
        L < p && (p = L),
        U > _ && (_ = U),
        t.x = (d + h) * .5,
        t.y = (u + f) * .5,
        t.z = (p + _) * .5,
        r.x = (h - d) * .5,
        r.y = (f - u) * .5,
        r.z = (_ - p) * .5
    }
    copy(e) {
        this.center.copy(e.center),
        this.halfExtents.copy(e.halfExtents)
    }
    clone() {
        return new Pe(this.center.clone(),this.halfExtents.clone())
    }
    intersects(e) {
        const t = this.getMax()
          , s = this.getMin()
          , i = e.getMax()
          , n = e.getMin();
        return s.x <= i.x && t.x >= n.x && s.y <= i.y && t.y >= n.y && s.z <= i.z && t.z >= n.z
    }
    _intersectsRay(e, t) {
        const s = Oa.copy(this.getMin()).sub(e.origin)
          , i = Fa.copy(this.getMax()).sub(e.origin)
          , n = e.direction;
        n.x === 0 ? (s.x = s.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE,
        i.x = i.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE) : (s.x /= n.x,
        i.x /= n.x),
        n.y === 0 ? (s.y = s.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE,
        i.y = i.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE) : (s.y /= n.y,
        i.y /= n.y),
        n.z === 0 ? (s.z = s.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE,
        i.z = i.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE) : (s.z /= n.z,
        i.z /= n.z);
        const r = ry.set(Math.min(s.x, i.x), Math.min(s.y, i.y), Math.min(s.z, i.z))
          , o = ay.set(Math.max(s.x, i.x), Math.max(s.y, i.y), Math.max(s.z, i.z))
          , l = Math.min(Math.min(o.x, o.y), o.z)
          , c = Math.max(Math.max(r.x, r.y), r.z)
          , d = l >= c && c >= 0;
        return d && t.copy(e.direction).mulScalar(c).add(e.origin),
        d
    }
    _fastIntersectsRay(e) {
        const t = Oa
          , s = Fa
          , i = ry
          , n = ay
          , r = sT
          , o = e.direction;
        return t.sub2(e.origin, this.center),
        n.set(Math.abs(t.x), Math.abs(t.y), Math.abs(t.z)),
        i.mul2(t, o),
        !(n.x > this.halfExtents.x && i.x >= 0 || n.y > this.halfExtents.y && i.y >= 0 || n.z > this.halfExtents.z && i.z >= 0 || (r.set(Math.abs(o.x), Math.abs(o.y), Math.abs(o.z)),
        s.cross(o, t),
        s.set(Math.abs(s.x), Math.abs(s.y), Math.abs(s.z)),
        s.x > this.halfExtents.y * r.z + this.halfExtents.z * r.y) || s.y > this.halfExtents.x * r.z + this.halfExtents.z * r.x || s.z > this.halfExtents.x * r.y + this.halfExtents.y * r.x)
    }
    intersectsRay(e, t) {
        return t ? this._intersectsRay(e, t) : this._fastIntersectsRay(e)
    }
    setMinMax(e, t) {
        this.center.add2(t, e).mulScalar(.5),
        this.halfExtents.sub2(t, e).mulScalar(.5)
    }
    getMin() {
        return this._min.copy(this.center).sub(this.halfExtents)
    }
    getMax() {
        return this._max.copy(this.center).add(this.halfExtents)
    }
    containsPoint(e) {
        const t = this.getMin()
          , s = this.getMax();
        return !(e.x < t.x || e.x > s.x || e.y < t.y || e.y > s.y || e.z < t.z || e.z > s.z)
    }
    setFromTransformedAabb(e, t, s=!1) {
        const i = e.center
          , n = e.halfExtents
          , r = t.data;
        let o = r[0]
          , l = r[4]
          , c = r[8]
          , d = r[1]
          , h = r[5]
          , u = r[9]
          , f = r[2]
          , p = r[6]
          , _ = r[10];
        if (s) {
            let m = o * o + l * l + c * c;
            if (m > 0) {
                const g = 1 / Math.sqrt(m);
                o *= g,
                l *= g,
                c *= g
            }
            if (m = d * d + h * h + u * u,
            m > 0) {
                const g = 1 / Math.sqrt(m);
                d *= g,
                h *= g,
                u *= g
            }
            if (m = f * f + p * p + _ * _,
            m > 0) {
                const g = 1 / Math.sqrt(m);
                f *= g,
                p *= g,
                _ *= g
            }
        }
        this.center.set(r[12] + o * i.x + l * i.y + c * i.z, r[13] + d * i.x + h * i.y + u * i.z, r[14] + f * i.x + p * i.y + _ * i.z),
        this.halfExtents.set(Math.abs(o) * n.x + Math.abs(l) * n.y + Math.abs(c) * n.z, Math.abs(d) * n.x + Math.abs(h) * n.y + Math.abs(u) * n.z, Math.abs(f) * n.x + Math.abs(p) * n.y + Math.abs(_) * n.z)
    }
    static computeMinMax(e, t, s, i=e.length / 3) {
        if (i > 0) {
            let n = e[0]
              , r = e[1]
              , o = e[2]
              , l = n
              , c = r
              , d = o;
            const h = i * 3;
            for (let u = 3; u < h; u += 3) {
                const f = e[u]
                  , p = e[u + 1]
                  , _ = e[u + 2];
                f < n && (n = f),
                p < r && (r = p),
                _ < o && (o = _),
                f > l && (l = f),
                p > c && (c = p),
                _ > d && (d = _)
            }
            t.set(n, r, o),
            s.set(l, c, d)
        }
    }
    compute(e, t) {
        Pe.computeMinMax(e, Oa, Fa, t),
        this.setMinMax(Oa, Fa)
    }
    intersectsBoundingSphere(e) {
        return this._distanceToBoundingSphereSq(e) <= e.radius * e.radius
    }
    _distanceToBoundingSphereSq(e) {
        const t = this.getMin()
          , s = this.getMax();
        let i = 0;
        const n = ["x", "y", "z"];
        for (let r = 0; r < 3; ++r) {
            let o = 0;
            const l = e.center[n[r]]
              , c = t[n[r]]
              , d = s[n[r]];
            let h = 0;
            l < c && (h = c - l,
            o += h * h),
            l > d && (h = l - d,
            o += h * h),
            i += o
        }
        return i
    }
    _expand(e, t) {
        Oa.add2(this.getMin(), e),
        Fa.add2(this.getMax(), t),
        this.setMinMax(Oa, Fa)
    }
}
const Oc = new y
  , iT = new y;
class b_ {
    constructor(e=new y, t=.5) {
        this.center = void 0,
        this.radius = void 0,
        this.center = e,
        this.radius = t
    }
    containsPoint(e) {
        const t = Oc.sub2(e, this.center).lengthSq()
          , s = this.radius;
        return t < s * s
    }
    intersectsRay(e, t) {
        const s = Oc.copy(e.origin).sub(this.center)
          , i = s.dot(iT.copy(e.direction).normalize())
          , n = s.dot(s) - this.radius * this.radius;
        if (n > 0 && i > 0)
            return !1;
        const r = i * i - n;
        if (r < 0)
            return !1;
        const o = Math.abs(-i - Math.sqrt(r));
        return t && t.copy(e.direction).mulScalar(o).add(e.origin),
        !0
    }
    intersectsBoundingSphere(e) {
        Oc.sub2(e.center, this.center);
        const t = e.radius + this.radius;
        return Oc.lengthSq() <= t * t
    }
}
class nT {
    constructor() {
        this.planes = [];
        for (let e = 0; e < 6; e++)
            this.planes[e] = []
    }
    setFromMat4(e) {
        const t = e.data;
        let s;
        const i = this.planes;
        s = i[0],
        s[0] = t[3] - t[0],
        s[1] = t[7] - t[4],
        s[2] = t[11] - t[8],
        s[3] = t[15] - t[12];
        let n = Math.sqrt(s[0] * s[0] + s[1] * s[1] + s[2] * s[2]);
        s[0] /= n,
        s[1] /= n,
        s[2] /= n,
        s[3] /= n,
        s = i[1],
        s[0] = t[3] + t[0],
        s[1] = t[7] + t[4],
        s[2] = t[11] + t[8],
        s[3] = t[15] + t[12],
        n = Math.sqrt(s[0] * s[0] + s[1] * s[1] + s[2] * s[2]),
        s[0] /= n,
        s[1] /= n,
        s[2] /= n,
        s[3] /= n,
        s = i[2],
        s[0] = t[3] + t[1],
        s[1] = t[7] + t[5],
        s[2] = t[11] + t[9],
        s[3] = t[15] + t[13],
        n = Math.sqrt(s[0] * s[0] + s[1] * s[1] + s[2] * s[2]),
        s[0] /= n,
        s[1] /= n,
        s[2] /= n,
        s[3] /= n,
        s = i[3],
        s[0] = t[3] - t[1],
        s[1] = t[7] - t[5],
        s[2] = t[11] - t[9],
        s[3] = t[15] - t[13],
        n = Math.sqrt(s[0] * s[0] + s[1] * s[1] + s[2] * s[2]),
        s[0] /= n,
        s[1] /= n,
        s[2] /= n,
        s[3] /= n,
        s = i[4],
        s[0] = t[3] - t[2],
        s[1] = t[7] - t[6],
        s[2] = t[11] - t[10],
        s[3] = t[15] - t[14],
        n = Math.sqrt(s[0] * s[0] + s[1] * s[1] + s[2] * s[2]),
        s[0] /= n,
        s[1] /= n,
        s[2] /= n,
        s[3] /= n,
        s = i[5],
        s[0] = t[3] + t[2],
        s[1] = t[7] + t[6],
        s[2] = t[11] + t[10],
        s[3] = t[15] + t[14],
        n = Math.sqrt(s[0] * s[0] + s[1] * s[1] + s[2] * s[2]),
        s[0] /= n,
        s[1] /= n,
        s[2] /= n,
        s[3] /= n
    }
    containsPoint(e) {
        let t, s;
        for (t = 0; t < 6; t++)
            if (s = this.planes[t],
            s[0] * e.x + s[1] * e.y + s[2] * e.z + s[3] <= 0)
                return !1;
        return !0
    }
    containsSphere(e) {
        let t = 0, s, i;
        const n = e.radius
          , r = e.center
          , o = r.x
          , l = r.y
          , c = r.z
          , d = this.planes;
        let h;
        for (i = 0; i < 6; i++) {
            if (h = d[i],
            s = h[0] * o + h[1] * l + h[2] * c + h[3],
            s <= -n)
                return 0;
            s > n && t++
        }
        return t === 6 ? 2 : 1
    }
}
class cr {
    constructor(e, t) {
        this.origin = new y,
        this.direction = y.FORWARD.clone(),
        e && this.origin.copy(e),
        t && this.direction.copy(t)
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.set(e.origin, e.direction)
    }
    clone() {
        return new this.constructor(this.origin,this.direction)
    }
}
class rT {
    constructor(e=y.UP, t=0) {
        this.normal = new y,
        this.distance = void 0,
        this.normal.copy(e),
        this.distance = t
    }
    setFromPointNormal(e, t) {
        return this.normal.copy(t),
        this.distance = -this.normal.dot(e),
        this
    }
    intersectsLine(e, t, s) {
        const i = this.distance
          , n = this.normal.dot(e) + i
          , r = this.normal.dot(t) + i
          , o = n / (n - r)
          , l = o >= 0 && o <= 1;
        return l && s && s.lerp(e, t, o),
        l
    }
    intersectsRay(e, t) {
        const s = this.normal.dot(e.direction);
        if (s === 0)
            return !1;
        const i = -(this.normal.dot(e.origin) + this.distance) / s;
        return i >= 0 && t && t.copy(e.direction).mulScalar(i).add(e.origin),
        i >= 0
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.distance = e.distance,
        this
    }
    clone() {
        const e = this.constructor;
        return new e().copy(this)
    }
}
const Du = "linear"
  , Ou = "inverse"
  , MS = "exponential"
  , wt = 0
  , oe = 1
  , Fu = 2
  , T_ = 0
  , Ut = 1
  , aT = 2
  , PS = 4
  , oT = 5
  , C_ = 6
  , E_ = 8
  , Qs = 0
  , lT = 2
  , hT = 3
  , cT = 4
  , es = 0
  , Do = 1
  , dT = 2
  , uT = 3
  , Oo = 1
  , Fo = 2
  , fh = 4
  , bt = 0
  , dr = 1
  , Zl = 2
  , fT = 3
  , be = 0
  , ot = 1
  , Vh = 2
  , Gh = 3
  , Hh = 4
  , ur = 5
  , pT = 0
  , A_ = 1
  , Yd = 2
  , cm = 3
  , mT = 4
  , _T = 5
  , gT = 6
  , Mn = 7
  , dm = 0
  , js = 1
  , fr = 2
  , M_ = 0
  , Bu = 1
  , ku = 2
  , Wh = 3
  , Nu = 4
  , Xh = 5
  , Ln = 6
  , ve = 7
  , jh = 8
  , Uu = 9
  , Jo = 10
  , el = 11
  , Tt = 12
  , Ta = 13
  , lt = 14
  , ca = 15
  , da = 16
  , ua = 17
  , fa = 18
  , zu = 19
  , Vu = 20
  , $h = 21
  , Gu = 22
  , Hu = 23
  , tl = 24
  , sl = 25
  , qh = 26
  , Yh = 27
  , P_ = 28
  , R_ = 29
  , I_ = 30
  , L_ = 31
  , Wu = 32
  , D_ = 33
  , Xu = 34
  , ju = 35
  , $u = 36
  , qu = 37
  , Yu = 38
  , O_ = 39
  , Ku = 40
  , Zu = 41
  , Qu = 42
  , Ju = 43
  , ef = 44
  , F_ = 45
  , tf = 46
  , sf = 47
  , nf = 48
  , rf = 49
  , ph = new Map([[M_, {
    name: "A8",
    size: 1
}], [Bu, {
    name: "L8",
    size: 1
}], [ku, {
    name: "LA8",
    size: 2
}], [Wh, {
    name: "RGB565",
    size: 2
}], [Nu, {
    name: "RGBA5551",
    size: 2
}], [Xh, {
    name: "RGBA4",
    size: 2
}], [Ln, {
    name: "RGB8",
    size: 4
}], [ve, {
    name: "RGBA8",
    size: 4
}], [el, {
    name: "RGB16F",
    size: 8
}], [Tt, {
    name: "RGBA16F",
    size: 8
}], [Ta, {
    name: "RGB32F",
    size: 16
}], [lt, {
    name: "RGBA32F",
    size: 16
}], [ca, {
    name: "R32F",
    size: 4
}], [da, {
    name: "DEPTH",
    size: 4
}], [ua, {
    name: "DEPTHSTENCIL",
    size: 4
}], [fa, {
    name: "111110F",
    size: 4
}], [zu, {
    name: "SRGB",
    size: 4
}], [Vu, {
    name: "SRGBA",
    size: 4
}], [L_, {
    name: "BGRA8",
    size: 4
}], [jh, {
    name: "DXT1",
    blockSize: 8
}], [Uu, {
    name: "DXT3",
    blockSize: 16
}], [Jo, {
    name: "DXT5",
    blockSize: 16
}], [$h, {
    name: "ETC1",
    blockSize: 8
}], [Gu, {
    name: "ETC2_RGB",
    blockSize: 8
}], [Hu, {
    name: "ETC2_RGBA",
    blockSize: 16
}], [tl, {
    name: "PVRTC_2BPP_RGB_1",
    blockSize: 8
}], [sl, {
    name: "PVRTC_2BPP_RGBA_1",
    blockSize: 8
}], [qh, {
    name: "PVRTC_4BPP_RGB_1",
    blockSize: 8
}], [Yh, {
    name: "PVRTC_4BPP_RGBA_1",
    blockSize: 8
}], [P_, {
    name: "ASTC_4x4",
    blockSize: 16
}], [R_, {
    name: "ATC_RGB",
    blockSize: 8
}], [I_, {
    name: "ATC_RGBA",
    blockSize: 16
}], [Wu, {
    name: "R8I",
    size: 1,
    isInt: !0
}], [D_, {
    name: "R8U",
    size: 1,
    isInt: !0
}], [Xu, {
    name: "R16I",
    size: 2,
    isInt: !0
}], [ju, {
    name: "R16U",
    size: 2,
    isInt: !0
}], [$u, {
    name: "R32I",
    size: 4,
    isInt: !0
}], [qu, {
    name: "R32U",
    size: 4,
    isInt: !0
}], [Yu, {
    name: "RG8I",
    size: 2,
    isInt: !0
}], [O_, {
    name: "RG8U",
    size: 2,
    isInt: !0
}], [Ku, {
    name: "RG16I",
    size: 4,
    isInt: !0
}], [Zu, {
    name: "RG16U",
    size: 4,
    isInt: !0
}], [Qu, {
    name: "RG32I",
    size: 8,
    isInt: !0
}], [Ju, {
    name: "RG32U",
    size: 8,
    isInt: !0
}], [ef, {
    name: "RGBA8I",
    size: 4,
    isInt: !0
}], [F_, {
    name: "RGBA8U",
    size: 4,
    isInt: !0
}], [tf, {
    name: "RGBA16I",
    size: 8,
    isInt: !0
}], [sf, {
    name: "RGBA16U",
    size: 8,
    isInt: !0
}], [nf, {
    name: "RGBA32I",
    size: 16,
    isInt: !0
}], [rf, {
    name: "RGBA32U",
    size: 16,
    isInt: !0
}]])
  , um = a => {
    var e;
    return ((e = ph.get(a)) == null ? void 0 : e.blockSize) !== void 0
}
  , ho = a => {
    var e;
    return ((e = ph.get(a)) == null ? void 0 : e.isInt) === !0
}
  , yT = a => {
    switch (a) {
    case Ta:
    case lt:
        return Float32Array;
    case $u:
    case Qu:
    case nf:
        return Int32Array;
    case qu:
    case Ju:
    case rf:
        return Uint32Array;
    case Xu:
    case Ku:
    case tf:
        return Int16Array;
    case ju:
    case Zu:
    case sf:
    case Wh:
    case Nu:
    case Xh:
    case el:
    case Tt:
        return Uint16Array;
    case Wu:
    case Yu:
    case ef:
        return Int8Array;
    default:
        return Uint8Array
    }
}
  , af = 0
  , of = 1
  , RS = 2
  , IS = 3
  , xn = 4
  , Ks = 5
  , Zr = 6
  , ut = "POSITION"
  , Is = "NORMAL"
  , Qi = "TANGENT"
  , Ji = "BLENDWEIGHT"
  , Ps = "BLENDINDICES"
  , jt = "COLOR"
  , oy = "TEXCOORD"
  , Ls = "TEXCOORD0"
  , xr = "TEXCOORD1"
  , Kh = "TEXCOORD2"
  , Zh = "TEXCOORD3"
  , Qh = "TEXCOORD4"
  , Jh = "TEXCOORD5"
  , ec = "TEXCOORD6"
  , tc = "TEXCOORD7"
  , vT = "ATTR"
  , Kd = "ATTR0"
  , fm = "ATTR1"
  , LS = "ATTR2"
  , DS = "ATTR3"
  , OS = "ATTR4"
  , ST = "ATTR5"
  , xT = "ATTR6"
  , wT = "ATTR7"
  , Qr = "ATTR8"
  , Jr = "ATTR9"
  , pm = "ATTR10"
  , mm = "ATTR11"
  , Ql = "ATTR12"
  , ea = "ATTR13"
  , Jl = "ATTR14"
  , $r = "ATTR15"
  , bT = 1
  , xo = 0
  , TT = 2
  , CT = 3
  , ET = 5
  , AT = 2
  , $s = "default"
  , pr = "rgbm"
  , B_ = "rgbe"
  , Bo = "rgbp"
  , lf = "swizzleGGGR"
  , Es = "2d"
  , zl = "2d-array"
  , Vl = "cube"
  , Id = "3d"
  , ta = 0
  , sa = 1
  , ko = 2
  , sc = 3
  , ic = 4
  , MT = "none"
  , _m = "cube"
  , ly = "equirect"
  , PT = "octahedral"
  , hf = "wgsl"
  , Ca = 0
  , Wi = 1
  , Ea = 2
  , wr = 3
  , nc = 4
  , il = 5
  , Me = 6
  , k_ = 7
  , wo = 0
  , pa = 1
  , yi = 2
  , mr = 3
  , As = 4
  , ma = 5
  , ia = 6
  , na = 7
  , ra = 8
  , mh = 9
  , _h = 10
  , gh = 11
  , Zd = 12
  , yh = 13
  , No = 14
  , RT = 15
  , IT = 16
  , cf = 17
  , LT = 18
  , DT = 19
  , OT = 20
  , df = 21
  , uf = 22
  , N_ = 23
  , FS = 24
  , FT = 25
  , Uo = 26
  , zo = 27
  , Vo = 28
  , Go = 29
  , Ho = 30
  , ff = 31
  , pf = 32
  , Wo = 33
  , mf = 34
  , _f = 35
  , Xo = 36
  , gf = 37
  , yf = 38
  , Qd = 39
  , U_ = 40
  , z_ = 41
  , BT = 42
  , kT = 43
  , NT = 44
  , UT = 45
  , zT = 46
  , VT = 47
  , GT = 48
  , HT = 49
  , BS = ["bool", "int", "float", "vec2", "vec3", "vec4", "ivec2", "ivec3", "ivec4", "bvec2", "bvec3", "bvec4", "mat2", "mat3", "mat4", "sampler2D", "samplerCube", "", "sampler2DShadow", "samplerCubeShadow", "sampler3D", "", "", "", "", "sampler2DArray", "uint", "uvec2", "uvec3", "uvec4", "", "", "", "", "", "", "", "", "", "", "", "", "isampler2D", "usampler2D", "isamplerCube", "usamplerCube", "isampler3D", "usampler3D", "isampler2DArray", "usampler2DArray"]
  , eh = "webgl1"
  , po = "webgl2"
  , kS = "webgpu"
  , Ld = "null"
  , jo = 1
  , Cs = 2
  , WT = 4
  , vh = 0
  , gm = 1
  , XT = ["mesh", "view"]
  , rc = "default"
  , bo = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Uint16Array]
  , th = [1, 1, 2, 2, 4, 4, 4, 2]
  , ym = [Uint8Array, Uint16Array, Uint32Array]
  , jT = [1, 2, 4]
  , De = {};
De[ut] = 0;
De[Is] = 1;
De[Ji] = 2;
De[Ps] = 3;
De[jt] = 4;
De[Ls] = 5;
De[xr] = 6;
De[Kh] = 7;
De[Zh] = 8;
De[Qh] = 9;
De[Jh] = 10;
De[ec] = 11;
De[tc] = 12;
De[Qi] = 13;
De[Kd] = 0;
De[fm] = 1;
De[LS] = 2;
De[DS] = 3;
De[OS] = 4;
De[ST] = 5;
De[xT] = 6;
De[wT] = 7;
De[Qr] = 8;
De[Jr] = 9;
De[pm] = 10;
De[mm] = 11;
De[Ql] = 12;
De[ea] = 13;
De[Jl] = 14;
De[$r] = 15;
const $T = "1.65"
  , qT = "modulepreload"
  , YT = function(a, e) {
    return new URL(a,e).href
}
  , hy = {}
  , vm = function(e, t, s) {
    let i = Promise.resolve();
    if (t && t.length > 0) {
        const n = document.getElementsByTagName("link");
        i = Promise.all(t.map(r => {
            if (r = YT(r, s),
            r in hy)
                return;
            hy[r] = !0;
            const o = r.endsWith(".css")
              , l = o ? '[rel="stylesheet"]' : "";
            if (!!s)
                for (let h = n.length - 1; h >= 0; h--) {
                    const u = n[h];
                    if (u.href === r && (!o || u.rel === "stylesheet"))
                        return
                }
            else if (document.querySelector(`link[href="${r}"]${l}`))
                return;
            const d = document.createElement("link");
            if (d.rel = o ? "stylesheet" : qT,
            o || (d.as = "script",
            d.crossOrigin = ""),
            d.href = r,
            document.head.appendChild(d),
            o)
                return new Promise( (h, u) => {
                    d.addEventListener("load", h),
                    d.addEventListener("error", () => u(new Error(`Unable to preload CSS for ${r}`)))
                }
                )
        }
        ))
    }
    return i.then( () => e()).catch(n => {
        const r = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (r.payload = n,
        window.dispatchEvent(r),
        !r.defaultPrevented)
            throw n
    }
    )
};
function Bt() {
    return Bt = Object.assign ? Object.assign.bind() : function(a) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var s in t)
                Object.prototype.hasOwnProperty.call(t, s) && (a[s] = t[s])
        }
        return a
    }
    ,
    Bt.apply(this, arguments)
}
const $e = {
    set(a, e, t, s=1) {
        return a & ~(s << t) | e << t
    },
    get(a, e, t=1) {
        return a >> e & t
    },
    all(a, e, t=1) {
        const s = t << e;
        return (a & s) === s
    },
    any(a, e, t=1) {
        return (a & t << e) !== 0
    }
};
var ac;
const Fc = 7
  , Hn = 15
  , cy = 0
  , dy = 3
  , uy = 7
  , fy = 11
  , py = 14
  , my = 18
  , Sm = 22
  , _y = 23
  , gy = 24
  , yy = 25
  , vy = 26
  , KT = 15
  , ZT = Sm;
class ft {
    constructor(e=!1, t=Qs, s=Ut, i=T_, n, r, o, l=!0, c=!0, d=!0, h=!0) {
        this.target0 = 0,
        this.setColorBlend(t, s, i),
        this.setAlphaBlend(n ?? t, r ?? s, o ?? i),
        this.setColorWrite(l, c, d, h),
        this.blend = e
    }
    set blend(e) {
        this.target0 = $e.set(this.target0, e ? 1 : 0, vy)
    }
    get blend() {
        return $e.all(this.target0, vy)
    }
    setColorBlend(e, t, s) {
        this.target0 = $e.set(this.target0, e, cy, Fc),
        this.target0 = $e.set(this.target0, t, dy, Hn),
        this.target0 = $e.set(this.target0, s, uy, Hn)
    }
    setAlphaBlend(e, t, s) {
        this.target0 = $e.set(this.target0, e, fy, Fc),
        this.target0 = $e.set(this.target0, t, py, Hn),
        this.target0 = $e.set(this.target0, s, my, Hn)
    }
    setColorWrite(e, t, s, i) {
        this.redWrite = e,
        this.greenWrite = t,
        this.blueWrite = s,
        this.alphaWrite = i
    }
    get colorOp() {
        return $e.get(this.target0, cy, Fc)
    }
    get colorSrcFactor() {
        return $e.get(this.target0, dy, Hn)
    }
    get colorDstFactor() {
        return $e.get(this.target0, uy, Hn)
    }
    get alphaOp() {
        return $e.get(this.target0, fy, Fc)
    }
    get alphaSrcFactor() {
        return $e.get(this.target0, py, Hn)
    }
    get alphaDstFactor() {
        return $e.get(this.target0, my, Hn)
    }
    set redWrite(e) {
        this.target0 = $e.set(this.target0, e ? 1 : 0, Sm)
    }
    get redWrite() {
        return $e.all(this.target0, Sm)
    }
    set greenWrite(e) {
        this.target0 = $e.set(this.target0, e ? 1 : 0, _y)
    }
    get greenWrite() {
        return $e.all(this.target0, _y)
    }
    set blueWrite(e) {
        this.target0 = $e.set(this.target0, e ? 1 : 0, gy)
    }
    get blueWrite() {
        return $e.all(this.target0, gy)
    }
    set alphaWrite(e) {
        this.target0 = $e.set(this.target0, e ? 1 : 0, yy)
    }
    get alphaWrite() {
        return $e.all(this.target0, yy)
    }
    get allWrite() {
        return $e.get(this.target0, ZT, KT)
    }
    copy(e) {
        return this.target0 = e.target0,
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    get key() {
        return this.target0
    }
    equals(e) {
        return this.target0 === e.target0
    }
}
ac = ft;
ft.NOBLEND = Object.freeze(new ac);
ft.NOWRITE = Object.freeze(new ac(void 0,void 0,void 0,void 0,void 0,void 0,void 0,!1,!1,!1,!1));
ft.ALPHABLEND = Object.freeze(new ac(!0,Qs,C_,E_));
ft.ADDBLEND = Object.freeze(new ac(!0,Qs,Ut,Ut));
class oc {
    constructor() {
        this.map = new Map,
        this.id = 0
    }
    get(e) {
        let t = this.map.get(e);
        return t === void 0 && (t = this.id++,
        this.map.set(e, t)),
        t
    }
}
var vf;
const QT = new oc
  , Sy = 7
  , xy = 0
  , wy = 3;
class $t {
    constructor(e=cm, t=!0) {
        this.data = 0,
        this._depthBias = 0,
        this._depthBiasSlope = 0,
        this.key = 0,
        this.func = e,
        this.write = t
    }
    set test(e) {
        this.func = e ? cm : Mn,
        this.updateKey()
    }
    get test() {
        return this.func !== Mn
    }
    set write(e) {
        this.data = $e.set(this.data, e ? 1 : 0, wy),
        this.updateKey()
    }
    get write() {
        return $e.all(this.data, wy)
    }
    set func(e) {
        this.data = $e.set(this.data, e, xy, Sy),
        this.updateKey()
    }
    get func() {
        return $e.get(this.data, xy, Sy)
    }
    set depthBias(e) {
        this._depthBias = e,
        this.updateKey()
    }
    get depthBias() {
        return this._depthBias
    }
    set depthBiasSlope(e) {
        this._depthBiasSlope = e,
        this.updateKey()
    }
    get depthBiasSlope() {
        return this._depthBiasSlope
    }
    copy(e) {
        return this.data = e.data,
        this._depthBias = e._depthBias,
        this._depthBiasSlope = e._depthBiasSlope,
        this.key = e.key,
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    updateKey() {
        const {data: e, _depthBias: t, _depthBiasSlope: s} = this
          , i = `${e}-${t}-${s}`;
        this.key = QT.get(i)
    }
    equals(e) {
        return this.key === e.key
    }
}
vf = $t;
$t.DEFAULT = Object.freeze(new vf);
$t.NODEPTH = Object.freeze(new vf(Mn,!1));
$t.WRITEDEPTH = Object.freeze(new vf(Mn,!0));
class NS {
    constructor() {
        this.globalId = 0,
        this.revision = 0
    }
    equals(e) {
        return this.globalId === e.globalId && this.revision === e.revision
    }
    copy(e) {
        this.globalId = e.globalId,
        this.revision = e.revision
    }
    reset() {
        this.globalId = 0,
        this.revision = 0
    }
}
let by = 0;
class JT {
    constructor() {
        by++,
        this.version = new NS,
        this.version.globalId = by
    }
    increment() {
        this.version.revision++
    }
}
class eC {
    constructor(e) {
        this.name = e,
        this.value = null,
        this.versionObject = new JT
    }
    toJSON(e) {}
    setValue(e) {
        this.value = e,
        this.versionObject.increment()
    }
    getValue() {
        return this.value
    }
}
class tC {
    constructor(e) {
        this.name = e,
        this.variables = new Map
    }
    resolve(e) {
        return this.variables.has(e) || this.variables.set(e, new eC(e)),
        this.variables.get(e)
    }
    removeValue(e) {
        for (const t in this.variables) {
            const s = this.variables[t];
            s.value === e && (s.value = null)
        }
    }
}
let sC = 0;
class xi {
    constructor(e, t, s, i=es, n) {
        this.device = e,
        this.format = t,
        this.numVertices = s,
        this.usage = i,
        this.id = sC++,
        this.impl = e.createVertexBufferImpl(this, t),
        this.numBytes = t.verticesByteSize ? t.verticesByteSize : t.size * s,
        this.adjustVramSizeTracking(e._vram, this.numBytes),
        n ? this.setData(n) : this.storage = new ArrayBuffer(this.numBytes),
        this.device.buffers.push(this)
    }
    destroy() {
        const e = this.device
          , t = e.buffers.indexOf(this);
        t !== -1 && e.buffers.splice(t, 1),
        this.impl.initialized && (this.impl.destroy(e),
        this.adjustVramSizeTracking(e._vram, -this.storage.byteLength))
    }
    adjustVramSizeTracking(e, t) {
        e.vb += t
    }
    loseContext() {
        this.impl.loseContext()
    }
    getFormat() {
        return this.format
    }
    getUsage() {
        return this.usage
    }
    getNumVertices() {
        return this.numVertices
    }
    lock() {
        return this.storage
    }
    unlock() {
        this.impl.unlock(this)
    }
    setData(e) {
        return e.byteLength !== this.numBytes ? !1 : (this.storage = e,
        this.unlock(),
        !0)
    }
}
function Sh(a) {
    let e = 0;
    for (let t = 0, s = a.length; t < s; t++)
        e = (e << 5) - e + a.charCodeAt(t),
        e |= 0;
    return e
}
function US(a) {
    let t = 2166136261;
    for (let s = 0; s < a.length; s++)
        t ^= a[s],
        t *= 16777619;
    return t >>> 0
}
class Os {
    constructor() {
        this._cache = new Map
    }
    get(e, t) {
        return this._cache.has(e) || (this._cache.set(e, t()),
        e.on("destroy", () => {
            this.remove(e)
        }
        ),
        e.on("devicelost", () => {
            var s;
            (s = this._cache.get(e)) == null || s.loseContext == null || s.loseContext(e)
        }
        )),
        this._cache.get(e)
    }
    remove(e) {
        var t;
        (t = this._cache.get(e)) == null || t.destroy == null || t.destroy(e),
        this._cache.delete(e)
    }
}
const iC = new oc
  , nC = [2, 4, 8, 12, 16]
  , rC = new Os;
class fs {
    constructor(e, t, s) {
        this.device = e,
        this._elements = [],
        this.hasUv0 = !1,
        this.hasUv1 = !1,
        this.hasColor = !1,
        this.hasTangents = !1,
        this.verticesByteSize = 0,
        this.vertexCount = s,
        this.interleaved = s === void 0,
        this.instancing = !1,
        this.size = t.reduce( (l, c) => l + Math.ceil(c.components * th[c.type] / 4) * 4, 0);
        let i = 0, n;
        for (let l = 0, c = t.length; l < c; l++) {
            var r, o;
            const d = t[l];
            n = d.components * th[d.type],
            s && (i = W.roundUp(i, n));
            const h = (r = d.asInt) != null ? r : !1
              , u = h ? !1 : (o = d.normalize) != null ? o : !1
              , f = {
                name: d.semantic,
                offset: s ? i : d.hasOwnProperty("offset") ? d.offset : i,
                stride: s ? n : d.hasOwnProperty("stride") ? d.stride : this.size,
                dataType: d.type,
                numComponents: d.components,
                normalize: u,
                size: n,
                asInt: h
            };
            this._elements.push(f),
            s ? i += n * s : i += Math.ceil(n / 4) * 4,
            d.semantic === Ls ? this.hasUv0 = !0 : d.semantic === xr ? this.hasUv1 = !0 : d.semantic === jt ? this.hasColor = !0 : d.semantic === Qi && (this.hasTangents = !0)
        }
        s && (this.verticesByteSize = i),
        this._evaluateHash()
    }
    get elements() {
        return this._elements
    }
    static getDefaultInstancingFormat(e) {
        return rC.get(e, () => new fs(e,[{
            semantic: Ql,
            components: 4,
            type: Me
        }, {
            semantic: ea,
            components: 4,
            type: Me
        }, {
            semantic: Jl,
            components: 4,
            type: Me
        }, {
            semantic: $r,
            components: 4,
            type: Me
        }]))
    }
    static isElementValid(e, t) {
        const s = t.components * th[t.type];
        return !(e.isWebGPU && !nC.includes(s))
    }
    update() {
        this._evaluateHash()
    }
    _evaluateHash() {
        const e = []
          , t = []
          , s = this._elements.length;
        for (let n = 0; n < s; n++) {
            const {name: r, dataType: o, numComponents: l, normalize: c, offset: d, stride: h, size: u, asInt: f} = this._elements[n]
              , p = r + o + l + c + f;
            e.push(p);
            const _ = p + d + h + u;
            t.push(_)
        }
        e.sort();
        const i = e.join();
        this.batchingHash = Sh(i),
        this.shaderProcessingHashString = i,
        this.renderingHashString = t.join("_"),
        this.renderingHash = iC.get(this.renderingHashString)
    }
}
var zS;
const aC = new oc;
class qs {
    set func(e) {
        this._func = e,
        this._dirty = !0
    }
    get func() {
        return this._func
    }
    set ref(e) {
        this._ref = e,
        this._dirty = !0
    }
    get ref() {
        return this._ref
    }
    set fail(e) {
        this._fail = e,
        this._dirty = !0
    }
    get fail() {
        return this._fail
    }
    set zfail(e) {
        this._zfail = e,
        this._dirty = !0
    }
    get zfail() {
        return this._zfail
    }
    set zpass(e) {
        this._zpass = e,
        this._dirty = !0
    }
    get zpass() {
        return this._zpass
    }
    set readMask(e) {
        this._readMask = e,
        this._dirty = !0
    }
    get readMask() {
        return this._readMask
    }
    set writeMask(e) {
        this._writeMask = e,
        this._dirty = !0
    }
    get writeMask() {
        return this._writeMask
    }
    constructor(e={}) {
        var t, s, i, n, r, o, l;
        this._func = void 0,
        this._ref = void 0,
        this._fail = void 0,
        this._zfail = void 0,
        this._zpass = void 0,
        this._readMask = void 0,
        this._writeMask = void 0,
        this._dirty = !0,
        this._key = void 0,
        this._func = (t = e.func) != null ? t : Mn,
        this._ref = (s = e.ref) != null ? s : 0,
        this._readMask = (i = e.readMask) != null ? i : 255,
        this._writeMask = (n = e.writeMask) != null ? n : 255,
        this._fail = (r = e.fail) != null ? r : xo,
        this._zfail = (o = e.zfail) != null ? o : xo,
        this._zpass = (l = e.zpass) != null ? l : xo,
        this._evalKey()
    }
    _evalKey() {
        const {_func: e, _ref: t, _fail: s, _zfail: i, _zpass: n, _readMask: r, _writeMask: o} = this
          , l = `${e},${t},${s},${i},${n},${r},${o}`;
        this._key = aC.get(l),
        this._dirty = !1
    }
    get key() {
        return this._dirty && this._evalKey(),
        this._key
    }
    copy(e) {
        return this._func = e._func,
        this._ref = e._ref,
        this._readMask = e._readMask,
        this._writeMask = e._writeMask,
        this._fail = e._fail,
        this._zfail = e._zfail,
        this._zpass = e._zpass,
        this._dirty = e._dirty,
        this._key = e._key,
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
zS = qs;
qs.DEFAULT = Object.freeze(new zS);
class br extends fe {
    constructor(e, t) {
        var s, i, n, r, o, l, c, d;
        super(),
        this.canvas = void 0,
        this.backBuffer = null,
        this.backBufferSize = new P,
        this.backBufferFormat = void 0,
        this.backBufferAntialias = !1,
        this.isWebGPU = !1,
        this.isWebGL1 = !1,
        this.isWebGL2 = !1,
        this.scope = void 0,
        this.boneLimit = void 0,
        this.maxAnisotropy = void 0,
        this.maxCubeMapSize = void 0,
        this.maxTextureSize = void 0,
        this.maxVolumeSize = void 0,
        this.maxColorAttachments = 1,
        this.precision = void 0,
        this.samples = void 0,
        this.supportsStencil = void 0,
        this.supportsMrt = !1,
        this.supportsVolumeTextures = !1,
        this.supportsCompute = !1,
        this.renderTarget = null,
        this.shaders = [],
        this.textures = [],
        this.targets = new Set,
        this.renderVersion = 0,
        this.renderPassIndex = void 0,
        this.insideRenderPass = !1,
        this.supportsInstancing = void 0,
        this.supportsUniformBuffers = !1,
        this.textureFloatRenderable = void 0,
        this.textureHalfFloatRenderable = void 0,
        this.textureFloatFilterable = !1,
        this.textureHalfFloatFilterable = !1,
        this.quadVertexBuffer = void 0,
        this.blendState = new ft,
        this.depthState = new $t,
        this.stencilEnabled = !1,
        this.stencilFront = new qs,
        this.stencilBack = new qs,
        this.dynamicBuffers = void 0,
        this.gpuProfiler = void 0,
        this.defaultClearOptions = {
            color: [0, 0, 0, 1],
            depth: 1,
            stencil: 0,
            flags: Oo | Fo
        },
        this.canvas = e,
        this.initOptions = Bt({}, t),
        (i = (s = this.initOptions).depth) != null || (s.depth = !0),
        (r = (n = this.initOptions).stencil) != null || (n.stencil = !0),
        (l = (o = this.initOptions).antialias) != null || (o.antialias = !0),
        (d = (c = this.initOptions).powerPreference) != null || (c.powerPreference = "high-performance"),
        this._maxPixelRatio = Le.browser ? Math.min(1, window.devicePixelRatio) : 1,
        this.buffers = [],
        this._vram = {
            tex: 0,
            vb: 0,
            ib: 0,
            ub: 0
        },
        this._shaderStats = {
            vsCompiled: 0,
            fsCompiled: 0,
            linked: 0,
            materialShaders: 0,
            compileTime: 0
        },
        this.initializeContextCaches(),
        this._drawCallsPerFrame = 0,
        this._shaderSwitchesPerFrame = 0,
        this._primsPerFrame = [];
        for (let h = af; h <= Zr; h++)
            this._primsPerFrame[h] = 0;
        this._renderTargetCreationTime = 0,
        this.scope = new tC("Device"),
        this.textureBias = this.scope.resolve("textureBias"),
        this.textureBias.setValue(0)
    }
    postInit() {
        const e = new fs(this,[{
            semantic: ut,
            components: 2,
            type: Me
        }])
          , t = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        this.quadVertexBuffer = new xi(this,e,4,es,t)
    }
    destroy() {
        var e, t, s;
        this.fire("destroy"),
        (e = this.quadVertexBuffer) == null || e.destroy(),
        this.quadVertexBuffer = null,
        (t = this.dynamicBuffers) == null || t.destroy(),
        this.dynamicBuffers = null,
        (s = this.gpuProfiler) == null || s.destroy(),
        this.gpuProfiler = null
    }
    onDestroyShader(e) {
        this.fire("destroy:shader", e);
        const t = this.shaders.indexOf(e);
        t !== -1 && this.shaders.splice(t, 1)
    }
    postDestroy() {
        this.scope = null,
        this.canvas = null
    }
    toJSON(e) {}
    initializeContextCaches() {
        this.indexBuffer = null,
        this.vertexBuffers = [],
        this.shader = null,
        this.renderTarget = null
    }
    initializeRenderState() {
        this.blendState = new ft,
        this.depthState = new $t,
        this.cullMode = dr,
        this.vx = this.vy = this.vw = this.vh = 0,
        this.sx = this.sy = this.sw = this.sh = 0,
        this.blendColor = new z(0,0,0,0)
    }
    setStencilState(e, t) {}
    setBlendState(e) {}
    setBlendColor(e, t, s, i) {}
    setDepthState(e) {}
    setCullMode(e) {}
    setRenderTarget(e) {
        this.renderTarget = e
    }
    setIndexBuffer(e) {
        this.indexBuffer = e
    }
    setVertexBuffer(e) {
        e && this.vertexBuffers.push(e)
    }
    getRenderTarget() {
        return this.renderTarget
    }
    initRenderTarget(e) {
        e.initialized || (e.init(),
        this.targets.add(e))
    }
    _isBrowserInterface(e) {
        return this._isImageBrowserInterface(e) || this._isImageCanvasInterface(e) || this._isImageVideoInterface(e)
    }
    _isImageBrowserInterface(e) {
        return typeof ImageBitmap < "u" && e instanceof ImageBitmap || typeof HTMLImageElement < "u" && e instanceof HTMLImageElement
    }
    _isImageCanvasInterface(e) {
        return typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement
    }
    _isImageVideoInterface(e) {
        return typeof HTMLVideoElement < "u" && e instanceof HTMLVideoElement
    }
    resizeCanvas(e, t) {
        const s = Math.min(this._maxPixelRatio, Le.browser ? window.devicePixelRatio : 1)
          , i = Math.floor(e * s)
          , n = Math.floor(t * s);
        (i !== this.canvas.width || n !== this.canvas.height) && this.setResolution(i, n)
    }
    setResolution(e, t) {
        this.canvas.width = e,
        this.canvas.height = t,
        this.fire(br.EVENT_RESIZE, e, t)
    }
    updateClientRect() {
        this.clientRect = this.canvas.getBoundingClientRect()
    }
    get width() {
        return this.canvas.width
    }
    get height() {
        return this.canvas.height
    }
    set fullscreen(e) {}
    get fullscreen() {
        return !1
    }
    set maxPixelRatio(e) {
        this._maxPixelRatio = e
    }
    get maxPixelRatio() {
        return this._maxPixelRatio
    }
    get deviceType() {
        return this._deviceType
    }
    getBoneLimit() {
        return this.boneLimit
    }
    setBoneLimit(e) {
        this.boneLimit = e
    }
    startRenderPass(e) {}
    endRenderPass(e) {}
    startComputePass() {}
    endComputePass() {}
    frameStart() {
        this.renderPassIndex = 0,
        this.renderVersion++
    }
    frameEnd() {}
    getRenderableHdrFormat(e=[fa, Tt, lt], t=!0) {
        for (let s = 0; s < e.length; s++) {
            const i = e[s];
            switch (i) {
            case fa:
                {
                    if (this.textureRG11B10Renderable)
                        return i;
                    break
                }
            case Tt:
                if (this.textureHalfFloatRenderable && (!t || this.textureHalfFloatFilterable))
                    return i;
                break;
            case lt:
                if (this.textureFloatRenderable && (!t || this.textureFloatFilterable))
                    return i;
                break
            }
        }
    }
}
br.EVENT_RESIZE = "resizecanvas";
let oC = 0;
class It {
    constructor(e={}) {
        var t, s, i, n, r, o;
        this.name = void 0,
        this._device = void 0,
        this._colorBuffer = void 0,
        this._colorBuffers = void 0,
        this._depthBuffer = void 0,
        this._depth = void 0,
        this._stencil = void 0,
        this._samples = void 0,
        this.autoResolve = void 0,
        this._face = void 0,
        this.flipY = void 0,
        this.id = oC++;
        const l = arguments[1]
          , c = arguments[2];
        if (e instanceof br ? (this._colorBuffer = l,
        e = c) : this._colorBuffer = e.colorBuffer,
        this._colorBuffer && (this._colorBuffers = [this._colorBuffer]),
        this._depthBuffer = e.depthBuffer,
        this._face = (t = e.face) != null ? t : 0,
        this._depthBuffer) {
            const m = this._depthBuffer._format;
            m === da ? (this._depth = !0,
            this._stencil = !1) : m === ua ? (this._depth = !0,
            this._stencil = !0) : (this._depth = !1,
            this._stencil = !1)
        } else {
            var d, h;
            this._depth = (d = e.depth) != null ? d : !0,
            this._stencil = (h = e.stencil) != null ? h : !1
        }
        e.colorBuffers && (this._colorBuffers || (this._colorBuffers = [...e.colorBuffers],
        this._colorBuffer = e.colorBuffers[0]));
        const u = ((s = this._colorBuffer) == null ? void 0 : s.device) || ((i = this._depthBuffer) == null ? void 0 : i.device) || e.graphicsDevice;
        this._device = u;
        const {maxSamples: f} = this._device;
        if (this._samples = Math.min((n = e.samples) != null ? n : 1, f),
        u.isWebGPU && (this._samples = this._samples > 1 ? f : 1),
        this.autoResolve = (r = e.autoResolve) != null ? r : !0,
        this.name = e.name,
        !this.name) {
            var p;
            this.name = (p = this._colorBuffer) == null ? void 0 : p.name
        }
        if (!this.name) {
            var _;
            this.name = (_ = this._depthBuffer) == null ? void 0 : _.name
        }
        this.name || (this.name = "Untitled"),
        this.flipY = (o = e.flipY) != null ? o : !1,
        this.validateMrt(),
        this.impl = u.createRenderTargetImpl(this)
    }
    destroy() {
        const e = this._device;
        e && (e.targets.delete(this),
        e.renderTarget === this && e.setRenderTarget(null),
        this.destroyFrameBuffers())
    }
    destroyFrameBuffers() {
        const e = this._device;
        e && this.impl.destroy(e)
    }
    destroyTextureBuffers() {
        var e, t;
        (e = this._depthBuffer) == null || e.destroy(),
        this._depthBuffer = null,
        (t = this._colorBuffers) == null || t.forEach(s => {
            s.destroy()
        }
        ),
        this._colorBuffers = null,
        this._colorBuffer = null
    }
    resize(e, t) {
        if (this.width !== e || this.height !== t) {
            var s, i;
            const n = this._device;
            this.destroyFrameBuffers(),
            n.renderTarget === this && n.setRenderTarget(null),
            (s = this._depthBuffer) == null || s.resize(e, t),
            (i = this._colorBuffers) == null || i.forEach(r => {
                r.resize(e, t)
            }
            ),
            this.validateMrt(),
            this.impl = n.createRenderTargetImpl(this)
        }
    }
    validateMrt() {}
    init() {
        this.impl.init(this._device, this)
    }
    get initialized() {
        return this.impl.initialized
    }
    get device() {
        return this._device
    }
    loseContext() {
        this.impl.loseContext()
    }
    resolve(e=!0, t=!!this._depthBuffer) {
        this._device && this._samples > 1 && this.impl.resolve(this._device, this, e, t)
    }
    copy(e, t, s) {
        if (!this._device)
            if (e._device)
                this._device = e._device;
            else
                return !1;
        return this._device.copyRenderTarget(e, this, t, s)
    }
    get samples() {
        return this._samples
    }
    get depth() {
        return this._depth
    }
    get stencil() {
        return this._stencil
    }
    get colorBuffer() {
        return this._colorBuffer
    }
    getColorBuffer(e) {
        var t;
        return (t = this._colorBuffers) == null ? void 0 : t[e]
    }
    get depthBuffer() {
        return this._depthBuffer
    }
    get face() {
        return this._face
    }
    get width() {
        var e, t;
        return ((e = this._colorBuffer) == null ? void 0 : e.width) || ((t = this._depthBuffer) == null ? void 0 : t.width) || this._device.width
    }
    get height() {
        var e, t;
        return ((e = this._colorBuffer) == null ? void 0 : e.height) || ((t = this._depthBuffer) == null ? void 0 : t.height) || this._device.height
    }
}
class lC {
    constructor() {
        this.bindGroup = void 0
    }
    update(e) {
        this.destroy();
        const t = e.device
          , s = this.createDescriptor(t, e);
        this.bindGroup = t.wgpu.createBindGroup(s)
    }
    destroy() {
        this.bindGroup = null
    }
    createDescriptor(e, t) {
        const s = []
          , i = t.format;
        let n = 0;
        return t.uniformBuffers.forEach(o => {
            const l = o.persistent ? o.impl.buffer : o.allocation.gpuBuffer.buffer;
            s.push({
                binding: n++,
                resource: {
                    buffer: l,
                    offset: 0,
                    size: o.format.byteSize
                }
            })
        }
        ),
        t.textures.forEach( (o, l) => {
            const c = o.impl
              , d = i.textureFormats[l]
              , h = c.getView(e);
            s.push({
                binding: n++,
                resource: h
            });
            const u = c.getSampler(e, d.sampleType);
            s.push({
                binding: n++,
                resource: u
            })
        }
        ),
        t.storageTextures.forEach( (o, l) => {
            const d = o.impl.getView(e);
            s.push({
                binding: n++,
                resource: d
            })
        }
        ),
        {
            layout: t.format.impl.bindGroupLayout,
            entries: s
        }
    }
}
class Ty {
    static shaderStage(e) {
        let t = 0;
        return e & jo && (t |= GPUShaderStage.VERTEX),
        e & Cs && (t |= GPUShaderStage.FRAGMENT),
        e & WT && (t |= GPUShaderStage.COMPUTE),
        t
    }
}
const me = [];
me[M_] = "";
me[Bu] = "r8unorm";
me[ku] = "rg8unorm";
me[Wh] = "";
me[Nu] = "";
me[Xh] = "";
me[Ln] = "rgba8unorm";
me[ve] = "rgba8unorm";
me[jh] = "bc1-rgba-unorm";
me[Uu] = "bc2-rgba-unorm";
me[Jo] = "bc3-rgba-unorm";
me[el] = "";
me[Tt] = "rgba16float";
me[Ta] = "";
me[lt] = "rgba32float";
me[ca] = "r32float";
me[da] = "depth32float";
me[ua] = "depth24plus-stencil8";
me[fa] = "rg11b10ufloat";
me[zu] = "";
me[Vu] = "";
me[$h] = "";
me[Gu] = "etc2-rgb8unorm";
me[Hu] = "etc2-rgba8unorm";
me[tl] = "";
me[sl] = "";
me[qh] = "";
me[Yh] = "";
me[P_] = "astc-4x4-unorm";
me[R_] = "";
me[I_] = "";
me[L_] = "bgra8unorm";
me[Wu] = "r8sint";
me[D_] = "r8uint";
me[Xu] = "r16sint";
me[ju] = "r16uint";
me[$u] = "r32sint";
me[qu] = "r32uint";
me[Yu] = "rg8sint";
me[O_] = "rg8uint";
me[Ku] = "rg16sint";
me[Zu] = "rg16uint";
me[Qu] = "rg32sint";
me[Ju] = "rg32uint";
me[ef] = "rgba8sint";
me[F_] = "rgba8uint";
me[tf] = "rgba16sint";
me[sf] = "rgba16uint";
me[nf] = "rgba32sint";
me[rf] = "rgba32uint";
const nl = [];
nl[ta] = "filtering";
nl[sa] = "non-filtering";
nl[ko] = "comparison";
nl[sc] = "comparison";
nl[ic] = "comparison";
const rl = [];
rl[ta] = "float";
rl[sa] = "unfilterable-float";
rl[ko] = "depth";
rl[sc] = "sint";
rl[ic] = "uint";
const hC = new oc;
class cC {
    constructor(e) {
        const t = e.device
          , {key: s, descr: i} = this.createDescriptor(e);
        this.key = hC.get(s),
        this.bindGroupLayout = t.wgpu.createBindGroupLayout(i)
    }
    destroy() {
        this.bindGroupLayout = null
    }
    loseContext() {}
    getTextureSlot(e, t) {
        return e.bufferFormats.length + t * 2
    }
    createDescriptor(e) {
        const t = [];
        let s = ""
          , i = 0;
        return e.bufferFormats.forEach(r => {
            const o = Ty.shaderStage(r.visibility);
            s += `#${i}U:${o}`,
            t.push({
                binding: i++,
                visibility: o,
                buffer: {
                    type: "uniform",
                    hasDynamicOffset: !0
                }
            })
        }
        ),
        e.textureFormats.forEach(r => {
            const o = Ty.shaderStage(r.visibility)
              , l = r.sampleType
              , c = r.textureDimension
              , d = !1
              , h = rl[l];
            s += `#${i}T:${o}-${h}-${c}-${d}`,
            t.push({
                binding: i++,
                visibility: o,
                texture: {
                    sampleType: h,
                    viewDimension: c,
                    multisampled: d
                }
            });
            const u = nl[l];
            s += `#${i}S:${o}-${u}`,
            t.push({
                binding: i++,
                visibility: o,
                sampler: {
                    type: u
                }
            })
        }
        ),
        e.storageTextureFormats.forEach(r => {
            const {format: o, textureDimension: l} = r;
            s += `#${i}ST:${o}-${l}`,
            t.push({
                binding: i++,
                visibility: GPUShaderStage.COMPUTE,
                storageTexture: {
                    access: "write-only",
                    format: me[o],
                    viewDimension: l
                }
            })
        }
        ),
        {
            key: s,
            descr: {
                entries: t
            }
        }
    }
}
class V_ {
    constructor() {
        this.buffer = null
    }
    destroy(e) {
        this.buffer && (this.buffer.destroy(),
        this.buffer = null)
    }
    get initialized() {
        return !!this.buffer
    }
    loseContext() {}
    unlock(e, t, s, i) {
        var n, r;
        const o = e.wgpu;
        if (!this.buffer) {
            const h = i.byteLength + 3 & -4;
            this.buffer = e.wgpu.createBuffer({
                size: h,
                usage: s | GPUBufferUsage.COPY_DST
            })
        }
        const l = (n = i.byteOffset) != null ? n : 0
          , c = new Uint8Array((r = i.buffer) != null ? r : i,l,i.byteLength)
          , d = new Uint8Array(this.buffer.size);
        d.set(c),
        o.queue.writeBuffer(this.buffer, 0, d, 0, d.length)
    }
}
class dC extends V_ {
    constructor(e) {
        super(),
        this.format = null,
        this.format = e.format === js ? "uint16" : "uint32"
    }
    unlock(e) {
        const t = e.device;
        super.unlock(t, e.usage, GPUBufferUsage.INDEX, e.storage)
    }
}
const uC = {
    equals(a, e) {
        if (a.size !== e.size)
            return !1;
        for (let t = 0; t < a.length; t++)
            if (a[t] !== e[t])
                return !1;
        return !0
    }
}
  , Dn = [];
Dn[Ca] = "sint8";
Dn[Wi] = "uint8";
Dn[Ea] = "sint16";
Dn[wr] = "uint16";
Dn[nc] = "sint32";
Dn[il] = "uint32";
Dn[Me] = "float32";
Dn[k_] = "float16";
const On = [];
On[Ca] = "snorm8";
On[Wi] = "unorm8";
On[Ea] = "snorm16";
On[wr] = "unorm16";
On[nc] = "sint32";
On[il] = "uint32";
On[Me] = "float32";
On[k_] = "float16";
class fC {
    constructor() {
        this.cache = new Map
    }
    get(e, t=null) {
        const s = this.getKey(e, t);
        let i = this.cache.get(s);
        return i || (i = this.create(e, t),
        this.cache.set(s, i)),
        i
    }
    getKey(e, t=null) {
        return `${e == null ? void 0 : e.renderingHashString}-${t == null ? void 0 : t.renderingHashString}`
    }
    create(e, t) {
        const s = []
          , i = n => {
            const r = n.interleaved
              , o = n.instancing ? "instance" : "vertex";
            let l = [];
            const c = n.elements.length;
            for (let d = 0; d < c; d++) {
                const h = n.elements[d]
                  , u = De[h.name]
                  , f = h.normalize ? On : Dn;
                l.push({
                    shaderLocation: u,
                    offset: r ? h.offset : 0,
                    format: `${f[h.dataType]}${h.numComponents > 1 ? "x" + h.numComponents : ""}`
                }),
                (!r || d === c - 1) && (s.push({
                    attributes: l,
                    arrayStride: h.stride,
                    stepMode: o
                }),
                l = [])
            }
        }
        ;
        return e && i(e),
        t && i(t),
        s
    }
}
class VS {
    constructor(e) {
        this.device = e
    }
    getPipelineLayout(e) {
        const t = [];
        e.forEach(n => {
            t.push(n.bindGroupLayout)
        }
        );
        const s = {
            bindGroupLayouts: t
        };
        return this.device.wgpu.createPipelineLayout(s)
    }
}
const pC = ["point-list", "line-list", void 0, "line-strip", "triangle-list", "triangle-strip", void 0]
  , Cy = ["add", "subtract", "reverse-subtract", "min", "max"]
  , Bc = ["zero", "one", "src", "one-minus-src", "dst", "one-minus-dst", "src-alpha", "src-alpha-saturated", "one-minus-src-alpha", "dst-alpha", "one-minus-dst-alpha", "constant", "one-minus-constant"]
  , Vf = ["never", "less", "equal", "less-equal", "greater", "not-equal", "greater-equal", "always"]
  , mC = ["none", "back", "front"]
  , Ba = ["keep", "zero", "replace", "increment-clamp", "increment-wrap", "decrement-clamp", "decrement-wrap", "invert"];
class _C {
    constructor() {
        this.pipeline = void 0,
        this.hashes = void 0
    }
}
class gC extends VS {
    constructor(e) {
        super(e),
        this.lookupHashes = new Uint32Array(13),
        this.vertexBufferLayout = new fC,
        this.cache = new Map
    }
    get(e, t, s, i, n, r, o, l, c, d, h, u) {
        var f, p, _, m, g, v, x, S;
        const w = this.lookupHashes;
        w[0] = e.type,
        w[1] = i.id,
        w[2] = c,
        w[3] = l.key,
        w[4] = o.key,
        w[5] = (f = t == null ? void 0 : t.renderingHash) != null ? f : 0,
        w[6] = (p = s == null ? void 0 : s.renderingHash) != null ? p : 0,
        w[7] = n.impl.key,
        w[8] = (_ = (m = r[0]) == null ? void 0 : m.key) != null ? _ : 0,
        w[9] = (g = (v = r[1]) == null ? void 0 : v.key) != null ? g : 0,
        w[10] = (x = (S = r[2]) == null ? void 0 : S.key) != null ? x : 0,
        w[11] = d ? h.key : 0,
        w[12] = d ? u.key : 0;
        const T = US(w);
        let b = this.cache.get(T);
        if (b)
            for (let L = 0; L < b.length; L++) {
                const U = b[L];
                if (uC.equals(U.hashes, w))
                    return U.pipeline
            }
        const E = pC[e.type]
          , C = this.getPipelineLayout(r)
          , R = this.vertexBufferLayout.get(t, s)
          , F = new _C;
        return F.hashes = new Uint32Array(w),
        F.pipeline = this.create(E, i, n, C, o, l, R, c, d, h, u),
        b ? b.push(F) : b = [F],
        this.cache.set(T, b),
        F.pipeline
    }
    getBlend(e) {
        let t;
        return e.blend && (t = {
            color: {
                operation: Cy[e.colorOp],
                srcFactor: Bc[e.colorSrcFactor],
                dstFactor: Bc[e.colorDstFactor]
            },
            alpha: {
                operation: Cy[e.alphaOp],
                srcFactor: Bc[e.alphaSrcFactor],
                dstFactor: Bc[e.alphaDstFactor]
            }
        }),
        t
    }
    getDepthStencil(e, t, s, i, n) {
        let r;
        const {depth: o, stencil: l} = t;
        return (o || l) && (r = {
            format: t.impl.depthFormat
        },
        o ? (r.depthWriteEnabled = e.write,
        r.depthCompare = Vf[e.func],
        r.depthBias = e.depthBias,
        r.depthBiasSlopeScale = e.depthBiasSlope) : (r.depthWriteEnabled = !1,
        r.depthCompare = "always"),
        l && s && (r.stencilReadMas = i.readMask,
        r.stencilWriteMask = i.writeMask,
        r.stencilFront = {
            compare: Vf[i.func],
            failOp: Ba[i.fail],
            passOp: Ba[i.zpass],
            depthFailOp: Ba[i.zfail]
        },
        r.stencilBack = {
            compare: Vf[n.func],
            failOp: Ba[n.fail],
            passOp: Ba[n.zpass],
            depthFailOp: Ba[n.zfail]
        })),
        r
    }
    create(e, t, s, i, n, r, o, l, c, d, h) {
        const u = this.device.wgpu
          , f = t.impl
          , p = {
            vertex: {
                module: f.getVertexShaderModule(),
                entryPoint: f.vertexEntryPoint,
                buffers: o
            },
            primitive: {
                topology: e,
                frontFace: "ccw",
                cullMode: mC[l]
            },
            depthStencil: this.getDepthStencil(r, s, c, d, h),
            multisample: {
                count: s.samples
            },
            layout: i
        }
          , _ = s.impl.colorAttachments;
        if (_.length > 0) {
            p.fragment = {
                module: f.getFragmentShaderModule(),
                entryPoint: f.fragmentEntryPoint,
                targets: []
            };
            let g = 0;
            n.redWrite && (g |= GPUColorWrite.RED),
            n.greenWrite && (g |= GPUColorWrite.GREEN),
            n.blueWrite && (g |= GPUColorWrite.BLUE),
            n.alphaWrite && (g |= GPUColorWrite.ALPHA);
            const v = this.getBlend(n);
            _.forEach(x => {
                p.fragment.targets.push({
                    format: x.format,
                    writeMask: g,
                    blend: v
                })
            }
            )
        }
        return u.createRenderPipeline(p)
    }
}
class yC extends VS {
    get(e, t) {
        const s = this.getPipelineLayout([t.impl]);
        return this.create(e, s)
    }
    create(e, t) {
        const s = this.device.wgpu
          , i = e.impl
          , n = {
            compute: {
                module: i.getComputeShaderModule(),
                entryPoint: i.computeEntryPoint
            },
            layout: t
        };
        return s.createComputePipeline(n)
    }
}
const vC = new oc;
class SC {
    constructor() {
        this.format = void 0,
        this.multisampledBuffer = void 0
    }
    destroy() {
        var e;
        (e = this.multisampledBuffer) == null || e.destroy(),
        this.multisampledBuffer = null
    }
}
class xC {
    constructor(e) {
        this.initialized = !1,
        this.key = void 0,
        this.colorAttachments = [],
        this.depthFormat = void 0,
        this.hasStencil = void 0,
        this.depthTexture = null,
        this.depthTextureInternal = !1,
        this.assignedColorTexture = null,
        this.renderPassDescriptor = {},
        this.renderTarget = e,
        e._colorBuffers && e._colorBuffers.forEach( (t, s) => {
            this.setColorAttachment(s, void 0, t.impl.format)
        }
        ),
        this.updateKey()
    }
    destroy(e) {
        if (this.initialized = !1,
        this.depthTextureInternal) {
            var t;
            (t = this.depthTexture) == null || t.destroy(),
            this.depthTexture = null
        }
        this.assignedColorTexture = null,
        this.colorAttachments.forEach(s => {
            s.destroy()
        }
        ),
        this.colorAttachments.length = 0
    }
    updateKey() {
        const e = this.renderTarget;
        let t = `${e.samples}:${e.depth ? this.depthFormat : "nodepth"}`;
        this.colorAttachments.forEach(s => {
            t += `:${s.format}`
        }
        ),
        this.key = vC.get(t)
    }
    setDepthFormat(e) {
        this.depthFormat = e,
        this.hasStencil = e === "depth24plus-stencil8"
    }
    assignColorTexture(e) {
        this.assignedColorTexture = e;
        const t = e.createView()
          , s = this.renderPassDescriptor.colorAttachments[0];
        this.renderTarget.samples > 1 ? s.resolveTarget = t : s.view = t,
        this.setColorAttachment(0, void 0, e.format),
        this.updateKey()
    }
    setColorAttachment(e, t, s) {
        this.colorAttachments[e] || (this.colorAttachments[e] = new SC),
        t && (this.colorAttachments[e].multisampledBuffer = t),
        s && (this.colorAttachments[e].format = s)
    }
    init(e, t) {
        var s, i;
        const n = e.wgpu;
        this.initDepthStencil(n, t),
        this.renderPassDescriptor.colorAttachments = [];
        const r = (s = (i = t._colorBuffers) == null ? void 0 : i.length) != null ? s : 1;
        for (let l = 0; l < r; ++l) {
            var o;
            const c = this.initColor(n, t, l)
              , d = l === 0 && ((o = this.colorAttachments[0]) == null ? void 0 : o.format);
            (c.view || d) && this.renderPassDescriptor.colorAttachments.push(c)
        }
        this.initialized = !0
    }
    initDepthStencil(e, t) {
        const {samples: s, width: i, height: n, depth: r, depthBuffer: o} = t;
        if (r || o) {
            if (o)
                this.depthTexture = o.impl.gpuTexture,
                this.setDepthFormat(o.impl.format);
            else {
                this.setDepthFormat("depth24plus-stencil8");
                const l = {
                    size: [i, n, 1],
                    dimension: "2d",
                    sampleCount: s,
                    format: this.depthFormat,
                    usage: GPUTextureUsage.RENDER_ATTACHMENT
                };
                s > 1 ? l.usage |= GPUTextureUsage.TEXTURE_BINDING : l.usage |= GPUTextureUsage.COPY_SRC,
                this.depthTexture = e.createTexture(l),
                this.depthTextureInternal = !0
            }
            this.renderPassDescriptor.depthStencilAttachment = {
                view: this.depthTexture.createView()
            }
        }
    }
    initColor(e, t, s) {
        const i = {}
          , {samples: n, width: r, height: o} = t
          , l = t.getColorBuffer(s);
        let c = null;
        if (l && (l.cubemap ? c = l.impl.createView({
            dimension: "2d",
            baseArrayLayer: t.face,
            arrayLayerCount: 1,
            mipLevelCount: 1
        }) : c = l.impl.createView({
            mipLevelCount: 1
        })),
        n > 1) {
            var d, h;
            const u = {
                size: [r, o, 1],
                dimension: "2d",
                sampleCount: n,
                format: (d = (h = this.colorAttachments[s]) == null ? void 0 : h.format) != null ? d : l.impl.format,
                usage: GPUTextureUsage.RENDER_ATTACHMENT
            }
              , f = e.createTexture(u);
            this.setColorAttachment(s, f, u.format),
            i.view = f.createView(),
            i.resolveTarget = c
        } else
            i.view = c;
        return i
    }
    setupForRenderPass(e) {
        var t, s;
        const i = (t = (s = this.renderPassDescriptor.colorAttachments) == null ? void 0 : s.length) != null ? t : 0;
        for (let r = 0; r < i; ++r) {
            const o = this.renderPassDescriptor.colorAttachments[r]
              , l = e.colorArrayOps[r];
            o.clearValue = l.clearValue,
            o.loadOp = l.clear ? "clear" : "load",
            o.storeOp = l.store ? "store" : "discard"
        }
        const n = this.renderPassDescriptor.depthStencilAttachment;
        n && (n.depthClearValue = e.depthStencilOps.clearDepthValue,
        n.depthLoadOp = e.depthStencilOps.clearDepth ? "clear" : "load",
        n.depthStoreOp = e.depthStencilOps.storeDepth ? "store" : "discard",
        n.depthReadOnly = !1,
        this.hasStencil && (n.stencilClearValue = e.depthStencilOps.clearStencilValue,
        n.stencilLoadOp = e.depthStencilOps.clearStencil ? "clear" : "load",
        n.stencilStoreOp = e.depthStencilOps.storeStencil ? "store" : "discard",
        n.stencilReadOnly = !1))
    }
    loseContext() {
        this.initialized = !1
    }
    resolve(e, t, s, i) {}
}
const Ct = [];
Ct[yi] = 1;
Ct[mr] = 2;
Ct[As] = 3;
Ct[ma] = 4;
Ct[pa] = 1;
Ct[ia] = 2;
Ct[na] = 3;
Ct[ra] = 4;
Ct[wo] = 1;
Ct[mh] = 2;
Ct[_h] = 3;
Ct[gh] = 4;
Ct[Zd] = 8;
Ct[yh] = 12;
Ct[No] = 16;
Ct[Uo] = 1;
Ct[zo] = 2;
Ct[Vo] = 3;
Ct[Go] = 4;
class vt {
    get isArrayType() {
        return this.count > 0
    }
    constructor(e, t, s=0) {
        if (this.name = void 0,
        this.type = void 0,
        this.byteSize = void 0,
        this.offset = void 0,
        this.scopeId = void 0,
        this.count = void 0,
        this.numComponents = void 0,
        this.shortName = e,
        this.name = s ? `${e}[0]` : e,
        this.type = t,
        this.numComponents = Ct[t],
        this.updateType = t,
        s > 0)
            switch (t) {
            case yi:
                this.updateType = cf;
                break;
            case pa:
                this.updateType = Ho;
                break;
            case Uo:
                this.updateType = ff;
                break;
            case wo:
                this.updateType = pf;
                break;
            case mr:
                this.updateType = df;
                break;
            case ia:
                this.updateType = Wo;
                break;
            case zo:
                this.updateType = mf;
                break;
            case mh:
                this.updateType = _f;
                break;
            case As:
                this.updateType = uf;
                break;
            case na:
                this.updateType = Xo;
                break;
            case Vo:
                this.updateType = gf;
                break;
            case _h:
                this.updateType = yf;
                break;
            case ma:
                this.updateType = N_;
                break;
            case ra:
                this.updateType = Qd;
                break;
            case Go:
                this.updateType = U_;
                break;
            case gh:
                this.updateType = z_;
                break;
            case No:
                this.updateType = FS;
                break
            }
        this.count = s;
        let i = this.numComponents;
        s && (i = W.roundUp(i, 4)),
        this.byteSize = i * 4,
        s && (this.byteSize *= s)
    }
    calculateOffset(e) {
        let t = this.byteSize <= 8 ? this.byteSize : 16;
        this.count && (t = 16),
        e = W.roundUp(e, t),
        this.offset = e / 4
    }
}
class Sf {
    constructor(e, t) {
        this.byteSize = 0,
        this.map = new Map,
        this.scope = e.scope,
        this.uniforms = t;
        let s = 0;
        for (let i = 0; i < t.length; i++) {
            const n = t[i];
            n.calculateOffset(s),
            s = n.offset * 4 + n.byteSize,
            n.scopeId = this.scope.resolve(n.name),
            this.map.set(n.name, n)
        }
        this.byteSize = W.roundUp(s, 16)
    }
    get(e) {
        return this.map.get(e)
    }
    getShaderDeclaration(e, t) {
        const s = XT[e];
        let i = `layout(set = ${e}, binding = ${t}, std140) uniform ub_${s} {
`;
        return this.uniforms.forEach(n => {
            const r = BS[n.type];
            i += `    ${r} ${n.shortName}${n.count ? `[${n.count}]` : ""};
`
        }
        ),
        i + `};
`
    }
}
let wC = 0;
const bC = {
    [Es]: "texture2D",
    [Vl]: "textureCube",
    [Id]: "texture3D",
    [zl]: "texture2DArray"
};
class xf {
    constructor(e, t) {
        this.name = e,
        this.visibility = t
    }
}
class Jn {
    constructor(e, t, s=Es, i=ta) {
        this.scopeId = void 0,
        this.name = e,
        this.visibility = t,
        this.textureDimension = s,
        this.sampleType = i
    }
}
class wf {
    constructor(e, t=[], s=[], i=[], n={}) {
        var r;
        this.compute = !1,
        this.id = wC++,
        this.compute = (r = n.compute) != null ? r : !1,
        this.device = e;
        const o = e.scope;
        this.bufferFormats = t,
        this.bufferFormatsMap = new Map,
        t.forEach( (l, c) => this.bufferFormatsMap.set(l.name, c)),
        this.textureFormats = s,
        this.textureFormatsMap = new Map,
        s.forEach( (l, c) => {
            this.textureFormatsMap.set(l.name, c),
            l.scopeId = o.resolve(l.name)
        }
        ),
        this.storageTextureFormats = i,
        this.storageTextureFormatsMap = new Map,
        i.forEach( (l, c) => {
            this.storageTextureFormatsMap.set(l.name, c),
            l.scopeId = o.resolve(l.name)
        }
        ),
        this.impl = e.createBindGroupFormatImpl(this)
    }
    destroy() {
        this.impl.destroy()
    }
    getTexture(e) {
        const t = this.textureFormatsMap.get(e);
        return t !== void 0 ? this.textureFormats[t] : null
    }
    getStorageTexture(e) {
        const t = this.storageTextureFormatsMap.get(e);
        return t !== void 0 ? this.storageTextureFormats[t] : null
    }
    getShaderDeclarationTextures(e) {
        let t = ""
          , s = this.bufferFormats.length;
        return this.textureFormats.forEach(i => {
            let n = bC[i.textureDimension]
              , r = ""
              , o = "";
            n === "texture2DArray" && (r = "_texture",
            o = `#define ${i.name} sampler2DArray(${i.name}${r}, ${i.name}_sampler)
`),
            i.sampleType === sc ? n = `i${n}` : i.sampleType === ic && (n = `u${n}`),
            t += `layout(set = ${e}, binding = ${s++}) uniform ${n} ${i.name}${r};
layout(set = ${e}, binding = ${s++}) uniform sampler ${i.name}_sampler;
` + o
        }
        ),
        t
    }
    loseContext() {}
}
const Ey = /[ \t]*(\battribute\b|\bvarying\b|\buniform\b)/g
  , Gf = /(\battribute\b|\bvarying\b|\bout\b|\buniform\b)[ \t]*([^;]+)([;]+)/g
  , Hf = "@@@"
  , TC = /([\w-]+)\[(.*?)\]/
  , CC = new Set(["highp", "mediump", "lowp"])
  , EC = new Set(["sampler2DShadow", "samplerCubeShadow", "sampler2DArrayShadow"])
  , AC = {
    sampler2D: Es,
    sampler3D: Id,
    samplerCube: Vl,
    samplerCubeShadow: Vl,
    sampler2DShadow: Es,
    sampler2DArray: zl,
    sampler2DArrayShadow: zl,
    isampler2D: Es,
    usampler2D: Es,
    isampler3D: Id,
    usampler3D: Id,
    isamplerCube: Vl,
    usamplerCube: Vl,
    isampler2DArray: zl,
    usampler2DArray: zl
};
class MC {
    constructor(e, t) {
        this.line = e;
        const s = e.trim().split(/\s+/);
        if (CC.has(s[0]) && (this.precision = s.shift()),
        this.type = s.shift(),
        e.includes(","),
        e.includes("[")) {
            const i = s.join(" ")
              , n = TC.exec(i);
            this.name = n[1],
            this.arraySize = Number(n[2]),
            isNaN(this.arraySize) && (t.failed = !0)
        } else
            this.name = s.shift(),
            this.arraySize = 0;
        this.isSampler = this.type.indexOf("sampler") !== -1,
        this.isSignedInt = this.type.indexOf("isampler") !== -1,
        this.isUnsignedInt = this.type.indexOf("usampler") !== -1
    }
}
class ws {
    static run(e, t, s) {
        const i = new Map
          , n = ws.extract(t.vshader)
          , r = ws.extract(t.fshader)
          , o = ws.processAttributes(n.attributes, t.attributes, t.processingOptions)
          , l = ws.processVaryings(n.varyings, i, !0)
          , c = ws.processVaryings(r.varyings, i, !1)
          , d = ws.processOuts(r.outs)
          , h = n.uniforms.concat(r.uniforms)
          , f = Array.from(new Set(h)).map(x => new MC(x,s))
          , p = ws.processUniforms(e, f, t.processingOptions, s)
          , _ = o + `
` + l + `
` + p.code
          , m = n.src.replace(Hf, _)
          , g = c + `
` + d + `
` + p.code
          , v = r.src.replace(Hf, g);
        return {
            vshader: m,
            fshader: v,
            meshUniformBufferFormat: p.meshUniformBufferFormat,
            meshBindGroupFormat: p.meshBindGroupFormat
        }
    }
    static extract(e) {
        const t = []
          , s = []
          , i = []
          , n = [];
        let r = `${Hf}
`, o;
        for (; (o = Ey.exec(e)) !== null; ) {
            const l = o[1];
            switch (l) {
            case "attribute":
            case "varying":
            case "uniform":
            case "out":
                {
                    Gf.lastIndex = o.index;
                    const c = Gf.exec(e);
                    l === "attribute" ? t.push(c[2]) : l === "varying" ? s.push(c[2]) : l === "out" ? i.push(c[2]) : l === "uniform" && n.push(c[2]),
                    e = ws.cutOut(e, o.index, Gf.lastIndex, r),
                    Ey.lastIndex = o.index + r.length,
                    r = "";
                    break
                }
            }
        }
        return {
            src: e,
            attributes: t,
            varyings: s,
            outs: i,
            uniforms: n
        }
    }
    static processUniforms(e, t, s, i) {
        const n = []
          , r = [];
        t.forEach(f => {
            f.isSampler ? n.push(f) : r.push(f)
        }
        );
        const o = [];
        r.forEach(f => {
            if (!s.hasUniform(f.name)) {
                const p = BS.indexOf(f.type)
                  , _ = new vt(f.name,p,f.arraySize);
                o.push(_)
            }
        }
        );
        const l = o.length ? new Sf(e,o) : null
          , c = [];
        l && c.push(new xf(rc,jo | Cs));
        const d = [];
        n.forEach(f => {
            if (!s.hasTexture(f.name)) {
                let p = ta;
                f.isSignedInt ? p = sc : f.isUnsignedInt ? p = ic : (f.precision === "highp" && (p = sa),
                EC.has(f.type) && (p = ko));
                const _ = AC[f.type];
                d.push(new Jn(f.name,jo | Cs,_,p))
            }
        }
        );
        const h = new wf(e,c,d);
        let u = "";
        return s.uniformFormats.forEach( (f, p) => {
            f && (u += f.getShaderDeclaration(p, 0))
        }
        ),
        l && (u += l.getShaderDeclaration(vh, 0)),
        s.bindGroupFormats.forEach( (f, p) => {
            f && (u += f.getShaderDeclarationTextures(p))
        }
        ),
        u += h.getShaderDeclarationTextures(vh),
        {
            code: u,
            meshUniformBufferFormat: l,
            meshBindGroupFormat: h
        }
    }
    static processVaryings(e, t, s) {
        let i = "";
        const n = s ? "out" : "in";
        return e.forEach( (r, o) => {
            const l = ws.splitToWords(r)
              , c = l[0]
              , d = l[1];
            s ? t.set(d, o) : o = t.get(d),
            i += `layout(location = ${o}) ${n} ${c} ${d};
`
        }
        ),
        i
    }
    static processOuts(e) {
        let t = "";
        return e.forEach( (s, i) => {
            t += `layout(location = ${i}) out ${s};
`
        }
        ),
        t
    }
    static getTypeCount(e) {
        const t = e.substring(e.length - 1)
          , s = parseInt(t, 10);
        return isNaN(s) ? 1 : s
    }
    static processAttributes(e, t, s) {
        let i = "";
        return e.forEach(n => {
            const r = ws.splitToWords(n);
            let o = r[0]
              , l = r[1];
            if (t.hasOwnProperty(l)) {
                const c = t[l]
                  , d = De[c];
                let h;
                const u = s.getVertexElement(c);
                if (u) {
                    const f = u.dataType;
                    if (f !== Me && f !== k_ && !u.normalize && !u.asInt) {
                        const p = ws.getTypeCount(o)
                          , _ = `_private_${l}`;
                        h = `vec${p} ${l} = vec${p}(${_});
`,
                        l = _;
                        const m = f === Ca || f === Ea || f === nc;
                        p === 1 ? o = m ? "int" : "uint" : o = m ? `ivec${p}` : `uvec${p}`
                    }
                }
                i += `layout(location = ${d}) in ${o} ${l};
`,
                h && (i += h)
            }
        }
        ),
        i
    }
    static splitToWords(e) {
        return e = e.replace(/\s+/g, " ").trim(),
        e.split(" ")
    }
    static cutOut(e, t, s, i) {
        return e.substring(0, t) + i + e.substring(s)
    }
}
class PC {
    constructor(e) {
        this._vertexCode = null,
        this._fragmentCode = null,
        this._computeCode = null,
        this.vertexEntryPoint = "main",
        this.fragmentEntryPoint = "main",
        this.computeEntryPoint = "main",
        this.shader = e;
        const t = e.definition;
        if (t.shaderLanguage === hf) {
            var s, i, n;
            this._vertexCode = (s = t.vshader) != null ? s : null,
            this._fragmentCode = (i = t.fshader) != null ? i : null,
            this._computeCode = (n = t.cshader) != null ? n : null,
            this.vertexEntryPoint = "vertexMain",
            this.fragmentEntryPoint = "fragmentMain",
            e.ready = !0
        } else
            t.processingOptions && this.process()
    }
    destroy(e) {
        this._vertexCode = null,
        this._fragmentCode = null
    }
    createShaderModule(e, t) {
        return this.shader.device.wgpu.createShaderModule({
            code: e
        })
    }
    getVertexShaderModule() {
        return this.createShaderModule(this._vertexCode, "Vertex")
    }
    getFragmentShaderModule() {
        return this.createShaderModule(this._fragmentCode, "Fragment")
    }
    getComputeShaderModule() {
        return this.createShaderModule(this._computeCode, "Compute")
    }
    process() {
        const e = this.shader
          , t = ws.run(e.device, e.definition, e);
        this._vertexCode = this.transpile(t.vshader, "vertex", e.definition.vshader),
        this._fragmentCode = this.transpile(t.fshader, "fragment", e.definition.fshader),
        this._vertexCode && this._fragmentCode ? e.ready = !0 : e.failed = !0,
        e.meshUniformBufferFormat = t.meshUniformBufferFormat,
        e.meshBindGroupFormat = t.meshBindGroupFormat
    }
    transpile(e, t, s) {
        try {
            const i = this.shader.device.glslang.compileGLSL(e, t);
            return this.shader.device.twgsl.convertSpirV2WGSL(i)
        } catch (i) {
            console.error(`Failed to transpile webgl ${t} shader [${this.shader.label}] to WebGPU: [${i.message}]`, {
                processed: e,
                original: s,
                shader: this.shader
            })
        }
    }
    get vertexCode() {
        return this._vertexCode
    }
    get fragmentCode() {
        return this._fragmentCode
    }
    loseContext() {}
    restoreContext(e, t) {}
}
class wn {
    static calcLevelDimension(e, t) {
        return Math.max(e >> t, 1)
    }
    static calcMipLevelsCount(e, t, s=1) {
        return 1 + Math.floor(Math.log2(Math.max(e, t, s)))
    }
    static calcLevelGpuSize(e, t, s, i) {
        var n, r, o;
        const l = ph.get(i)
          , c = (n = (r = ph.get(i)) == null ? void 0 : r.size) != null ? n : 0;
        if (c > 0)
            return e * t * s * c;
        const d = (o = l.blockSize) != null ? o : 0;
        let h = Math.floor((e + 3) / 4);
        const u = Math.floor((t + 3) / 4)
          , f = Math.floor((s + 3) / 4);
        return (i === tl || i === sl) && (h = Math.max(Math.floor(h / 2), 1)),
        h * u * f * d
    }
    static calcGpuSize(e, t, s, i, n, r) {
        let o = 0;
        for (; o += wn.calcLevelGpuSize(e, t, s, i),
        !(!n || e === 1 && t === 1 && s === 1); )
            e = Math.max(e >> 1, 1),
            t = Math.max(t >> 1, 1),
            s = Math.max(s >> 1, 1);
        return o * (r ? 6 : 1)
    }
}
const To = [];
To[wt] = "repeat";
To[oe] = "clamp-to-edge";
To[Fu] = "mirror-repeat";
const bn = [];
bn[be] = {
    level: "nearest",
    mip: "nearest"
};
bn[ot] = {
    level: "linear",
    mip: "nearest"
};
bn[Vh] = {
    level: "nearest",
    mip: "nearest"
};
bn[Gh] = {
    level: "nearest",
    mip: "linear"
};
bn[Hh] = {
    level: "linear",
    mip: "nearest"
};
bn[ur] = {
    level: "linear",
    mip: "linear"
};
const RC = a => {}
;
class IC {
    constructor(e) {
        this.gpuTexture = void 0,
        this.view = void 0,
        this.samplers = [],
        this.descr = void 0,
        this.format = void 0,
        this.texture = e,
        this.format = me[e.format],
        this.create(e.device)
    }
    create(e) {
        const t = this.texture
          , s = e.wgpu
          , i = t.requiredMipLevels;
        this.descr = {
            size: {
                width: t.width,
                height: t.height,
                depthOrArrayLayers: t.cubemap ? 6 : t.array ? t.arrayLength : 1
            },
            format: this.format,
            mipLevelCount: i,
            sampleCount: 1,
            dimension: t.volume ? "3d" : "2d",
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | (um(t.format) ? 0 : GPUTextureUsage.RENDER_ATTACHMENT) | (t.storage ? GPUTextureUsage.STORAGE_BINDING : 0)
        },
        this.gpuTexture = s.createTexture(this.descr);
        let n;
        this.texture.format === ua && (n = {
            format: "depth24plus",
            aspect: "depth-only"
        }),
        this.view = this.createView(n)
    }
    destroy(e) {}
    propertyChanged(e) {
        this.samplers.length = 0
    }
    getView(e) {
        return this.uploadImmediate(e, this.texture),
        this.view
    }
    createView(e) {
        var t, s, i, n, r, o, l;
        const c = e ?? {}
          , d = this.descr
          , h = this.texture
          , u = () => h.cubemap ? "cube" : h.volume ? "3d" : h.array ? "2d-array" : "2d"
          , f = {
            format: (t = c.format) != null ? t : d.format,
            dimension: (s = c.dimension) != null ? s : u(),
            aspect: (i = c.aspect) != null ? i : "all",
            baseMipLevel: (n = c.baseMipLevel) != null ? n : 0,
            mipLevelCount: (r = c.mipLevelCount) != null ? r : d.mipLevelCount,
            baseArrayLayer: (o = c.baseArrayLayer) != null ? o : 0,
            arrayLayerCount: (l = c.arrayLayerCount) != null ? l : d.depthOrArrayLayers
        };
        return this.gpuTexture.createView(f)
    }
    getSampler(e, t) {
        let s = this.samplers[t];
        if (!s) {
            const i = this.texture
              , n = {
                addressModeU: To[i.addressU],
                addressModeV: To[i.addressV],
                addressModeW: To[i.addressW]
            };
            !t && i.compareOnRead && (t = ko),
            t === ko || t === sc || t === ic ? (n.compare = "less",
            n.magFilter = "linear",
            n.minFilter = "linear") : t === sa || this.texture.format === lt || this.texture.format === ua || this.texture.format === Tt || ho(this.texture.format) ? (n.magFilter = "nearest",
            n.minFilter = "nearest",
            n.mipmapFilter = "nearest") : (n.magFilter = bn[i.magFilter].level,
            n.minFilter = bn[i.minFilter].level,
            n.mipmapFilter = bn[i.minFilter].mip);
            const r = n.minFilter === "linear" && n.magFilter === "linear" && n.mipmapFilter === "linear";
            n.maxAnisotropy = r ? W.clamp(Math.round(i._anisotropy), 1, e.maxTextureAnisotropy) : 1,
            s = e.wgpu.createSampler(n),
            this.samplers[t] = s
        }
        return s
    }
    loseContext() {}
    uploadImmediate(e, t) {
        (t._needsUpload || t._needsMipmapsUpload) && (this.uploadData(e),
        t._needsUpload = !1,
        t._needsMipmapsUpload = !1)
    }
    uploadData(e) {
        const t = this.texture;
        if (t._levels) {
            let s = !1
              , i = !1;
            const n = t.requiredMipLevels;
            for (let r = 0; r < n; r++) {
                const o = t._levels[r];
                if (o) {
                    if (t.cubemap)
                        for (let l = 0; l < 6; l++) {
                            const c = o[l];
                            c ? this.isExternalImage(c) ? (this.uploadExternalImage(e, c, r, l),
                            s = !0) : ArrayBuffer.isView(c) && (this.uploadTypedArrayData(e, c, r, l),
                            s = !0) : i = !0
                        }
                    else if (!t._volume)
                        if (t.array)
                            if (t.arrayLength === o.length)
                                for (let l = 0; l < t._arrayLength; l++) {
                                    const c = o[l];
                                    this.isExternalImage(c) ? (this.uploadExternalImage(e, c, r, l),
                                    s = !0) : ArrayBuffer.isView(c) && (this.uploadTypedArrayData(e, c, r, l),
                                    s = !0)
                                }
                            else
                                i = !0;
                        else
                            this.isExternalImage(o) ? (this.uploadExternalImage(e, o, r, 0),
                            s = !0) : ArrayBuffer.isView(o) && (this.uploadTypedArrayData(e, o, r, 0),
                            s = !0)
                } else
                    i = !0
            }
            s && i && t.mipmaps && !um(t.format) && e.mipmapRenderer.generate(this),
            t._gpuSize && t.adjustVramSizeTracking(e._vram, -t._gpuSize),
            t._gpuSize = t.gpuSize,
            t.adjustVramSizeTracking(e._vram, t._gpuSize)
        }
    }
    isExternalImage(e) {
        return e instanceof ImageBitmap || e instanceof HTMLVideoElement || e instanceof HTMLCanvasElement || e instanceof OffscreenCanvas
    }
    uploadExternalImage(e, t, s, i) {
        const n = {
            source: t,
            origin: [0, 0],
            flipY: !1
        }
          , r = {
            texture: this.gpuTexture,
            mipLevel: s,
            origin: [0, 0, i],
            aspect: "all"
        }
          , o = {
            width: this.descr.size.width,
            height: this.descr.size.height,
            depthOrArrayLayers: 1
        };
        e.submit(),
        RC(t instanceof HTMLCanvasElement && t.getContext("2d")),
        e.wgpu.queue.copyExternalImageToTexture(n, r, o)
    }
    uploadTypedArrayData(e, t, s, i) {
        const n = this.texture
          , r = e.wgpu
          , o = {
            texture: this.gpuTexture,
            origin: [0, 0, i],
            mipLevel: s
        }
          , l = wn.calcLevelDimension(n.width, s)
          , c = wn.calcLevelDimension(n.height, s);
        wn.calcLevelGpuSize(l, c, 1, n.format);
        const d = ph.get(n.format);
        let h, u;
        if (d.size)
            h = {
                offset: 0,
                bytesPerRow: d.size * l,
                rowsPerImage: c
            },
            u = {
                width: l,
                height: c
            };
        else if (d.blockSize) {
            const f = p => Math.floor((p + 3) / 4);
            h = {
                offset: 0,
                bytesPerRow: d.blockSize * f(l),
                rowsPerImage: f(c)
            },
            u = {
                width: Math.max(4, l),
                height: Math.max(4, c)
            }
        }
        e.submit(),
        r.queue.writeTexture(o, t, h, u)
    }
}
class LC extends V_ {
    constructor(e) {
        super()
    }
    destroy(e) {
        super.destroy(e)
    }
    unlock(e) {
        const t = e.device;
        super.unlock(t, void 0, GPUBufferUsage.UNIFORM, e.storage)
    }
}
class DC extends V_ {
    constructor(e, t) {
        super()
    }
    destroy(e) {
        super.destroy(e)
    }
    unlock(e) {
        const t = e.device;
        super.unlock(t, e.usage, GPUBufferUsage.VERTEX, e.storage)
    }
}
const Wn = /[ \t]*#(ifn?def|if|endif|else|elif|define|undef|extension)/g
  , Ay = /define[ \t]+([^\n]+)\r?(?:\n|$)/g
  , My = /extension[ \t]+([\w-]+)[ \t]*:[ \t]*(enable|require)/g
  , Py = /undef[ \t]+([^\n]+)\r?(?:\n|$)/g
  , Wf = /(ifdef|ifndef|if)[ \t]*([^\r\n]+)\r?\n/g
  , Xf = /(endif|else|elif)([ \t]+[^\r\n]+)?\r?(?:\n|$)/g
  , Ry = /([\w-]+)/
  , OC = /(!|\s)?defined\(([\w-]+)\)/
  , FC = /[><=|&+-]/g;
class tr {
    static run(e, t=!1) {
        e = e.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, "$1"),
        e = e.split(/\r?\n/).map(n => n.trimEnd()).join(`
`);
        const s = new Map;
        if (t) {
            const n = new Map
              , r = /(pcFragColor[1-8])\b/g
              , o = e.match(r);
            o == null || o.forEach(l => {
                var c;
                const d = parseInt(l.charAt(l.length - 1), 10);
                n.set(d, ((c = n.get(d)) != null ? c : 0) + 1)
            }
            ),
            n.forEach( (l, c) => {
                l === 1 && s.set(`REMOVE_COLOR_ATTACHMENT_${c}`, "")
            }
            )
        }
        e = this._preprocess(e, s);
        const i = new Map;
        return s.forEach( (n, r) => {
            Number.isInteger(parseFloat(n)) && !n.includes(".") && i.set(r, n)
        }
        ),
        e !== null && (e = e.split(/\r?\n/).map(n => n.trim() === "" ? "" : n).map(n => (i.forEach( (r, o) => {
            n = n.replace(new RegExp(`\\[${o}\\]`,"g"), `[${r}]`)
        }
        ),
        n)).join(`
`),
        e = e.replace(/(\n\n){3,}/gm, `

`)),
        e
    }
    static _preprocess(e, t=new Map) {
        const s = e
          , i = [];
        let n = !1, r;
        for (; (r = Wn.exec(e)) !== null; ) {
            const o = r[1];
            switch (o) {
            case "define":
                {
                    Ay.lastIndex = r.index;
                    const l = Ay.exec(e);
                    n || (n = l === null);
                    const c = l[1];
                    Ry.lastIndex = l.index;
                    const h = Ry.exec(c)[1];
                    let u = c.substring(h.length).trim();
                    u === "" && (u = "true"),
                    tr._keep(i) && t.set(h, u),
                    Wn.lastIndex = l.index + l[0].length;
                    break
                }
            case "undef":
                {
                    Py.lastIndex = r.index;
                    const l = Py.exec(e)
                      , c = l[1].trim();
                    tr._keep(i) && t.delete(c),
                    Wn.lastIndex = l.index + l[0].length;
                    break
                }
            case "extension":
                {
                    My.lastIndex = r.index;
                    const l = My.exec(e);
                    if (n || (n = l === null),
                    l) {
                        const c = l[1];
                        tr._keep(i) && t.set(c, "true")
                    }
                    Wn.lastIndex = l.index + l[0].length;
                    break
                }
            case "ifdef":
            case "ifndef":
            case "if":
                {
                    Wf.lastIndex = r.index;
                    const l = Wf.exec(e)
                      , c = l[2]
                      , d = tr.evaluate(c, t);
                    n || (n = d.error);
                    let h = d.result;
                    o === "ifndef" && (h = !h),
                    i.push({
                        anyKeep: h,
                        keep: h,
                        start: r.index,
                        end: Wf.lastIndex
                    }),
                    Wn.lastIndex = l.index + l[0].length;
                    break
                }
            case "endif":
            case "else":
            case "elif":
                {
                    Xf.lastIndex = r.index;
                    const l = Xf.exec(e)
                      , c = i.pop()
                      , d = c.keep ? e.substring(c.end, r.index) : "";
                    e = e.substring(0, c.start) + d + e.substring(Xf.lastIndex),
                    Wn.lastIndex = c.start + d.length;
                    const h = l[1];
                    if (h === "else" || h === "elif") {
                        let u = !1;
                        if (!c.anyKeep)
                            if (h === "else")
                                u = !c.keep;
                            else {
                                const f = tr.evaluate(l[2], t);
                                u = f.result,
                                n || (n = f.error)
                            }
                        i.push({
                            anyKeep: c.anyKeep || u,
                            keep: u,
                            start: Wn.lastIndex,
                            end: Wn.lastIndex
                        })
                    }
                    break
                }
            }
        }
        return n ? (console.warn("Failed to preprocess shader: ", {
            source: s
        }),
        s) : e
    }
    static _keep(e) {
        for (let t = 0; t < e.length; t++)
            if (!e[t].keep)
                return !1;
        return !0
    }
    static evaluate(e, t) {
        const s = FC.exec(e) === null;
        let i = !1;
        const n = OC.exec(e);
        n && (i = n[1] === "!",
        e = n[2]),
        e = e.trim();
        let r = t.has(e);
        return i && (r = !r),
        {
            result: r,
            error: !s
        }
    }
}
let BC = 0;
class Xi {
    constructor(e, t) {
        this.meshUniformBufferFormat = void 0,
        this.meshBindGroupFormat = void 0,
        this.id = BC++,
        this.device = e,
        this.definition = t,
        this.name = t.name || "Untitled",
        this.init(),
        t.cshader || (t.vshader = tr.run(t.vshader),
        t.fshader = tr.run(t.fshader, e.isWebGL2)),
        this.impl = e.createShaderImpl(this)
    }
    init() {
        this.ready = !1,
        this.failed = !1
    }
    get label() {
        return `Shader Id ${this.id} ${this.name}`
    }
    destroy() {
        this.device.onDestroyShader(this),
        this.impl.destroy(this)
    }
    loseContext() {
        this.init(),
        this.impl.loseContext()
    }
    restoreContext() {
        this.impl.restoreContext(this.device, this)
    }
}
let kC = 0;
class lc {
    constructor(e, t, s) {
        this.renderVersionUpdated = -1,
        this.uniformBuffers = void 0,
        this.uniformBufferOffsets = [],
        this.id = kC++,
        this.device = e,
        this.format = t,
        this.dirty = !0,
        this.impl = e.createBindGroupImpl(this),
        this.textures = [],
        this.storageTextures = [],
        this.uniformBuffers = [],
        this.defaultUniformBuffer = s,
        s && this.setUniformBuffer(rc, s)
    }
    destroy() {
        this.impl.destroy(),
        this.impl = null,
        this.format = null,
        this.defaultUniformBuffer = null
    }
    setUniformBuffer(e, t) {
        const s = this.format.bufferFormatsMap.get(e);
        this.uniformBuffers[s] !== t && (this.uniformBuffers[s] = t,
        this.dirty = !0)
    }
    setTexture(e, t) {
        const s = this.format.textureFormatsMap.get(e);
        this.textures[s] !== t ? (this.textures[s] = t,
        this.dirty = !0) : this.renderVersionUpdated < t.renderVersionDirty && (this.dirty = !0)
    }
    setStorageTexture(e, t) {
        const s = this.format.storageTextureFormatsMap.get(e);
        this.storageTextures[s] !== t ? (this.storageTextures[s] = t,
        this.dirty = !0) : this.renderVersionUpdated < t.renderVersionDirty && (this.dirty = !0)
    }
    update() {
        const {textureFormats: e, storageTextureFormats: t} = this.format;
        for (let s = 0; s < e.length; s++) {
            const i = e[s]
              , n = i.scopeId.value;
            this.setTexture(i.name, n)
        }
        for (let s = 0; s < t.length; s++) {
            const i = t[s]
              , n = i.scopeId.value;
            this.setStorageTexture(i.name, n)
        }
        this.uniformBufferOffsets.length = this.uniformBuffers.length;
        for (let s = 0; s < this.uniformBuffers.length; s++) {
            const i = this.uniformBuffers[s];
            this.uniformBufferOffsets[s] = i.offset,
            this.renderVersionUpdated < i.renderVersionDirty && (this.dirty = !0)
        }
        this.dirty && (this.dirty = !1,
        this.renderVersionUpdated = this.device.renderVersion,
        this.impl.update(this))
    }
}
class NC {
    constructor(e) {
        this.device = void 0,
        this.device = e
    }
}
class UC {
    constructor() {
        this.gpuBuffer = void 0,
        this.stagingBuffer = void 0,
        this.offset = void 0,
        this.size = void 0
    }
}
class zC {
    constructor() {
        this.storage = void 0,
        this.gpuBuffer = void 0,
        this.offset = void 0
    }
}
class VC {
    constructor(e, t, s) {
        this.bufferSize = void 0,
        this.gpuBuffers = [],
        this.stagingBuffers = [],
        this.usedBuffers = [],
        this.activeBuffer = null,
        this.device = e,
        this.bufferSize = t,
        this.bufferAlignment = s
    }
    destroy() {
        this.gpuBuffers.forEach(e => {
            e.destroy(this.device)
        }
        ),
        this.gpuBuffers = null,
        this.stagingBuffers.forEach(e => {
            e.destroy(this.device)
        }
        ),
        this.stagingBuffers = null,
        this.usedBuffers = null,
        this.activeBuffer = null
    }
    alloc(e, t) {
        if (this.activeBuffer) {
            const n = W.roundUp(this.activeBuffer.size, this.bufferAlignment);
            this.bufferSize - n < t && this.scheduleSubmit()
        }
        if (!this.activeBuffer) {
            let n = this.gpuBuffers.pop();
            n || (n = this.createBuffer(this.device, this.bufferSize, !1));
            let r = this.stagingBuffers.pop();
            r || (r = this.createBuffer(this.device, this.bufferSize, !0)),
            this.activeBuffer = new UC,
            this.activeBuffer.stagingBuffer = r,
            this.activeBuffer.gpuBuffer = n,
            this.activeBuffer.offset = 0,
            this.activeBuffer.size = 0
        }
        const s = this.activeBuffer
          , i = W.roundUp(s.size, this.bufferAlignment);
        e.gpuBuffer = s.gpuBuffer,
        e.offset = i,
        e.storage = s.stagingBuffer.alloc(i, t),
        s.size = i + t
    }
    scheduleSubmit() {
        this.activeBuffer && (this.usedBuffers.push(this.activeBuffer),
        this.activeBuffer = null)
    }
    submit() {
        this.scheduleSubmit()
    }
}
const ze = [];
ze[yi] = function(a, e, t) {
    const s = a.storageFloat32;
    s[t] = e
}
;
ze[mr] = (a, e, t) => {
    const s = a.storageFloat32;
    s[t] = e[0],
    s[t + 1] = e[1]
}
;
ze[As] = (a, e, t) => {
    const s = a.storageFloat32;
    s[t] = e[0],
    s[t + 1] = e[1],
    s[t + 2] = e[2]
}
;
ze[ma] = (a, e, t) => {
    const s = a.storageFloat32;
    s[t] = e[0],
    s[t + 1] = e[1],
    s[t + 2] = e[2],
    s[t + 3] = e[3]
}
;
ze[pa] = function(a, e, t) {
    const s = a.storageInt32;
    s[t] = e
}
;
ze[ia] = function(a, e, t) {
    const s = a.storageInt32;
    s[t] = e[0],
    s[t + 1] = e[1]
}
;
ze[na] = function(a, e, t) {
    const s = a.storageInt32;
    s[t] = e[0],
    s[t + 1] = e[1],
    s[t + 2] = e[2]
}
;
ze[ra] = function(a, e, t) {
    const s = a.storageInt32;
    s[t] = e[0],
    s[t + 1] = e[1],
    s[t + 2] = e[2],
    s[t + 3] = e[3]
}
;
ze[Zd] = (a, e, t) => {
    const s = a.storageFloat32;
    s[t] = e[0],
    s[t + 1] = e[1],
    s[t + 4] = e[2],
    s[t + 5] = e[3],
    s[t + 8] = e[4],
    s[t + 9] = e[5]
}
;
ze[yh] = (a, e, t) => {
    const s = a.storageFloat32;
    s[t] = e[0],
    s[t + 1] = e[1],
    s[t + 2] = e[2],
    s[t + 4] = e[3],
    s[t + 5] = e[4],
    s[t + 6] = e[5],
    s[t + 8] = e[6],
    s[t + 9] = e[7],
    s[t + 10] = e[8]
}
;
ze[cf] = function(a, e, t, s) {
    const i = a.storageFloat32;
    for (let n = 0; n < s; n++)
        i[t + n * 4] = e[n]
}
;
ze[df] = (a, e, t, s) => {
    const i = a.storageFloat32;
    for (let n = 0; n < s; n++)
        i[t + n * 4] = e[n * 2],
        i[t + n * 4 + 1] = e[n * 2 + 1]
}
;
ze[uf] = (a, e, t, s) => {
    const i = a.storageFloat32;
    for (let n = 0; n < s; n++)
        i[t + n * 4] = e[n * 3],
        i[t + n * 4 + 1] = e[n * 3 + 1],
        i[t + n * 4 + 2] = e[n * 3 + 2]
}
;
ze[Uo] = (a, e, t, s) => {
    const i = a.storageUint32;
    i[t] = e
}
;
ze[zo] = (a, e, t, s) => {
    const i = a.storageUint32;
    i[t] = e[0],
    i[t + 1] = e[1]
}
;
ze[Vo] = (a, e, t, s) => {
    const i = a.storageUint32;
    i[t] = e[0],
    i[t + 1] = e[1],
    i[t + 2] = e[2]
}
;
ze[Go] = (a, e, t, s) => {
    const i = a.storageUint32;
    i[t] = e[0],
    i[t + 1] = e[1],
    i[t + 2] = e[2],
    i[t + 3] = e[3]
}
;
ze[Ho] = function(a, e, t, s) {
    const i = a.storageInt32;
    for (let n = 0; n < s; n++)
        i[t + n * 4] = e[n]
}
;
ze[pf] = ze[Ho];
ze[ff] = function(a, e, t, s) {
    const i = a.storageUint32;
    for (let n = 0; n < s; n++)
        i[t + n * 4] = e[n]
}
;
ze[Wo] = (a, e, t, s) => {
    const i = a.storageInt32;
    for (let n = 0; n < s; n++)
        i[t + n * 4] = e[n * 2],
        i[t + n * 4 + 1] = e[n * 2 + 1]
}
;
ze[_f] = ze[Wo];
ze[mf] = (a, e, t, s) => {
    const i = a.storageUint32;
    for (let n = 0; n < s; n++)
        i[t + n * 4] = e[n * 2],
        i[t + n * 4 + 1] = e[n * 2 + 1]
}
;
ze[Xo] = (a, e, t, s) => {
    const i = a.storageInt32;
    for (let n = 0; n < s; n++)
        i[t + n * 4] = e[n * 3],
        i[t + n * 4 + 1] = e[n * 3 + 1],
        i[t + n * 4 + 2] = e[n * 3 + 2]
}
;
ze[yf] = ze[Xo];
ze[gf] = (a, e, t, s) => {
    const i = a.storageUint32;
    for (let n = 0; n < s; n++)
        i[t + n * 4] = e[n * 3],
        i[t + n * 4 + 1] = e[n * 3 + 1],
        i[t + n * 4 + 2] = e[n * 3 + 2]
}
;
class bf {
    constructor(e, t, s=!0) {
        if (this.device = void 0,
        this.persistent = void 0,
        this.allocation = void 0,
        this.storageFloat32 = void 0,
        this.storageInt32 = void 0,
        this.storageUint32 = void 0,
        this.renderVersionDirty = 0,
        this.device = e,
        this.format = t,
        this.persistent = s,
        s) {
            this.impl = e.createUniformBufferImpl(this);
            const i = new ArrayBuffer(t.byteSize);
            this.assignStorage(new Int32Array(i)),
            e._vram.ub += this.format.byteSize
        } else
            this.allocation = new zC
    }
    destroy() {
        if (this.persistent) {
            const e = this.device;
            this.impl.destroy(e),
            e._vram.ub -= this.format.byteSize
        }
    }
    get offset() {
        return this.persistent ? 0 : this.allocation.offset
    }
    assignStorage(e) {
        this.storageInt32 = e,
        this.storageUint32 = new Uint32Array(e.buffer,e.byteOffset,e.byteLength / 4),
        this.storageFloat32 = new Float32Array(e.buffer,e.byteOffset,e.byteLength / 4)
    }
    loseContext() {
        var e;
        (e = this.impl) == null || e.loseContext()
    }
    setUniform(e) {
        const t = e.offset
          , s = e.scopeId.value;
        if (s != null) {
            const i = ze[e.updateType];
            i ? i(this, s, t, e.count) : this.storageFloat32.set(s, t)
        }
    }
    set(e) {
        const t = this.format.map.get(e);
        t && this.setUniform(t)
    }
    update() {
        const e = this.persistent;
        if (!e) {
            const s = this.allocation
              , i = s.gpuBuffer;
            this.device.dynamicBuffers.alloc(s, this.format.byteSize),
            this.assignStorage(s.storage),
            i !== s.gpuBuffer && (this.renderVersionDirty = this.device.renderVersion)
        }
        const t = this.format.uniforms;
        for (let s = 0; s < t.length; s++)
            this.setUniform(t[s]);
        e ? this.impl.unlock(this) : (this.storageFloat32 = null,
        this.storageInt32 = null)
    }
}
const GC = {
    type: Ks,
    base: 0,
    count: 4,
    indexed: !1
};
class HC {
    constructor(e) {
        const t = `

						struct ub_mesh {
								color : vec4f,
								depth: f32
						}

						@group(0) @binding(0) var<uniform> ubMesh : ub_mesh;

						var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
								vec2(-1.0, 1.0), vec2(1.0, 1.0),
								vec2(-1.0, -1.0), vec2(1.0, -1.0)
						);

						struct VertexOutput {
								@builtin(position) position : vec4f
						}

						@vertex
						fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
								var output : VertexOutput;
								output.position = vec4(pos[vertexIndex], ubMesh.depth, 1.0);
								return output;
						}

						@fragment
						fn fragmentMain() -> @location(0) vec4f {
								return ubMesh.color;
						}
				`;
        this.shader = new Xi(e,{
            name: "WebGPUClearRendererShader",
            shaderLanguage: hf,
            vshader: t,
            fshader: t
        }),
        this.uniformBuffer = new bf(e,new Sf(e,[new vt("color",ma), new vt("depth",yi)]),!1);
        const s = new wf(e,[new xf(rc,jo | Cs)]);
        this.bindGroup = new lc(e,s,this.uniformBuffer),
        this.colorData = new Float32Array(4),
        this.colorId = e.scope.resolve("color"),
        this.depthId = e.scope.resolve("depth")
    }
    destroy() {
        this.shader.destroy(),
        this.shader = null,
        this.uniformBuffer.destroy(),
        this.uniformBuffer = null,
        this.bindGroup.destroy(),
        this.bindGroup = null
    }
    clear(e, t, s, i) {
        var n;
        s = s || i;
        const r = (n = s.flags) != null ? n : i.flags;
        if (r !== 0) {
            if (r & Oo && t.colorBuffer) {
                var o;
                const d = (o = s.color) != null ? o : i.color;
                this.colorData.set(d),
                e.setBlendState(ft.NOBLEND)
            } else
                e.setBlendState(ft.NOWRITE);
            if (this.colorId.setValue(this.colorData),
            r & Fo && t.depth) {
                var l;
                const d = (l = s.depth) != null ? l : i.depth;
                this.depthId.setValue(d),
                e.setDepthState($t.WRITEDEPTH)
            } else
                this.depthId.setValue(1),
                e.setDepthState($t.NODEPTH);
            r & fh && t.stencil,
            e.setCullMode(bt),
            e.setShader(this.shader);
            const c = this.bindGroup;
            c.defaultUniformBuffer.update(),
            c.update(),
            e.setBindGroup(vh, c),
            e.draw(GC)
        }
    }
}
class WC {
    constructor(e) {
        this.device = void 0,
        this.device = e;
        const t = `
 
						var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
								vec2(-1.0, 1.0), vec2(1.0, 1.0),
								vec2(-1.0, -1.0), vec2(1.0, -1.0)
						);

						struct VertexOutput {
								@builtin(position) position : vec4f,
								@location(0) texCoord : vec2f
						};

						@vertex
						fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
							var output : VertexOutput;
							output.texCoord = pos[vertexIndex] * vec2f(0.5, -0.5) + vec2f(0.5);
							output.position = vec4f(pos[vertexIndex], 0, 1);
							return output;
						}

						@group(0) @binding(0) var imgSampler : sampler;
						@group(0) @binding(1) var img : texture_2d<f32>;

						@fragment
						fn fragmentMain(@location(0) texCoord : vec2f) -> @location(0) vec4f {
							return textureSample(img, imgSampler, texCoord);
						}
				`;
        this.shader = new Xi(e,{
            name: "WebGPUMipmapRendererShader",
            shaderLanguage: hf,
            vshader: t,
            fshader: t
        }),
        this.minSampler = e.wgpu.createSampler({
            minFilter: "linear"
        })
    }
    destroy() {
        this.shader.destroy(),
        this.shader = null
    }
    generate(e) {
        var t;
        const s = e.descr;
        if (s.mipLevelCount <= 1 || e.texture.volume)
            return;
        const i = this.device
          , n = i.wgpu
          , r = this.shader.impl
          , o = n.createRenderPipeline({
            layout: "auto",
            vertex: {
                module: r.getVertexShaderModule(),
                entryPoint: r.vertexEntryPoint
            },
            fragment: {
                module: r.getFragmentShaderModule(),
                entryPoint: r.fragmentEntryPoint,
                targets: [{
                    format: s.format
                }]
            },
            primitive: {
                topology: "triangle-strip"
            }
        })
          , l = e.texture
          , c = l.cubemap ? 6 : l.array ? l.arrayLength : 1
          , d = [];
        for (let u = 0; u < c; u++)
            d.push(e.createView({
                dimension: "2d",
                baseMipLevel: 0,
                mipLevelCount: 1,
                baseArrayLayer: u
            }));
        const h = (t = i.commandEncoder) != null ? t : n.createCommandEncoder();
        for (let u = 1; u < s.mipLevelCount; u++)
            for (let f = 0; f < c; f++) {
                const p = e.createView({
                    dimension: "2d",
                    baseMipLevel: u,
                    mipLevelCount: 1,
                    baseArrayLayer: f
                })
                  , _ = h.beginRenderPass({
                    colorAttachments: [{
                        view: p,
                        loadOp: "clear",
                        storeOp: "store"
                    }]
                })
                  , m = n.createBindGroup({
                    layout: o.getBindGroupLayout(0),
                    entries: [{
                        binding: 0,
                        resource: this.minSampler
                    }, {
                        binding: 1,
                        resource: d[f]
                    }]
                });
                _.setPipeline(o),
                _.setBindGroup(0, m),
                _.draw(4),
                _.end(),
                d[f] = p
            }
        if (!i.commandEncoder) {
            const u = h.finish();
            i.addCommandBuffer(u)
        }
        i.pipeline = null
    }
}
class XC extends NC {
    constructor(e, t, s) {
        super(e),
        this.buffer = null,
        this.mappedRange = null,
        this.buffer = e.wgpu.createBuffer({
            size: t,
            usage: s ? GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC : GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            mappedAtCreation: s
        }),
        s && this.onAvailable(),
        e._vram.ub += t
    }
    destroy(e) {
        e._vram.ub -= this.buffer.size,
        this.buffer.destroy(),
        this.buffer = null
    }
    onAvailable() {
        this.mappedRange = this.buffer.getMappedRange()
    }
    alloc(e, t) {
        return new Int32Array(this.mappedRange,e,t / 4)
    }
}
class jC extends VC {
    constructor(...e) {
        super(...e),
        this.pendingStagingBuffers = []
    }
    createBuffer(e, t, s) {
        return new XC(e,t,s)
    }
    submit() {
        super.submit();
        const e = this.usedBuffers.length;
        if (e) {
            const t = this.device
              , s = this.gpuBuffers
              , i = t.wgpu.createCommandEncoder();
            for (let r = e - 1; r >= 0; r--) {
                const o = this.usedBuffers[r]
                  , {stagingBuffer: l, gpuBuffer: c, offset: d, size: h} = o
                  , u = l.buffer;
                u.unmap(),
                i.copyBufferToBuffer(u, d, c.buffer, d, h),
                s.push(c)
            }
            const n = i.finish();
            t.addCommandBuffer(n, !0);
            for (let r = 0; r < e; r++) {
                const o = this.usedBuffers[r].stagingBuffer;
                this.pendingStagingBuffers.push(o)
            }
            this.usedBuffers.length = 0
        }
    }
    onCommandBuffersSubmitted() {
        const e = this.pendingStagingBuffers.length;
        if (e) {
            for (let t = 0; t < e; t++) {
                const s = this.pendingStagingBuffers[t];
                s.buffer.mapAsync(GPUMapMode.WRITE).then( () => {
                    this.stagingBuffers && (s.onAvailable(),
                    this.stagingBuffers.push(s))
                }
                )
            }
            this.pendingStagingBuffers.length = 0
        }
    }
}
class GS {
    constructor() {
        this.frameAllocations = [],
        this.pastFrameAllocations = new Map,
        this._enabled = !1,
        this._enableRequest = !1,
        this._frameTime = 0
    }
    loseContext() {
        this.pastFrameAllocations.clear()
    }
    set enabled(e) {
        this._enableRequest = e
    }
    get enabled() {
        return this._enableRequest
    }
    processEnableRequest() {
        this._enableRequest !== this._enabled && (this._enabled = this._enableRequest,
        this._enabled || (this._frameTime = 0))
    }
    request(e) {
        this.pastFrameAllocations.set(e, this.frameAllocations),
        this.frameAllocations = []
    }
    report(e, t) {
        if (t) {
            const s = this.pastFrameAllocations.get(e);
            if (t.length > 0 && (this._frameTime = t[0]),
            Uh.get(Ab))
                for (let i = 0; i < s.length; ++i)
                    s[i]
        }
        this.pastFrameAllocations.delete(e)
    }
    getSlot(e) {
        const t = this.frameAllocations.length;
        return this.frameAllocations.push(e),
        t
    }
    get slotCount() {
        return this.frameAllocations.length
    }
}
class $C {
    constructor(e, t, s) {
        this.querySet = void 0,
        this.stagingBuffers = [],
        this.activeStagingBuffer = null,
        this.bytesPerSlot = void 0,
        this.device = e,
        this.capacity = s,
        this.bytesPerSlot = t ? 8 : 4;
        const i = e.wgpu;
        this.querySet = i.createQuerySet({
            type: t ? "timestamp" : "occlusion",
            count: s
        }),
        this.queryBuffer = i.createBuffer({
            size: this.bytesPerSlot * s,
            usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
        })
    }
    destroy() {
        var e, t;
        (e = this.querySet) == null || e.destroy(),
        this.querySet = null,
        (t = this.queryBuffer) == null || t.destroy(),
        this.queryBuffer = null,
        this.activeStagingBuffer = null,
        this.stagingBuffers.forEach(s => {
            s.destroy()
        }
        ),
        this.stagingBuffers = null
    }
    getStagingBuffer() {
        let e = this.stagingBuffers.pop();
        return e || (e = this.device.wgpu.createBuffer({
            size: this.queryBuffer.size,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        })),
        e
    }
    resolve(e) {
        const t = this.device
          , s = t.wgpu.createCommandEncoder();
        s.resolveQuerySet(this.querySet, 0, e, this.queryBuffer, 0);
        const i = this.getStagingBuffer();
        this.activeStagingBuffer = i,
        s.copyBufferToBuffer(this.queryBuffer, 0, i, 0, this.bytesPerSlot * e);
        const n = s.finish();
        t.addCommandBuffer(n)
    }
    request(e, t) {
        const s = this.activeStagingBuffer;
        return this.activeStagingBuffer = null,
        s.mapAsync(GPUMapMode.READ).then( () => {
            const i = new BigInt64Array(s.getMappedRange())
              , n = [];
            for (let r = 0; r < e; r++)
                n.push(Number(i[r * 2 + 1] - i[r * 2]) * 1e-6);
            return s.unmap(),
            this.stagingBuffers.push(s),
            {
                renderVersion: t,
                timings: n
            }
        }
        )
    }
}
class qC extends GS {
    constructor(e) {
        super(),
        this.device = void 0,
        this.frameGPUMarkerSlot = void 0,
        this.device = e,
        this.timestampQueriesSet = e.supportsTimestampQuery ? new $C(e,!0,512) : null
    }
    destroy() {
        var e;
        (e = this.timestampQueriesSet) == null || e.destroy(),
        this.timestampQueriesSet = null
    }
    frameMarker(e) {
        if (this.timestampQueriesSet) {
            const t = this.device.wgpu.createCommandEncoder();
            this.frameGPUMarkerSlot = e ? this.getSlot("GpuFrame") : this.frameGPUMarkerSlot,
            t.writeTimestamp(this.timestampQueriesSet.querySet, this.frameGPUMarkerSlot * 2 + (e ? 0 : 1));
            const s = t.finish();
            this.device.addCommandBuffer(s, e)
        }
    }
    frameStart() {
        this.processEnableRequest(),
        this._enabled && this.frameMarker(!0)
    }
    frameEnd() {
        if (this._enabled) {
            var e;
            this.frameMarker(!1),
            (e = this.timestampQueriesSet) == null || e.resolve(this.slotCount * 2)
        }
    }
    request() {
        if (this._enabled) {
            var e;
            const t = this.device.renderVersion;
            (e = this.timestampQueriesSet) == null || e.request(this.slotCount, t).then(s => {
                this.report(s.renderVersion, s.timings)
            }
            ),
            super.request(t)
        }
    }
}
class YC {
    constructor(e) {
        this.device = void 0,
        this.pipelineCache = new Map,
        this.device = e;
        const t = `
 
						var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
								vec2(-1.0, 1.0), vec2(1.0, 1.0), vec2(-1.0, -1.0), vec2(1.0, -1.0)
						);

						struct VertexOutput {
								@builtin(position) position : vec4f,
						};

						@vertex
						fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
							var output : VertexOutput;
							output.position = vec4f(pos[vertexIndex], 0, 1);
							return output;
						}

						@group(0) @binding(0) var img : texture_depth_multisampled_2d;

						@fragment
						fn fragmentMain(@builtin(position) fragColor: vec4f) -> @location(0) vec4f {
								// load th depth value from sample index 0
								var depth = textureLoad(img, vec2i(fragColor.xy), 0u);
								return vec4<f32>(depth, 0.0, 0.0, 0.0);
						}
				`;
        this.shader = new Xi(e,{
            name: "WebGPUResolverDepthShader",
            shaderLanguage: hf,
            vshader: t,
            fshader: t
        })
    }
    destroy() {
        this.shader.destroy(),
        this.shader = null,
        this.pipelineCache = null
    }
    getPipeline(e) {
        let t = this.pipelineCache.get(e);
        return t || (t = this.createPipeline(e),
        this.pipelineCache.set(e, t)),
        t
    }
    createPipeline(e) {
        const t = this.shader.impl;
        return this.device.wgpu.createRenderPipeline({
            layout: "auto",
            vertex: {
                module: t.getVertexShaderModule(),
                entryPoint: t.vertexEntryPoint
            },
            fragment: {
                module: t.getFragmentShaderModule(),
                entryPoint: t.fragmentEntryPoint,
                targets: [{
                    format: e
                }]
            },
            primitive: {
                topology: "triangle-strip"
            }
        })
    }
    resolveDepth(e, t, s) {
        const i = this.device
          , n = i.wgpu
          , r = this.getPipeline(s.format)
          , o = t.depthOrArrayLayers;
        for (let l = 0; l < o; l++) {
            const c = t.createView({
                dimension: "2d",
                aspect: "depth-only",
                baseMipLevel: 0,
                mipLevelCount: 1,
                baseArrayLayer: l
            })
              , d = s.createView({
                dimension: "2d",
                baseMipLevel: 0,
                mipLevelCount: 1,
                baseArrayLayer: l
            })
              , h = e.beginRenderPass({
                colorAttachments: [{
                    view: d,
                    loadOp: "clear",
                    storeOp: "store"
                }]
            })
              , u = n.createBindGroup({
                layout: r.getBindGroupLayout(0),
                entries: [{
                    binding: 0,
                    resource: c
                }]
            });
            h.setPipeline(r),
            h.setBindGroup(0, u),
            h.draw(4),
            h.end()
        }
        i.pipeline = null
    }
}
class KC {
    constructor(e) {
        this.compute = e;
        const {device: t, shader: s} = e
          , {computeBindGroupFormat: i} = s.impl;
        this.bindGroup = new lc(t,i),
        this.pipeline = t.computePipeline.get(s, i)
    }
    dispatch(e, t, s) {
        const i = this.compute.device;
        i.startComputePass();
        const {bindGroup: n} = this;
        n.update(),
        i.setBindGroup(0, n);
        const r = i.passEncoder;
        r.setPipeline(this.pipeline),
        r.dispatchWorkgroups(e, t, s),
        i.endComputePass()
    }
}
class ZC extends br {
    constructor(e, t={}) {
        var s, i;
        super(e, t),
        this.renderPipeline = new gC(this),
        this.computePipeline = new yC(this),
        this.clearRenderer = void 0,
        this.mipmapRenderer = void 0,
        this.pipeline = void 0,
        this.bindGroupFormats = [],
        this.commandEncoder = null,
        this.commandBuffers = [],
        this.limits = void 0,
        t = this.initOptions,
        t.alpha = (s = t.alpha) != null ? s : !0,
        this.backBufferAntialias = (i = t.antialias) != null ? i : !1,
        this.isWebGPU = !0,
        this._deviceType = kS
    }
    destroy() {
        this.clearRenderer.destroy(),
        this.clearRenderer = null,
        this.mipmapRenderer.destroy(),
        this.mipmapRenderer = null,
        this.resolver.destroy(),
        this.resolver = null,
        super.destroy()
    }
    initDeviceCaps() {
        this.disableParticleSystem = !0;
        const e = this.gpuAdapter.limits;
        this.limits = e,
        this.precision = "highp",
        this.maxPrecision = "highp",
        this.maxSamples = 4,
        this.maxTextures = 16,
        this.maxTextureSize = e.maxTextureDimension2D,
        this.maxCubeMapSize = e.maxTextureDimension2D,
        this.maxVolumeSize = e.maxTextureDimension3D,
        this.maxColorAttachments = e.maxColorAttachments,
        this.maxPixelRatio = 1,
        this.maxAnisotropy = 16,
        this.fragmentUniformsCount = e.maxUniformBufferBindingSize / 16,
        this.vertexUniformsCount = e.maxUniformBufferBindingSize / 16,
        this.supportsInstancing = !0,
        this.supportsUniformBuffers = !0,
        this.supportsVolumeTextures = !0,
        this.supportsBoneTextures = !0,
        this.supportsMorphTargetTexturesCore = !0,
        this.supportsAreaLights = !0,
        this.supportsDepthShadow = !0,
        this.supportsGpuParticles = !1,
        this.supportsMrt = !0,
        this.supportsCompute = !0,
        this.extUintElement = !0,
        this.extTextureFloat = !0,
        this.textureFloatRenderable = !0,
        this.textureHalfFloatFilterable = !0,
        this.extTextureHalfFloat = !0,
        this.textureHalfFloatRenderable = !0,
        this.textureHalfFloatUpdatable = !0,
        this.boneLimit = 1024,
        this.supportsImageBitmap = !0,
        this.extStandardDerivatives = !0,
        this.extBlendMinmax = !0,
        this.areaLightLutFormat = this.textureFloatFilterable ? lt : ve,
        this.supportsTextureFetch = !0,
        this.samples = this.backBufferAntialias ? 4 : 1
    }
    async initWebGpu(e, t) {
        if (!window.navigator.gpu)
            throw new Error("Unable to retrieve GPU. Ensure you are using a browser that supports WebGPU rendering.");
        const s = d => {
            const h = new URL(window.location.href);
            return h.pathname = d,
            h.search = "",
            h.toString()
        }
          , i = await Promise.all([vm( () => import(`${s(t)}`), __vite__mapDeps([]), import.meta.url).then(d => twgsl(t.replace(".js", ".wasm"))), vm( () => import(`${s(e)}`), __vite__mapDeps([]), import.meta.url).then(d => d.default())]);
        this.twgsl = i[0],
        this.glslang = i[1];
        const n = {
            powerPreference: this.initOptions.powerPreference !== "default" ? this.initOptions.powerPreference : void 0
        };
        this.gpuAdapter = await window.navigator.gpu.requestAdapter(n);
        const r = []
          , o = d => {
            const h = this.gpuAdapter.features.has(d);
            return h && r.push(d),
            h
        }
        ;
        this.textureFloatFilterable = o("float32-filterable"),
        this.extCompressedTextureS3TC = o("texture-compression-bc"),
        this.extCompressedTextureETC = o("texture-compression-etc2"),
        this.extCompressedTextureASTC = o("texture-compression-astc"),
        this.textureRG11B10Renderable = o("rg11b10ufloat-renderable");
        const l = {
            requiredFeatures: r,
            requiredLimits: {},
            defaultQueue: {
                label: "Default Queue"
            }
        };
        this.wgpu = await this.gpuAdapter.requestDevice(l),
        this.initDeviceCaps(),
        this.gpuContext = this.canvas.getContext("webgpu");
        const c = navigator.gpu.getPreferredCanvasFormat();
        return this.backBufferFormat = c === "rgba8unorm" ? ve : L_,
        this.canvasConfig = {
            device: this.wgpu,
            colorSpace: "srgb",
            alphaMode: this.initOptions.alpha ? "premultiplied" : "opaque",
            format: c,
            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,
            viewFormats: []
        },
        this.gpuContext.configure(this.canvasConfig),
        this.createBackbuffer(),
        this.clearRenderer = new HC(this),
        this.mipmapRenderer = new WC(this),
        this.resolver = new YC(this),
        this.postInit(),
        this
    }
    postInit() {
        super.postInit(),
        this.initializeRenderState(),
        this.setupPassEncoderDefaults(),
        this.gpuProfiler = new qC(this),
        this.dynamicBuffers = new jC(this,1024 * 1024,this.limits.minUniformBufferOffsetAlignment)
    }
    createBackbuffer() {
        this.supportsStencil = this.initOptions.stencil,
        this.backBuffer = new It({
            name: "WebgpuFramebuffer",
            graphicsDevice: this,
            depth: this.initOptions.depth,
            stencil: this.supportsStencil,
            samples: this.samples
        })
    }
    frameStart() {
        super.frameStart(),
        this.gpuProfiler.frameStart(),
        this.submit();
        const e = this.gpuContext.getCurrentTexture();
        (this.backBufferSize.x !== e.width || this.backBufferSize.y !== e.height) && (this.backBufferSize.set(e.width, e.height),
        this.backBuffer.destroy(),
        this.backBuffer = null,
        this.createBackbuffer());
        const t = this.backBuffer
          , s = t.impl;
        s.setColorAttachment(0, void 0, e.format),
        this.initRenderTarget(t),
        s.assignColorTexture(e)
    }
    frameEnd() {
        super.frameEnd(),
        this.gpuProfiler.frameEnd(),
        this.submit(),
        this.gpuProfiler.request()
    }
    createUniformBufferImpl(e) {
        return new LC(e)
    }
    createVertexBufferImpl(e, t) {
        return new DC(e,t)
    }
    createIndexBufferImpl(e) {
        return new dC(e)
    }
    createShaderImpl(e) {
        return new PC(e)
    }
    createTextureImpl(e) {
        return new IC(e)
    }
    createRenderTargetImpl(e) {
        return new xC(e)
    }
    createBindGroupFormatImpl(e) {
        return new cC(e)
    }
    createBindGroupImpl(e) {
        return new lC
    }
    createComputeImpl(e) {
        return new KC(e)
    }
    setBindGroup(e, t) {
        this.passEncoder && (this.passEncoder.setBindGroup(e, t.impl.bindGroup, t.uniformBufferOffsets),
        this.bindGroupFormats[e] = t.format.impl)
    }
    submitVertexBuffer(e, t) {
        const s = e.format.elements
          , i = s.length
          , n = e.impl.buffer;
        for (let r = 0; r < i; r++)
            this.passEncoder.setVertexBuffer(t + r, n, s[r].offset);
        return i
    }
    draw(e, t=1, s) {
        if (this.shader.ready && !this.shader.failed) {
            const i = this.passEncoder
              , n = this.vertexBuffers[0]
              , r = this.vertexBuffers[1];
            if (this.vertexBuffers.length = 0,
            n) {
                const c = this.submitVertexBuffer(n, 0);
                r && this.submitVertexBuffer(r, c)
            }
            const o = this.renderPipeline.get(e, n == null ? void 0 : n.format, r == null ? void 0 : r.format, this.shader, this.renderTarget, this.bindGroupFormats, this.blendState, this.depthState, this.cullMode, this.stencilEnabled, this.stencilFront, this.stencilBack);
            this.pipeline !== o && (this.pipeline = o,
            i.setPipeline(o));
            const l = this.indexBuffer;
            l ? (this.indexBuffer = null,
            i.setIndexBuffer(l.impl.buffer, l.impl.format),
            i.drawIndexed(e.count, t, 0, 0, 0)) : i.draw(e.count, t, 0, 0)
        }
    }
    setShader(e) {
        return this.shader = e,
        !0
    }
    setBlendState(e) {
        this.blendState.copy(e)
    }
    setDepthState(e) {
        this.depthState.copy(e)
    }
    setStencilState(e, t) {
        if (e || t) {
            this.stencilEnabled = !0,
            this.stencilFront.copy(e ?? qs.DEFAULT),
            this.stencilBack.copy(t ?? qs.DEFAULT);
            const s = this.stencilFront.ref;
            this.stencilRef !== s && (this.stencilRef = s,
            this.passEncoder.setStencilReference(s))
        } else
            this.stencilEnabled = !1
    }
    setBlendColor(e, t, s, i) {
        const n = this.blendColor;
        (e !== n.r || t !== n.g || s !== n.b || i !== n.a) && (n.set(e, t, s, i),
        this.passEncoder.setBlendConstant(n))
    }
    setCullMode(e) {
        this.cullMode = e
    }
    setAlphaToCoverage(e) {}
    initializeContextCaches() {
        super.initializeContextCaches()
    }
    setupPassEncoderDefaults() {
        this.pipeline = null,
        this.stencilRef = 0,
        this.blendColor.set(0, 0, 0, 0)
    }
    _uploadDirtyTextures() {
        this.textures.forEach(e => {
            (e._needsUpload || e._needsMipmaps) && e.upload()
        }
        )
    }
    startRenderPass(e) {
        this._uploadDirtyTextures();
        const t = e.renderTarget || this.backBuffer;
        this.renderTarget = t;
        const s = t.impl;
        this.commandEncoder = this.wgpu.createCommandEncoder(),
        t !== this.backBuffer && this.initRenderTarget(t),
        s.setupForRenderPass(e);
        const i = s.renderPassDescriptor;
        if (this.gpuProfiler._enabled && this.gpuProfiler.timestampQueriesSet) {
            const o = this.gpuProfiler.getSlot(e.name);
            i.timestampWrites = {
                querySet: this.gpuProfiler.timestampQueriesSet.querySet,
                beginningOfPassWriteIndex: o * 2,
                endOfPassWriteIndex: o * 2 + 1
            }
        }
        this.passEncoder = this.commandEncoder.beginRenderPass(i),
        this.setupPassEncoderDefaults();
        const {width: n, height: r} = t;
        this.setViewport(0, 0, n, r),
        this.setScissor(0, 0, n, r),
        this.insideRenderPass = !0
    }
    endRenderPass(e) {
        this.passEncoder.end(),
        this.passEncoder = null,
        this.insideRenderPass = !1,
        this.bindGroupFormats.length = 0;
        for (let s = 0; s < e.colorArrayOps.length; s++)
            e.colorArrayOps[s].mipmaps && this.mipmapRenderer.generate(e.renderTarget._colorBuffers[s].impl);
        const t = this.commandEncoder.finish();
        this.addCommandBuffer(t),
        this.commandEncoder = null
    }
    startComputePass() {
        this.commandEncoder = this.wgpu.createCommandEncoder(),
        this.pipeline = null,
        this.passEncoder = this.commandEncoder.beginComputePass(),
        this.insideRenderPass = !0
    }
    endComputePass() {
        this.passEncoder.end(),
        this.passEncoder = null,
        this.insideRenderPass = !1,
        this.bindGroupFormats.length = 0;
        const e = this.commandEncoder.finish();
        this.addCommandBuffer(e),
        this.commandEncoder = null
    }
    addCommandBuffer(e, t=!1) {
        t ? this.commandBuffers.unshift(e) : this.commandBuffers.push(e)
    }
    submit() {
        this.commandBuffers.length > 0 && (this.dynamicBuffers.submit(),
        this.wgpu.queue.submit(this.commandBuffers),
        this.commandBuffers.length = 0,
        this.dynamicBuffers.onCommandBuffersSubmitted())
    }
    clear(e) {
        e.flags && this.clearRenderer.clear(this, this.renderTarget, e, this.defaultClearOptions)
    }
    setViewport(e, t, s, i) {
        this.passEncoder && (this.renderTarget.flipY || (t = this.renderTarget.height - t - i),
        this.vx = e,
        this.vy = t,
        this.vw = s,
        this.vh = i,
        this.passEncoder.setViewport(e, t, s, i, 0, 1))
    }
    setScissor(e, t, s, i) {
        this.passEncoder && (this.renderTarget.flipY || (t = this.renderTarget.height - t - i),
        this.sx = e,
        this.sy = t,
        this.sw = s,
        this.sh = i,
        this.passEncoder.setScissorRect(e, t, s, i))
    }
    copyRenderTarget(e, t, s, i) {
        var n;
        const r = {
            width: e ? e.width : t.width,
            height: e ? e.height : t.height,
            depthOrArrayLayers: 1
        }
          , o = (n = this.commandEncoder) != null ? n : this.wgpu.createCommandEncoder();
        if (s) {
            const l = {
                texture: e ? e.colorBuffer.impl.gpuTexture : this.renderTarget.impl.assignedColorTexture,
                mipLevel: 0
            }
              , c = {
                texture: t ? t.colorBuffer.impl.gpuTexture : this.renderTarget.impl.assignedColorTexture,
                mipLevel: 0
            };
            o.copyTextureToTexture(l, c, r)
        }
        if (i) {
            const c = (e || this.renderTarget).impl.depthTexture;
            if (e.samples > 1) {
                const d = t.colorBuffer.impl.gpuTexture;
                this.resolver.resolveDepth(o, c, d)
            } else {
                const d = t ? t.depthBuffer.impl.gpuTexture : this.renderTarget.impl.depthTexture
                  , h = {
                    texture: c,
                    mipLevel: 0
                }
                  , u = {
                    texture: d,
                    mipLevel: 0
                };
                o.copyTextureToTexture(h, u, r)
            }
        }
        if (!this.commandEncoder) {
            const l = o.finish();
            this.addCommandBuffer(l)
        }
        return !0
    }
}
let QC = 0;
class ge {
    constructor(e, t={}) {
        var s, i, n, r, o, l, c, d, h, u, f, p, _, m, g, v, x, S, w;
        if (this.name = void 0,
        this._gpuSize = 0,
        this.id = QC++,
        this._invalid = !1,
        this._lockedLevel = -1,
        this.renderVersionDirty = 0,
        this._storage = !1,
        this.device = e,
        this.name = (s = t.name) != null ? s : "",
        this._width = Math.floor((i = t.width) != null ? i : 4),
        this._height = Math.floor((n = t.height) != null ? n : 4),
        this._format = (r = t.format) != null ? r : ve,
        this._compressed = um(this._format),
        this._integerFormat = ho(this._format),
        this._integerFormat && (t.mipmaps = !1,
        t.minFilter = be,
        t.magFilter = be),
        e.supportsVolumeTextures) {
            var T, b, E;
            this._volume = (T = t.volume) != null ? T : !1,
            this._depth = Math.floor((b = t.depth) != null ? b : 1),
            this._arrayLength = Math.floor((E = t.arrayLength) != null ? E : 0)
        } else
            this._volume = !1,
            this._depth = 1,
            this._arrayLength = 0;
        this._storage = (o = t.storage) != null ? o : !1,
        this._cubemap = (l = t.cubemap) != null ? l : !1,
        this.fixCubemapSeams = (c = t.fixCubemapSeams) != null ? c : !1,
        this._flipY = (d = t.flipY) != null ? d : !1,
        this._premultiplyAlpha = (h = t.premultiplyAlpha) != null ? h : !1,
        this._mipmaps = (u = (f = t.mipmaps) != null ? f : t.autoMipmap) != null ? u : !0,
        this._minFilter = (p = t.minFilter) != null ? p : ur,
        this._magFilter = (_ = t.magFilter) != null ? _ : ot,
        this._anisotropy = (m = t.anisotropy) != null ? m : 1,
        this._addressU = (g = t.addressU) != null ? g : wt,
        this._addressV = (v = t.addressV) != null ? v : wt,
        this._addressW = (x = t.addressW) != null ? x : wt,
        this._compareOnRead = (S = t.compareOnRead) != null ? S : !1,
        this._compareFunc = (w = t.compareFunc) != null ? w : A_,
        this.type = $s,
        t.hasOwnProperty("type") ? this.type = t.type : t.hasOwnProperty("rgbm") ? this.type = t.rgbm ? pr : $s : t.hasOwnProperty("swizzleGGGR") && (this.type = t.swizzleGGGR ? lf : $s),
        this.projection = MT,
        this._cubemap ? this.projection = _m : t.projection && t.projection !== _m && (this.projection = t.projection),
        this.impl = e.createTextureImpl(this),
        this.dirtyAll(),
        this._levels = t.levels,
        this._levels ? this.upload() : this._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null],
        e.textures.push(this)
    }
    destroy() {
        const e = this.device;
        if (e) {
            const t = e.textures.indexOf(this);
            t !== -1 && e.textures.splice(t, 1),
            e.scope.removeValue(this),
            this.impl.destroy(e),
            this.adjustVramSizeTracking(e._vram, -this._gpuSize),
            this._levels = null,
            this.device = null
        }
    }
    resize(e, t, s=1) {
        const i = this.device;
        this.adjustVramSizeTracking(i._vram, -this._gpuSize),
        this.impl.destroy(i),
        this._width = Math.floor(e),
        this._height = Math.floor(t),
        this._depth = Math.floor(s),
        this.impl = i.createTextureImpl(this),
        this.dirtyAll()
    }
    loseContext() {
        this.impl.loseContext(),
        this.dirtyAll()
    }
    adjustVramSizeTracking(e, t) {
        e.tex += t
    }
    propertyChanged(e) {
        this.impl.propertyChanged(e),
        this.renderVersionDirty = this.device.renderVersion
    }
    get requiredMipLevels() {
        return this.mipmaps ? wn.calcMipLevelsCount(this.width, this.height) : 1
    }
    set minFilter(e) {
        this._minFilter !== e && (ho(this._format) || (this._minFilter = e,
        this.propertyChanged(1)))
    }
    get minFilter() {
        return this._minFilter
    }
    set magFilter(e) {
        this._magFilter !== e && (ho(this._format) || (this._magFilter = e,
        this.propertyChanged(2)))
    }
    get magFilter() {
        return this._magFilter
    }
    set addressU(e) {
        this._addressU !== e && (this._addressU = e,
        this.propertyChanged(4))
    }
    get addressU() {
        return this._addressU
    }
    set addressV(e) {
        this._addressV !== e && (this._addressV = e,
        this.propertyChanged(8))
    }
    get addressV() {
        return this._addressV
    }
    set addressW(e) {
        this.device.supportsVolumeTextures && this._volume && e !== this._addressW && (this._addressW = e,
        this.propertyChanged(16))
    }
    get addressW() {
        return this._addressW
    }
    set compareOnRead(e) {
        this._compareOnRead !== e && (this._compareOnRead = e,
        this.propertyChanged(32))
    }
    get compareOnRead() {
        return this._compareOnRead
    }
    set compareFunc(e) {
        this._compareFunc !== e && (this._compareFunc = e,
        this.propertyChanged(64))
    }
    get compareFunc() {
        return this._compareFunc
    }
    set anisotropy(e) {
        this._anisotropy !== e && (this._anisotropy = e,
        this.propertyChanged(128))
    }
    get anisotropy() {
        return this._anisotropy
    }
    set mipmaps(e) {
        this._mipmaps !== e && (this.device.isWebGPU || ho(this._format) || (this._mipmaps = e),
        e && (this._needsMipmapsUpload = !0))
    }
    get mipmaps() {
        return this._mipmaps
    }
    get storage() {
        return this._storage
    }
    get width() {
        return this._width
    }
    get height() {
        return this._height
    }
    get depth() {
        return this._depth
    }
    get format() {
        return this._format
    }
    get cubemap() {
        return this._cubemap
    }
    get gpuSize() {
        const e = this.pot && this._mipmaps && !(this._compressed && this._levels.length === 1);
        return wn.calcGpuSize(this._width, this._height, this._depth, this._format, e, this._cubemap)
    }
    get array() {
        return this._arrayLength > 0
    }
    get arrayLength() {
        return this._arrayLength
    }
    get volume() {
        return this._volume
    }
    set flipY(e) {
        this._flipY !== e && (this._flipY = e,
        this._needsUpload = !0)
    }
    get flipY() {
        return this._flipY
    }
    set premultiplyAlpha(e) {
        this._premultiplyAlpha !== e && (this._premultiplyAlpha = e,
        this._needsUpload = !0)
    }
    get premultiplyAlpha() {
        return this._premultiplyAlpha
    }
    get pot() {
        return W.powerOfTwo(this._width) && W.powerOfTwo(this._height)
    }
    get encoding() {
        switch (this.type) {
        case pr:
            return "rgbm";
        case B_:
            return "rgbe";
        case Bo:
            return "rgbp";
        default:
            return this.format === el || this.format === Ta || this.format === Tt || this.format === lt || ho(this.format) ? "linear" : "srgb"
        }
    }
    dirtyAll() {
        this._levelsUpdated = this._cubemap ? [[!0, !0, !0, !0, !0, !0]] : [!0],
        this._needsUpload = !0,
        this._needsMipmapsUpload = this._mipmaps,
        this._mipmapsUploaded = !1,
        this.propertyChanged(255)
    }
    lock(e={}) {
        var t, s, i;
        (t = e.level) != null || (e.level = 0),
        (s = e.face) != null || (e.face = 0),
        (i = e.mode) != null || (e.mode = AT),
        this._lockedLevel = e.level;
        const n = this.cubemap ? this._levels[e.face] : this._levels;
        if (n[e.level] === null) {
            const r = Math.max(1, this._width >> e.level)
              , o = Math.max(1, this._height >> e.level)
              , l = Math.max(1, this._depth >> e.level)
              , c = new ArrayBuffer(wn.calcLevelGpuSize(r, o, l, this._format));
            n[e.level] = new (yT(this._format))(c)
        }
        return n[e.level]
    }
    setSource(e, t=0) {
        let s = !1, i, n;
        if (this._cubemap) {
            if (e[0]) {
                i = e[0].width || 0,
                n = e[0].height || 0;
                for (let r = 0; r < 6; r++) {
                    const o = e[r];
                    if (!o || o.width !== i || o.height !== n || !this.device._isBrowserInterface(o)) {
                        s = !0;
                        break
                    }
                }
            } else
                s = !0;
            if (!s)
                for (let r = 0; r < 6; r++)
                    this._levels[t][r] !== e[r] && (this._levelsUpdated[t][r] = !0)
        } else
            this.device._isBrowserInterface(e) || (s = !0),
            s || (e !== this._levels[t] && (this._levelsUpdated[t] = !0),
            i = e.width,
            n = e.height);
        if (s)
            if (this._width = 4,
            this._height = 4,
            this._cubemap)
                for (let r = 0; r < 6; r++)
                    this._levels[t][r] = null,
                    this._levelsUpdated[t][r] = !0;
            else
                this._levels[t] = null,
                this._levelsUpdated[t] = !0;
        else
            t === 0 && (this._width = i,
            this._height = n),
            this._levels[t] = e;
        (this._invalid !== s || !s) && (this._invalid = s,
        this.upload())
    }
    getSource(e=0) {
        return this._levels[e]
    }
    unlock() {
        this._lockedLevel,
        this.upload(),
        this._lockedLevel = -1
    }
    upload() {
        var e, t;
        this._needsUpload = !0,
        this._needsMipmapsUpload = this._mipmaps,
        (e = (t = this.impl).uploadImmediate) == null || e.call(t, this.device, this)
    }
    async downloadAsync() {
        const e = [];
        for (let i = 0; i < (this.cubemap ? 6 : 1); i++) {
            var t, s;
            const n = new It({
                colorBuffer: this,
                depth: !1,
                face: i
            });
            this.device.setRenderTarget(n),
            this.device.initRenderTarget(n);
            const r = this.cubemap ? this._levels[i] : this._levels;
            let o = r[0];
            r[0] && this.device._isBrowserInterface(r[0]) && (r[0] = null),
            o = this.lock({
                face: i
            });
            const l = (t = (s = this.device).readPixelsAsync) == null ? void 0 : t.call(s, 0, 0, this.width, this.height, o).then( () => n.destroy());
            e.push(l)
        }
        await Promise.all(e)
    }
}
class HS {
    constructor() {
        this.bufferId = null
    }
    destroy(e) {
        this.bufferId && (e.gl.deleteBuffer(this.bufferId),
        this.bufferId = null)
    }
    get initialized() {
        return !!this.bufferId
    }
    loseContext() {
        this.bufferId = null
    }
    unlock(e, t, s, i) {
        const n = e.gl;
        if (this.bufferId)
            n.bindBuffer(s, this.bufferId),
            n.bufferSubData(s, 0, i);
        else {
            let r;
            switch (t) {
            case es:
                r = n.STATIC_DRAW;
                break;
            case Do:
                r = n.DYNAMIC_DRAW;
                break;
            case dT:
                r = n.STREAM_DRAW;
                break;
            case uT:
                r = e.isWebGL2 ? n.DYNAMIC_COPY : n.STATIC_DRAW;
                break
            }
            this.bufferId = n.createBuffer(),
            n.bindBuffer(s, this.bufferId),
            n.bufferData(s, i, r)
        }
    }
}
class JC extends HS {
    constructor(...e) {
        super(...e),
        this.vao = null
    }
    destroy(e) {
        super.destroy(e),
        e.unbindVertexArray()
    }
    loseContext() {
        super.loseContext(),
        this.vao = null
    }
    unlock(e) {
        const t = e.device;
        super.unlock(t, e.usage, t.gl.ARRAY_BUFFER, e.storage)
    }
}
class eE extends HS {
    constructor(e) {
        super();
        const t = e.device.gl
          , s = e.format;
        s === dm ? this.glFormat = t.UNSIGNED_BYTE : s === js ? this.glFormat = t.UNSIGNED_SHORT : s === fr && (this.glFormat = t.UNSIGNED_INT)
    }
    unlock(e) {
        const t = e.device;
        super.unlock(t, e.usage, t.gl.ELEMENT_ARRAY_BUFFER, e.storage)
    }
}
class Iy {
    constructor(e, t, s, i) {
        if (this.locationId = i,
        this.scopeId = e.scope.resolve(t),
        this.version = new NS,
        t.substring(t.length - 3) === "[0]")
            switch (s) {
            case yi:
                s = cf;
                break;
            case pa:
                s = Ho;
                break;
            case Uo:
                s = ff;
                break;
            case wo:
                s = pf;
                break;
            case mr:
                s = df;
                break;
            case ia:
                s = Wo;
                break;
            case zo:
                s = mf;
                break;
            case mh:
                s = _f;
                break;
            case As:
                s = uf;
                break;
            case na:
                s = Xo;
                break;
            case Vo:
                s = gf;
                break;
            case _h:
                s = yf;
                break;
            case ma:
                s = N_;
                break;
            case ra:
                s = Qd;
                break;
            case Go:
                s = U_;
                break;
            case gh:
                s = z_;
                break
            }
        this.dataType = s,
        this.value = [null, null, null, null],
        this.array = []
    }
}
const tE = ["gl_VertexID", "gl_InstanceID", "gl_DrawID", "gl_BaseVertex", "gl_BaseInstance"];
class sE {
    constructor() {
        this.map = new Map
    }
    destroy(e) {
        this.map.forEach(t => {
            e.gl.deleteShader(t)
        }
        )
    }
    loseContext(e) {
        this.map.clear()
    }
}
class iE {
    constructor() {
        this.shaders = []
    }
    loseContext(e) {
        this.shaders = []
    }
}
const nE = new Os
  , rE = new Os
  , aE = new Os;
class xh {
    constructor(e) {
        this.compileDuration = 0,
        this.init(),
        this.compile(e.device, e),
        xh.getBatchShaders(e.device).push(e),
        e.device.shaders.push(e)
    }
    destroy(e) {
        this.glProgram && (e.device.gl.deleteProgram(this.glProgram),
        this.glProgram = null)
    }
    init() {
        this.uniforms = [],
        this.samplers = [],
        this.attributes = [],
        this.glProgram = null,
        this.glVertexShader = null,
        this.glFragmentShader = null
    }
    static getBatchShaders(e) {
        return aE.get(e, () => new iE).shaders
    }
    static endShaderBatch(e) {
        const t = xh.getBatchShaders(e);
        t.forEach(s => s.impl.link(e, s)),
        t.length = 0
    }
    loseContext() {
        this.init()
    }
    restoreContext(e, t) {
        this.compile(e, t)
    }
    compile(e, t) {
        const s = t.definition;
        this.glVertexShader = this._compileShaderSource(e, s.vshader, !0),
        this.glFragmentShader = this._compileShaderSource(e, s.fshader, !1)
    }
    link(e, t) {
        if (this.glProgram)
            return;
        const s = e.gl;
        if (s.isContextLost())
            return;
        const i = s.createProgram();
        this.glProgram = i,
        s.attachShader(i, this.glVertexShader),
        s.attachShader(i, this.glFragmentShader);
        const n = t.definition
          , r = n.attributes;
        if (e.isWebGL2 && n.useTransformFeedback) {
            const o = [];
            for (const l in r)
                r.hasOwnProperty(l) && o.push("out_" + l);
            s.transformFeedbackVaryings(i, o, s.INTERLEAVED_ATTRIBS)
        }
        for (const o in r)
            if (r.hasOwnProperty(o)) {
                const l = r[o]
                  , c = De[l];
                s.bindAttribLocation(i, c, o)
            }
        s.linkProgram(i)
    }
    _compileShaderSource(e, t, s) {
        const i = e.gl
          , r = (s ? nE : rE).get(e, () => new sE);
        let o = r.map.get(t);
        if (!o) {
            if (o = i.createShader(s ? i.VERTEX_SHADER : i.FRAGMENT_SHADER),
            !o && i.isContextLost())
                return o;
            i.shaderSource(o, t),
            i.compileShader(o),
            r.map.set(t, o)
        }
        return o
    }
    finalize(e, t) {
        const s = e.gl;
        if (s.isContextLost())
            return !0;
        this.glProgram || this.link(e, t);
        const i = this.glProgram
          , n = t.definition;
        if (!s.getProgramParameter(i, s.LINK_STATUS)) {
            if (!this._isCompiled(e, t, this.glVertexShader, n.vshader, "vertex") || !this._isCompiled(e, t, this.glFragmentShader, n.fshader, "fragment"))
                return !1;
            const d = "Failed to link shader program. Error: " + s.getProgramInfoLog(i);
            return console.error(d),
            !1
        }
        let o = 0;
        const l = s.getProgramParameter(i, s.ACTIVE_ATTRIBUTES);
        for (; o < l; ) {
            const d = s.getActiveAttrib(i, o++)
              , h = s.getAttribLocation(i, d.name);
            if (tE.indexOf(d.name) === -1)
                if (n.attributes[d.name] === void 0)
                    console.error(`Vertex shader attribute "${d.name}" is not mapped to a semantic in shader definition, shader [${t.label}]`, t),
                    t.failed = !0;
                else {
                    const u = new Iy(e,n.attributes[d.name],e.pcUniformType[d.type],h);
                    this.attributes.push(u)
                }
        }
        o = 0;
        const c = s.getProgramParameter(i, s.ACTIVE_UNIFORMS);
        for (; o < c; ) {
            const d = s.getActiveUniform(i, o++)
              , h = s.getUniformLocation(i, d.name)
              , u = new Iy(e,d.name,e.pcUniformType[d.type],h);
            d.type === s.SAMPLER_2D || d.type === s.SAMPLER_CUBE || e.isWebGL2 && (d.type === s.UNSIGNED_INT_SAMPLER_2D || d.type === s.INT_SAMPLER_2D || d.type === s.SAMPLER_2D_SHADOW || d.type === s.SAMPLER_CUBE_SHADOW || d.type === s.SAMPLER_3D || d.type === s.INT_SAMPLER_3D || d.type === s.UNSIGNED_INT_SAMPLER_3D || d.type === s.SAMPLER_2D_ARRAY || d.type === s.INT_SAMPLER_2D_ARRAY || d.type === s.UNSIGNED_INT_SAMPLER_2D_ARRAY) ? this.samplers.push(u) : this.uniforms.push(u)
        }
        return t.ready = !0,
        !0
    }
    _isCompiled(e, t, s, i, n) {
        const r = e.gl;
        if (!r.getShaderParameter(s, r.COMPILE_STATUS)) {
            const o = r.getShaderInfoLog(s)
              , [l,c] = this._processError(i, o)
              , d = `Failed to compile ${n} shader:

${o}
${l}`;
            return console.error(d),
            !1
        }
        return !0
    }
    _processError(e, t) {
        const s = {};
        let i = "";
        if (e) {
            const n = e.split(`
`);
            let r = 0
              , o = n.length;
            if (t && t.startsWith("ERROR:")) {
                const l = t.match(/^ERROR:\s([0-9]+):([0-9]+):\s*(.+)/);
                l && (s.message = l[3],
                s.line = parseInt(l[2], 10),
                r = Math.max(0, s.line - 6),
                o = Math.min(n.length, s.line + 5))
            }
            for (let l = r; l < o; l++)
                i += l + 1 + ":	" + n[l] + `
`;
            s.source = e
        }
        return [i, s]
    }
}
function Ly(a, e) {
    const t = a.width
      , s = a.height;
    if (t > e || s > e) {
        const i = e / Math.max(t, s)
          , n = Math.floor(t * i)
          , r = Math.floor(s * i)
          , o = document.createElement("canvas");
        return o.width = n,
        o.height = r,
        o.getContext("2d").drawImage(a, 0, 0, t, s, 0, 0, n, r),
        o
    }
    return a
}
class oE {
    constructor() {
        this._glTexture = null,
        this._glTarget = void 0,
        this._glFormat = void 0,
        this._glInternalFormat = void 0,
        this._glPixelType = void 0,
        this._glCreated = void 0,
        this.dirtyParameterFlags = 0
    }
    destroy(e) {
        if (this._glTexture) {
            for (let t = 0; t < e.textureUnits.length; t++) {
                const s = e.textureUnits[t];
                for (let i = 0; i < s.length; i++)
                    s[i] === this._glTexture && (s[i] = null)
            }
            e.gl.deleteTexture(this._glTexture),
            this._glTexture = null
        }
    }
    loseContext() {
        this._glTexture = null
    }
    propertyChanged(e) {
        this.dirtyParameterFlags |= e
    }
    initialize(e, t) {
        const s = e.gl;
        switch (this._glTexture = s.createTexture(),
        this._glTarget = t._cubemap ? s.TEXTURE_CUBE_MAP : t._volume ? s.TEXTURE_3D : t.array ? s.TEXTURE_2D_ARRAY : s.TEXTURE_2D,
        t._format) {
        case M_:
            this._glFormat = s.ALPHA,
            this._glInternalFormat = s.ALPHA,
            this._glPixelType = s.UNSIGNED_BYTE;
            break;
        case Bu:
            this._glFormat = s.LUMINANCE,
            this._glInternalFormat = s.LUMINANCE,
            this._glPixelType = s.UNSIGNED_BYTE;
            break;
        case ku:
            this._glFormat = s.LUMINANCE_ALPHA,
            this._glInternalFormat = s.LUMINANCE_ALPHA,
            this._glPixelType = s.UNSIGNED_BYTE;
            break;
        case Wh:
            this._glFormat = s.RGB,
            this._glInternalFormat = s.RGB,
            this._glPixelType = s.UNSIGNED_SHORT_5_6_5;
            break;
        case Nu:
            this._glFormat = s.RGBA,
            this._glInternalFormat = s.RGBA,
            this._glPixelType = s.UNSIGNED_SHORT_5_5_5_1;
            break;
        case Xh:
            this._glFormat = s.RGBA,
            this._glInternalFormat = s.RGBA,
            this._glPixelType = s.UNSIGNED_SHORT_4_4_4_4;
            break;
        case Ln:
            this._glFormat = s.RGB,
            this._glInternalFormat = e.isWebGL2 ? s.RGB8 : s.RGB,
            this._glPixelType = s.UNSIGNED_BYTE;
            break;
        case ve:
            this._glFormat = s.RGBA,
            this._glInternalFormat = e.isWebGL2 ? s.RGBA8 : s.RGBA,
            this._glPixelType = s.UNSIGNED_BYTE;
            break;
        case jh:
            this._glFormat = s.RGB,
            this._glInternalFormat = e.extCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
            break;
        case Uu:
            this._glFormat = s.RGBA,
            this._glInternalFormat = e.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            break;
        case Jo:
            this._glFormat = s.RGBA,
            this._glInternalFormat = e.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            break;
        case $h:
            this._glFormat = s.RGB,
            this._glInternalFormat = e.extCompressedTextureETC1.COMPRESSED_RGB_ETC1_WEBGL;
            break;
        case tl:
            this._glFormat = s.RGB,
            this._glInternalFormat = e.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            break;
        case sl:
            this._glFormat = s.RGBA,
            this._glInternalFormat = e.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            break;
        case qh:
            this._glFormat = s.RGB,
            this._glInternalFormat = e.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            break;
        case Yh:
            this._glFormat = s.RGBA,
            this._glInternalFormat = e.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            break;
        case Gu:
            this._glFormat = s.RGB,
            this._glInternalFormat = e.extCompressedTextureETC.COMPRESSED_RGB8_ETC2;
            break;
        case Hu:
            this._glFormat = s.RGBA,
            this._glInternalFormat = e.extCompressedTextureETC.COMPRESSED_RGBA8_ETC2_EAC;
            break;
        case P_:
            this._glFormat = s.RGBA,
            this._glInternalFormat = e.extCompressedTextureASTC.COMPRESSED_RGBA_ASTC_4x4_KHR;
            break;
        case R_:
            this._glFormat = s.RGB,
            this._glInternalFormat = e.extCompressedTextureATC.COMPRESSED_RGB_ATC_WEBGL;
            break;
        case I_:
            this._glFormat = s.RGBA,
            this._glInternalFormat = e.extCompressedTextureATC.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
            break;
        case el:
            this._glFormat = s.RGB,
            e.isWebGL2 ? (this._glInternalFormat = s.RGB16F,
            this._glPixelType = s.HALF_FLOAT) : (this._glInternalFormat = s.RGB,
            this._glPixelType = e.extTextureHalfFloat.HALF_FLOAT_OES);
            break;
        case Tt:
            this._glFormat = s.RGBA,
            e.isWebGL2 ? (this._glInternalFormat = s.RGBA16F,
            this._glPixelType = s.HALF_FLOAT) : (this._glInternalFormat = s.RGBA,
            this._glPixelType = e.extTextureHalfFloat.HALF_FLOAT_OES);
            break;
        case Ta:
            this._glFormat = s.RGB,
            e.isWebGL2 ? this._glInternalFormat = s.RGB32F : this._glInternalFormat = s.RGB,
            this._glPixelType = s.FLOAT;
            break;
        case lt:
            this._glFormat = s.RGBA,
            e.isWebGL2 ? this._glInternalFormat = s.RGBA32F : this._glInternalFormat = s.RGBA,
            this._glPixelType = s.FLOAT;
            break;
        case ca:
            this._glFormat = s.RED,
            this._glInternalFormat = s.R32F,
            this._glPixelType = s.FLOAT;
            break;
        case da:
            e.isWebGL2 ? (this._glFormat = s.DEPTH_COMPONENT,
            this._glInternalFormat = s.DEPTH_COMPONENT32F,
            this._glPixelType = s.FLOAT) : (this._glFormat = s.DEPTH_COMPONENT,
            this._glInternalFormat = s.DEPTH_COMPONENT,
            this._glPixelType = s.UNSIGNED_SHORT);
            break;
        case ua:
            this._glFormat = s.DEPTH_STENCIL,
            e.isWebGL2 ? (this._glInternalFormat = s.DEPTH24_STENCIL8,
            this._glPixelType = s.UNSIGNED_INT_24_8) : (this._glInternalFormat = s.DEPTH_STENCIL,
            this._glPixelType = e.extDepthTexture.UNSIGNED_INT_24_8_WEBGL);
            break;
        case fa:
            this._glFormat = s.RGB,
            this._glInternalFormat = s.R11F_G11F_B10F,
            this._glPixelType = s.UNSIGNED_INT_10F_11F_11F_REV;
            break;
        case zu:
            this._glFormat = s.RGB,
            this._glInternalFormat = s.SRGB8,
            this._glPixelType = s.UNSIGNED_BYTE;
            break;
        case Vu:
            this._glFormat = s.RGBA,
            this._glInternalFormat = s.SRGB8_ALPHA8,
            this._glPixelType = s.UNSIGNED_BYTE;
            break;
        case Wu:
            this._glFormat = s.RED_INTEGER,
            this._glInternalFormat = s.R8I,
            this._glPixelType = s.BYTE;
            break;
        case D_:
            this._glFormat = s.RED_INTEGER,
            this._glInternalFormat = s.R8UI,
            this._glPixelType = s.UNSIGNED_BYTE;
            break;
        case Xu:
            this._glFormat = s.RED_INTEGER,
            this._glInternalFormat = s.R16I,
            this._glPixelType = s.SHORT;
            break;
        case ju:
            this._glFormat = s.RED_INTEGER,
            this._glInternalFormat = s.R16UI,
            this._glPixelType = s.UNSIGNED_SHORT;
            break;
        case $u:
            this._glFormat = s.RED_INTEGER,
            this._glInternalFormat = s.R32I,
            this._glPixelType = s.INT;
            break;
        case qu:
            this._glFormat = s.RED_INTEGER,
            this._glInternalFormat = s.R32UI,
            this._glPixelType = s.UNSIGNED_INT;
            break;
        case Yu:
            this._glFormat = s.RG_INTEGER,
            this._glInternalFormat = s.RG8I,
            this._glPixelType = s.BYTE;
            break;
        case O_:
            this._glFormat = s.RG_INTEGER,
            this._glInternalFormat = s.RG8UI,
            this._glPixelType = s.UNSIGNED_BYTE;
            break;
        case Ku:
            this._glFormat = s.RG_INTEGER,
            this._glInternalFormat = s.RG16I,
            this._glPixelType = s.SHORT;
            break;
        case Zu:
            this._glFormat = s.RG_INTEGER,
            this._glInternalFormat = s.RG16UI,
            this._glPixelType = s.UNSIGNED_SHORT;
            break;
        case Qu:
            this._glFormat = s.RG_INTEGER,
            this._glInternalFormat = s.RG32I,
            this._glPixelType = s.INT;
            break;
        case Ju:
            this._glFormat = s.RG_INTEGER,
            this._glInternalFormat = s.RG32UI,
            this._glPixelType = s.UNSIGNED_INT;
            break;
        case ef:
            this._glFormat = s.RGBA_INTEGER,
            this._glInternalFormat = s.RGBA8I,
            this._glPixelType = s.BYTE;
            break;
        case F_:
            this._glFormat = s.RGBA_INTEGER,
            this._glInternalFormat = s.RGBA8UI,
            this._glPixelType = s.UNSIGNED_BYTE;
            break;
        case tf:
            this._glFormat = s.RGBA_INTEGER,
            this._glInternalFormat = s.RGBA16I,
            this._glPixelType = s.SHORT;
            break;
        case sf:
            this._glFormat = s.RGBA_INTEGER,
            this._glInternalFormat = s.RGBA16UI,
            this._glPixelType = s.UNSIGNED_SHORT;
            break;
        case nf:
            this._glFormat = s.RGBA_INTEGER,
            this._glInternalFormat = s.RGBA32I,
            this._glPixelType = s.INT;
            break;
        case rf:
            this._glFormat = s.RGBA_INTEGER,
            this._glInternalFormat = s.RGBA32UI,
            this._glPixelType = s.UNSIGNED_INT;
            break
        }
        this._glCreated = !1
    }
    upload(e, t) {
        const s = e.gl;
        if (!t._needsUpload && (t._needsMipmapsUpload && t._mipmapsUploaded || !t.pot))
            return;
        let i = 0, n, r;
        const o = t.requiredMipLevels;
        for (t.array && s.texStorage3D(s.TEXTURE_2D_ARRAY, o, this._glInternalFormat, t._width, t._height, t._arrayLength); t._levels[i] || i === 0; ) {
            if (!t._needsUpload && i === 0) {
                i++;
                continue
            } else if (i && (!t._needsMipmapsUpload || !t._mipmaps))
                break;
            if (n = t._levels[i],
            r = 1 / Math.pow(2, i),
            i === 1 && !t._compressed && !t._integerFormat && t._levels.length < o && (s.generateMipmap(this._glTarget),
            t._mipmapsUploaded = !0),
            t._cubemap) {
                let l;
                if (e._isBrowserInterface(n[0]))
                    for (l = 0; l < 6; l++) {
                        if (!t._levelsUpdated[0][l])
                            continue;
                        let c = n[l];
                        e._isImageBrowserInterface(c) && (c.width > e.maxCubeMapSize || c.height > e.maxCubeMapSize) && (c = Ly(c, e.maxCubeMapSize),
                        i === 0 && (t._width = c.width,
                        t._height = c.height)),
                        e.setUnpackFlipY(!1),
                        e.setUnpackPremultiplyAlpha(t._premultiplyAlpha),
                        this._glCreated ? s.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + l, i, 0, 0, this._glFormat, this._glPixelType, c) : s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + l, i, this._glInternalFormat, this._glFormat, this._glPixelType, c)
                    }
                else
                    for (r = 1 / Math.pow(2, i),
                    l = 0; l < 6; l++) {
                        if (!t._levelsUpdated[0][l])
                            continue;
                        const c = n[l];
                        t._compressed ? this._glCreated && c ? s.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + l, i, 0, 0, Math.max(t._width * r, 1), Math.max(t._height * r, 1), this._glInternalFormat, c) : s.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + l, i, this._glInternalFormat, Math.max(t._width * r, 1), Math.max(t._height * r, 1), 0, c) : (e.setUnpackFlipY(!1),
                        e.setUnpackPremultiplyAlpha(t._premultiplyAlpha),
                        this._glCreated && c ? s.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + l, i, 0, 0, Math.max(t._width * r, 1), Math.max(t._height * r, 1), this._glFormat, this._glPixelType, c) : s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + l, i, this._glInternalFormat, Math.max(t._width * r, 1), Math.max(t._height * r, 1), 0, this._glFormat, this._glPixelType, c))
                    }
            } else if (t._volume)
                t._compressed ? s.compressedTexImage3D(s.TEXTURE_3D, i, this._glInternalFormat, Math.max(t._width * r, 1), Math.max(t._height * r, 1), Math.max(t._depth * r, 1), 0, n) : (e.setUnpackFlipY(!1),
                e.setUnpackPremultiplyAlpha(t._premultiplyAlpha),
                s.texImage3D(s.TEXTURE_3D, i, this._glInternalFormat, Math.max(t._width * r, 1), Math.max(t._height * r, 1), Math.max(t._depth * r, 1), 0, this._glFormat, this._glPixelType, n));
            else if (t.array && typeof n == "object") {
                if (t._arrayLength === n.length)
                    if (t._compressed)
                        for (let l = 0; l < t._arrayLength; l++)
                            s.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, i, 0, 0, l, Math.max(Math.floor(t._width * r), 1), Math.max(Math.floor(t._height * r), 1), 1, this._glFormat, n[l]);
                    else
                        for (let l = 0; l < t._arrayLength; l++)
                            s.texSubImage3D(s.TEXTURE_2D_ARRAY, i, 0, 0, l, Math.max(Math.floor(t._width * r), 1), Math.max(Math.floor(t._height * r), 1), 1, this._glFormat, this._glPixelType, n[l])
            } else {
                if (e._isBrowserInterface(n)) {
                    e._isImageBrowserInterface(n) && (n.width > e.maxTextureSize || n.height > e.maxTextureSize) && (n = Ly(n, e.maxTextureSize),
                    i === 0 && (t._width = n.width,
                    t._height = n.height));
                    const l = n.width || n.videoWidth
                      , c = n.height || n.videoHeight;
                    e.setUnpackFlipY(t._flipY),
                    e.setUnpackPremultiplyAlpha(t._premultiplyAlpha),
                    this._glCreated && t._width === l && t._height === c && !e._isImageVideoInterface(n) ? s.texSubImage2D(s.TEXTURE_2D, i, 0, 0, this._glFormat, this._glPixelType, n) : (s.texImage2D(s.TEXTURE_2D, i, this._glInternalFormat, this._glFormat, this._glPixelType, n),
                    i === 0 && (t._width = l,
                    t._height = c))
                } else
                    r = 1 / Math.pow(2, i),
                    t._compressed ? this._glCreated && n ? s.compressedTexSubImage2D(s.TEXTURE_2D, i, 0, 0, Math.max(Math.floor(t._width * r), 1), Math.max(Math.floor(t._height * r), 1), this._glInternalFormat, n) : s.compressedTexImage2D(s.TEXTURE_2D, i, this._glInternalFormat, Math.max(Math.floor(t._width * r), 1), Math.max(Math.floor(t._height * r), 1), 0, n) : (e.setUnpackFlipY(!1),
                    e.setUnpackPremultiplyAlpha(t._premultiplyAlpha),
                    this._glCreated && n ? s.texSubImage2D(s.TEXTURE_2D, i, 0, 0, Math.max(t._width * r, 1), Math.max(t._height * r, 1), this._glFormat, this._glPixelType, n) : s.texImage2D(s.TEXTURE_2D, i, this._glInternalFormat, Math.max(t._width * r, 1), Math.max(t._height * r, 1), 0, this._glFormat, this._glPixelType, n));
                i === 0 ? t._mipmapsUploaded = !1 : t._mipmapsUploaded = !0
            }
            i++
        }
        if (t._needsUpload)
            if (t._cubemap)
                for (let l = 0; l < 6; l++)
                    t._levelsUpdated[0][l] = !1;
            else
                t._levelsUpdated[0] = !1;
        !t._compressed && !t._integerFormat && t._mipmaps && t._needsMipmapsUpload && (t.pot || e.isWebGL2) && t._levels.length === 1 && (s.generateMipmap(this._glTarget),
        t._mipmapsUploaded = !0),
        t._gpuSize && t.adjustVramSizeTracking(e._vram, -t._gpuSize),
        t._gpuSize = t.gpuSize,
        t.adjustVramSizeTracking(e._vram, t._gpuSize),
        this._glCreated = !0
    }
}
class lE {
    constructor(e, t) {
        this.msaaFB = void 0,
        this.resolveFB = void 0,
        this.msaaFB = e,
        this.resolveFB = t
    }
    destroy(e) {
        this.msaaFB && (e.deleteRenderbuffer(this.msaaFB),
        this.msaaFB = null),
        this.resolveFB && (e.deleteRenderbuffer(this.resolveFB),
        this.resolveFB = null)
    }
}
class hE {
    constructor() {
        this._glFrameBuffer = null,
        this._glDepthBuffer = null,
        this._glResolveFrameBuffer = null,
        this.colorMrtFramebuffers = null,
        this._glMsaaColorBuffers = [],
        this._glMsaaDepthBuffer = null,
        this.suppliedColorFramebuffer = void 0,
        this._isInitialized = !1
    }
    destroy(e) {
        var t;
        const s = e.gl;
        this._isInitialized = !1,
        this._glFrameBuffer && (this._glFrameBuffer !== this.suppliedColorFramebuffer && s.deleteFramebuffer(this._glFrameBuffer),
        this._glFrameBuffer = null),
        this._glDepthBuffer && (s.deleteRenderbuffer(this._glDepthBuffer),
        this._glDepthBuffer = null),
        this._glResolveFrameBuffer && (this._glResolveFrameBuffer !== this.suppliedColorFramebuffer && s.deleteFramebuffer(this._glResolveFrameBuffer),
        this._glResolveFrameBuffer = null),
        this._glMsaaColorBuffers.forEach(i => {
            s.deleteRenderbuffer(i)
        }
        ),
        this._glMsaaColorBuffers.length = 0,
        (t = this.colorMrtFramebuffers) == null || t.forEach(i => {
            i.destroy(s)
        }
        ),
        this.colorMrtFramebuffers = null,
        this._glMsaaDepthBuffer && (s.deleteRenderbuffer(this._glMsaaDepthBuffer),
        this._glMsaaDepthBuffer = null),
        this.suppliedColorFramebuffer = void 0
    }
    get initialized() {
        return this._isInitialized
    }
    init(e, t) {
        const s = e.gl;
        this._isInitialized = !0;
        const i = [];
        if (this.suppliedColorFramebuffer !== void 0)
            this._glFrameBuffer = this.suppliedColorFramebuffer;
        else {
            var n, r, o, l;
            this._glFrameBuffer = s.createFramebuffer(),
            e.setFramebuffer(this._glFrameBuffer);
            const h = (n = (r = t._colorBuffers) == null ? void 0 : r.length) != null ? n : 0
              , u = e.isWebGL2 ? s.COLOR_ATTACHMENT0 : (o = (l = e.extDrawBuffers) == null ? void 0 : l.COLOR_ATTACHMENT0_WEBGL) != null ? o : s.COLOR_ATTACHMENT0;
            for (let p = 0; p < h; ++p) {
                const _ = t.getColorBuffer(p);
                _ && (_.impl._glTexture || (_._width = Math.min(_.width, e.maxRenderBufferSize),
                _._height = Math.min(_.height, e.maxRenderBufferSize),
                e.setTexture(_, 0)),
                s.framebufferTexture2D(s.FRAMEBUFFER, u + p, _._cubemap ? s.TEXTURE_CUBE_MAP_POSITIVE_X + t._face : s.TEXTURE_2D, _.impl._glTexture, 0),
                i.push(u + p))
            }
            e.drawBuffers && e.drawBuffers(i);
            const f = t._depthBuffer;
            if (f)
                f.impl._glTexture || (f._width = Math.min(f.width, e.maxRenderBufferSize),
                f._height = Math.min(f.height, e.maxRenderBufferSize),
                e.setTexture(f, 0)),
                t._stencil ? s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, f._cubemap ? s.TEXTURE_CUBE_MAP_POSITIVE_X + t._face : s.TEXTURE_2D, t._depthBuffer.impl._glTexture, 0) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, f._cubemap ? s.TEXTURE_CUBE_MAP_POSITIVE_X + t._face : s.TEXTURE_2D, t._depthBuffer.impl._glTexture, 0);
            else if (t._depth && !(t._samples > 1 && e.isWebGL2)) {
                if (this._glDepthBuffer || (this._glDepthBuffer = s.createRenderbuffer()),
                s.bindRenderbuffer(s.RENDERBUFFER, this._glDepthBuffer),
                t._stencil)
                    s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, t.width, t.height),
                    s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, this._glDepthBuffer);
                else {
                    const _ = e.isWebGL2 ? s.DEPTH_COMPONENT32F : s.DEPTH_COMPONENT16;
                    s.renderbufferStorage(s.RENDERBUFFER, _, t.width, t.height),
                    s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, this._glDepthBuffer)
                }
                s.bindRenderbuffer(s.RENDERBUFFER, null)
            }
        }
        if (e.isWebGL2 && t._samples > 1) {
            var c, d;
            this._glResolveFrameBuffer = this._glFrameBuffer,
            this._glFrameBuffer = s.createFramebuffer(),
            e.setFramebuffer(this._glFrameBuffer);
            const h = (c = (d = t._colorBuffers) == null ? void 0 : d.length) != null ? c : 0;
            if (this.suppliedColorFramebuffer !== void 0) {
                const u = s.createRenderbuffer();
                this._glMsaaColorBuffers.push(u);
                const f = e.backBufferFormat === ve ? s.RGBA8 : s.RGB8;
                s.bindRenderbuffer(s.RENDERBUFFER, u),
                s.renderbufferStorageMultisample(s.RENDERBUFFER, t._samples, f, t.width, t.height),
                s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, u)
            } else
                for (let u = 0; u < h; ++u) {
                    const f = t.getColorBuffer(u);
                    if (f) {
                        const p = s.createRenderbuffer();
                        this._glMsaaColorBuffers.push(p),
                        s.bindRenderbuffer(s.RENDERBUFFER, p),
                        s.renderbufferStorageMultisample(s.RENDERBUFFER, t._samples, f.impl._glInternalFormat, t.width, t.height),
                        s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + u, s.RENDERBUFFER, p)
                    }
                }
            t._depth && (this._glMsaaDepthBuffer || (this._glMsaaDepthBuffer = s.createRenderbuffer()),
            s.bindRenderbuffer(s.RENDERBUFFER, this._glMsaaDepthBuffer),
            t._stencil ? (s.renderbufferStorageMultisample(s.RENDERBUFFER, t._samples, s.DEPTH24_STENCIL8, t.width, t.height),
            s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, this._glMsaaDepthBuffer)) : (s.renderbufferStorageMultisample(s.RENDERBUFFER, t._samples, s.DEPTH_COMPONENT32F, t.width, t.height),
            s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, this._glMsaaDepthBuffer))),
            h > 1 && (this._createMsaaMrtFramebuffers(e, t, h),
            e.setFramebuffer(this._glFrameBuffer),
            e.drawBuffers(i))
        }
    }
    _createMsaaMrtFramebuffers(e, t, s) {
        const i = e.gl;
        this.colorMrtFramebuffers = [];
        for (let n = 0; n < s; ++n) {
            const r = t.getColorBuffer(n)
              , o = i.createFramebuffer();
            e.setFramebuffer(o);
            const l = this._glMsaaColorBuffers[n];
            i.bindRenderbuffer(i.RENDERBUFFER, l),
            i.renderbufferStorageMultisample(i.RENDERBUFFER, t._samples, r.impl._glInternalFormat, t.width, t.height),
            i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, l),
            e.drawBuffers([i.COLOR_ATTACHMENT0]);
            const c = i.createFramebuffer();
            e.setFramebuffer(c),
            i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, r._cubemap ? i.TEXTURE_CUBE_MAP_POSITIVE_X + t._face : i.TEXTURE_2D, r.impl._glTexture, 0),
            this.colorMrtFramebuffers[n] = new lE(o,c)
        }
    }
    _checkFbo(e, t, s="") {
        const i = e.gl;
        switch (i.checkFramebufferStatus(i.FRAMEBUFFER)) {
        case i.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            break;
        case i.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            break;
        case i.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            break;
        case i.FRAMEBUFFER_UNSUPPORTED:
            break
        }
    }
    loseContext() {
        this._glFrameBuffer = null,
        this._glDepthBuffer = null,
        this._glResolveFrameBuffer = null,
        this._glMsaaColorBuffers.length = 0,
        this._glMsaaDepthBuffer = null,
        this.colorMrtFramebuffers = null,
        this.suppliedColorFramebuffer = void 0,
        this._isInitialized = !1
    }
    internalResolve(e, t, s, i, n) {
        e.setScissor(0, 0, i.width, i.height);
        const r = e.gl;
        r.bindFramebuffer(r.READ_FRAMEBUFFER, t),
        r.bindFramebuffer(r.DRAW_FRAMEBUFFER, s),
        r.blitFramebuffer(0, 0, i.width, i.height, 0, 0, i.width, i.height, n, r.NEAREST)
    }
    resolve(e, t, s, i) {
        if (e.isWebGL2) {
            const n = e.gl;
            if (this.colorMrtFramebuffers) {
                if (s)
                    for (let r = 0; r < this.colorMrtFramebuffers.length; r++) {
                        const o = this.colorMrtFramebuffers[r];
                        this.internalResolve(e, o.msaaFB, o.resolveFB, t, n.COLOR_BUFFER_BIT)
                    }
                i && this.internalResolve(e, this._glFrameBuffer, this._glResolveFrameBuffer, t, n.DEPTH_BUFFER_BIT)
            } else
                this.internalResolve(e, this._glFrameBuffer, this._glResolveFrameBuffer, t, (s ? n.COLOR_BUFFER_BIT : 0) | (i ? n.DEPTH_BUFFER_BIT : 0));
            n.bindFramebuffer(n.FRAMEBUFFER, this._glFrameBuffer)
        }
    }
}
var WS = `
#define pcFragColor0 gl_FragData[0]
#if COLOR_ATTACHMENT_1
#define pcFragColor1 gl_FragData[1]
#endif
#if COLOR_ATTACHMENT_2
#define pcFragColor2 gl_FragData[2]
#endif
#if COLOR_ATTACHMENT_3
#define pcFragColor3 gl_FragData[3]
#endif
#if COLOR_ATTACHMENT_4
#define pcFragColor4 gl_FragData[4]
#endif
#if COLOR_ATTACHMENT_5
#define pcFragColor5 gl_FragData[5]
#endif
#if COLOR_ATTACHMENT_6
#define pcFragColor6 gl_FragData[6]
#endif
#if COLOR_ATTACHMENT_7
#define pcFragColor7 gl_FragData[7]
#endif
#define texture2DBias texture2D
#define itexture2D texture2D
#define utexture2D texture2D
#define SHADOWMAP_PASS(name) name
#define SHADOWMAP_ACCEPT(name) sampler2D name
#define TEXTURE_PASS(name) name
#define TEXTURE_ACCEPT(name) sampler2D name
#ifndef SUPPORTS_TEXLOD
	#define texture2DLodEXT texture2D
	#define texture2DProjLodEXT textureProj
	#define textureCubeLodEXT textureCube
	#define textureShadow texture2D
#else
	#define textureShadow(res, uv) texture2DGradEXT(res, uv, vec2(1, 1), vec2(1, 1))
#endif
#ifdef SUPPORTS_MRT
	#define gl_FragColor pcFragColor0
#endif
`
  , XS = `
#ifndef outType_0
#define outType_0 vec4
#endif
layout(location = 0) out highp outType_0 pc_fragColor;
#ifndef REMOVE_COLOR_ATTACHMENT_1
#if COLOR_ATTACHMENT_1
layout(location = 1) out highp outType_1 pc_fragColor1;
#endif
#endif
#ifndef REMOVE_COLOR_ATTACHMENT_2
#if COLOR_ATTACHMENT_2
layout(location = 2) out highp outType_2 pc_fragColor2;
#endif
#endif
#ifndef REMOVE_COLOR_ATTACHMENT_3
#if COLOR_ATTACHMENT_3
layout(location = 3) out highp outType_3 pc_fragColor3;
#endif
#endif
#ifndef REMOVE_COLOR_ATTACHMENT_4
#if COLOR_ATTACHMENT_4
layout(location = 4) out highp outType_4 pc_fragColor4;
#endif
#endif
#ifndef REMOVE_COLOR_ATTACHMENT_5
#if COLOR_ATTACHMENT_5
layout(location = 5) out highp outType_5 pc_fragColor5;
#endif
#endif
#ifndef REMOVE_COLOR_ATTACHMENT_6
#if COLOR_ATTACHMENT_6
layout(location = 6) out highp outType_6 pc_fragColor6;
#endif
#endif
#ifndef REMOVE_COLOR_ATTACHMENT_7
#if COLOR_ATTACHMENT_7
layout(location = 7) out highp outType_7 pc_fragColor7;
#endif
#endif
#define gl_FragColor pc_fragColor
#define pcFragColor0 pc_fragColor
#define pcFragColor1 pc_fragColor1
#define pcFragColor2 pc_fragColor2
#define pcFragColor3 pc_fragColor3
#define pcFragColor4 pc_fragColor4
#define pcFragColor5 pc_fragColor5
#define pcFragColor6 pc_fragColor6
#define pcFragColor7 pc_fragColor7
#define varying in
#define texture2D texture
#define texture2DBias texture
#define textureCube texture
#define texture2DProj textureProj
#define texture2DLodEXT textureLod
#define texture2DProjLodEXT textureProjLod
#define textureCubeLodEXT textureLod
#define texture2DGradEXT textureGrad
#define texture2DProjGradEXT textureProjGrad
#define textureCubeGradEXT textureGrad
#define utexture2D texture
#define itexture2D texture
#define textureShadow(res, uv) textureGrad(res, uv, vec2(1, 1), vec2(1, 1))
#define SHADOWMAP_PASS(name) name
#define SHADOWMAP_ACCEPT(name) sampler2DShadow name
#define TEXTURE_PASS(name) name
#define TEXTURE_ACCEPT(name) sampler2D name
#define GL2
#define SUPPORTS_TEXLOD
#define SUPPORTS_MRT
`
  , jS = `
#define attribute in
#define varying out
#define texture2D texture
#define utexture2D texture
#define itexture2D texture
#define GL2
#define VERTEXSHADER
`
  , $S = `
#extension GL_EXT_samplerless_texture_functions : require
#ifndef outType_0
#define outType_0 vec4
#endif
#ifndef outType_1
#define outType_1 vec4
#endif
#ifndef outType_2
#define outType_2 vec4
#endif
#ifndef outType_3
#define outType_3 vec4
#endif
#ifndef outType_4
#define outType_4 vec4
#endif
#ifndef outType_5
#define outType_5 vec4
#endif
#ifndef outType_6
#define outType_6 vec4
#endif
#ifndef outType_7
#define outType_7 vec4
#endif
layout(location = 0) out highp outType_0 pc_fragColor;
layout(location = 1) out highp outType_1 pc_fragColor1;
layout(location = 2) out highp outType_2 pc_fragColor2;
layout(location = 3) out highp outType_3 pc_fragColor3;
layout(location = 4) out highp outType_4 pc_fragColor4;
layout(location = 5) out highp outType_5 pc_fragColor5;
layout(location = 6) out highp outType_6 pc_fragColor6;
layout(location = 7) out highp outType_7 pc_fragColor7;
#define gl_FragColor pc_fragColor
#define pcFragColor0 pc_fragColor
#define pcFragColor1 pc_fragColor1
#define pcFragColor2 pc_fragColor2
#define pcFragColor3 pc_fragColor3
#define pcFragColor4 pc_fragColor4
#define pcFragColor5 pc_fragColor5
#define pcFragColor6 pc_fragColor6
#define pcFragColor7 pc_fragColor7
#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)
#define texture2DBias(res, uv, bias) texture(sampler2D(res, res ## _sampler), uv, bias)
#define texture2DLodEXT(res, uv, lod) textureLod(sampler2D(res, res ## _sampler), uv, lod)
#define textureCube(res, uv) texture(samplerCube(res, res ## _sampler), uv)
#define textureCubeLodEXT(res, uv, lod) textureLod(samplerCube(res, res ## _sampler), uv, lod)
#define textureShadow(res, uv) textureLod(sampler2DShadow(res, res ## _sampler), uv, 0.0)
#define itexture2D(res, uv) texture(isampler2D(res, res ## _sampler), uv)
#define utexture2D(res, uv) texture(usampler2D(res, res ## _sampler), uv)
#define SHADOWMAP_PASS(name) name, name ## _sampler
#define SHADOWMAP_ACCEPT(name) texture2D name, sampler name ## _sampler
#define TEXTURE_PASS(name) name, name ## _sampler
#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler
#define GL2
#define WEBGPU
#define SUPPORTS_TEXLOD
#define SUPPORTS_MRT
`
  , qS = `
#extension GL_EXT_samplerless_texture_functions : require
#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)
#define itexture2D(res, uv) texture(isampler2D(res, res ## _sampler), uv)
#define utexture2D(res, uv) texture(usampler2D(res, res ## _sampler), uv)
#define GL2
#define WEBGPU
#define VERTEXSHADER
`
  , Dy = `
vec2 getGrabScreenPos(vec4 clipPos) {
	vec2 uv = (clipPos.xy / clipPos.w) * 0.5 + 0.5;
	#ifdef WEBGPU
		uv.y = 1.0 - uv.y;
	#endif
	return uv;
}
vec2 getImageEffectUV(vec2 uv) {
	#ifdef WEBGPU
		uv.y = 1.0 - uv.y;
	#endif
	return uv;
}
`;
const cE = {
    vertex_position: ut,
    vertex_normal: Is,
    vertex_tangent: Qi,
    vertex_texCoord0: Ls,
    vertex_texCoord1: xr,
    vertex_texCoord2: Kh,
    vertex_texCoord3: Zh,
    vertex_texCoord4: Qh,
    vertex_texCoord5: Jh,
    vertex_texCoord6: ec,
    vertex_texCoord7: tc,
    vertex_color: jt,
    vertex_boneIndices: Ps,
    vertex_boneWeights: Ji
};
class Pt {
    static createDefinition(e, t) {
        var s, i;
        const n = (u, f, p, _, m) => {
            const g = e.isWebGPU ? u : e.isWebGL2 ? f : Pt.gl1Extensions(e, m) + p;
            let v = "";
            if (!_) {
                var x;
                let w = (x = m.fragmentOutputTypes) != null ? x : "vec4";
                Array.isArray(w) || (w = [w]);
                for (let T = 0; T < e.maxColorAttachments; T++) {
                    var S;
                    v += `#define COLOR_ATTACHMENT_${T}
`;
                    const b = (S = w[T]) != null ? S : "vec4";
                    v += `#define outType_${T} ${b}
`
                }
            }
            return v + g
        }
          , r = (s = t.name) != null ? s : "Untitled"
          , o = t.vertexDefines || n(qS, jS, "", !0, t)
          , l = Pt.versionCode(e) + o + Dy + Pt.getShaderNameCode(r) + t.vertexCode
          , c = t.fragmentDefines || n($S, XS, WS, !1, t)
          , d = (t.fragmentPreamble || "") + Pt.versionCode(e) + c + Pt.precisionCode(e) + `
` + Dy + Pt.getShaderNameCode(r) + (t.fragmentCode || Pt.dummyFragmentCode())
          , h = (i = t.attributes) != null ? i : Pt.collectAttributes(t.vertexCode);
        return {
            name: r,
            attributes: h,
            vshader: l,
            fshader: d,
            useTransformFeedback: t.useTransformFeedback
        }
    }
    static getShaderNameCode(e) {
        return `#define SHADER_NAME ${e}
`
    }
    static gl1Extensions(e, t, s) {
        let i;
        return s ? i = t.vertexExtensions ? `${t.vertexExtensions}
` : "" : (i = t.fragmentExtensions ? `${t.fragmentExtensions}
` : "",
        e.extStandardDerivatives && (i += `#extension GL_OES_standard_derivatives : enable
`),
        e.extTextureLod && (i += `#extension GL_EXT_shader_texture_lod : enable
`,
        i += `#define SUPPORTS_TEXLOD
`),
        e.extDrawBuffers && (i += `#extension GL_EXT_draw_buffers : require
`,
        i += `#define SUPPORTS_MRT
`)),
        i
    }
    static dummyFragmentCode() {
        return "void main(void) {gl_FragColor = vec4(0.0);}"
    }
    static versionCode(e) {
        return e.isWebGPU ? `#version 450
` : e.isWebGL2 ? `#version 300 es
` : ""
    }
    static precisionCode(e, t) {
        let s = "";
        t && t !== "highp" && t !== "mediump" && t !== "lowp" && (t = null),
        t && (t === "highp" && e.maxPrecision !== "highp" && (t = "mediump"),
        t === "mediump" && e.maxPrecision === "lowp" && (t = "lowp"));
        const i = t || e.precision;
        return e.isWebGPU ? s = `precision ${i} float;
precision ${i} int;
` : (s = `precision ${i} float;
`,
        e.isWebGL2 && (s += `precision ${i} sampler2DShadow;
`)),
        s
    }
    static collectAttributes(e) {
        const t = {};
        let s = 0
          , i = e.indexOf("attribute");
        for (; i >= 0 && !(i > 0 && e[i - 1] === "/"); ) {
            const n = e.indexOf(";", i)
              , r = e.lastIndexOf(" ", n)
              , o = e.substring(r + 1, n)
              , l = cE[o];
            l !== void 0 ? t[o] = l : (t[o] = "ATTR" + s,
            s++),
            i = e.indexOf("attribute", i + 1)
        }
        return t
    }
}
class dE {
    constructor() {
        this.renderVersion = void 0,
        this.queries = []
    }
    destroy(e) {
        this.queries.forEach(t => e.deleteQuery(t)),
        this.queries = null
    }
}
class uE extends GS {
    constructor(e) {
        super(),
        this.device = void 0,
        this.freeQueries = [],
        this.frameQueries = [],
        this.previousFrameQueries = [],
        this.timings = [],
        this.device = e,
        this.ext = e.extDisjointTimerQuery
    }
    destroy() {
        this.freeQueries.forEach(e => this.device.gl.deleteQuery(e)),
        this.frameQueries.forEach(e => this.device.gl.deleteQuery(e)),
        this.previousFrameQueries.forEach(e => e.destroy(this.device.gl)),
        this.freeQueries = null,
        this.frameQueries = null,
        this.previousFrameQueries = null
    }
    loseContext() {
        super.loseContext(),
        this.freeQueries = [],
        this.frameQueries = [],
        this.previousFrameQueries = []
    }
    restoreContext() {
        this.ext = this.device.extDisjointTimerQuery
    }
    getQuery() {
        var e;
        return (e = this.freeQueries.pop()) != null ? e : this.device.gl.createQuery()
    }
    start(e) {
        if (this.ext) {
            const t = this.getSlot(e)
              , s = this.getQuery();
            return this.frameQueries[t] = s,
            this.device.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, s),
            t
        }
    }
    end(e) {
        e !== void 0 && this.device.gl.endQuery(this.ext.TIME_ELAPSED_EXT)
    }
    frameStart() {
        this.processEnableRequest(),
        this._enabled && (this.frameGPUMarkerSlot = this.start("GpuFrame"))
    }
    frameEnd() {
        this._enabled && this.end(this.frameGPUMarkerSlot)
    }
    request() {
        if (this._enabled) {
            const e = this.ext
              , t = this.device.gl
              , s = this.device.renderVersion
              , i = this.frameQueries;
            if (i.length > 0) {
                this.frameQueries = [];
                const n = new dE;
                n.queries = i,
                n.renderVersion = s,
                this.previousFrameQueries.push(n)
            }
            if (this.previousFrameQueries.length > 0) {
                const n = this.previousFrameQueries[0]
                  , r = n.queries
                  , o = r[r.length - 1]
                  , l = t.getQueryParameter(o, t.QUERY_RESULT_AVAILABLE)
                  , c = t.getParameter(e.GPU_DISJOINT_EXT);
                if (l && !c) {
                    this.previousFrameQueries.shift();
                    const d = this.timings;
                    d.length = 0;
                    for (let h = 0; h < r.length; h++) {
                        const u = r[h]
                          , f = t.getQueryParameter(u, t.QUERY_RESULT);
                        d[h] = f * 1e-6,
                        this.freeQueries.push(u)
                    }
                    this.report(n.renderVersion, d)
                }
                c && (this.previousFrameQueries.forEach(d => {
                    this.report(d.renderVersion, null),
                    d.destroy(t)
                }
                ),
                this.previousFrameQueries.length = 0)
            }
            super.request(s)
        }
    }
}
const ka = []
  , xm = `
attribute vec2 vertex_position;
varying vec2 vUv0;
void main(void)
{
	gl_Position = vec4(vertex_position, 0.5, 1.0);
	vUv0 = vertex_position.xy*0.5+0.5;
}
`
  , fE = `
void main(void) { 
	gl_FragColor = vec4(2147483648.0);
}
`
  , pE = `
uniform sampler2D source;
vec4 packFloat(float depth) {
	const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
	const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
	vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);
	res -= res.xxyz * bit_mask;
	return res;
}
void main(void) {
	float c = texture2D(source, vec2(0.0)).r;
	float diff = abs(c - 2147483648.0) / 2147483648.0;
	gl_FragColor = packFloat(diff);
}
`
  , mE = `
varying vec2 vUv0;
uniform sampler2D source;
void main(void) {
	gl_FragColor = texture2D(source, vUv0);
}
`;
function wm(a, e, t) {
    const s = a.renderTarget;
    a.setRenderTarget(e),
    a.updateBegin(),
    a.setCullMode(bt),
    a.setBlendState(ft.NOBLEND),
    a.setDepthState($t.NODEPTH),
    a.setStencilState(null, null),
    a.setVertexBuffer(a.quadVertexBuffer, 0),
    a.setShader(t),
    a.draw({
        type: Ks,
        base: 0,
        count: 4,
        indexed: !1
    }),
    a.updateEnd(),
    a.setRenderTarget(s),
    a.updateBegin()
}
function Oy(a, e) {
    let t = !0;
    const s = a.createTexture();
    a.bindTexture(a.TEXTURE_2D, s),
    a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST),
    a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST),
    a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE),
    a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE),
    a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, 2, 2, 0, a.RGBA, e, null);
    const i = a.createFramebuffer();
    return a.bindFramebuffer(a.FRAMEBUFFER, i),
    a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, s, 0),
    a.checkFramebufferStatus(a.FRAMEBUFFER) !== a.FRAMEBUFFER_COMPLETE && (t = !1),
    a.bindTexture(a.TEXTURE_2D, null),
    a.deleteTexture(s),
    a.bindFramebuffer(a.FRAMEBUFFER, null),
    a.deleteFramebuffer(i),
    t
}
function _E(a, e) {
    let t = !0;
    const s = a.createTexture();
    a.bindTexture(a.TEXTURE_2D, s),
    a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST),
    a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST),
    a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE),
    a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE);
    const i = new Uint16Array(4 * 2 * 2);
    return a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, 2, 2, 0, a.RGBA, e, i),
    a.getError() !== a.NO_ERROR && (t = !1,
    console.log("Above error related to HALF_FLOAT_OES can be ignored, it was triggered by testing half float texture support")),
    a.bindTexture(a.TEXTURE_2D, null),
    a.deleteTexture(s),
    t
}
function gE(a) {
    if (!a.textureFloatRenderable)
        return !1;
    const e = new Xi(a,Pt.createDefinition(a, {
        name: "ptest1",
        vertexCode: xm,
        fragmentCode: fE
    }))
      , t = new Xi(a,Pt.createDefinition(a, {
        name: "ptest2",
        vertexCode: xm,
        fragmentCode: pE
    }))
      , s = {
        format: lt,
        width: 1,
        height: 1,
        mipmaps: !1,
        minFilter: be,
        magFilter: be,
        name: "testFHP"
    }
      , i = new ge(a,s)
      , n = new It({
        colorBuffer: i,
        depth: !1
    });
    wm(a, n, e),
    s.format = ve;
    const r = new ge(a,s)
      , o = new It({
        colorBuffer: r,
        depth: !1
    });
    a.constantTexSource.setValue(i),
    wm(a, o, t);
    const l = a.activeFramebuffer;
    a.setFramebuffer(o.impl._glFrameBuffer);
    const c = new Uint8Array(4);
    a.readPixels(0, 0, 1, 1, c),
    a.setFramebuffer(l);
    const d = c[0] / 255
      , h = c[1] / 255
      , u = c[2] / 255
      , f = c[3] / 255
      , p = d / (256 * 256 * 256) + h / (256 * 256) + u / 256 + f;
    return i.destroy(),
    n.destroy(),
    r.destroy(),
    o.destroy(),
    e.destroy(),
    t.destroy(),
    p === 0
}
class YS extends br {
    constructor(e, t={}) {
        var s;
        super(e, t),
        this.gl = void 0,
        this._defaultFramebuffer = null,
        this._defaultFramebufferChanged = !1,
        t = this.initOptions,
        this.updateClientRect(),
        this.initTextureUnits(),
        this.contextLost = !1,
        this._contextLostHandler = _ => {
            _.preventDefault(),
            this.contextLost = !0,
            this.loseContext(),
            this.fire("devicelost")
        }
        ,
        this._contextRestoredHandler = () => {
            this.contextLost = !1,
            this.restoreContext(),
            this.fire("devicerestored")
        }
        ;
        const i = typeof navigator < "u" && navigator.userAgent;
        if (this.forceDisableMultisampling = i && i.includes("AppleWebKit") && (i.includes("15.4") || i.includes("15_4")),
        this.forceDisableMultisampling && (t.antialias = !1),
        Le.browserName === "firefox" && Le.name === "windows") {
            const m = (typeof navigator < "u" ? navigator.userAgent : "").match(/Firefox\/(\d+(\.\d+)*)/)
              , g = m ? m[1] : null;
            if (g) {
                const v = parseFloat(g);
                (v >= 120 || v === 115) && (t.antialias = !1)
            }
        }
        let n = null;
        if (this.backBufferAntialias = (s = t.antialias) != null ? s : !1,
        t.antialias = !1,
        t.gl)
            n = t.gl;
        else {
            const m = (t.preferWebGl2 !== void 0 ? t.preferWebGl2 : !0) ? ["webgl2", "webgl", "experimental-webgl"] : ["webgl", "experimental-webgl"];
            for (let g = 0; g < m.length && (n = e.getContext(m[g], t),
            !n); g++)
                ;
        }
        if (!n)
            throw new Error("WebGL not supported");
        this.gl = n,
        this.isWebGL2 = typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext,
        this.isWebGL1 = !this.isWebGL2,
        this._deviceType = this.isWebGL2 ? po : eh,
        this.updateBackbufferFormat(null);
        const r = Le.browserName === "chrome"
          , o = Le.browserName === "safari"
          , l = Le.browser && navigator.appVersion.indexOf("Mac") !== -1;
        this._tempEnableSafariTextureUnitWorkaround = o,
        this._tempMacChromeBlitFramebufferWorkaround = l && r && !t.alpha,
        e.addEventListener("webglcontextlost", this._contextLostHandler, !1),
        e.addEventListener("webglcontextrestored", this._contextRestoredHandler, !1),
        this.initializeExtensions(),
        this.initializeCapabilities(),
        this.initializeRenderState(),
        this.initializeContextCaches(),
        this.createBackbuffer(null),
        this.supportsImageBitmap = !o && typeof ImageBitmap < "u",
        this.glAddress = [n.REPEAT, n.CLAMP_TO_EDGE, n.MIRRORED_REPEAT],
        this.glBlendEquation = [n.FUNC_ADD, n.FUNC_SUBTRACT, n.FUNC_REVERSE_SUBTRACT, this.isWebGL2 ? n.MIN : this.extBlendMinmax ? this.extBlendMinmax.MIN_EXT : n.FUNC_ADD, this.isWebGL2 ? n.MAX : this.extBlendMinmax ? this.extBlendMinmax.MAX_EXT : n.FUNC_ADD],
        this.glBlendFunctionColor = [n.ZERO, n.ONE, n.SRC_COLOR, n.ONE_MINUS_SRC_COLOR, n.DST_COLOR, n.ONE_MINUS_DST_COLOR, n.SRC_ALPHA, n.SRC_ALPHA_SATURATE, n.ONE_MINUS_SRC_ALPHA, n.DST_ALPHA, n.ONE_MINUS_DST_ALPHA, n.CONSTANT_COLOR, n.ONE_MINUS_CONSTANT_COLOR],
        this.glBlendFunctionAlpha = [n.ZERO, n.ONE, n.SRC_COLOR, n.ONE_MINUS_SRC_COLOR, n.DST_COLOR, n.ONE_MINUS_DST_COLOR, n.SRC_ALPHA, n.SRC_ALPHA_SATURATE, n.ONE_MINUS_SRC_ALPHA, n.DST_ALPHA, n.ONE_MINUS_DST_ALPHA, n.CONSTANT_ALPHA, n.ONE_MINUS_CONSTANT_ALPHA],
        this.glComparison = [n.NEVER, n.LESS, n.EQUAL, n.LEQUAL, n.GREATER, n.NOTEQUAL, n.GEQUAL, n.ALWAYS],
        this.glStencilOp = [n.KEEP, n.ZERO, n.REPLACE, n.INCR, n.INCR_WRAP, n.DECR, n.DECR_WRAP, n.INVERT],
        this.glClearFlag = [0, n.COLOR_BUFFER_BIT, n.DEPTH_BUFFER_BIT, n.COLOR_BUFFER_BIT | n.DEPTH_BUFFER_BIT, n.STENCIL_BUFFER_BIT, n.STENCIL_BUFFER_BIT | n.COLOR_BUFFER_BIT, n.STENCIL_BUFFER_BIT | n.DEPTH_BUFFER_BIT, n.STENCIL_BUFFER_BIT | n.COLOR_BUFFER_BIT | n.DEPTH_BUFFER_BIT],
        this.glCull = [0, n.BACK, n.FRONT, n.FRONT_AND_BACK],
        this.glFilter = [n.NEAREST, n.LINEAR, n.NEAREST_MIPMAP_NEAREST, n.NEAREST_MIPMAP_LINEAR, n.LINEAR_MIPMAP_NEAREST, n.LINEAR_MIPMAP_LINEAR],
        this.glPrimitive = [n.POINTS, n.LINES, n.LINE_LOOP, n.LINE_STRIP, n.TRIANGLES, n.TRIANGLE_STRIP, n.TRIANGLE_FAN],
        this.glType = [n.BYTE, n.UNSIGNED_BYTE, n.SHORT, n.UNSIGNED_SHORT, n.INT, n.UNSIGNED_INT, n.FLOAT, n.HALF_FLOAT],
        this.pcUniformType = {},
        this.pcUniformType[n.BOOL] = wo,
        this.pcUniformType[n.INT] = pa,
        this.pcUniformType[n.FLOAT] = yi,
        this.pcUniformType[n.FLOAT_VEC2] = mr,
        this.pcUniformType[n.FLOAT_VEC3] = As,
        this.pcUniformType[n.FLOAT_VEC4] = ma,
        this.pcUniformType[n.INT_VEC2] = ia,
        this.pcUniformType[n.INT_VEC3] = na,
        this.pcUniformType[n.INT_VEC4] = ra,
        this.pcUniformType[n.BOOL_VEC2] = mh,
        this.pcUniformType[n.BOOL_VEC3] = _h,
        this.pcUniformType[n.BOOL_VEC4] = gh,
        this.pcUniformType[n.FLOAT_MAT2] = Zd,
        this.pcUniformType[n.FLOAT_MAT3] = yh,
        this.pcUniformType[n.FLOAT_MAT4] = No,
        this.pcUniformType[n.SAMPLER_2D] = RT,
        this.pcUniformType[n.SAMPLER_CUBE] = IT,
        this.pcUniformType[n.UNSIGNED_INT] = Uo,
        this.pcUniformType[n.UNSIGNED_INT_VEC2] = zo,
        this.pcUniformType[n.UNSIGNED_INT_VEC3] = Vo,
        this.pcUniformType[n.UNSIGNED_INT_VEC4] = Go,
        this.isWebGL2 && (this.pcUniformType[n.SAMPLER_2D_SHADOW] = LT,
        this.pcUniformType[n.SAMPLER_CUBE_SHADOW] = DT,
        this.pcUniformType[n.SAMPLER_2D_ARRAY] = FT,
        this.pcUniformType[n.SAMPLER_3D] = OT,
        this.pcUniformType[n.INT_SAMPLER_2D] = BT,
        this.pcUniformType[n.UNSIGNED_INT_SAMPLER_2D] = kT,
        this.pcUniformType[n.INT_SAMPLER_CUBE] = NT,
        this.pcUniformType[n.UNSIGNED_INT_SAMPLER_2D] = UT,
        this.pcUniformType[n.INT_SAMPLER_3D] = zT,
        this.pcUniformType[n.UNSIGNED_INT_SAMPLER_3D] = VT,
        this.pcUniformType[n.INT_SAMPLER_2D_ARRAY] = GT,
        this.pcUniformType[n.UNSIGNED_INT_SAMPLER_2D_ARRAY] = HT),
        this.targetToSlot = {},
        this.targetToSlot[n.TEXTURE_2D] = 0,
        this.targetToSlot[n.TEXTURE_CUBE_MAP] = 1,
        this.targetToSlot[n.TEXTURE_3D] = 2;
        let c, d, h, u, f;
        this.commitFunction = [],
        this.commitFunction[wo] = function(_, m) {
            _.value !== m && (n.uniform1i(_.locationId, m),
            _.value = m)
        }
        ,
        this.commitFunction[pa] = this.commitFunction[wo],
        this.commitFunction[yi] = function(_, m) {
            _.value !== m && (n.uniform1f(_.locationId, m),
            _.value = m)
        }
        ,
        this.commitFunction[mr] = function(_, m) {
            f = _.value,
            c = m[0],
            d = m[1],
            (f[0] !== c || f[1] !== d) && (n.uniform2fv(_.locationId, m),
            f[0] = c,
            f[1] = d)
        }
        ,
        this.commitFunction[As] = function(_, m) {
            f = _.value,
            c = m[0],
            d = m[1],
            h = m[2],
            (f[0] !== c || f[1] !== d || f[2] !== h) && (n.uniform3fv(_.locationId, m),
            f[0] = c,
            f[1] = d,
            f[2] = h)
        }
        ,
        this.commitFunction[ma] = function(_, m) {
            f = _.value,
            c = m[0],
            d = m[1],
            h = m[2],
            u = m[3],
            (f[0] !== c || f[1] !== d || f[2] !== h || f[3] !== u) && (n.uniform4fv(_.locationId, m),
            f[0] = c,
            f[1] = d,
            f[2] = h,
            f[3] = u)
        }
        ,
        this.commitFunction[ia] = function(_, m) {
            f = _.value,
            c = m[0],
            d = m[1],
            (f[0] !== c || f[1] !== d) && (n.uniform2iv(_.locationId, m),
            f[0] = c,
            f[1] = d)
        }
        ,
        this.commitFunction[mh] = this.commitFunction[ia],
        this.commitFunction[na] = function(_, m) {
            f = _.value,
            c = m[0],
            d = m[1],
            h = m[2],
            (f[0] !== c || f[1] !== d || f[2] !== h) && (n.uniform3iv(_.locationId, m),
            f[0] = c,
            f[1] = d,
            f[2] = h)
        }
        ,
        this.commitFunction[_h] = this.commitFunction[na],
        this.commitFunction[ra] = function(_, m) {
            f = _.value,
            c = m[0],
            d = m[1],
            h = m[2],
            u = m[3],
            (f[0] !== c || f[1] !== d || f[2] !== h || f[3] !== u) && (n.uniform4iv(_.locationId, m),
            f[0] = c,
            f[1] = d,
            f[2] = h,
            f[3] = u)
        }
        ,
        this.commitFunction[gh] = this.commitFunction[ra],
        this.commitFunction[Zd] = function(_, m) {
            n.uniformMatrix2fv(_.locationId, !1, m)
        }
        ,
        this.commitFunction[yh] = function(_, m) {
            n.uniformMatrix3fv(_.locationId, !1, m)
        }
        ,
        this.commitFunction[No] = function(_, m) {
            n.uniformMatrix4fv(_.locationId, !1, m)
        }
        ,
        this.commitFunction[cf] = function(_, m) {
            n.uniform1fv(_.locationId, m)
        }
        ,
        this.commitFunction[df] = function(_, m) {
            n.uniform2fv(_.locationId, m)
        }
        ,
        this.commitFunction[uf] = function(_, m) {
            n.uniform3fv(_.locationId, m)
        }
        ,
        this.commitFunction[N_] = function(_, m) {
            n.uniform4fv(_.locationId, m)
        }
        ,
        this.commitFunction[Uo] = function(_, m) {
            _.value !== m && (n.uniform1ui(_.locationId, m),
            _.value = m)
        }
        ,
        this.commitFunction[zo] = function(_, m) {
            f = _.value,
            c = m[0],
            d = m[1],
            (f[0] !== c || f[1] !== d) && (n.uniform2uiv(_.locationId, m),
            f[0] = c,
            f[1] = d)
        }
        ,
        this.commitFunction[Vo] = function(_, m) {
            f = _.value,
            c = m[0],
            d = m[1],
            h = m[2],
            (f[0] !== c || f[1] !== d || f[2] !== h) && (n.uniform3uiv(_.locationId, m),
            f[0] = c,
            f[1] = d,
            f[2] = h)
        }
        ,
        this.commitFunction[Go] = function(_, m) {
            f = _.value,
            c = m[0],
            d = m[1],
            h = m[2],
            u = m[3],
            (f[0] !== c || f[1] !== d || f[2] !== h || f[3] !== u) && (n.uniform4uiv(_.locationId, m),
            f[0] = c,
            f[1] = d,
            f[2] = h,
            f[3] = u)
        }
        ,
        this.commitFunction[Ho] = function(_, m) {
            n.uniform1iv(_.locationId, m)
        }
        ,
        this.commitFunction[ff] = function(_, m) {
            n.uniform1uiv(_.locationId, m)
        }
        ,
        this.commitFunction[pf] = this.commitFunction[Ho],
        this.commitFunction[Wo] = function(_, m) {
            n.uniform2iv(_.locationId, m)
        }
        ,
        this.commitFunction[mf] = function(_, m) {
            n.uniform2uiv(_.locationId, m)
        }
        ,
        this.commitFunction[_f] = this.commitFunction[Wo],
        this.commitFunction[Xo] = function(_, m) {
            n.uniform3iv(_.locationId, m)
        }
        ,
        this.commitFunction[gf] = function(_, m) {
            n.uniform3uiv(_.locationId, m)
        }
        ,
        this.commitFunction[yf] = this.commitFunction[Xo],
        this.commitFunction[Qd] = function(_, m) {
            n.uniform4iv(_.locationId, m)
        }
        ,
        this.commitFunction[U_] = function(_, m) {
            n.uniform4uiv(_.locationId, m)
        }
        ,
        this.commitFunction[z_] = this.commitFunction[Qd],
        this.commitFunction[FS] = function(_, m) {
            n.uniformMatrix4fv(_.locationId, !1, m)
        }
        ,
        this.supportsBoneTextures = this.extTextureFloat && this.maxVertexTextures > 0;
        let p = this.vertexUniformsCount;
        p -= 4 * 4,
        p -= 8,
        p -= 1,
        p -= 4 * 4,
        this.boneLimit = Math.floor(p / 3),
        this.boneLimit = Math.min(this.boneLimit, 128),
        this.unmaskedRenderer === "Mali-450 MP" && (this.boneLimit = 34),
        this.constantTexSource = this.scope.resolve("source"),
        this.extTextureFloat ? this.isWebGL2 ? this.textureFloatRenderable = !!this.extColorBufferFloat : this.textureFloatRenderable = Oy(n, n.FLOAT) : this.textureFloatRenderable = !1,
        this.extColorBufferHalfFloat ? this.textureHalfFloatRenderable = !!this.extColorBufferHalfFloat : this.extTextureHalfFloat ? this.isWebGL2 ? this.textureHalfFloatRenderable = !!this.extColorBufferFloat : this.textureHalfFloatRenderable = Oy(n, this.extTextureHalfFloat.HALF_FLOAT_OES) : this.textureHalfFloatRenderable = !1,
        this.supportsMorphTargetTexturesCore = this.maxPrecision === "highp" && this.maxVertexTextures >= 2,
        this.supportsDepthShadow = this.isWebGL2,
        this._textureFloatHighPrecision = void 0,
        this._textureHalfFloatUpdatable = void 0,
        this.areaLightLutFormat = ve,
        this.extTextureHalfFloat && this.textureHalfFloatUpdatable && this.extTextureHalfFloatLinear ? this.areaLightLutFormat = Tt : this.extTextureFloat && this.extTextureFloatLinear && (this.areaLightLutFormat = lt),
        this.postInit()
    }
    postInit() {
        super.postInit(),
        this.gpuProfiler = new uE(this)
    }
    destroy() {
        super.destroy();
        const e = this.gl;
        this.isWebGL2 && this.feedback && e.deleteTransformFeedback(this.feedback),
        this.clearVertexArrayObjectCache(),
        this.canvas.removeEventListener("webglcontextlost", this._contextLostHandler, !1),
        this.canvas.removeEventListener("webglcontextrestored", this._contextRestoredHandler, !1),
        this._contextLostHandler = null,
        this._contextRestoredHandler = null,
        this.gl = null,
        super.postDestroy()
    }
    createBackbuffer(e) {
        this.supportsStencil = this.initOptions.stencil,
        this.backBuffer = new It({
            name: "WebglFramebuffer",
            graphicsDevice: this,
            depth: this.initOptions.depth,
            stencil: this.supportsStencil,
            samples: this.samples
        }),
        this.backBuffer.impl.suppliedColorFramebuffer = e
    }
    updateBackbufferFormat(e) {
        const t = this.gl;
        t.bindFramebuffer(t.FRAMEBUFFER, e);
        const s = this.gl.getParameter(this.gl.ALPHA_BITS);
        this.backBufferFormat = s ? ve : Ln
    }
    updateBackbuffer() {
        const e = this.canvas.width !== this.backBufferSize.x || this.canvas.height !== this.backBufferSize.y;
        (this._defaultFramebufferChanged || e) && (this._defaultFramebufferChanged && this.updateBackbufferFormat(this._defaultFramebuffer),
        this._defaultFramebufferChanged = !1,
        this.backBufferSize.set(this.canvas.width, this.canvas.height),
        this.backBuffer.destroy(),
        this.createBackbuffer(this._defaultFramebuffer))
    }
    createVertexBufferImpl(e, t) {
        return new JC
    }
    createIndexBufferImpl(e) {
        return new eE(e)
    }
    createShaderImpl(e) {
        return new xh(e)
    }
    createTextureImpl(e) {
        return new oE
    }
    createRenderTargetImpl(e) {
        return new hE
    }
    getPrecision() {
        const e = this.gl;
        let t = "highp";
        if (e.getShaderPrecisionFormat) {
            const s = e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT)
              , i = e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT)
              , n = e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT)
              , r = e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT);
            if (s && i && n && r) {
                const o = s.precision > 0 && n.precision > 0
                  , l = i.precision > 0 && r.precision > 0;
                o || (l ? t = "mediump" : t = "lowp")
            }
        }
        return t
    }
    getExtension() {
        for (let e = 0; e < arguments.length; e++)
            if (this.supportedExtensions.indexOf(arguments[e]) !== -1)
                return this.gl.getExtension(arguments[e]);
        return null
    }
    get extDisjointTimerQuery() {
        return this._extDisjointTimerQuery || this.isWebGL2 && (this._extDisjointTimerQuery = this.getExtension("EXT_disjoint_timer_query_webgl2", "EXT_disjoint_timer_query")),
        this._extDisjointTimerQuery
    }
    initializeExtensions() {
        var e;
        const t = this.gl;
        if (this.supportedExtensions = (e = t.getSupportedExtensions()) != null ? e : [],
        this._extDisjointTimerQuery = null,
        this.isWebGL2)
            this.extBlendMinmax = !0,
            this.extDrawBuffers = !0,
            this.drawBuffers = t.drawBuffers.bind(t),
            this.extInstancing = !0,
            this.extStandardDerivatives = !0,
            this.extTextureFloat = !0,
            this.extTextureHalfFloat = !0,
            this.textureHalfFloatFilterable = !0,
            this.extTextureLod = !0,
            this.extUintElement = !0,
            this.extVertexArrayObject = !0,
            this.extColorBufferFloat = this.getExtension("EXT_color_buffer_float"),
            this.extDepthTexture = !0,
            this.textureRG11B10Renderable = !0;
        else {
            var s;
            if (this.extBlendMinmax = this.getExtension("EXT_blend_minmax"),
            this.extDrawBuffers = this.getExtension("WEBGL_draw_buffers"),
            this.extInstancing = this.getExtension("ANGLE_instanced_arrays"),
            this.drawBuffers = (s = this.extDrawBuffers) == null ? void 0 : s.drawBuffersWEBGL.bind(this.extDrawBuffers),
            this.extInstancing) {
                const i = this.extInstancing;
                t.drawArraysInstanced = i.drawArraysInstancedANGLE.bind(i),
                t.drawElementsInstanced = i.drawElementsInstancedANGLE.bind(i),
                t.vertexAttribDivisor = i.vertexAttribDivisorANGLE.bind(i)
            }
            if (this.extStandardDerivatives = this.getExtension("OES_standard_derivatives"),
            this.extTextureFloat = this.getExtension("OES_texture_float"),
            this.extTextureLod = this.getExtension("EXT_shader_texture_lod"),
            this.extUintElement = this.getExtension("OES_element_index_uint"),
            this.extVertexArrayObject = this.getExtension("OES_vertex_array_object"),
            this.extVertexArrayObject) {
                const i = this.extVertexArrayObject;
                t.createVertexArray = i.createVertexArrayOES.bind(i),
                t.deleteVertexArray = i.deleteVertexArrayOES.bind(i),
                t.isVertexArray = i.isVertexArrayOES.bind(i),
                t.bindVertexArray = i.bindVertexArrayOES.bind(i)
            }
            this.extColorBufferFloat = null,
            this.extDepthTexture = t.getExtension("WEBGL_depth_texture"),
            this.extTextureHalfFloat = this.getExtension("OES_texture_half_float"),
            this.extTextureHalfFloatLinear = this.getExtension("OES_texture_half_float_linear"),
            this.textureHalfFloatFilterable = !!this.extTextureHalfFloatLinear
        }
        this.extDebugRendererInfo = this.getExtension("WEBGL_debug_renderer_info"),
        this.extTextureFloatLinear = this.getExtension("OES_texture_float_linear"),
        this.textureFloatFilterable = !!this.extTextureFloatLinear,
        this.extFloatBlend = this.getExtension("EXT_float_blend"),
        this.extTextureFilterAnisotropic = this.getExtension("EXT_texture_filter_anisotropic", "WEBKIT_EXT_texture_filter_anisotropic"),
        this.extCompressedTextureETC1 = this.getExtension("WEBGL_compressed_texture_etc1"),
        this.extCompressedTextureETC = this.getExtension("WEBGL_compressed_texture_etc"),
        this.extCompressedTexturePVRTC = this.getExtension("WEBGL_compressed_texture_pvrtc", "WEBKIT_WEBGL_compressed_texture_pvrtc"),
        this.extCompressedTextureS3TC = this.getExtension("WEBGL_compressed_texture_s3tc", "WEBKIT_WEBGL_compressed_texture_s3tc"),
        this.extCompressedTextureATC = this.getExtension("WEBGL_compressed_texture_atc"),
        this.extCompressedTextureASTC = this.getExtension("WEBGL_compressed_texture_astc"),
        this.extParallelShaderCompile = this.getExtension("KHR_parallel_shader_compile"),
        this.extColorBufferHalfFloat = this.getExtension("EXT_color_buffer_half_float")
    }
    initializeCapabilities() {
        var e, t;
        const s = this.gl;
        let i;
        const n = typeof navigator < "u" ? navigator.userAgent : "";
        this.maxPrecision = this.precision = this.getPrecision();
        const r = s.getContextAttributes();
        this.supportsMsaa = (e = r == null ? void 0 : r.antialias) != null ? e : !1,
        this.supportsStencil = (t = r == null ? void 0 : r.stencil) != null ? t : !1,
        this.supportsInstancing = !!this.extInstancing,
        this.maxTextureSize = s.getParameter(s.MAX_TEXTURE_SIZE),
        this.maxCubeMapSize = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE),
        this.maxRenderBufferSize = s.getParameter(s.MAX_RENDERBUFFER_SIZE),
        this.maxTextures = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS),
        this.maxCombinedTextures = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
        this.maxVertexTextures = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
        this.vertexUniformsCount = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS),
        this.fragmentUniformsCount = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS),
        this.isWebGL2 ? (this.maxDrawBuffers = s.getParameter(s.MAX_DRAW_BUFFERS),
        this.maxColorAttachments = s.getParameter(s.MAX_COLOR_ATTACHMENTS),
        this.maxVolumeSize = s.getParameter(s.MAX_3D_TEXTURE_SIZE),
        this.supportsMrt = !0,
        this.supportsVolumeTextures = !0) : (i = this.extDrawBuffers,
        this.supportsMrt = !!i,
        this.maxDrawBuffers = i ? s.getParameter(i.MAX_DRAW_BUFFERS_WEBGL) : 1,
        this.maxColorAttachments = i ? s.getParameter(i.MAX_COLOR_ATTACHMENTS_WEBGL) : 1,
        this.maxVolumeSize = 1),
        i = this.extDebugRendererInfo,
        this.unmaskedRenderer = i ? s.getParameter(i.UNMASKED_RENDERER_WEBGL) : "",
        this.unmaskedVendor = i ? s.getParameter(i.UNMASKED_VENDOR_WEBGL) : "";
        const o = /\bMali-G52+/
          , l = /SM-[a-zA-Z0-9]+/;
        this.supportsGpuParticles = !(this.unmaskedVendor === "ARM" && n.match(l)) && !this.unmaskedRenderer.match(o),
        i = this.extTextureFilterAnisotropic,
        this.maxAnisotropy = i ? s.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
        const c = this.isWebGL2 && !this.forceDisableMultisampling;
        this.maxSamples = c ? s.getParameter(s.MAX_SAMPLES) : 1,
        this.maxSamples = Math.min(this.maxSamples, 4),
        this.samples = c && this.backBufferAntialias ? this.maxSamples : 1,
        this.supportsAreaLights = this.isWebGL2 || !Le.android,
        this.supportsTextureFetch = this.isWebGL2,
        this.maxTextures <= 8 && (this.supportsAreaLights = !1)
    }
    initializeRenderState() {
        super.initializeRenderState();
        const e = this.gl;
        e.disable(e.BLEND),
        e.blendFunc(e.ONE, e.ZERO),
        e.blendEquation(e.FUNC_ADD),
        e.colorMask(!0, !0, !0, !0),
        e.blendColor(0, 0, 0, 0),
        e.enable(e.CULL_FACE),
        e.cullFace(e.BACK),
        e.enable(e.DEPTH_TEST),
        e.depthFunc(e.LEQUAL),
        e.depthMask(!0),
        this.stencil = !1,
        e.disable(e.STENCIL_TEST),
        this.stencilFuncFront = this.stencilFuncBack = Mn,
        this.stencilRefFront = this.stencilRefBack = 0,
        this.stencilMaskFront = this.stencilMaskBack = 255,
        e.stencilFunc(e.ALWAYS, 0, 255),
        this.stencilFailFront = this.stencilFailBack = xo,
        this.stencilZfailFront = this.stencilZfailBack = xo,
        this.stencilZpassFront = this.stencilZpassBack = xo,
        this.stencilWriteMaskFront = 255,
        this.stencilWriteMaskBack = 255,
        e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
        e.stencilMask(255),
        this.alphaToCoverage = !1,
        this.raster = !0,
        this.isWebGL2 && (e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
        e.disable(e.RASTERIZER_DISCARD)),
        this.depthBiasEnabled = !1,
        e.disable(e.POLYGON_OFFSET_FILL),
        this.clearDepth = 1,
        e.clearDepth(1),
        this.clearColor = new z(0,0,0,0),
        e.clearColor(0, 0, 0, 0),
        this.clearStencil = 0,
        e.clearStencil(0),
        this.isWebGL2 ? e.hint(e.FRAGMENT_SHADER_DERIVATIVE_HINT, e.NICEST) : this.extStandardDerivatives && e.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, e.NICEST),
        e.enable(e.SCISSOR_TEST),
        e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE),
        this.unpackFlipY = !1,
        e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1),
        this.unpackPremultiplyAlpha = !1,
        e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
        e.pixelStorei(e.UNPACK_ALIGNMENT, 1)
    }
    initTextureUnits(e=16) {
        this.textureUnits = [];
        for (let t = 0; t < e; t++)
            this.textureUnits.push([null, null, null])
    }
    initializeContextCaches() {
        super.initializeContextCaches(),
        this._vaoMap = new Map,
        this.boundVao = null,
        this.activeFramebuffer = null,
        this.feedback = null,
        this.transformFeedbackBuffer = null,
        this.textureUnit = 0,
        this.initTextureUnits(this.maxCombinedTextures)
    }
    loseContext() {
        var e;
        this.backBufferSize.set(-1, -1);
        for (const t of this.shaders)
            t.loseContext();
        for (const t of this.textures)
            t.loseContext();
        for (const t of this.buffers)
            t.loseContext();
        for (const t of this.targets)
            t.loseContext();
        (e = this.gpuProfiler) == null || e.loseContext()
    }
    restoreContext() {
        var e;
        this.initializeExtensions(),
        this.initializeCapabilities(),
        this.initializeRenderState(),
        this.initializeContextCaches();
        for (const t of this.shaders)
            t.restoreContext();
        for (const t of this.buffers)
            t.unlock();
        (e = this.gpuProfiler) == null || e.restoreContext()
    }
    endShaderBatch() {
        xh.endShaderBatch(this)
    }
    setViewport(e, t, s, i) {
        (this.vx !== e || this.vy !== t || this.vw !== s || this.vh !== i) && (this.gl.viewport(e, t, s, i),
        this.vx = e,
        this.vy = t,
        this.vw = s,
        this.vh = i)
    }
    setScissor(e, t, s, i) {
        (this.sx !== e || this.sy !== t || this.sw !== s || this.sh !== i) && (this.gl.scissor(e, t, s, i),
        this.sx = e,
        this.sy = t,
        this.sw = s,
        this.sh = i)
    }
    setFramebuffer(e) {
        if (this.activeFramebuffer !== e) {
            const t = this.gl;
            t.bindFramebuffer(t.FRAMEBUFFER, e),
            this.activeFramebuffer = e
        }
    }
    copyRenderTarget(e, t, s, i) {
        const n = this.gl;
        if (e === this.backBuffer && (e = null),
        !this.isWebGL2 && i)
            return !1;
        if (s) {
            if (t) {
                if (e && (!e._colorBuffer || !t._colorBuffer || e._colorBuffer._format !== t._colorBuffer._format))
                    return !1
            } else if (!e._colorBuffer)
                return !1
        }
        if (i && e && !e._depth && (!e._depthBuffer || !t._depthBuffer || e._depthBuffer._format !== t._depthBuffer._format))
            return !1;
        if (this.isWebGL2 && t) {
            var r;
            const o = this.renderTarget;
            this.renderTarget = t,
            this.updateBegin();
            const l = e ? e.impl._glFrameBuffer : (r = this.backBuffer) == null ? void 0 : r.impl._glFrameBuffer
              , c = t.impl._glFrameBuffer;
            n.bindFramebuffer(n.READ_FRAMEBUFFER, l),
            n.bindFramebuffer(n.DRAW_FRAMEBUFFER, c);
            const d = e ? e.width : t.width
              , h = e ? e.height : t.height;
            n.blitFramebuffer(0, 0, d, h, 0, 0, d, h, (s ? n.COLOR_BUFFER_BIT : 0) | (i ? n.DEPTH_BUFFER_BIT : 0), n.NEAREST),
            this.renderTarget = o,
            n.bindFramebuffer(n.FRAMEBUFFER, o ? o.impl._glFrameBuffer : null)
        } else {
            const o = this.getCopyShader();
            this.constantTexSource.setValue(e._colorBuffer),
            wm(this, t, o)
        }
        return !0
    }
    getCopyShader() {
        return this._copyShader || (this._copyShader = new Xi(this,Pt.createDefinition(this, {
            name: "outputTex2D",
            vertexCode: xm,
            fragmentCode: mE
        }))),
        this._copyShader
    }
    frameStart() {
        super.frameStart(),
        this.updateBackbuffer(),
        this.gpuProfiler.frameStart()
    }
    frameEnd() {
        super.frameEnd(),
        this.gpuProfiler.frameEnd(),
        this.gpuProfiler.request()
    }
    startRenderPass(e) {
        var t;
        const s = (t = e.renderTarget) != null ? t : this.backBuffer;
        this.renderTarget = s,
        this.updateBegin();
        const {width: i, height: n} = s;
        this.setViewport(0, 0, i, n),
        this.setScissor(0, 0, i, n);
        const r = e.colorOps
          , o = e.depthStencilOps;
        if (r != null && r.clear || o.clearDepth || o.clearStencil) {
            let l = 0;
            const c = {};
            r != null && r.clear && (l |= Oo,
            c.color = [r.clearValue.r, r.clearValue.g, r.clearValue.b, r.clearValue.a]),
            o.clearDepth && (l |= Fo,
            c.depth = o.clearDepthValue),
            o.clearStencil && (l |= fh,
            c.stencil = o.clearStencilValue),
            c.flags = l,
            this.clear(c)
        }
        this.insideRenderPass = !0
    }
    endRenderPass(e) {
        this.unbindVertexArray();
        const t = this.renderTarget
          , s = e.colorArrayOps.length;
        if (t) {
            var i;
            if (this.isWebGL2) {
                ka.length = 0;
                const n = this.gl;
                for (let r = 0; r < s; r++) {
                    const o = e.colorArrayOps[r];
                    o.store || o.resolve || ka.push(n.COLOR_ATTACHMENT0 + r)
                }
                t !== this.backBuffer && (e.depthStencilOps.storeDepth || ka.push(n.DEPTH_ATTACHMENT),
                e.depthStencilOps.storeStencil || ka.push(n.STENCIL_ATTACHMENT)),
                ka.length > 0 && e.fullSizeClearRect && n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, ka)
            }
            (i = e.colorOps) != null && i.resolve && this.isWebGL2 && e.samples > 1 && t.autoResolve && t.resolve(!0, !1);
            for (let n = 0; n < s; n++)
                if (e.colorArrayOps[n].mipmaps) {
                    const o = t._colorBuffers[n];
                    o && o.impl._glTexture && o.mipmaps && (o.pot || this.isWebGL2) && (this.activeTexture(this.maxCombinedTextures - 1),
                    this.bindTexture(o),
                    this.gl.generateMipmap(o.impl._glTarget))
                }
        }
        this.insideRenderPass = !1
    }
    set defaultFramebuffer(e) {
        this._defaultFramebuffer !== e && (this._defaultFramebuffer = e,
        this._defaultFramebufferChanged = !0)
    }
    get defaultFramebuffer() {
        return this._defaultFramebuffer
    }
    updateBegin() {
        var e;
        if (this.boundVao = null,
        this._tempEnableSafariTextureUnitWorkaround)
            for (let i = 0; i < this.textureUnits.length; ++i)
                for (let n = 0; n < 3; ++n)
                    this.textureUnits[i][n] = null;
        const t = (e = this.renderTarget) != null ? e : this.backBuffer
          , s = t.impl;
        s.initialized || this.initRenderTarget(t),
        this.setFramebuffer(s._glFrameBuffer)
    }
    updateEnd() {
        this.unbindVertexArray();
        const e = this.renderTarget;
        if (e && e !== this.backBuffer) {
            this.isWebGL2 && e._samples > 1 && e.autoResolve && e.resolve();
            const t = e._colorBuffer;
            t && t.impl._glTexture && t.mipmaps && (t.pot || this.isWebGL2) && (this.activeTexture(this.maxCombinedTextures - 1),
            this.bindTexture(t),
            this.gl.generateMipmap(t.impl._glTarget))
        }
    }
    setUnpackFlipY(e) {
        if (this.unpackFlipY !== e) {
            this.unpackFlipY = e;
            const t = this.gl;
            t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e)
        }
    }
    setUnpackPremultiplyAlpha(e) {
        if (this.unpackPremultiplyAlpha !== e) {
            this.unpackPremultiplyAlpha = e;
            const t = this.gl;
            t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e)
        }
    }
    activeTexture(e) {
        this.textureUnit !== e && (this.gl.activeTexture(this.gl.TEXTURE0 + e),
        this.textureUnit = e)
    }
    bindTexture(e) {
        const t = e.impl
          , s = t._glTarget
          , i = t._glTexture
          , n = this.textureUnit
          , r = this.targetToSlot[s];
        this.textureUnits[n][r] !== i && (this.gl.bindTexture(s, i),
        this.textureUnits[n][r] = i)
    }
    bindTextureOnUnit(e, t) {
        const s = e.impl
          , i = s._glTarget
          , n = s._glTexture
          , r = this.targetToSlot[i];
        this.textureUnits[t][r] !== n && (this.activeTexture(t),
        this.gl.bindTexture(i, n),
        this.textureUnits[t][r] = n)
    }
    setTextureParameters(e) {
        const t = this.gl
          , s = e.impl.dirtyParameterFlags
          , i = e.impl._glTarget;
        if (s & 1) {
            let n = e._minFilter;
            (!e.pot && !this.isWebGL2 || !e._mipmaps || e._compressed && e._levels.length === 1) && (n === Vh || n === Gh ? n = be : (n === Hh || n === ur) && (n = ot)),
            t.texParameteri(i, t.TEXTURE_MIN_FILTER, this.glFilter[n])
        }
        if (s & 2 && t.texParameteri(i, t.TEXTURE_MAG_FILTER, this.glFilter[e._magFilter]),
        s & 4 && (this.isWebGL2 ? t.texParameteri(i, t.TEXTURE_WRAP_S, this.glAddress[e._addressU]) : t.texParameteri(i, t.TEXTURE_WRAP_S, this.glAddress[e.pot ? e._addressU : oe])),
        s & 8 && (this.isWebGL2 ? t.texParameteri(i, t.TEXTURE_WRAP_T, this.glAddress[e._addressV]) : t.texParameteri(i, t.TEXTURE_WRAP_T, this.glAddress[e.pot ? e._addressV : oe])),
        s & 16 && this.isWebGL2 && t.texParameteri(i, t.TEXTURE_WRAP_R, this.glAddress[e._addressW]),
        s & 32 && this.isWebGL2 && t.texParameteri(i, t.TEXTURE_COMPARE_MODE, e._compareOnRead ? t.COMPARE_REF_TO_TEXTURE : t.NONE),
        s & 64 && this.isWebGL2 && t.texParameteri(i, t.TEXTURE_COMPARE_FUNC, this.glComparison[e._compareFunc]),
        s & 128) {
            const n = this.extTextureFilterAnisotropic;
            n && t.texParameterf(i, n.TEXTURE_MAX_ANISOTROPY_EXT, W.clamp(Math.round(e._anisotropy), 1, this.maxAnisotropy))
        }
    }
    setTexture(e, t) {
        const s = e.impl;
        s._glTexture || s.initialize(this, e),
        s.dirtyParameterFlags > 0 || e._needsUpload || e._needsMipmapsUpload ? (this.activeTexture(t),
        this.bindTexture(e),
        s.dirtyParameterFlags && (this.setTextureParameters(e),
        s.dirtyParameterFlags = 0),
        (e._needsUpload || e._needsMipmapsUpload) && (s.upload(this, e),
        e._needsUpload = !1,
        e._needsMipmapsUpload = !1)) : this.bindTextureOnUnit(e, t)
    }
    createVertexArray(e) {
        let t, s;
        const i = e.length > 1;
        if (i) {
            t = "";
            for (let n = 0; n < e.length; n++) {
                const r = e[n];
                t += r.id + r.format.renderingHash
            }
            s = this._vaoMap.get(t)
        }
        if (!s) {
            const n = this.gl;
            s = n.createVertexArray(),
            n.bindVertexArray(s),
            n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, null);
            for (let r = 0; r < e.length; r++) {
                const o = e[r];
                n.bindBuffer(n.ARRAY_BUFFER, o.impl.bufferId);
                const l = o.format.elements;
                for (let c = 0; c < l.length; c++) {
                    const d = l[c]
                      , h = De[d.name];
                    d.asInt ? n.vertexAttribIPointer(h, d.numComponents, this.glType[d.dataType], d.stride, d.offset) : n.vertexAttribPointer(h, d.numComponents, this.glType[d.dataType], d.normalize, d.stride, d.offset),
                    n.enableVertexAttribArray(h),
                    o.format.instancing && n.vertexAttribDivisor(h, 1)
                }
            }
            n.bindVertexArray(null),
            n.bindBuffer(n.ARRAY_BUFFER, null),
            i && this._vaoMap.set(t, s)
        }
        return s
    }
    unbindVertexArray() {
        this.boundVao && (this.boundVao = null,
        this.gl.bindVertexArray(null))
    }
    setBuffers() {
        const e = this.gl;
        let t;
        if (this.vertexBuffers.length === 1) {
            const i = this.vertexBuffers[0];
            i.impl.vao || (i.impl.vao = this.createVertexArray(this.vertexBuffers)),
            t = i.impl.vao
        } else
            t = this.createVertexArray(this.vertexBuffers);
        this.boundVao !== t && (this.boundVao = t,
        e.bindVertexArray(t)),
        this.vertexBuffers.length = 0;
        const s = this.indexBuffer ? this.indexBuffer.impl.bufferId : null;
        e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, s)
    }
    draw(e, t, s) {
        const i = this.gl;
        let n, r, o, l, c, d, h, u;
        const f = this.shader;
        if (!f)
            return;
        const p = f.impl.samplers
          , _ = f.impl.uniforms;
        s || this.setBuffers();
        let m = 0;
        for (let x = 0, S = p.length; x < S; x++) {
            if (n = p[x],
            r = n.scopeId.value,
            !r)
                return;
            if (r instanceof ge)
                o = r,
                this.setTexture(o, m),
                n.slot !== m && (i.uniform1i(n.locationId, m),
                n.slot = m),
                m++;
            else {
                n.array.length = 0,
                l = r.length;
                for (let w = 0; w < l; w++)
                    o = r[w],
                    this.setTexture(o, m),
                    n.array[w] = m,
                    m++;
                i.uniform1iv(n.locationId, n.array)
            }
        }
        for (let x = 0, S = _.length; x < S; x++)
            c = _[x],
            d = c.scopeId,
            h = c.version,
            u = d.versionObject.version,
            (h.globalId !== u.globalId || h.revision !== u.revision) && (h.globalId = u.globalId,
            h.revision = u.revision,
            d.value !== null && this.commitFunction[c.dataType](c, d.value));
        this.isWebGL2 && this.transformFeedbackBuffer && (i.bindBufferBase(i.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.impl.bufferId),
        i.beginTransformFeedback(i.POINTS));
        const g = this.glPrimitive[e.type]
          , v = e.count;
        if (e.indexed) {
            const x = this.indexBuffer
              , S = x.impl.glFormat
              , w = e.base * x.bytesPerIndex;
            t > 0 ? i.drawElementsInstanced(g, v, S, w, t) : i.drawElements(g, v, S, w)
        } else {
            const x = e.base;
            t > 0 ? i.drawArraysInstanced(g, x, v, t) : i.drawArrays(g, x, v)
        }
        this.isWebGL2 && this.transformFeedbackBuffer && (i.endTransformFeedback(),
        i.bindBufferBase(i.TRANSFORM_FEEDBACK_BUFFER, 0, null)),
        this._drawCallsPerFrame++
    }
    clear(e) {
        var t;
        const s = this.defaultClearOptions;
        e = e || s;
        const i = (t = e.flags) != null ? t : s.flags;
        if (i !== 0) {
            const l = this.gl;
            if (i & Oo) {
                var n;
                const c = (n = e.color) != null ? n : s.color
                  , d = c[0]
                  , h = c[1]
                  , u = c[2]
                  , f = c[3]
                  , p = this.clearColor;
                (d !== p.r || h !== p.g || u !== p.b || f !== p.a) && (this.gl.clearColor(d, h, u, f),
                this.clearColor.set(d, h, u, f)),
                this.setBlendState(ft.NOBLEND)
            }
            if (i & Fo) {
                var r;
                const c = (r = e.depth) != null ? r : s.depth;
                c !== this.clearDepth && (this.gl.clearDepth(c),
                this.clearDepth = c),
                this.setDepthState($t.WRITEDEPTH)
            }
            if (i & fh) {
                var o;
                const c = (o = e.stencil) != null ? o : s.stencil;
                c !== this.clearStencil && (this.gl.clearStencil(c),
                this.clearStencil = c)
            }
            l.clear(this.glClearFlag[i])
        }
    }
    submit() {
        this.gl.flush()
    }
    readPixels(e, t, s, i, n) {
        const r = this.gl;
        r.readPixels(e, t, s, i, r.RGBA, r.UNSIGNED_BYTE, n)
    }
    async readPixelsAsync(e, t, s, i, n) {
        var r, o, l;
        const c = this.gl;
        if (!this.isWebGL2) {
            this.readPixels(e, t, s, i, n);
            return
        }
        const d = (_, m) => {
            const g = c.fenceSync(c.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return this.submit(),
            new Promise( (v, x) => {
                function S() {
                    const w = c.clientWaitSync(g, _, 0);
                    w === c.WAIT_FAILED ? (c.deleteSync(g),
                    x(new Error("webgl clientWaitSync sync failed"))) : w === c.TIMEOUT_EXPIRED ? setTimeout(S, m) : (c.deleteSync(g),
                    v())
                }
                S()
            }
            )
        }
          , h = (r = this.renderTarget.colorBuffer) == null ? void 0 : r.impl
          , u = (o = h == null ? void 0 : h._glFormat) != null ? o : c.RGBA
          , f = (l = h == null ? void 0 : h._glPixelType) != null ? l : c.UNSIGNED_BYTE
          , p = c.createBuffer();
        c.bindBuffer(c.PIXEL_PACK_BUFFER, p),
        c.bufferData(c.PIXEL_PACK_BUFFER, n.byteLength, c.STREAM_READ),
        c.readPixels(e, t, s, i, u, f, 0),
        c.bindBuffer(c.PIXEL_PACK_BUFFER, null),
        await d(0, 20),
        c.bindBuffer(c.PIXEL_PACK_BUFFER, p),
        c.getBufferSubData(c.PIXEL_PACK_BUFFER, 0, n),
        c.bindBuffer(c.PIXEL_PACK_BUFFER, null),
        c.deleteBuffer(p)
    }
    setAlphaToCoverage(e) {
        this.isWebGL1 || this.alphaToCoverage !== e && (this.alphaToCoverage = e,
        e ? this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE) : this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE))
    }
    setTransformFeedbackBuffer(e) {
        if (this.transformFeedbackBuffer !== e && (this.transformFeedbackBuffer = e,
        this.isWebGL2)) {
            const t = this.gl;
            e ? (this.feedback || (this.feedback = t.createTransformFeedback()),
            t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, this.feedback)) : t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, null)
        }
    }
    setRaster(e) {
        this.raster !== e && (this.raster = e,
        this.isWebGL2 && (e ? this.gl.disable(this.gl.RASTERIZER_DISCARD) : this.gl.enable(this.gl.RASTERIZER_DISCARD)))
    }
    setStencilTest(e) {
        if (this.stencil !== e) {
            const t = this.gl;
            e ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST),
            this.stencil = e
        }
    }
    setStencilFunc(e, t, s) {
        (this.stencilFuncFront !== e || this.stencilRefFront !== t || this.stencilMaskFront !== s || this.stencilFuncBack !== e || this.stencilRefBack !== t || this.stencilMaskBack !== s) && (this.gl.stencilFunc(this.glComparison[e], t, s),
        this.stencilFuncFront = this.stencilFuncBack = e,
        this.stencilRefFront = this.stencilRefBack = t,
        this.stencilMaskFront = this.stencilMaskBack = s)
    }
    setStencilFuncFront(e, t, s) {
        if (this.stencilFuncFront !== e || this.stencilRefFront !== t || this.stencilMaskFront !== s) {
            const i = this.gl;
            i.stencilFuncSeparate(i.FRONT, this.glComparison[e], t, s),
            this.stencilFuncFront = e,
            this.stencilRefFront = t,
            this.stencilMaskFront = s
        }
    }
    setStencilFuncBack(e, t, s) {
        if (this.stencilFuncBack !== e || this.stencilRefBack !== t || this.stencilMaskBack !== s) {
            const i = this.gl;
            i.stencilFuncSeparate(i.BACK, this.glComparison[e], t, s),
            this.stencilFuncBack = e,
            this.stencilRefBack = t,
            this.stencilMaskBack = s
        }
    }
    setStencilOperation(e, t, s, i) {
        (this.stencilFailFront !== e || this.stencilZfailFront !== t || this.stencilZpassFront !== s || this.stencilFailBack !== e || this.stencilZfailBack !== t || this.stencilZpassBack !== s) && (this.gl.stencilOp(this.glStencilOp[e], this.glStencilOp[t], this.glStencilOp[s]),
        this.stencilFailFront = this.stencilFailBack = e,
        this.stencilZfailFront = this.stencilZfailBack = t,
        this.stencilZpassFront = this.stencilZpassBack = s),
        (this.stencilWriteMaskFront !== i || this.stencilWriteMaskBack !== i) && (this.gl.stencilMask(i),
        this.stencilWriteMaskFront = i,
        this.stencilWriteMaskBack = i)
    }
    setStencilOperationFront(e, t, s, i) {
        (this.stencilFailFront !== e || this.stencilZfailFront !== t || this.stencilZpassFront !== s) && (this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[e], this.glStencilOp[t], this.glStencilOp[s]),
        this.stencilFailFront = e,
        this.stencilZfailFront = t,
        this.stencilZpassFront = s),
        this.stencilWriteMaskFront !== i && (this.gl.stencilMaskSeparate(this.gl.FRONT, i),
        this.stencilWriteMaskFront = i)
    }
    setStencilOperationBack(e, t, s, i) {
        (this.stencilFailBack !== e || this.stencilZfailBack !== t || this.stencilZpassBack !== s) && (this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[e], this.glStencilOp[t], this.glStencilOp[s]),
        this.stencilFailBack = e,
        this.stencilZfailBack = t,
        this.stencilZpassBack = s),
        this.stencilWriteMaskBack !== i && (this.gl.stencilMaskSeparate(this.gl.BACK, i),
        this.stencilWriteMaskBack = i)
    }
    setBlendState(e) {
        const t = this.blendState;
        if (!t.equals(e)) {
            const s = this.gl
              , {blend: i, colorOp: n, alphaOp: r, colorSrcFactor: o, colorDstFactor: l, alphaSrcFactor: c, alphaDstFactor: d} = e;
            if (t.blend !== i && (i ? s.enable(s.BLEND) : s.disable(s.BLEND)),
            t.colorOp !== n || t.alphaOp !== r) {
                const h = this.glBlendEquation;
                s.blendEquationSeparate(h[n], h[r])
            }
            (t.colorSrcFactor !== o || t.colorDstFactor !== l || t.alphaSrcFactor !== c || t.alphaDstFactor !== d) && s.blendFuncSeparate(this.glBlendFunctionColor[o], this.glBlendFunctionColor[l], this.glBlendFunctionAlpha[c], this.glBlendFunctionAlpha[d]),
            t.allWrite !== e.allWrite && this.gl.colorMask(e.redWrite, e.greenWrite, e.blueWrite, e.alphaWrite),
            t.copy(e)
        }
    }
    setBlendColor(e, t, s, i) {
        const n = this.blendColor;
        (e !== n.r || t !== n.g || s !== n.b || i !== n.a) && (this.gl.blendColor(e, t, s, i),
        n.set(e, t, s, i))
    }
    setStencilState(e, t) {
        if (e || t)
            if (this.setStencilTest(!0),
            e === t)
                this.setStencilFunc(e.func, e.ref, e.readMask),
                this.setStencilOperation(e.fail, e.zfail, e.zpass, e.writeMask);
            else {
                var s, i;
                (s = e) != null || (e = qs.DEFAULT),
                this.setStencilFuncFront(e.func, e.ref, e.readMask),
                this.setStencilOperationFront(e.fail, e.zfail, e.zpass, e.writeMask),
                (i = t) != null || (t = qs.DEFAULT),
                this.setStencilFuncBack(t.func, t.ref, t.readMask),
                this.setStencilOperationBack(t.fail, t.zfail, t.zpass, t.writeMask)
            }
        else
            this.setStencilTest(!1)
    }
    setDepthState(e) {
        const t = this.depthState;
        if (!t.equals(e)) {
            const s = this.gl
              , i = e.write;
            t.write !== i && s.depthMask(i);
            let {func: n, test: r} = e;
            !r && i && (r = !0,
            n = Mn),
            t.func !== n && s.depthFunc(this.glComparison[n]),
            t.test !== r && (r ? s.enable(s.DEPTH_TEST) : s.disable(s.DEPTH_TEST));
            const {depthBias: o, depthBiasSlope: l} = e;
            o || l ? (this.depthBiasEnabled || (this.depthBiasEnabled = !0,
            this.gl.enable(this.gl.POLYGON_OFFSET_FILL)),
            s.polygonOffset(l, o)) : this.depthBiasEnabled && (this.depthBiasEnabled = !1,
            this.gl.disable(this.gl.POLYGON_OFFSET_FILL)),
            t.copy(e)
        }
    }
    setCullMode(e) {
        if (this.cullMode !== e) {
            if (e === bt)
                this.gl.disable(this.gl.CULL_FACE);
            else {
                this.cullMode === bt && this.gl.enable(this.gl.CULL_FACE);
                const t = this.glCull[e];
                this.cullFace !== t && (this.gl.cullFace(t),
                this.cullFace = t)
            }
            this.cullMode = e
        }
    }
    setShader(e) {
        if (e !== this.shader) {
            if (e.failed)
                return !1;
            if (!e.ready && !e.impl.finalize(this, e))
                return e.failed = !0,
                !1;
            this.shader = e,
            this.gl.useProgram(e.impl.glProgram),
            this.attributesInvalidated = !0
        }
        return !0
    }
    clearVertexArrayObjectCache() {
        const e = this.gl;
        this._vaoMap.forEach( (t, s, i) => {
            e.deleteVertexArray(t)
        }
        ),
        this._vaoMap.clear()
    }
    set fullscreen(e) {
        e ? this.gl.canvas.requestFullscreen() : document.exitFullscreen()
    }
    get fullscreen() {
        return !!document.fullscreenElement
    }
    get textureFloatHighPrecision() {
        return this._textureFloatHighPrecision === void 0 && (this._textureFloatHighPrecision = gE(this)),
        this._textureFloatHighPrecision
    }
    get textureHalfFloatUpdatable() {
        return this._textureHalfFloatUpdatable === void 0 && (this.isWebGL2 ? this._textureHalfFloatUpdatable = !0 : this._textureHalfFloatUpdatable = _E(this.gl, this.extTextureHalfFloat.HALF_FLOAT_OES)),
        this._textureHalfFloatUpdatable
    }
}
class yE {
    unlock(e) {}
}
class vE {
    destroy(e) {}
    init(e, t) {}
    loseContext() {}
    resolve(e, t, s, i) {}
}
class SE {
    destroy(e) {}
    loseContext() {}
    restoreContext(e, t) {}
}
class xE {
    destroy(e) {}
    propertyChanged(e) {}
    loseContext() {}
}
class wE {
    destroy(e) {}
    unlock(e) {}
}
class bE extends br {
    constructor(e, t={}) {
        super(e, t),
        t = this.initOptions,
        this.isNull = !0,
        this._deviceType = Ld,
        this.samples = 1
    }
    destroy() {
        super.destroy()
    }
    initDeviceCaps() {
        this.disableParticleSystem = !0,
        this.precision = "highp",
        this.maxPrecision = "highp",
        this.maxSamples = 4,
        this.maxTextures = 16,
        this.maxTextureSize = 4096,
        this.maxCubeMapSize = 4096,
        this.maxVolumeSize = 4096,
        this.maxColorAttachments = 8,
        this.maxPixelRatio = 1,
        this.maxAnisotropy = 16,
        this.supportsInstancing = !0,
        this.supportsUniformBuffers = !1,
        this.supportsVolumeTextures = !0,
        this.supportsBoneTextures = !0,
        this.supportsMorphTargetTexturesCore = !0,
        this.supportsAreaLights = !0,
        this.supportsDepthShadow = !0,
        this.supportsGpuParticles = !1,
        this.supportsMrt = !0,
        this.extUintElement = !0,
        this.extTextureFloat = !0,
        this.textureFloatRenderable = !0,
        this.extTextureHalfFloat = !0,
        this.textureHalfFloatRenderable = !0,
        this.textureHalfFloatUpdatable = !0,
        this.boneLimit = 1024,
        this.supportsImageBitmap = !0,
        this.extStandardDerivatives = !0,
        this.extBlendMinmax = !0,
        this.areaLightLutFormat = ve,
        this.supportsTextureFetch = !0
    }
    postInit() {
        super.postInit()
    }
    frameStart() {
        super.frameStart()
    }
    frameEnd() {
        super.frameEnd()
    }
    updateBegin() {}
    updateEnd() {}
    readPixels(e, t, s, i, n) {}
    createVertexBufferImpl(e, t) {
        return new wE(e,t)
    }
    createIndexBufferImpl(e) {
        return new yE(e)
    }
    createShaderImpl(e) {
        return new SE(e)
    }
    createTextureImpl(e) {
        return new xE(e)
    }
    createRenderTargetImpl(e) {
        return new vE(e)
    }
    draw(e, t=1, s) {}
    setShader(e) {
        return !0
    }
    setBlendState(e) {}
    setDepthState(e) {}
    setStencilState(e, t) {}
    setBlendColor(e, t, s, i) {}
    setCullMode(e) {}
    setAlphaToCoverage(e) {}
    initializeContextCaches() {
        super.initializeContextCaches()
    }
    clear(e) {}
    setViewport(e, t, s, i) {}
    setScissor(e, t, s, i) {}
    copyRenderTarget(e, t, s, i) {
        return !0
    }
}
function TE(a, e={}) {
    var t;
    const s = (t = e.deviceTypes) != null ? t : [];
    if (s.includes(po) || s.push(po),
    s.includes(eh) || s.push(eh),
    s.includes(Ld) || s.push(Ld),
    Le.browser && navigator.xr) {
        var i;
        (i = e.xrCompatible) != null || (e.xrCompatible = !0)
    }
    const n = [];
    for (let o = 0; o < s.length; o++) {
        var r;
        const l = s[o];
        l === kS && (r = window) != null && (r = r.navigator) != null && r.gpu && n.push( () => new ZC(a,e).initWebGpu(e.glslangUrl, e.twgslUrl)),
        (l === eh || l === po) && n.push( () => (e.preferWebGl2 = l === po,
        new YS(a,e))),
        l === Ld && n.push( () => new bE(a,e))
    }
    return new Promise( (o, l) => {
        let c = 0;
        const d = () => {
            c >= n.length ? l(new Error("Failed to create a graphics device")) : Promise.resolve(n[c++]()).then(h => {
                h ? o(h) : d()
            }
            ).catch(h => {
                console.log(h),
                d()
            }
            )
        }
        ;
        d()
    }
    )
}
let CE = 0;
class _r {
    constructor(e, t, s, i=es, n) {
        this.device = e,
        this.format = t,
        this.numIndices = s,
        this.usage = i,
        this.id = CE++,
        this.impl = e.createIndexBufferImpl(this);
        const r = jT[t];
        this.bytesPerIndex = r,
        this.numBytes = this.numIndices * r,
        n ? this.setData(n) : this.storage = new ArrayBuffer(this.numBytes),
        this.adjustVramSizeTracking(e._vram, this.numBytes),
        this.device.buffers.push(this)
    }
    destroy() {
        const e = this.device
          , t = e.buffers.indexOf(this);
        t !== -1 && e.buffers.splice(t, 1),
        this.device.indexBuffer === this && (this.device.indexBuffer = null),
        this.impl.initialized && (this.impl.destroy(e),
        this.adjustVramSizeTracking(e._vram, -this.storage.byteLength))
    }
    adjustVramSizeTracking(e, t) {
        e.ib += t
    }
    loseContext() {
        this.impl.loseContext()
    }
    getFormat() {
        return this.format
    }
    getNumIndices() {
        return this.numIndices
    }
    lock() {
        return this.storage
    }
    unlock() {
        this.impl.unlock(this)
    }
    setData(e) {
        return e.byteLength !== this.numBytes ? !1 : (this.storage = e,
        this.unlock(),
        !0)
    }
    _lockTypedArray() {
        const e = this.lock();
        return this.format === fr ? new Uint32Array(e) : this.format === js ? new Uint16Array(e) : new Uint8Array(e)
    }
    writeData(e, t) {
        const s = this._lockTypedArray();
        if (e.length > t)
            if (ArrayBuffer.isView(e))
                e = e.subarray(0, t),
                s.set(e);
            else
                for (let i = 0; i < t; i++)
                    s[i] = e[i];
        else
            s.set(e);
        this.unlock()
    }
    readData(e) {
        const t = this._lockTypedArray()
          , s = this.numIndices;
        if (ArrayBuffer.isView(e))
            e.set(t);
        else {
            e.length = 0;
            for (let i = 0; i < s; i++)
                e[i] = t[i]
        }
        return s
    }
}
class EE {
    constructor() {
        this.clearValue = new z(0,0,0,1),
        this.clear = !1,
        this.store = !1,
        this.resolve = !0,
        this.mipmaps = !1
    }
}
class AE {
    constructor() {
        this.clearDepthValue = 1,
        this.clearStencilValue = 0,
        this.clearDepth = !1,
        this.clearStencil = !1,
        this.storeDepth = !1,
        this.storeStencil = !1
    }
}
class Js {
    get colorOps() {
        return this.colorArrayOps[0]
    }
    constructor(e) {
        this.name = "",
        this.device = void 0,
        this._enabled = !0,
        this.executeEnabled = !0,
        this.renderTarget = void 0,
        this.options = void 0,
        this.samples = 0,
        this.colorArrayOps = [],
        this.depthStencilOps = void 0,
        this.requiresCubemaps = !0,
        this.fullSizeClearRect = !0,
        this.beforePasses = [],
        this.afterPasses = [],
        this.device = e
    }
    init(e=null, t=null) {
        var s;
        if (this.options = t,
        t) {
            var i, n;
            this.options.scaleX = (i = this.options.scaleX) != null ? i : 1,
            this.options.scaleY = (n = this.options.scaleY) != null ? n : 1
        }
        this.renderTarget = e,
        this.samples = Math.max(this.renderTarget ? this.renderTarget.samples : this.device.samples, 1),
        this.depthStencilOps = new AE;
        const r = e ? (s = e._colorBuffers) == null ? void 0 : s.length : 1;
        this.colorArrayOps.length = 0;
        for (let l = 0; l < r; l++) {
            var o;
            const c = new EE;
            this.colorArrayOps[l] = c,
            this.samples === 1 && (c.store = !0,
            c.resolve = !1),
            (o = this.renderTarget) != null && (o = o._colorBuffers) != null && o[l].mipmaps && (c.mipmaps = !0)
        }
        this.postInit()
    }
    destroy() {}
    postInit() {}
    frameUpdate() {
        if (this.options && this.renderTarget) {
            var e;
            const t = (e = this.options.resizeSource) != null ? e : this.device.backBuffer
              , s = Math.floor(t.width * this.options.scaleX)
              , i = Math.floor(t.height * this.options.scaleY);
            this.renderTarget.resize(s, i)
        }
    }
    before() {}
    execute() {}
    after() {}
    onEnable() {}
    onDisable() {}
    set enabled(e) {
        this._enabled !== e && (this._enabled = e,
        e ? this.onEnable() : this.onDisable())
    }
    get enabled() {
        return this._enabled
    }
    setClearColor(e) {
        const t = this.colorArrayOps.length;
        for (let s = 0; s < t; s++) {
            const i = this.colorArrayOps[s];
            e && i.clearValue.copy(e),
            i.clear = !!e
        }
    }
    setClearDepth(e) {
        e && (this.depthStencilOps.clearDepthValue = e),
        this.depthStencilOps.clearDepth = e !== void 0
    }
    setClearStencil(e) {
        e && (this.depthStencilOps.clearStencilValue = e),
        this.depthStencilOps.clearStencil = e !== void 0
    }
    render() {
        if (this.enabled) {
            const e = this.device
              , t = this.renderTarget !== void 0;
            this.before(),
            this.executeEnabled && (t && e.startRenderPass(this),
            this.execute(),
            t && e.endRenderPass(this)),
            this.after(),
            e.renderPassIndex++
        }
    }
}
class Aa {
    constructor(e, t, s) {
        this.uniformFormats = [],
        this.bindGroupFormats = [],
        this.vertexFormat = void 0,
        this.uniformFormats[gm] = e,
        this.bindGroupFormats[gm] = t,
        this.vertexFormat = s
    }
    hasUniform(e) {
        for (let t = 0; t < this.uniformFormats.length; t++) {
            const s = this.uniformFormats[t];
            if (s != null && s.get(e))
                return !0
        }
        return !1
    }
    hasTexture(e) {
        for (let t = 0; t < this.bindGroupFormats.length; t++) {
            const s = this.bindGroupFormats[t];
            if (s != null && s.getTexture(e))
                return !0
        }
        return !1
    }
    getVertexElement(e) {
        var t;
        return (t = this.vertexFormat) == null ? void 0 : t.elements.find(s => s.name === e)
    }
    generateKey(e) {
        let t = JSON.stringify(this.uniformFormats) + JSON.stringify(this.bindGroupFormats);
        if (e.isWebGPU) {
            var s;
            t += (s = this.vertexFormat) == null ? void 0 : s.shaderProcessingHashString
        }
        return t
    }
}
function ME(a) {
    this.array[this.index] = a
}
function PE(a, e) {
    this.array[this.index] = a,
    this.array[this.index + 1] = e
}
function RE(a, e, t) {
    this.array[this.index] = a,
    this.array[this.index + 1] = e,
    this.array[this.index + 2] = t
}
function IE(a, e, t, s) {
    this.array[this.index] = a,
    this.array[this.index + 1] = e,
    this.array[this.index + 2] = t,
    this.array[this.index + 3] = s
}
function LE(a, e, t) {
    this.array[a] = e[t]
}
function DE(a, e, t) {
    this.array[a] = e[t],
    this.array[a + 1] = e[t + 1]
}
function OE(a, e, t) {
    this.array[a] = e[t],
    this.array[a + 1] = e[t + 1],
    this.array[a + 2] = e[t + 2]
}
function FE(a, e, t) {
    this.array[a] = e[t],
    this.array[a + 1] = e[t + 1],
    this.array[a + 2] = e[t + 2],
    this.array[a + 3] = e[t + 3]
}
function BE(a, e, t) {
    e[t] = this.array[a]
}
function kE(a, e, t) {
    e[t] = this.array[a],
    e[t + 1] = this.array[a + 1]
}
function NE(a, e, t) {
    e[t] = this.array[a],
    e[t + 1] = this.array[a + 1],
    e[t + 2] = this.array[a + 2]
}
function UE(a, e, t) {
    e[t] = this.array[a],
    e[t + 1] = this.array[a + 1],
    e[t + 2] = this.array[a + 2],
    e[t + 3] = this.array[a + 3]
}
class zE {
    constructor(e, t, s) {
        switch (this.index = 0,
        this.numComponents = t.numComponents,
        s.interleaved ? this.array = new bo[t.dataType](e,t.offset) : this.array = new bo[t.dataType](e,t.offset,s.vertexCount * t.numComponents),
        this.stride = t.stride / this.array.constructor.BYTES_PER_ELEMENT,
        t.numComponents) {
        case 1:
            this.set = ME,
            this.getToArray = BE,
            this.setFromArray = LE;
            break;
        case 2:
            this.set = PE,
            this.getToArray = kE,
            this.setFromArray = DE;
            break;
        case 3:
            this.set = RE,
            this.getToArray = NE,
            this.setFromArray = OE;
            break;
        case 4:
            this.set = IE,
            this.getToArray = UE,
            this.setFromArray = FE;
            break
        }
    }
    get(e) {
        return this.array[this.index + e]
    }
    set(e, t, s, i) {}
    getToArray(e, t, s) {}
    setFromArray(e, t, s) {}
}
class sh {
    constructor(e) {
        this.vertexBuffer = e,
        this.vertexFormatSize = e.getFormat().size,
        this.buffer = this.vertexBuffer.lock(),
        this.accessors = [],
        this.element = {};
        const t = this.vertexBuffer.getFormat();
        for (let s = 0; s < t.elements.length; s++) {
            const i = t.elements[s];
            this.accessors[s] = new zE(this.buffer,i,t),
            this.element[i.name] = this.accessors[s]
        }
    }
    next(e=1) {
        let t = 0;
        const s = this.accessors
          , i = this.accessors.length;
        for (; t < i; ) {
            const n = s[t++];
            n.index += e * n.stride
        }
    }
    end() {
        this.vertexBuffer.unlock()
    }
    writeData(e, t, s) {
        const i = this.element[e];
        if (i) {
            s > this.vertexBuffer.numVertices && (s = this.vertexBuffer.numVertices);
            const n = i.numComponents;
            if (this.vertexBuffer.getFormat().interleaved) {
                let r = 0;
                for (let o = 0; o < s; o++)
                    i.setFromArray(r, t, o * n),
                    r += i.stride
            } else if (t.length > s * n) {
                const r = s * n;
                if (ArrayBuffer.isView(t))
                    t = t.subarray(0, r),
                    i.array.set(t);
                else
                    for (let o = 0; o < r; o++)
                        i.array[o] = t[o]
            } else
                i.array.set(t)
        }
    }
    readData(e, t) {
        const s = this.element[e];
        let i = 0;
        if (s) {
            i = this.vertexBuffer.numVertices;
            let n;
            const r = s.numComponents;
            if (this.vertexBuffer.getFormat().interleaved) {
                Array.isArray(t) && (t.length = 0),
                s.index = 0;
                let o = 0;
                for (n = 0; n < i; n++)
                    s.getToArray(o, t, n * r),
                    o += s.stride
            } else if (ArrayBuffer.isView(t))
                t.set(s.array);
            else {
                t.length = 0;
                const o = i * r;
                for (n = 0; n < o; n++)
                    t[n] = s.array[n]
            }
        }
        return i
    }
}
const $o = "mousedown"
  , qo = "mousemove"
  , wh = "mouseup"
  , bh = "mousewheel"
  , Jd = "touchstart"
  , eu = "touchend"
  , tu = "touchmove"
  , su = "touchcancel"
  , VE = -1
  , Fy = 0
  , By = 1
  , ky = 2;
class GE {
    constructor(e, t) {
        t ? (this.key = t.keyCode,
        this.element = t.target,
        this.event = t) : (this.key = null,
        this.element = null,
        this.event = null)
    }
}
const kc = new GE;
function jf(a) {
    return kc.key = a.keyCode,
    kc.element = a.target,
    kc.event = a,
    kc
}
function Nc(a) {
    return typeof a == "string" ? a.toUpperCase().charCodeAt(0) : a
}
const HE = {
    9: "Tab",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    27: "Escape",
    37: "Left",
    38: "Up",
    39: "Right",
    40: "Down",
    46: "Delete",
    91: "Win"
};
class G_ extends fe {
    constructor(e, t={}) {
        super(),
        this._element = null,
        this._keyDownHandler = this._handleKeyDown.bind(this),
        this._keyUpHandler = this._handleKeyUp.bind(this),
        this._keyPressHandler = this._handleKeyPress.bind(this),
        this._visibilityChangeHandler = this._handleVisibilityChange.bind(this),
        this._windowBlurHandler = this._handleWindowBlur.bind(this),
        this._keymap = {},
        this._lastmap = {},
        e && this.attach(e),
        this.preventDefault = t.preventDefault || !1,
        this.stopPropagation = t.stopPropagation || !1
    }
    attach(e) {
        this._element && this.detach(),
        this._element = e,
        this._element.addEventListener("keydown", this._keyDownHandler, !1),
        this._element.addEventListener("keypress", this._keyPressHandler, !1),
        this._element.addEventListener("keyup", this._keyUpHandler, !1),
        document.addEventListener("visibilitychange", this._visibilityChangeHandler, !1),
        window.addEventListener("blur", this._windowBlurHandler, !1)
    }
    detach() {
        this._element && (this._element.removeEventListener("keydown", this._keyDownHandler),
        this._element.removeEventListener("keypress", this._keyPressHandler),
        this._element.removeEventListener("keyup", this._keyUpHandler),
        this._element = null,
        document.removeEventListener("visibilitychange", this._visibilityChangeHandler, !1),
        window.removeEventListener("blur", this._windowBlurHandler, !1))
    }
    toKeyIdentifier(e) {
        e = Nc(e);
        const t = HE[e.toString()];
        if (t)
            return t;
        let s = e.toString(16).toUpperCase();
        const i = s.length;
        for (let n = 0; n < 4 - i; n++)
            s = "0" + s;
        return "U+" + s
    }
    _handleKeyDown(e) {
        const t = e.keyCode || e.charCode;
        if (t === void 0)
            return;
        const s = this.toKeyIdentifier(t);
        this._keymap[s] = !0,
        this.fire("keydown", jf(e)),
        this.preventDefault && e.preventDefault(),
        this.stopPropagation && e.stopPropagation()
    }
    _handleKeyUp(e) {
        const t = e.keyCode || e.charCode;
        if (t === void 0)
            return;
        const s = this.toKeyIdentifier(t);
        delete this._keymap[s],
        this.fire("keyup", jf(e)),
        this.preventDefault && e.preventDefault(),
        this.stopPropagation && e.stopPropagation()
    }
    _handleKeyPress(e) {
        this.fire("keypress", jf(e)),
        this.preventDefault && e.preventDefault(),
        this.stopPropagation && e.stopPropagation()
    }
    _handleVisibilityChange() {
        document.visibilityState === "hidden" && this._handleWindowBlur()
    }
    _handleWindowBlur() {
        this._keymap = {},
        this._lastmap = {}
    }
    update() {
        for (const e in this._lastmap)
            delete this._lastmap[e];
        for (const e in this._keymap)
            this._keymap.hasOwnProperty(e) && (this._lastmap[e] = this._keymap[e])
    }
    isPressed(e) {
        const t = Nc(e)
          , s = this.toKeyIdentifier(t);
        return !!this._keymap[s]
    }
    wasPressed(e) {
        const t = Nc(e)
          , s = this.toKeyIdentifier(t);
        return !!this._keymap[s] && !this._lastmap[s]
    }
    wasReleased(e) {
        const t = Nc(e)
          , s = this.toKeyIdentifier(t);
        return !this._keymap[s] && !!this._lastmap[s]
    }
}
G_.EVENT_KEYDOWN = "keydown";
G_.EVENT_KEYUP = "keyup";
function bm() {
    return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement)
}
class mo {
    constructor(e, t) {
        let s = {
            x: 0,
            y: 0
        };
        if (t) {
            if (t instanceof mo)
                throw Error("Expected MouseEvent");
            s = e._getTargetCoords(t)
        } else
            t = {};
        if (s)
            this.x = s.x,
            this.y = s.y;
        else if (bm())
            this.x = 0,
            this.y = 0;
        else
            return;
        this.wheelDelta = 0,
        t.type === "wheel" && (t.deltaY > 0 ? this.wheelDelta = 1 : t.deltaY < 0 && (this.wheelDelta = -1)),
        bm() ? (this.dx = t.movementX || t.webkitMovementX || t.mozMovementX || 0,
        this.dy = t.movementY || t.webkitMovementY || t.mozMovementY || 0) : (this.dx = this.x - e._lastX,
        this.dy = this.y - e._lastY),
        t.type === "mousedown" || t.type === "mouseup" ? this.button = t.button : this.button = VE,
        this.buttons = e._buttons.slice(0),
        this.element = t.target,
        this.ctrlKey = t.ctrlKey || !1,
        this.altKey = t.altKey || !1,
        this.shiftKey = t.shiftKey || !1,
        this.metaKey = t.metaKey || !1,
        this.event = t
    }
}
class gr extends fe {
    constructor(e) {
        super(),
        this._lastX = 0,
        this._lastY = 0,
        this._buttons = [!1, !1, !1],
        this._lastbuttons = [!1, !1, !1],
        this._upHandler = this._handleUp.bind(this),
        this._downHandler = this._handleDown.bind(this),
        this._moveHandler = this._handleMove.bind(this),
        this._wheelHandler = this._handleWheel.bind(this),
        this._contextMenuHandler = t => {
            t.preventDefault()
        }
        ,
        this._target = null,
        this._attached = !1,
        this.attach(e)
    }
    static isPointerLocked() {
        return bm()
    }
    attach(e) {
        if (this._target = e,
        this._attached)
            return;
        this._attached = !0;
        const t = Le.passiveEvents ? {
            passive: !1
        } : !1;
        window.addEventListener("mouseup", this._upHandler, t),
        window.addEventListener("mousedown", this._downHandler, t),
        window.addEventListener("mousemove", this._moveHandler, t),
        window.addEventListener("wheel", this._wheelHandler, t)
    }
    detach() {
        if (!this._attached)
            return;
        this._attached = !1,
        this._target = null;
        const e = Le.passiveEvents ? {
            passive: !1
        } : !1;
        window.removeEventListener("mouseup", this._upHandler, e),
        window.removeEventListener("mousedown", this._downHandler, e),
        window.removeEventListener("mousemove", this._moveHandler, e),
        window.removeEventListener("wheel", this._wheelHandler, e)
    }
    disableContextMenu() {
        this._target && this._target.addEventListener("contextmenu", this._contextMenuHandler)
    }
    enableContextMenu() {
        this._target && this._target.removeEventListener("contextmenu", this._contextMenuHandler)
    }
    enablePointerLock(e, t) {
        if (!document.body.requestPointerLock) {
            t && t();
            return
        }
        const s = () => {
            e(),
            document.removeEventListener("pointerlockchange", s)
        }
          , i = () => {
            t(),
            document.removeEventListener("pointerlockerror", i)
        }
        ;
        e && document.addEventListener("pointerlockchange", s, !1),
        t && document.addEventListener("pointerlockerror", i, !1),
        document.body.requestPointerLock()
    }
    disablePointerLock(e) {
        if (!document.exitPointerLock)
            return;
        const t = () => {
            e(),
            document.removeEventListener("pointerlockchange", t)
        }
        ;
        e && document.addEventListener("pointerlockchange", t, !1),
        document.exitPointerLock()
    }
    update() {
        this._lastbuttons[0] = this._buttons[0],
        this._lastbuttons[1] = this._buttons[1],
        this._lastbuttons[2] = this._buttons[2]
    }
    isPressed(e) {
        return this._buttons[e]
    }
    wasPressed(e) {
        return this._buttons[e] && !this._lastbuttons[e]
    }
    wasReleased(e) {
        return !this._buttons[e] && this._lastbuttons[e]
    }
    _handleUp(e) {
        this._buttons[e.button] = !1;
        const t = new mo(this,e);
        t.event && this.fire(wh, t)
    }
    _handleDown(e) {
        this._buttons[e.button] = !0;
        const t = new mo(this,e);
        t.event && this.fire($o, t)
    }
    _handleMove(e) {
        const t = new mo(this,e);
        t.event && (this.fire(qo, t),
        this._lastX = t.x,
        this._lastY = t.y)
    }
    _handleWheel(e) {
        const t = new mo(this,e);
        t.event && this.fire(bh, t)
    }
    _getTargetCoords(e) {
        const t = this._target.getBoundingClientRect()
          , s = Math.floor(t.left)
          , i = Math.floor(t.top);
        return e.clientX < s || e.clientX >= s + this._target.clientWidth || e.clientY < i || e.clientY >= i + this._target.clientHeight ? null : {
            x: e.clientX - s,
            y: e.clientY - i
        }
    }
}
gr.EVENT_MOUSEMOVE = qo;
gr.EVENT_MOUSEDOWN = $o;
gr.EVENT_MOUSEUP = wh;
gr.EVENT_MOUSEWHEEL = bh;
function WE(a) {
    let e = 0
      , t = 0
      , s = a.target;
    for (; !(s instanceof HTMLElement); )
        s = s.parentNode;
    let i = s;
    do
        e += i.offsetLeft - i.scrollLeft,
        t += i.offsetTop - i.scrollTop,
        i = i.offsetParent;
    while (i);
    return {
        x: a.pageX - e,
        y: a.pageY - t
    }
}
class Ny {
    constructor(e) {
        const t = WE(e);
        this.id = e.identifier,
        this.x = t.x,
        this.y = t.y,
        this.target = e.target,
        this.touch = e
    }
}
class Uc {
    constructor(e, t) {
        if (this.element = t.target,
        this.event = t,
        this.touches = [],
        this.changedTouches = [],
        t) {
            for (let s = 0, i = t.touches.length; s < i; s++)
                this.touches.push(new Ny(t.touches[s]));
            for (let s = 0, i = t.changedTouches.length; s < i; s++)
                this.changedTouches.push(new Ny(t.changedTouches[s]))
        }
    }
    getTouchById(e, t) {
        for (let s = 0, i = t.length; s < i; s++)
            if (t[s].id === e)
                return t[s];
        return null
    }
}
class XE extends fe {
    constructor(e) {
        super(),
        this._element = null,
        this._startHandler = this._handleTouchStart.bind(this),
        this._endHandler = this._handleTouchEnd.bind(this),
        this._moveHandler = this._handleTouchMove.bind(this),
        this._cancelHandler = this._handleTouchCancel.bind(this),
        this.attach(e)
    }
    attach(e) {
        this._element && this.detach(),
        this._element = e,
        this._element.addEventListener("touchstart", this._startHandler, !1),
        this._element.addEventListener("touchend", this._endHandler, !1),
        this._element.addEventListener("touchmove", this._moveHandler, !1),
        this._element.addEventListener("touchcancel", this._cancelHandler, !1)
    }
    detach() {
        this._element && (this._element.removeEventListener("touchstart", this._startHandler, !1),
        this._element.removeEventListener("touchend", this._endHandler, !1),
        this._element.removeEventListener("touchmove", this._moveHandler, !1),
        this._element.removeEventListener("touchcancel", this._cancelHandler, !1)),
        this._element = null
    }
    _handleTouchStart(e) {
        this.fire("touchstart", new Uc(this,e))
    }
    _handleTouchEnd(e) {
        this.fire("touchend", new Uc(this,e))
    }
    _handleTouchMove(e) {
        e.preventDefault(),
        this.fire("touchmove", new Uc(this,e))
    }
    _handleTouchCancel(e) {
        this.fire("touchcancel", new Uc(this,e))
    }
}
class we {
    get(e, t, s) {
        return typeof t == "function" && (s = t,
        t = {}),
        this.request("GET", e, t, s)
    }
    post(e, t, s, i) {
        return typeof s == "function" && (i = s,
        s = {}),
        s.postdata = t,
        this.request("POST", e, s, i)
    }
    put(e, t, s, i) {
        return typeof s == "function" && (i = s,
        s = {}),
        s.postdata = t,
        this.request("PUT", e, s, i)
    }
    del(e, t, s) {
        return typeof t == "function" && (s = t,
        t = {}),
        this.request("DELETE", e, t, s)
    }
    request(e, t, s, i) {
        let n, r, o, l = !1;
        if (typeof s == "function" && (i = s,
        s = {}),
        s.retry && (s = Object.assign({
            retries: 0,
            maxRetries: 5
        }, s)),
        s.callback = i,
        s.async == null && (s.async = !0),
        s.headers == null && (s.headers = {}),
        s.postdata != null)
            if (s.postdata instanceof Document)
                o = s.postdata;
            else if (s.postdata instanceof FormData)
                o = s.postdata;
            else if (s.postdata instanceof Object) {
                let d = s.headers["Content-Type"];
                switch (d === void 0 && (s.headers["Content-Type"] = we.ContentType.FORM_URLENCODED,
                d = s.headers["Content-Type"]),
                d) {
                case we.ContentType.FORM_URLENCODED:
                    {
                        o = "";
                        let h = !0;
                        for (const u in s.postdata)
                            if (s.postdata.hasOwnProperty(u)) {
                                h ? h = !1 : o += "&";
                                const f = encodeURIComponent(u)
                                  , p = encodeURIComponent(s.postdata[u]);
                                o += `${f}=${p}`
                            }
                        break
                    }
                default:
                case we.ContentType.JSON:
                    d == null && (s.headers["Content-Type"] = we.ContentType.JSON),
                    o = JSON.stringify(s.postdata);
                    break
                }
            } else
                o = s.postdata;
        if (s.cache === !1) {
            const d = Hi();
            n = new Uf(t),
            n.query ? n.query = n.query + "&ts=" + d : n.query = "ts=" + d,
            t = n.toString()
        }
        s.query && (n = new Uf(t),
        r = or(n.getQuery(), s.query),
        n.setQuery(r),
        t = n.toString());
        const c = new XMLHttpRequest;
        c.open(e, t, s.async),
        c.withCredentials = s.withCredentials !== void 0 ? s.withCredentials : !1,
        c.responseType = s.responseType || this._guessResponseType(t);
        for (const d in s.headers)
            s.headers.hasOwnProperty(d) && c.setRequestHeader(d, s.headers[d]);
        c.onreadystatechange = () => {
            this._onReadyStateChange(e, t, s, c)
        }
        ,
        c.onerror = () => {
            this._onError(e, t, s, c),
            l = !0
        }
        ;
        try {
            c.send(o)
        } catch (d) {
            l || s.error(c.status, c, d)
        }
        return c
    }
    _guessResponseType(e) {
        const t = new Uf(e)
          , s = ye.getExtension(t.path).toLowerCase();
        return we.binaryExtensions.indexOf(s) >= 0 ? we.ResponseType.ARRAY_BUFFER : s === ".json" ? we.ResponseType.JSON : s === ".xml" ? we.ResponseType.DOCUMENT : we.ResponseType.TEXT
    }
    _isBinaryContentType(e) {
        return [we.ContentType.BASIS, we.ContentType.BIN, we.ContentType.DDS, we.ContentType.GLB, we.ContentType.MP3, we.ContentType.MP4, we.ContentType.OGG, we.ContentType.OPUS, we.ContentType.WAV].indexOf(e) >= 0
    }
    _isBinaryResponseType(e) {
        return e === we.ResponseType.ARRAY_BUFFER || e === we.ResponseType.BLOB || e === we.ResponseType.JSON
    }
    _onReadyStateChange(e, t, s, i) {
        if (i.readyState === 4)
            switch (i.status) {
            case 0:
                {
                    i.responseURL && i.responseURL.startsWith("file:///") ? this._onSuccess(e, t, s, i) : this._onError(e, t, s, i);
                    break
                }
            case 200:
            case 201:
            case 206:
            case 304:
                {
                    this._onSuccess(e, t, s, i);
                    break
                }
            default:
                {
                    this._onError(e, t, s, i);
                    break
                }
            }
    }
    _onSuccess(e, t, s, i) {
        let n, r;
        const o = i.getResponseHeader("Content-Type");
        o && (r = o.split(";")[0].trim());
        try {
            this._isBinaryContentType(r) || this._isBinaryResponseType(i.responseType) ? n = i.response : r === we.ContentType.JSON || t.split("?")[0].endsWith(".json") ? n = JSON.parse(i.responseText) : i.responseType === we.ResponseType.DOCUMENT || r === we.ContentType.XML ? n = i.responseXML : n = i.responseText,
            s.callback(null, n)
        } catch (l) {
            s.callback(l)
        }
    }
    _onError(e, t, s, i) {
        if (!s.retrying)
            if (s.retry && s.retries < s.maxRetries) {
                s.retries++,
                s.retrying = !0;
                const n = W.clamp(Math.pow(2, s.retries) * we.retryDelay, 0, s.maxRetryDelay || 5e3);
                console.log(`${e}: ${t} - Error ${i.status}. Retrying in ${n} ms`),
                setTimeout( () => {
                    s.retrying = !1,
                    this.request(e, t, s, s.callback)
                }
                , n)
            } else
                s.callback(i.status === 0 ? "Network error" : i.status, null)
    }
}
we.ContentType = {
    AAC: "audio/aac",
    BASIS: "image/basis",
    BIN: "application/octet-stream",
    DDS: "image/dds",
    FORM_URLENCODED: "application/x-www-form-urlencoded",
    GIF: "image/gif",
    GLB: "model/gltf-binary",
    JPEG: "image/jpeg",
    JSON: "application/json",
    MP3: "audio/mpeg",
    MP4: "audio/mp4",
    OGG: "audio/ogg",
    OPUS: 'audio/ogg; codecs="opus"',
    PNG: "image/png",
    TEXT: "text/plain",
    WAV: "audio/x-wav",
    XML: "application/xml"
};
we.ResponseType = {
    TEXT: "text",
    ARRAY_BUFFER: "arraybuffer",
    BLOB: "blob",
    DOCUMENT: "document",
    JSON: "json"
};
we.binaryExtensions = [".model", ".wav", ".ogg", ".mp3", ".mp4", ".m4a", ".aac", ".dds", ".basis", ".glb", ".opus"];
we.retryDelay = 100;
const st = new we;
function Fn() {
    return typeof AudioContext < "u" || typeof webkitAudioContext < "u"
}
class iu {
    constructor(e, t, s={}) {
        var i, n, r;
        if (this.volume = (i = s.volume) != null ? i : 1,
        this.loop = (n = s.loop) != null ? n : !1,
        this.pitch = (r = s.pitch) != null ? r : 1,
        this.sound = t,
        this.paused = !1,
        this.suspended = !1,
        this.manager = e,
        this.source = null,
        Fn()) {
            this.startTime = 0,
            this.startOffset = 0;
            const o = e.context;
            this.gain = o.createGain()
        } else
            t.audio && (this.source = t.audio.cloneNode(!1),
            this.source.pause())
    }
    getVolume() {
        return this.volume
    }
    getLoop() {
        return this.loop
    }
    setLoop(e) {
        this.loop = e,
        this.source && (this.source.loop = e)
    }
    getPitch() {
        return this.pitch
    }
    onManagerVolumeChange() {
        this.setVolume(this.getVolume())
    }
    onManagerSuspend() {
        this.isPlaying() && !this.suspended && (this.suspended = !0,
        this.pause())
    }
    onManagerResume() {
        this.suspended && (this.suspended = !1,
        this.unpause())
    }
    play() {
        if (this.source)
            throw new Error("Call stop() before calling play()");
        this._createSource(),
        this.source && (this.startTime = this.manager.context.currentTime,
        this.source.start(0, this.startOffset % this.source.buffer.duration),
        this.setVolume(this.volume),
        this.setLoop(this.loop),
        this.setPitch(this.pitch),
        this.manager.on("volumechange", this.onManagerVolumeChange, this),
        this.manager.on("suspend", this.onManagerSuspend, this),
        this.manager.on("resume", this.onManagerResume, this),
        this.manager.suspended && this.onManagerSuspend())
    }
    pause() {
        this.source && (this.paused = !0,
        this.startOffset += this.manager.context.currentTime - this.startTime,
        this.source.stop(0),
        this.source = null)
    }
    unpause() {
        if (this.source || !this.paused) {
            console.warn("Call pause() before unpausing.");
            return
        }
        this._createSource(),
        this.source && (this.startTime = this.manager.context.currentTime,
        this.source.start(0, this.startOffset % this.source.buffer.duration),
        this.setVolume(this.volume),
        this.setLoop(this.loop),
        this.setPitch(this.pitch),
        this.paused = !1)
    }
    stop() {
        this.source && (this.source.stop(0),
        this.source = null),
        this.manager.off("volumechange", this.onManagerVolumeChange, this),
        this.manager.off("suspend", this.onManagerSuspend, this),
        this.manager.off("resume", this.onManagerResume, this)
    }
    setVolume(e) {
        e = W.clamp(e, 0, 1),
        this.volume = e,
        this.gain && (this.gain.gain.value = e * this.manager.volume)
    }
    setPitch(e) {
        this.pitch = e,
        this.source && (this.source.playbackRate.value = e)
    }
    isPlaying() {
        return !this.paused && this.source.playbackState === this.source.PLAYING_STATE
    }
    getDuration() {
        return this.source ? this.source.buffer.duration : 0
    }
    _createSource() {
        const e = this.manager.context;
        this.sound.buffer && (this.source = e.createBufferSource(),
        this.source.buffer = this.sound.buffer,
        this.source.connect(this.gain),
        this.gain.connect(e.destination),
        this.loop || (this.source.onended = this.pause.bind(this)))
    }
}
Fn() || Object.assign(iu.prototype, {
    play: function() {
        this.source && (this.paused = !1,
        this.setVolume(this.volume),
        this.setLoop(this.loop),
        this.setPitch(this.pitch),
        this.source.play()),
        this.manager.on("volumechange", this.onManagerVolumeChange, this),
        this.manager.on("suspend", this.onManagerSuspend, this),
        this.manager.on("resume", this.onManagerResume, this),
        this.manager.suspended && this.onManagerSuspend()
    },
    pause: function() {
        this.source && (this.paused = !0,
        this.source.pause())
    },
    unpause: function() {
        this.source && (this.paused = !1,
        this.source.play())
    },
    stop: function() {
        this.source && this.source.pause(),
        this.manager.off("volumechange", this.onManagerVolumeChange, this),
        this.manager.off("suspend", this.onManagerSuspend, this),
        this.manager.off("resume", this.onManagerResume, this)
    },
    setVolume: function(a) {
        a = W.clamp(a, 0, 1),
        this.volume = a,
        this.source && (this.source.volume = a * this.manager.volume)
    },
    setPitch: function(a) {
        this.pitch = a,
        this.source && (this.source.playbackRate = a)
    },
    getDuration: function() {
        return this.source && !isNaN(this.source.duration) ? this.source.duration : 0
    },
    isPlaying: function() {
        return !this.source.paused
    }
});
const jE = 1e4;
class nr extends iu {
    constructor(e, t, s) {
        super(e, t, s),
        this.position = new y,
        this.velocity = new y,
        Fn() ? this.panner = e.context.createPanner() : (this.maxDistance = jE,
        this.minDistance = 1,
        this.rollOffFactor = 1,
        this.distanceModel = Ou)
    }
    getPosition() {
        return this.position
    }
    setPosition(e) {
        this.position.copy(e);
        const t = this.panner;
        "positionX"in t ? (t.positionX.value = e.x,
        t.positionY.value = e.y,
        t.positionZ.value = e.z) : t.setPosition && t.setPosition(e.x, e.y, e.z)
    }
    getVelocity() {
        return this.velocity
    }
    setVelocity(e) {
        this.velocity.copy(e)
    }
    getMaxDistance() {
        return this.panner.maxDistance
    }
    setMaxDistance(e) {
        this.panner.maxDistance = e
    }
    getMinDistance() {
        return this.panner.refDistance
    }
    setMinDistance(e) {
        this.panner.refDistance = e
    }
    getRollOffFactor() {
        return this.panner.rolloffFactor
    }
    setRollOffFactor(e) {
        this.panner.rolloffFactor = e
    }
    getDistanceModel() {
        return this.panner.distanceModel
    }
    setDistanceModel(e) {
        this.panner.distanceModel = e
    }
    _createSource() {
        const e = this.manager.context;
        this.source = e.createBufferSource(),
        this.source.buffer = this.sound.buffer,
        this.source.connect(this.panner),
        this.panner.connect(this.gain),
        this.gain.connect(e.destination),
        this.loop || (this.source.onended = this.pause.bind(this))
    }
}
if (!Fn()) {
    let a = new y;
    const e = function(s, i, n, r, o, l) {
        a = a.sub2(s, i);
        const c = a.length();
        if (c < n)
            return 1;
        if (c > r)
            return 0;
        let d = 0;
        return l === Du ? d = 1 - o * (c - n) / (r - n) : l === Ou ? d = n / (n + o * (c - n)) : l === MS && (d = Math.pow(c / n, -o)),
        W.clamp(d, 0, 1)
    };
    Object.assign(nr.prototype, {
        setPosition: function(t) {
            if (this.position.copy(t),
            this.source) {
                const i = this.manager.listener.getPosition()
                  , n = e(i, this.position, this.minDistance, this.maxDistance, this.rollOffFactor, this.distanceModel)
                  , r = this.getVolume();
                this.source.volume = r * n
            }
        },
        getMaxDistance: function() {
            return this.maxDistance
        },
        setMaxDistance: function(t) {
            this.maxDistance = t
        },
        getMinDistance: function() {
            return this.minDistance
        },
        setMinDistance: function(t) {
            this.minDistance = t
        },
        getRollOffFactor: function() {
            return this.rollOffFactor
        },
        setRollOffFactor: function(t) {
            this.rollOffFactor = t
        },
        getDistanceModel: function() {
            return this.distanceModel
        },
        setDistanceModel: function(t) {
            this.distanceModel = t
        }
    })
}
class $E {
    constructor(e) {
        this._manager = e,
        this.position = new y,
        this.velocity = new y,
        this.orientation = new ee
    }
    getPosition() {
        return this.position
    }
    setPosition(e) {
        this.position.copy(e);
        const t = this.listener;
        t && ("positionX"in t ? (t.positionX.value = e.x,
        t.positionY.value = e.y,
        t.positionZ.value = e.z) : t.setPosition && t.setPosition(e.x, e.y, e.z))
    }
    getVelocity() {
        return this.velocity
    }
    setVelocity(e) {}
    setOrientation(e) {
        this.orientation.copy(e);
        const t = this.listener;
        if (t) {
            const s = e.data;
            "forwardX"in t ? (t.forwardX.value = -s[8],
            t.forwardY.value = -s[9],
            t.forwardZ.value = -s[10],
            t.upX.value = s[4],
            t.upY.value = s[5],
            t.upZ.value = s[6]) : t.setOrientation && t.setOrientation(-s[8], -s[9], -s[10], s[4], s[5], s[6])
        }
    }
    getOrientation() {
        return this.orientation
    }
    get listener() {
        const e = this._manager.context;
        return e ? e.listener : null
    }
}
const zc = "running"
  , Uy = ["click", "touchstart", "mousedown"];
let qE = class extends fe {
    constructor() {
        super(),
        this._context = null,
        this.AudioContext = typeof AudioContext < "u" && AudioContext || typeof webkitAudioContext < "u" && webkitAudioContext,
        this.AudioContext,
        this._unlockHandlerFunc = this._unlockHandler.bind(this),
        this._userSuspended = !1,
        this.listener = new $E(this),
        this._volume = 1
    }
    set volume(e) {
        e = W.clamp(e, 0, 1),
        this._volume = e,
        this.fire("volumechange", e)
    }
    get volume() {
        return this._volume
    }
    get suspended() {
        return this._userSuspended
    }
    get context() {
        return !this._context && this.AudioContext && (this._context = new this.AudioContext,
        this._context.state !== zc && this._registerUnlockListeners()),
        this._context
    }
    suspend() {
        this._userSuspended || (this._userSuspended = !0,
        this._context && this._context.state === zc && this._suspend())
    }
    resume() {
        this._userSuspended && (this._userSuspended = !1,
        this._context && this._context.state !== zc && this._resume())
    }
    destroy() {
        if (this.fire("destroy"),
        this._context) {
            var e;
            this._removeUnlockListeners(),
            (e = this._context) == null || e.close(),
            this._context = null
        }
    }
    playSound(e, t={}) {
        let s = null;
        return iu && (s = new iu(this,e,t),
        s.play()),
        s
    }
    playSound3d(e, t, s={}) {
        let i = null;
        return nr && (i = new nr(this,e,s),
        i.setPosition(t),
        s.volume && i.setVolume(s.volume),
        s.loop && i.setLoop(s.loop),
        s.maxDistance && i.setMaxDistance(s.maxDistance),
        s.minDistance && i.setMinDistance(s.minDistance),
        s.rollOffFactor && i.setRollOffFactor(s.rollOffFactor),
        s.distanceModel && i.setDistanceModel(s.distanceModel),
        i.play()),
        i
    }
    _resume() {
        this._context.resume().then( () => {
            const e = this._context.createBufferSource();
            e.buffer = this._context.createBuffer(1, 1, this._context.sampleRate),
            e.connect(this._context.destination),
            e.start(0),
            e.onended = t => {
                e.disconnect(0),
                this.fire("resume")
            }
        }
        , e => {}
        ).catch(e => {}
        )
    }
    _suspend() {
        this._context.suspend().then( () => {
            this.fire("suspend")
        }
        , e => {}
        ).catch(e => {}
        )
    }
    _unlockHandler() {
        this._removeUnlockListeners(),
        !this._userSuspended && this._context.state !== zc && this._resume()
    }
    _registerUnlockListeners() {
        Uy.forEach(e => {
            window.addEventListener(e, this._unlockHandlerFunc, !1)
        }
        )
    }
    _removeUnlockListeners() {
        Uy.forEach(e => {
            window.removeEventListener(e, this._unlockHandlerFunc, !1)
        }
        )
    }
}
  , YE = class {
    constructor(e) {
        this.audio = void 0,
        this.buffer = void 0,
        e instanceof Audio ? this.audio = e : this.buffer = e
    }
    get duration() {
        let e = 0;
        return this.buffer ? e = this.buffer.duration : this.audio && (e = this.audio.duration),
        e || 0
    }
}
;
const is = 0
  , _o = 1
  , ci = 2;
function as(a, e) {
    return a % e || 0
}
class Xs extends fe {
    constructor(e, t, s) {
        super(),
        this.source = null,
        this._manager = e,
        this._volume = s.volume !== void 0 ? W.clamp(Number(s.volume) || 0, 0, 1) : 1,
        this._pitch = s.pitch !== void 0 ? Math.max(.01, Number(s.pitch) || 0) : 1,
        this._loop = !!(s.loop !== void 0 && s.loop),
        this._sound = t,
        this._state = ci,
        this._suspended = !1,
        this._suspendEndEvent = 0,
        this._suspendInstanceEvents = !1,
        this._playWhenLoaded = !0,
        this._startTime = Math.max(0, Number(s.startTime) || 0),
        this._duration = Math.max(0, Number(s.duration) || 0),
        this._startOffset = null,
        this._onPlayCallback = s.onPlay,
        this._onPauseCallback = s.onPause,
        this._onResumeCallback = s.onResume,
        this._onStopCallback = s.onStop,
        this._onEndCallback = s.onEnd,
        Fn() ? (this._startedAt = 0,
        this._currentTime = 0,
        this._currentOffset = 0,
        this._inputNode = null,
        this._connectorNode = null,
        this._firstNode = null,
        this._lastNode = null,
        this._waitingContextSuspension = !1,
        this._initializeNodes(),
        this._endedHandler = this._onEnded.bind(this)) : (this._isReady = !1,
        this._loadedMetadataHandler = this._onLoadedMetadata.bind(this),
        this._timeUpdateHandler = this._onTimeUpdate.bind(this),
        this._endedHandler = this._onEnded.bind(this),
        this._createSource())
    }
    set currentTime(e) {
        if (!(e < 0))
            if (this._state === is) {
                const t = this._suspendInstanceEvents;
                this._suspendInstanceEvents = !0,
                this.stop(),
                this._startOffset = e,
                this.play(),
                this._suspendInstanceEvents = t
            } else
                this._startOffset = e,
                this._currentTime = e
    }
    get currentTime() {
        return this._startOffset !== null ? this._startOffset : this._state === _o ? this._currentTime : this._state === ci || !this.source ? 0 : (this._updateCurrentTime(),
        this._currentTime)
    }
    set duration(e) {
        this._duration = Math.max(0, Number(e) || 0);
        const t = this._state === is;
        this.stop(),
        t && this.play()
    }
    get duration() {
        return this._sound ? this._duration ? as(this._duration, this._sound.duration) : this._sound.duration : 0
    }
    get isPaused() {
        return this._state === _o
    }
    get isPlaying() {
        return this._state === is
    }
    get isStopped() {
        return this._state === ci
    }
    get isSuspended() {
        return this._suspended
    }
    set loop(e) {
        this._loop = !!e,
        this.source && (this.source.loop = this._loop)
    }
    get loop() {
        return this._loop
    }
    set pitch(e) {
        this._currentOffset = this.currentTime,
        this._startedAt = this._manager.context.currentTime,
        this._pitch = Math.max(Number(e) || 0, .01),
        this.source && (this.source.playbackRate.value = this._pitch)
    }
    get pitch() {
        return this._pitch
    }
    set sound(e) {
        this._sound = e,
        this._state !== ci ? this.stop() : this._createSource()
    }
    get sound() {
        return this._sound
    }
    set startTime(e) {
        this._startTime = Math.max(0, Number(e) || 0);
        const t = this._state === is;
        this.stop(),
        t && this.play()
    }
    get startTime() {
        return this._startTime
    }
    set volume(e) {
        e = W.clamp(e, 0, 1),
        this._volume = e,
        this.gain && (this.gain.gain.value = e * this._manager.volume)
    }
    get volume() {
        return this._volume
    }
    _onPlay() {
        this.fire("play"),
        this._onPlayCallback && this._onPlayCallback(this)
    }
    _onPause() {
        this.fire("pause"),
        this._onPauseCallback && this._onPauseCallback(this)
    }
    _onResume() {
        this.fire("resume"),
        this._onResumeCallback && this._onResumeCallback(this)
    }
    _onStop() {
        this.fire("stop"),
        this._onStopCallback && this._onStopCallback(this)
    }
    _onEnded() {
        if (this._suspendEndEvent > 0) {
            this._suspendEndEvent--;
            return
        }
        this.fire("end"),
        this._onEndCallback && this._onEndCallback(this),
        this.stop()
    }
    _onManagerVolumeChange() {
        this.volume = this._volume
    }
    _onManagerSuspend() {
        this._state === is && !this._suspended && (this._suspended = !0,
        this.pause())
    }
    _onManagerResume() {
        this._suspended && (this._suspended = !1,
        this.resume())
    }
    _initializeNodes() {
        this.gain = this._manager.context.createGain(),
        this._inputNode = this.gain,
        this._connectorNode = this.gain,
        this._connectorNode.connect(this._manager.context.destination)
    }
    play() {
        return this._state !== ci && this.stop(),
        this._state = is,
        this._playWhenLoaded = !1,
        this._waitingContextSuspension ? !1 : this._manager.suspended ? (this._manager.once("resume", this._playAudioImmediate, this),
        this._waitingContextSuspension = !0,
        !1) : (this._playAudioImmediate(),
        !0)
    }
    _playAudioImmediate() {
        if (this._waitingContextSuspension = !1,
        this._state !== is)
            return;
        this.source || this._createSource();
        let e = as(this._startOffset, this.duration);
        e = as(this._startTime + e, this._sound.duration),
        this._startOffset = null,
        this._duration ? this.source.start(0, e, this._duration) : this.source.start(0, e),
        this._startedAt = this._manager.context.currentTime,
        this._currentTime = 0,
        this._currentOffset = e,
        this.volume = this._volume,
        this.loop = this._loop,
        this.pitch = this._pitch,
        this._manager.on("volumechange", this._onManagerVolumeChange, this),
        this._manager.on("suspend", this._onManagerSuspend, this),
        this._manager.on("resume", this._onManagerResume, this),
        this._manager.on("destroy", this._onManagerDestroy, this),
        this._suspendInstanceEvents || this._onPlay()
    }
    pause() {
        return this._playWhenLoaded = !1,
        this._state !== is ? !1 : (this._state = _o,
        this._waitingContextSuspension || (this._updateCurrentTime(),
        this._suspendEndEvent++,
        this.source.stop(0),
        this.source = null,
        this._startOffset = null,
        this._suspendInstanceEvents || this._onPause()),
        !0)
    }
    resume() {
        if (this._state !== _o)
            return !1;
        let e = this.currentTime;
        return this._state = is,
        this._waitingContextSuspension || (this.source || this._createSource(),
        this._startOffset !== null && (e = as(this._startOffset, this.duration),
        e = as(this._startTime + e, this._sound.duration),
        this._startOffset = null),
        this._duration ? this.source.start(0, e, this._duration) : this.source.start(0, e),
        this._startedAt = this._manager.context.currentTime,
        this._currentOffset = e,
        this.volume = this._volume,
        this.loop = this._loop,
        this.pitch = this._pitch,
        this._playWhenLoaded = !1,
        this._suspendInstanceEvents || this._onResume()),
        !0
    }
    stop() {
        if (this._playWhenLoaded = !1,
        this._state === ci)
            return !1;
        const e = this._state === is;
        return this._state = ci,
        this._waitingContextSuspension || (this._manager.off("volumechange", this._onManagerVolumeChange, this),
        this._manager.off("suspend", this._onManagerSuspend, this),
        this._manager.off("resume", this._onManagerResume, this),
        this._manager.off("destroy", this._onManagerDestroy, this),
        this._startedAt = 0,
        this._currentTime = 0,
        this._currentOffset = 0,
        this._startOffset = null,
        this._suspendEndEvent++,
        e && this.source && this.source.stop(0),
        this.source = null,
        this._suspendInstanceEvents || this._onStop()),
        !0
    }
    setExternalNodes(e, t) {
        if (!e) {
            console.error("The firstNode must be a valid Audio Node");
            return
        }
        t || (t = e);
        const s = this._manager.context.destination;
        this._firstNode !== e && (this._firstNode ? this._connectorNode.disconnect(this._firstNode) : this._connectorNode.disconnect(s),
        this._firstNode = e,
        this._connectorNode.connect(e)),
        this._lastNode !== t && (this._lastNode && this._lastNode.disconnect(s),
        this._lastNode = t,
        this._lastNode.connect(s))
    }
    clearExternalNodes() {
        const e = this._manager.context.destination;
        this._firstNode && (this._connectorNode.disconnect(this._firstNode),
        this._firstNode = null),
        this._lastNode && (this._lastNode.disconnect(e),
        this._lastNode = null),
        this._connectorNode.connect(e)
    }
    getExternalNodes() {
        return [this._firstNode, this._lastNode]
    }
    _createSource() {
        if (!this._sound)
            return null;
        const e = this._manager.context;
        return this._sound.buffer && (this.source = e.createBufferSource(),
        this.source.buffer = this._sound.buffer,
        this.source.connect(this._inputNode),
        this.source.onended = this._endedHandler,
        this.source.loopStart = as(this._startTime, this.source.buffer.duration),
        this._duration && (this.source.loopEnd = Math.max(this.source.loopStart, as(this._startTime + this._duration, this.source.buffer.duration)))),
        this.source
    }
    _updateCurrentTime() {
        this._currentTime = as((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset, this.duration)
    }
    _onManagerDestroy() {
        this.source && this._state === is && (this.source.stop(0),
        this.source = null)
    }
}
Xs.EVENT_PLAY = "play";
Xs.EVENT_PAUSE = "pause";
Xs.EVENT_RESUME = "resume";
Xs.EVENT_STOP = "stop";
Xs.EVENT_END = "end";
Fn() || (Object.assign(Xs.prototype, {
    play: function() {
        return this._state !== ci && this.stop(),
        !this.source && !this._createSource() ? !1 : (this.volume = this._volume,
        this.pitch = this._pitch,
        this.loop = this._loop,
        this.source.play(),
        this._state = is,
        this._playWhenLoaded = !1,
        this._manager.on("volumechange", this._onManagerVolumeChange, this),
        this._manager.on("suspend", this._onManagerSuspend, this),
        this._manager.on("resume", this._onManagerResume, this),
        this._manager.on("destroy", this._onManagerDestroy, this),
        this._manager.suspended && this._onManagerSuspend(),
        this._suspendInstanceEvents || this._onPlay(),
        !0)
    },
    pause: function() {
        return !this.source || this._state !== is ? !1 : (this._suspendEndEvent++,
        this.source.pause(),
        this._playWhenLoaded = !1,
        this._state = _o,
        this._startOffset = null,
        this._suspendInstanceEvents || this._onPause(),
        !0)
    },
    resume: function() {
        return !this.source || this._state !== _o ? !1 : (this._state = is,
        this._playWhenLoaded = !1,
        this.source.paused && (this.source.play(),
        this._suspendInstanceEvents || this._onResume()),
        !0)
    },
    stop: function() {
        return !this.source || this._state === ci ? !1 : (this._manager.off("volumechange", this._onManagerVolumeChange, this),
        this._manager.off("suspend", this._onManagerSuspend, this),
        this._manager.off("resume", this._onManagerResume, this),
        this._manager.off("destroy", this._onManagerDestroy, this),
        this._suspendEndEvent++,
        this.source.pause(),
        this._playWhenLoaded = !1,
        this._state = ci,
        this._startOffset = null,
        this._suspendInstanceEvents || this._onStop(),
        !0)
    },
    setExternalNodes: function() {},
    clearExternalNodes: function() {},
    getExternalNodes: function() {
        return [null, null]
    },
    _onLoadedMetadata: function() {
        this.source.removeEventListener("loadedmetadata", this._loadedMetadataHandler),
        this._isReady = !0;
        let a = as(this._startOffset, this.duration);
        a = as(this._startTime + a, this._sound.duration),
        this._startOffset = null,
        this.source.currentTime = a
    },
    _createSource: function() {
        return this._sound && this._sound.audio && (this._isReady = !1,
        this.source = this._sound.audio.cloneNode(!0),
        this.source.addEventListener("loadedmetadata", this._loadedMetadataHandler),
        this.source.addEventListener("timeupdate", this._timeUpdateHandler),
        this.source.onended = this._endedHandler),
        this.source
    },
    _onTimeUpdate: function() {
        this._duration && this.source.currentTime > as(this._startTime + this._duration, this.source.duration) && (this.loop ? this.source.currentTime = as(this._startTime, this.source.duration) : (this.source.removeEventListener("timeupdate", this._timeUpdateHandler),
        this.source.pause(),
        this._onEnded()))
    },
    _onManagerDestroy: function() {
        this.source && this.source.pause()
    }
}),
Object.defineProperty(Xs.prototype, "volume", {
    get: function() {
        return this._volume
    },
    set: function(a) {
        a = W.clamp(a, 0, 1),
        this._volume = a,
        this.source && (this.source.volume = a * this._manager.volume)
    }
}),
Object.defineProperty(Xs.prototype, "pitch", {
    get: function() {
        return this._pitch
    },
    set: function(a) {
        this._pitch = Math.max(Number(a) || 0, .01),
        this.source && (this.source.playbackRate = this._pitch)
    }
}),
Object.defineProperty(Xs.prototype, "sound", {
    get: function() {
        return this._sound
    },
    set: function(a) {
        this.stop(),
        this._sound = a
    }
}),
Object.defineProperty(Xs.prototype, "currentTime", {
    get: function() {
        return this._startOffset !== null ? this._startOffset : this._state === ci || !this.source ? 0 : this.source.currentTime - this._startTime
    },
    set: function(a) {
        a < 0 || (this._startOffset = a,
        this.source && this._isReady && (this.source.currentTime = as(this._startTime + as(a, this.duration), this._sound.duration),
        this._startOffset = null))
    }
}));
const KE = 1e4;
class co extends Xs {
    constructor(e, t, s={}) {
        super(e, t, s),
        this._position = new y,
        this._velocity = new y,
        s.position && (this.position = s.position),
        this.maxDistance = s.maxDistance !== void 0 ? Number(s.maxDistance) : KE,
        this.refDistance = s.refDistance !== void 0 ? Number(s.refDistance) : 1,
        this.rollOffFactor = s.rollOffFactor !== void 0 ? Number(s.rollOffFactor) : 1,
        this.distanceModel = s.distanceModel !== void 0 ? s.distanceModel : Du
    }
    _initializeNodes() {
        this.gain = this._manager.context.createGain(),
        this.panner = this._manager.context.createPanner(),
        this.panner.connect(this.gain),
        this._inputNode = this.panner,
        this._connectorNode = this.gain,
        this._connectorNode.connect(this._manager.context.destination)
    }
    set position(e) {
        this._position.copy(e);
        const t = this.panner;
        "positionX"in t ? (t.positionX.value = e.x,
        t.positionY.value = e.y,
        t.positionZ.value = e.z) : t.setPosition && t.setPosition(e.x, e.y, e.z)
    }
    get position() {
        return this._position
    }
    set velocity(e) {
        this._velocity.copy(e)
    }
    get velocity() {
        return this._velocity
    }
    set maxDistance(e) {
        this.panner.maxDistance = e
    }
    get maxDistance() {
        return this.panner.maxDistance
    }
    set refDistance(e) {
        this.panner.refDistance = e
    }
    get refDistance() {
        return this.panner.refDistance
    }
    set rollOffFactor(e) {
        this.panner.rolloffFactor = e
    }
    get rollOffFactor() {
        return this.panner.rolloffFactor
    }
    set distanceModel(e) {
        this.panner.distanceModel = e
    }
    get distanceModel() {
        return this.panner.distanceModel
    }
}
if (!Fn()) {
    let a = new y;
    const e = function(s, i, n, r, o, l) {
        a = a.sub2(s, i);
        const c = a.length();
        if (c < n)
            return 1;
        if (c > r)
            return 0;
        let d = 0;
        return l === Du ? d = 1 - o * (c - n) / (r - n) : l === Ou ? d = n / (n + o * (c - n)) : l === MS && (d = Math.pow(c / n, -o)),
        W.clamp(d, 0, 1)
    };
    Object.defineProperty(co.prototype, "position", {
        get: function() {
            return this._position
        },
        set: function(t) {
            if (this._position.copy(t),
            this.source) {
                const i = this._manager.listener.getPosition()
                  , n = e(i, this._position, this.refDistance, this.maxDistance, this.rollOffFactor, this.distanceModel)
                  , r = this.volume;
                this.source.volume = r * n * this._manager.volume
            }
        }
    }),
    Object.defineProperty(co.prototype, "maxDistance", {
        get: function() {
            return this._maxDistance
        },
        set: function(t) {
            this._maxDistance = t
        }
    }),
    Object.defineProperty(co.prototype, "refDistance", {
        get: function() {
            return this._refDistance
        },
        set: function(t) {
            this._refDistance = t
        }
    }),
    Object.defineProperty(co.prototype, "rollOffFactor", {
        get: function() {
            return this._rollOffFactor
        },
        set: function(t) {
            this._rollOffFactor = t
        }
    }),
    Object.defineProperty(co.prototype, "distanceModel", {
        get: function() {
            return this._distanceModel
        },
        set: function(t) {
            this._distanceModel = t
        }
    })
}
const KS = 0
  , hc = 1
  , ps = 2
  , ls = 3
  , _a = 4
  , H_ = 5
  , fi = 6
  , ZS = 7
  , QS = 8
  , JS = 9
  , ex = 10
  , Tf = "none"
  , ZE = "linear"
  , W_ = 2
  , QE = 0
  , JE = 2
  , X_ = 15
  , Bn = 0
  , hs = 1
  , j_ = 2
  , $_ = 3
  , Cf = 4
  , pe = 0
  , Oe = 1
  , He = 2
  , Nt = 0
  , eA = 1
  , tA = 2
  , sA = 3
  , q_ = 0
  , iA = 1
  , St = 0
  , zs = 1
  , pi = 2
  , Hs = 3
  , gi = 4
  , Ni = 5
  , Kt = 6
  , Tr = {};
Tr[St] = "PCF3";
Tr[zs] = "VSM8";
Tr[pi] = "VSM16";
Tr[Hs] = "VSM32";
Tr[gi] = "PCF5";
Tr[Ni] = "PCF1";
Tr[Kt] = "PCSS";
const Y_ = 1
  , Tm = 0
  , tx = 0
  , di = 0
  , K_ = 1
  , ih = 0
  , nA = 1
  , Di = 0
  , Co = 1
  , nh = 0
  , Wr = 1
  , Vc = 2
  , sx = 0
  , rA = 1
  , ji = 0
  , cc = 1
  , zy = "mul"
  , dc = 0
  , Z_ = 1
  , aA = 2
  , uc = 3
  , fc = 0
  , oA = 1
  , lA = 2
  , hA = 3
  , cA = 4
  , dA = 0
  , Th = 1
  , Cm = 2
  , nu = 1
  , Ch = 2
  , ix = 4
  , nx = 8
  , rx = 16
  , Eh = 32
  , ru = 64
  , Q_ = 128
  , Ah = 256
  , J_ = 512
  , Mh = 1024
  , Ph = 2048
  , Rh = 4096
  , eg = 8192
  , Si = 0
  , ga = 1
  , tg = 2
  , Sn = 0
  , Em = 1
  , Rs = 1
  , Ui = 2
  , zi = 4
  , pc = 0
  , $i = 1
  , Vi = 2
  , mc = 3
  , ax = 4
  , gn = 0
  , xt = 1
  , _t = 2
  , Dd = 1
  , Gc = 0
  , Od = 0
  , uA = 1
  , fA = 2
  , Vy = 3
  , pA = 4
  , mA = 5
  , sg = 0
  , Am = 1
  , Se = 0
  , Re = 1
  , Fd = "infinite"
  , _A = "box"
  , gA = "dome"
  , cs = "none"
  , Gy = "bayer8";
class ig {
    constructor() {
        this._refCount = 0
    }
    incRefCount() {
        this._refCount++
    }
    decRefCount() {
        this._refCount--
    }
    get refCount() {
        return this._refCount
    }
}
let yA = 0;
class Oi {
    constructor() {
        this.initDefaults()
    }
    initDefaults() {
        this.recreate = !1,
        this.verticesUsage = es,
        this.indicesUsage = es,
        this.maxVertices = 0,
        this.maxIndices = 0,
        this.vertexCount = 0,
        this.indexCount = 0,
        this.vertexStreamsUpdated = !1,
        this.indexStreamUpdated = !1,
        this.vertexStreamDictionary = {},
        this.indices = null
    }
    _changeVertexCount(e, t) {
        this.vertexCount || (this.vertexCount = e)
    }
}
Oi.DEFAULT_COMPONENTS_POSITION = 3;
Oi.DEFAULT_COMPONENTS_NORMAL = 3;
Oi.DEFAULT_COMPONENTS_UV = 2;
Oi.DEFAULT_COMPONENTS_COLORS = 4;
class vA {
    constructor(e, t, s, i) {
        this.data = e,
        this.componentCount = t,
        this.dataType = s,
        this.dataTypeNormalize = i
    }
}
class ms extends ig {
    constructor(e) {
        super(),
        this._aabbVer = 0,
        this._aabb = new Pe,
        this.id = yA++,
        this.device = e,
        this.vertexBuffer = null,
        this.indexBuffer = [null],
        this.primitive = [{
            type: 0,
            base: 0,
            count: 0
        }],
        this.skin = null,
        this._morph = null,
        this._geometryData = null,
        this.boneAabb = null
    }
    set morph(e) {
        e !== this._morph && (this._morph && this._morph.decRefCount(),
        this._morph = e,
        e && e.incRefCount())
    }
    get morph() {
        return this._morph
    }
    set aabb(e) {
        this._aabb = e,
        this._aabbVer++
    }
    get aabb() {
        return this._aabb
    }
    destroy() {
        const e = this.morph;
        e && (this.morph = null,
        e.refCount < 1 && e.destroy()),
        this.vertexBuffer && (this.vertexBuffer.destroy(),
        this.vertexBuffer = null);
        for (let t = 0; t < this.indexBuffer.length; t++)
            this._destroyIndexBuffer(t);
        this.indexBuffer.length = 0,
        this._geometryData = null
    }
    _destroyIndexBuffer(e) {
        this.indexBuffer[e] && (this.indexBuffer[e].destroy(),
        this.indexBuffer[e] = null)
    }
    _initBoneAabbs(e) {
        this.boneAabb = [],
        this.boneUsed = [];
        let t, s, i, n, r;
        const o = []
          , l = []
          , c = this.boneUsed
          , d = this.skin.boneNames.length;
        let h, u, f;
        for (let S = 0; S < d; S++)
            o[S] = new y(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),
            l[S] = new y(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);
        const p = new sh(this.vertexBuffer)
          , _ = p.element[ut]
          , m = p.element[Ji]
          , g = p.element[Ps]
          , v = this.vertexBuffer.numVertices;
        for (let S = 0; S < v; S++) {
            for (let w = 0; w < 4; w++)
                if (m.array[m.index + w] > 0) {
                    const b = g.array[g.index + w];
                    if (c[b] = !0,
                    t = _.array[_.index],
                    s = _.array[_.index + 1],
                    i = _.array[_.index + 2],
                    n = l[b],
                    r = o[b],
                    r.x > t && (r.x = t),
                    r.y > s && (r.y = s),
                    r.z > i && (r.z = i),
                    n.x < t && (n.x = t),
                    n.y < s && (n.y = s),
                    n.z < i && (n.z = i),
                    e) {
                        let E = h = t
                          , C = u = s
                          , R = f = i;
                        for (let F = 0; F < e.length; F++) {
                            const L = e[F]
                              , U = L.deltaPositions[S * 3]
                              , I = L.deltaPositions[S * 3 + 1]
                              , O = L.deltaPositions[S * 3 + 2];
                            U < 0 ? E += U : h += U,
                            I < 0 ? C += I : u += I,
                            O < 0 ? R += O : f += O
                        }
                        r.x > E && (r.x = E),
                        r.y > C && (r.y = C),
                        r.z > R && (r.z = R),
                        n.x < h && (n.x = h),
                        n.y < u && (n.y = u),
                        n.z < f && (n.z = f)
                    }
                }
            p.next()
        }
        const x = this.vertexBuffer.getFormat().elements.find(S => S.name === ut);
        if (x && x.normalize) {
            const S = ( () => {
                switch (x.dataType) {
                case Ca:
                    return w => Math.max(w / 127, -1);
                case Wi:
                    return w => w / 255;
                case Ea:
                    return w => Math.max(w / 32767, -1);
                case wr:
                    return w => w / 65535;
                default:
                    return w => w
                }
            }
            )();
            for (let w = 0; w < d; w++)
                if (c[w]) {
                    const T = o[w]
                      , b = l[w];
                    T.set(S(T.x), S(T.y), S(T.z)),
                    b.set(S(b.x), S(b.y), S(b.z))
                }
        }
        for (let S = 0; S < d; S++) {
            const w = new Pe;
            w.setMinMax(o[S], l[S]),
            this.boneAabb.push(w)
        }
    }
    _initGeometryData() {
        this._geometryData || (this._geometryData = new Oi,
        this.vertexBuffer && (this._geometryData.vertexCount = this.vertexBuffer.numVertices,
        this._geometryData.maxVertices = this.vertexBuffer.numVertices),
        this.indexBuffer.length > 0 && this.indexBuffer[0] && (this._geometryData.indexCount = this.indexBuffer[0].numIndices,
        this._geometryData.maxIndices = this.indexBuffer[0].numIndices))
    }
    clear(e, t, s=0, i=0) {
        this._initGeometryData(),
        this._geometryData.initDefaults(),
        this._geometryData.recreate = !0,
        this._geometryData.maxVertices = s,
        this._geometryData.maxIndices = i,
        this._geometryData.verticesUsage = e ? es : Do,
        this._geometryData.indicesUsage = t ? es : Do
    }
    setVertexStream(e, t, s, i, n=Me, r=!1) {
        this._initGeometryData();
        const o = i || t.length / s;
        this._geometryData._changeVertexCount(o, e),
        this._geometryData.vertexStreamsUpdated = !0,
        this._geometryData.vertexStreamDictionary[e] = new vA(t,s,n,r)
    }
    getVertexStream(e, t) {
        let s = 0
          , i = !1;
        if (this._geometryData) {
            const n = this._geometryData.vertexStreamDictionary[e];
            n && (i = !0,
            s = this._geometryData.vertexCount,
            ArrayBuffer.isView(t) ? t.set(n.data) : (t.length = 0,
            t.push(n.data)))
        }
        return i || this.vertexBuffer && (s = new sh(this.vertexBuffer).readData(e, t)),
        s
    }
    setPositions(e, t=Oi.DEFAULT_COMPONENTS_POSITION, s) {
        this.setVertexStream(ut, e, t, s, Me, !1)
    }
    setNormals(e, t=Oi.DEFAULT_COMPONENTS_NORMAL, s) {
        this.setVertexStream(Is, e, t, s, Me, !1)
    }
    setUvs(e, t, s=Oi.DEFAULT_COMPONENTS_UV, i) {
        this.setVertexStream(oy + e, t, s, i, Me, !1)
    }
    setColors(e, t=Oi.DEFAULT_COMPONENTS_COLORS, s) {
        this.setVertexStream(jt, e, t, s, Me, !1)
    }
    setColors32(e, t) {
        this.setVertexStream(jt, e, Oi.DEFAULT_COMPONENTS_COLORS, t, Wi, !0)
    }
    setIndices(e, t) {
        this._initGeometryData(),
        this._geometryData.indexStreamUpdated = !0,
        this._geometryData.indices = e,
        this._geometryData.indexCount = t || e.length
    }
    getPositions(e) {
        return this.getVertexStream(ut, e)
    }
    getNormals(e) {
        return this.getVertexStream(Is, e)
    }
    getUvs(e, t) {
        return this.getVertexStream(oy + e, t)
    }
    getColors(e) {
        return this.getVertexStream(jt, e)
    }
    getIndices(e) {
        let t = 0;
        if (this._geometryData && this._geometryData.indices) {
            const s = this._geometryData.indices;
            if (t = this._geometryData.indexCount,
            ArrayBuffer.isView(e))
                e.set(s);
            else {
                e.length = 0;
                for (let i = 0, n = s.length; i < n; i++)
                    e.push(s[i])
            }
        } else
            this.indexBuffer.length > 0 && this.indexBuffer[0] && (t = this.indexBuffer[0].readData(e));
        return t
    }
    update(e=xn, t=!0) {
        if (this._geometryData) {
            if (t) {
                const n = this._geometryData.vertexStreamDictionary[ut];
                n && n.componentCount === 3 && (this._aabb.compute(n.data, this._geometryData.vertexCount),
                this._aabbVer++)
            }
            let s = this._geometryData.recreate;
            this._geometryData.vertexCount > this._geometryData.maxVertices && (s = !0,
            this._geometryData.maxVertices = this._geometryData.vertexCount),
            s && this.vertexBuffer && (this.vertexBuffer.destroy(),
            this.vertexBuffer = null);
            let i = this._geometryData.recreate;
            this._geometryData.indexCount > this._geometryData.maxIndices && (i = !0,
            this._geometryData.maxIndices = this._geometryData.indexCount),
            i && this.indexBuffer.length > 0 && this.indexBuffer[0] && (this.indexBuffer[0].destroy(),
            this.indexBuffer[0] = null),
            this._geometryData.vertexStreamsUpdated && this._updateVertexBuffer(),
            this._geometryData.indexStreamUpdated && this._updateIndexBuffer(),
            this.primitive[0].type = e,
            this.indexBuffer.length > 0 && this.indexBuffer[0] ? this._geometryData.indexStreamUpdated && (this.primitive[0].count = this._geometryData.indexCount,
            this.primitive[0].indexed = !0) : this._geometryData.vertexStreamsUpdated && (this.primitive[0].count = this._geometryData.vertexCount,
            this.primitive[0].indexed = !1),
            this._geometryData.vertexCount = 0,
            this._geometryData.indexCount = 0,
            this._geometryData.vertexStreamsUpdated = !1,
            this._geometryData.indexStreamUpdated = !1,
            this._geometryData.recreate = !1,
            this.updateRenderStates()
        }
    }
    _buildVertexFormat(e) {
        const t = [];
        for (const s in this._geometryData.vertexStreamDictionary) {
            const i = this._geometryData.vertexStreamDictionary[s];
            t.push({
                semantic: s,
                components: i.componentCount,
                type: i.dataType,
                normalize: i.dataTypeNormalize
            })
        }
        return new fs(this.device,t,e)
    }
    _updateVertexBuffer() {
        if (!this.vertexBuffer) {
            const s = this._geometryData.maxVertices
              , i = this._buildVertexFormat(s);
            this.vertexBuffer = new xi(this.device,i,s,this._geometryData.verticesUsage)
        }
        const e = new sh(this.vertexBuffer)
          , t = this._geometryData.vertexCount;
        for (const s in this._geometryData.vertexStreamDictionary) {
            const i = this._geometryData.vertexStreamDictionary[s];
            e.writeData(s, i.data, t),
            delete this._geometryData.vertexStreamDictionary[s]
        }
        e.end()
    }
    _updateIndexBuffer() {
        if (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {
            const t = this._geometryData.maxVertices > 65535 ? fr : js;
            this.indexBuffer[0] = new _r(this.device,t,this._geometryData.maxIndices,this._geometryData.indicesUsage)
        }
        const e = this._geometryData.indices;
        e && (this.indexBuffer[0].writeData(e, this._geometryData.indexCount),
        this._geometryData.indices = null)
    }
    prepareRenderState(e) {
        e === Wr ? this.generateWireframe() : e === Vc && (this.primitive[Vc] = {
            type: af,
            base: 0,
            count: this.vertexBuffer ? this.vertexBuffer.numVertices : 0,
            indexed: !1
        })
    }
    updateRenderStates() {
        this.primitive[Vc] && this.prepareRenderState(Vc),
        this.primitive[Wr] && this.prepareRenderState(Wr)
    }
    generateWireframe() {
        this._destroyIndexBuffer(Wr);
        const e = this.vertexBuffer.numVertices
          , t = [];
        let s;
        if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
            const r = [[0, 1], [1, 2], [2, 0]]
              , o = this.primitive[nh].base
              , l = this.primitive[nh].count
              , c = this.indexBuffer[nh]
              , d = new ym[c.format](c.storage)
              , h = new Set;
            for (let u = o; u < o + l; u += 3)
                for (let f = 0; f < 3; f++) {
                    const p = d[u + r[f][0]]
                      , _ = d[u + r[f][1]]
                      , m = p > _ ? _ * e + p : p * e + _;
                    h.has(m) || (h.add(m),
                    t.push(p, _))
                }
            s = c.format
        } else {
            for (let r = 0; r < e; r += 3)
                t.push(r, r + 1, r + 1, r + 2, r + 2, r);
            s = t.length > 65535 ? fr : js
        }
        const i = new _r(this.vertexBuffer.device,s,t.length);
        new ym[i.format](i.storage).set(t),
        i.unlock(),
        this.primitive[Wr] = {
            type: of,
            base: 0,
            count: t.length,
            indexed: !0
        },
        this.indexBuffer[Wr] = i
    }
}
const Ts = 4 / 64
  , ks = 1 - Ts * 2
  , pl = [];
function SA(a, e) {
    const t = e.length / 3
      , s = a.length / 3
      , i = new y
      , n = new y
      , r = new y
      , o = new y
      , l = new y
      , c = new y
      , d = [];
    for (let h = 0; h < a.length; h++)
        d[h] = 0;
    for (let h = 0; h < t; h++) {
        const u = e[h * 3]
          , f = e[h * 3 + 1]
          , p = e[h * 3 + 2];
        i.set(a[u * 3], a[u * 3 + 1], a[u * 3 + 2]),
        n.set(a[f * 3], a[f * 3 + 1], a[f * 3 + 2]),
        r.set(a[p * 3], a[p * 3 + 1], a[p * 3 + 2]),
        o.sub2(n, i),
        l.sub2(r, i),
        c.cross(o, l).normalize(),
        d[u * 3] += c.x,
        d[u * 3 + 1] += c.y,
        d[u * 3 + 2] += c.z,
        d[f * 3] += c.x,
        d[f * 3 + 1] += c.y,
        d[f * 3 + 2] += c.z,
        d[p * 3] += c.x,
        d[p * 3 + 1] += c.y,
        d[p * 3 + 2] += c.z
    }
    for (let h = 0; h < s; h++) {
        const u = d[h * 3]
          , f = d[h * 3 + 1]
          , p = d[h * 3 + 2]
          , _ = 1 / Math.sqrt(u * u + f * f + p * p);
        d[h * 3] *= _,
        d[h * 3 + 1] *= _,
        d[h * 3 + 2] *= _
    }
    return d
}
function Ma(a, e, t, s) {
    const i = s.length / 3
      , n = a.length / 3
      , r = new y
      , o = new y
      , l = new y
      , c = new P
      , d = new P
      , h = new P
      , u = new y
      , f = new y
      , p = new Float32Array(n * 3)
      , _ = new Float32Array(n * 3)
      , m = [];
    for (let w = 0; w < i; w++) {
        const T = s[w * 3]
          , b = s[w * 3 + 1]
          , E = s[w * 3 + 2];
        r.set(a[T * 3], a[T * 3 + 1], a[T * 3 + 2]),
        o.set(a[b * 3], a[b * 3 + 1], a[b * 3 + 2]),
        l.set(a[E * 3], a[E * 3 + 1], a[E * 3 + 2]),
        c.set(t[T * 2], t[T * 2 + 1]),
        d.set(t[b * 2], t[b * 2 + 1]),
        h.set(t[E * 2], t[E * 2 + 1]);
        const C = o.x - r.x
          , R = l.x - r.x
          , F = o.y - r.y
          , L = l.y - r.y
          , U = o.z - r.z
          , I = l.z - r.z
          , O = d.x - c.x
          , D = h.x - c.x
          , A = d.y - c.y
          , k = h.y - c.y
          , N = O * k - D * A;
        if (N === 0)
            u.set(0, 1, 0),
            f.set(1, 0, 0);
        else {
            const H = 1 / N;
            u.set((k * C - A * R) * H, (k * F - A * L) * H, (k * U - A * I) * H),
            f.set((O * R - D * C) * H, (O * L - D * F) * H, (O * I - D * U) * H)
        }
        p[T * 3 + 0] += u.x,
        p[T * 3 + 1] += u.y,
        p[T * 3 + 2] += u.z,
        p[b * 3 + 0] += u.x,
        p[b * 3 + 1] += u.y,
        p[b * 3 + 2] += u.z,
        p[E * 3 + 0] += u.x,
        p[E * 3 + 1] += u.y,
        p[E * 3 + 2] += u.z,
        _[T * 3 + 0] += f.x,
        _[T * 3 + 1] += f.y,
        _[T * 3 + 2] += f.z,
        _[b * 3 + 0] += f.x,
        _[b * 3 + 1] += f.y,
        _[b * 3 + 2] += f.z,
        _[E * 3 + 0] += f.x,
        _[E * 3 + 1] += f.y,
        _[E * 3 + 2] += f.z
    }
    const g = new y
      , v = new y
      , x = new y
      , S = new y;
    for (let w = 0; w < n; w++) {
        x.set(e[w * 3], e[w * 3 + 1], e[w * 3 + 2]),
        g.set(p[w * 3], p[w * 3 + 1], p[w * 3 + 2]),
        v.set(_[w * 3], _[w * 3 + 1], _[w * 3 + 2]);
        const T = x.dot(g);
        S.copy(x).mulScalar(T),
        S.sub2(g, S).normalize(),
        m[w * 4] = S.x,
        m[w * 4 + 1] = S.y,
        m[w * 4 + 2] = S.z,
        S.cross(x, g),
        m[w * 4 + 3] = S.dot(v) < 0 ? -1 : 1
    }
    return m
}
function qi(a, e, t) {
    const s = new ms(a);
    return s.setPositions(e),
    t && (t.normals && s.setNormals(t.normals),
    t.tangents && s.setVertexStream(Qi, t.tangents, 4),
    t.colors && s.setColors32(t.colors),
    t.uvs && s.setUvs(0, t.uvs),
    t.uvs1 && s.setUvs(1, t.uvs1),
    t.blendIndices && s.setVertexStream(Ps, t.blendIndices, 4, t.blendIndices.length / 4, Wi),
    t.blendWeights && s.setVertexStream(Ji, t.blendWeights, 4),
    t.indices && s.setIndices(t.indices)),
    s.update(),
    s
}
function xA(a, e={}) {
    var t, s, i, n, r, o;
    const l = (t = e.tubeRadius) != null ? t : .2
      , c = (s = e.ringRadius) != null ? s : .3
      , d = ((i = e.sectorAngle) != null ? i : 360) * W.DEG_TO_RAD
      , h = (n = e.segments) != null ? n : 30
      , u = (r = e.sides) != null ? r : 20
      , f = (o = e.calculateTangents) != null ? o : !1
      , p = []
      , _ = []
      , m = []
      , g = [];
    for (let x = 0; x <= u; x++)
        for (let S = 0; S <= h; S++) {
            const w = Math.cos(d * S / h) * (c + l * Math.cos(2 * Math.PI * x / u))
              , T = Math.sin(2 * Math.PI * x / u) * l
              , b = Math.sin(d * S / h) * (c + l * Math.cos(2 * Math.PI * x / u))
              , E = Math.cos(d * S / h) * Math.cos(2 * Math.PI * x / u)
              , C = Math.sin(2 * Math.PI * x / u)
              , R = Math.sin(d * S / h) * Math.cos(2 * Math.PI * x / u)
              , F = x / u
              , L = 1 - S / h;
            if (p.push(w, T, b),
            _.push(E, C, R),
            m.push(F, 1 - L),
            x < u && S < h) {
                const U = x * (h + 1) + S
                  , I = (x + 1) * (h + 1) + S
                  , O = x * (h + 1) + (S + 1)
                  , D = (x + 1) * (h + 1) + (S + 1);
                g.push(U, I, O),
                g.push(I, D, O)
            }
        }
    const v = {
        normals: _,
        uvs: m,
        uvs1: m,
        indices: g
    };
    return f && (v.tangents = Ma(p, _, m, g)),
    qi(a, p, v)
}
function ng(a, e, t, s, i, n) {
    const r = new y
      , o = new y
      , l = new y
      , c = new y
      , d = new y
      , h = new y
      , u = []
      , f = []
      , p = []
      , _ = []
      , m = [];
    let g;
    if (t > 0)
        for (let v = 0; v <= s; v++)
            for (let x = 0; x <= i; x++) {
                const S = x / i * 2 * Math.PI - Math.PI
                  , w = Math.sin(S)
                  , T = Math.cos(S);
                d.set(w * a, -t / 2, T * a),
                c.set(w * e, t / 2, T * e),
                r.lerp(d, c, v / s),
                o.sub2(c, d).normalize(),
                h.set(T, 0, -w),
                l.cross(h, o).normalize(),
                u.push(r.x, r.y, r.z),
                f.push(l.x, l.y, l.z);
                let b = x / i
                  , E = v / s;
                p.push(b, 1 - E);
                const C = E;
                if (E = b,
                b = C,
                b = b * ks + Ts,
                E = E * ks + Ts,
                b /= 3,
                _.push(b, 1 - E),
                v < s && x < i) {
                    const R = v * (i + 1) + x
                      , F = v * (i + 1) + (x + 1)
                      , L = (v + 1) * (i + 1) + x
                      , U = (v + 1) * (i + 1) + (x + 1);
                    m.push(R, F, L),
                    m.push(F, U, L)
                }
            }
    if (n) {
        const v = Math.floor(i / 2)
          , x = i
          , S = t / 2;
        for (let w = 0; w <= v; w++) {
            const T = w * Math.PI * .5 / v
              , b = Math.sin(T)
              , E = Math.cos(T);
            for (let C = 0; C <= x; C++) {
                const R = C * 2 * Math.PI / x - Math.PI / 2
                  , F = Math.sin(R)
                  , U = Math.cos(R) * b
                  , I = E
                  , O = F * b;
                let D = 1 - C / x
                  , A = 1 - w / v;
                u.push(U * e, I * e + S, O * e),
                f.push(U, I, O),
                p.push(D, 1 - A),
                D = D * ks + Ts,
                A = A * ks + Ts,
                D /= 3,
                A /= 3,
                D += 1 / 3,
                _.push(D, 1 - A)
            }
        }
        g = (s + 1) * (i + 1);
        for (let w = 0; w < v; ++w)
            for (let T = 0; T < x; ++T) {
                const b = w * (x + 1) + T
                  , E = b + x + 1;
                m.push(g + b + 1, g + E, g + b),
                m.push(g + b + 1, g + E + 1, g + E)
            }
        for (let w = 0; w <= v; w++) {
            const T = Math.PI * .5 + w * Math.PI * .5 / v
              , b = Math.sin(T)
              , E = Math.cos(T);
            for (let C = 0; C <= x; C++) {
                const R = C * 2 * Math.PI / x - Math.PI / 2
                  , F = Math.sin(R)
                  , U = Math.cos(R) * b
                  , I = E
                  , O = F * b;
                let D = 1 - C / x
                  , A = 1 - w / v;
                u.push(U * e, I * e - S, O * e),
                f.push(U, I, O),
                p.push(D, 1 - A),
                D = D * ks + Ts,
                A = A * ks + Ts,
                D /= 3,
                A /= 3,
                D += 2 / 3,
                _.push(D, 1 - A)
            }
        }
        g = (s + 1) * (i + 1) + (x + 1) * (v + 1);
        for (let w = 0; w < v; ++w)
            for (let T = 0; T < x; ++T) {
                const b = w * (x + 1) + T
                  , E = b + x + 1;
                m.push(g + b + 1, g + E, g + b),
                m.push(g + b + 1, g + E + 1, g + E)
            }
    } else {
        if (g = (s + 1) * (i + 1),
        a > 0)
            for (let v = 0; v < i; v++) {
                const x = v / i * 2 * Math.PI
                  , S = Math.sin(x)
                  , w = -t / 2
                  , T = Math.cos(x);
                let b = 1 - (S + 1) / 2
                  , E = (T + 1) / 2;
                u.push(S * a, w, T * a),
                f.push(0, -1, 0),
                p.push(b, 1 - E),
                b = b * ks + Ts,
                E = E * ks + Ts,
                b /= 3,
                E /= 3,
                b += 1 / 3,
                _.push(b, 1 - E),
                v > 1 && m.push(g, g + v, g + v - 1)
            }
        if (g += i,
        e > 0)
            for (let v = 0; v < i; v++) {
                const x = v / i * 2 * Math.PI
                  , S = Math.sin(x)
                  , w = t / 2
                  , T = Math.cos(x);
                let b = 1 - (S + 1) / 2
                  , E = (T + 1) / 2;
                u.push(S * e, w, T * e),
                f.push(0, 1, 0),
                p.push(b, 1 - E),
                b = b * ks + Ts,
                E = E * ks + Ts,
                b /= 3,
                E /= 3,
                b += 2 / 3,
                _.push(b, 1 - E),
                v > 1 && m.push(g, g + v - 1, g + v)
            }
    }
    return {
        positions: u,
        normals: f,
        uvs: p,
        uvs1: _,
        indices: m
    }
}
function wA(a, e={}) {
    var t, s, i, n, r;
    const o = (t = e.radius) != null ? t : .5
      , l = (s = e.height) != null ? s : 1
      , c = (i = e.heightSegments) != null ? i : 5
      , d = (n = e.capSegments) != null ? n : 20
      , h = (r = e.calculateTangents) != null ? r : !1
      , u = ng(o, o, l, c, d, !1);
    return h && (u.tangents = Ma(u.positions, u.normals, u.uvs, u.indices)),
    qi(a, u.positions, u)
}
function bA(a, e={}) {
    var t, s, i, n, r;
    const o = (t = e.radius) != null ? t : .3
      , l = (s = e.height) != null ? s : 1
      , c = (i = e.heightSegments) != null ? i : 1
      , d = (n = e.sides) != null ? n : 20
      , h = (r = e.calculateTangents) != null ? r : !1
      , u = ng(o, o, l - 2 * o, c, d, !0);
    return h && (u.tangents = Ma(u.positions, u.normals, u.uvs, u.indices)),
    qi(a, u.positions, u)
}
function TA(a, e={}) {
    var t, s, i, n, r, o;
    const l = (t = e.baseRadius) != null ? t : .5
      , c = (s = e.peakRadius) != null ? s : 0
      , d = (i = e.height) != null ? i : 1
      , h = (n = e.heightSegments) != null ? n : 5
      , u = (r = e.capSegments) != null ? r : 18
      , f = (o = e.calculateTangents) != null ? o : !1
      , p = ng(l, c, d, h, u, !1);
    return f && (p.tangents = Ma(p.positions, p.normals, p.uvs, p.indices)),
    qi(a, p.positions, p)
}
function CA(a, e={}) {
    var t, s, i, n;
    const r = (t = e.radius) != null ? t : .5
      , o = (s = e.latitudeBands) != null ? s : 16
      , l = (i = e.longitudeBands) != null ? i : 16
      , c = (n = e.calculateTangents) != null ? n : !1
      , d = []
      , h = []
      , u = []
      , f = [];
    for (let _ = 0; _ <= o; _++) {
        const m = _ * Math.PI / o
          , g = Math.sin(m)
          , v = Math.cos(m);
        for (let x = 0; x <= l; x++) {
            const S = x * 2 * Math.PI / l - Math.PI / 2
              , w = Math.sin(S)
              , b = Math.cos(S) * g
              , E = v
              , C = w * g
              , R = 1 - x / l
              , F = 1 - _ / o;
            d.push(b * r, E * r, C * r),
            h.push(b, E, C),
            u.push(R, 1 - F)
        }
    }
    for (let _ = 0; _ < o; ++_)
        for (let m = 0; m < l; ++m) {
            const g = _ * (l + 1) + m
              , v = g + l + 1;
            f.push(g + 1, v, g),
            f.push(g + 1, v + 1, v)
        }
    const p = {
        normals: h,
        uvs: u,
        uvs1: u,
        indices: f
    };
    return c && (p.tangents = Ma(d, h, u, f)),
    qi(a, d, p)
}
function EA(a, e={}) {
    var t, s, i, n;
    const r = (t = e.halfExtents) != null ? t : new P(.5,.5)
      , o = (s = e.widthSegments) != null ? s : 5
      , l = (i = e.lengthSegments) != null ? i : 5
      , c = (n = e.calculateTangents) != null ? n : !1
      , d = []
      , h = []
      , u = []
      , f = [];
    let p = 0;
    for (let m = 0; m <= o; m++)
        for (let g = 0; g <= l; g++) {
            const v = -r.x + 2 * r.x * m / o
              , x = 0
              , S = -(-r.y + 2 * r.y * g / l)
              , w = m / o
              , T = g / l;
            d.push(v, x, S),
            h.push(0, 1, 0),
            u.push(w, 1 - T),
            m < o && g < l && (f.push(p + l + 1, p + 1, p),
            f.push(p + l + 1, p + l + 2, p + 1)),
            p++
        }
    const _ = {
        normals: h,
        uvs: u,
        uvs1: u,
        indices: f
    };
    return c && (_.tangents = Ma(d, h, u, f)),
    qi(a, d, _)
}
function au(a, e={}) {
    var t, s, i, n, r, o;
    const l = (t = e.halfExtents) != null ? t : new y(.5,.5,.5)
      , c = (s = e.widthSegments) != null ? s : 1
      , d = (i = e.lengthSegments) != null ? i : 1
      , h = (n = e.heightSegments) != null ? n : 1
      , u = (r = e.calculateTangents) != null ? r : !1
      , f = (o = e.yOffset) != null ? o : 0
      , p = -l.y + f
      , _ = l.y + f
      , m = [new y(-l.x,p,l.z), new y(l.x,p,l.z), new y(l.x,_,l.z), new y(-l.x,_,l.z), new y(l.x,p,-l.z), new y(-l.x,p,-l.z), new y(-l.x,_,-l.z), new y(l.x,_,-l.z)]
      , g = [[0, 1, 3], [4, 5, 7], [3, 2, 6], [1, 0, 4], [1, 4, 2], [5, 0, 6]]
      , v = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]]
      , x = {
        FRONT: 0,
        BACK: 1,
        TOP: 2,
        BOTTOM: 3,
        RIGHT: 4,
        LEFT: 5
    }
      , S = []
      , w = []
      , T = []
      , b = []
      , E = [];
    let C = 0;
    const R = (L, U, I) => {
        const O = new y
          , D = new y
          , A = new y
          , k = new y;
        for (let N = 0; N <= U; N++)
            for (let H = 0; H <= I; H++) {
                O.lerp(m[g[L][0]], m[g[L][1]], N / U),
                D.lerp(m[g[L][0]], m[g[L][2]], H / I),
                A.sub2(D, m[g[L][0]]),
                k.add2(O, A);
                let K = N / U
                  , q = H / I;
                S.push(k.x, k.y, k.z),
                w.push(v[L][0], v[L][1], v[L][2]),
                T.push(K, 1 - q),
                K = K * ks + Ts,
                q = q * ks + Ts,
                K /= 3,
                q /= 3,
                K += L % 3 / 3,
                q += Math.floor(L / 3) / 3,
                b.push(K, 1 - q),
                N < U && H < I && (E.push(C + I + 1, C + 1, C),
                E.push(C + I + 1, C + I + 2, C + 1)),
                C++
            }
    }
    ;
    R(x.FRONT, c, h),
    R(x.BACK, c, h),
    R(x.TOP, c, d),
    R(x.BOTTOM, c, d),
    R(x.RIGHT, d, h),
    R(x.LEFT, d, h);
    const F = {
        normals: w,
        uvs: T,
        uvs1: b,
        indices: E
    };
    return u && (F.tangents = Ma(S, w, T, E)),
    qi(a, S, F)
}
function ox(a, e) {
    let t = null;
    for (let s = 0; s < pl.length; s++)
        pl[s].type === e && pl[s].device === a && (t = pl[s].primData);
    if (!t) {
        let s, i;
        switch (e) {
        case "box":
            s = au(a),
            i = {
                x: 2,
                y: 2,
                z: 2,
                uv: 2 / 3
            };
            break;
        case "capsule":
            s = bA(a, {
                radius: .5,
                height: 2
            }),
            i = {
                x: Math.PI * 2,
                y: Math.PI,
                z: Math.PI * 2,
                uv: 1 / 3 + 1 / 3 / 3 * 2
            };
            break;
        case "cone":
            s = TA(a, {
                baseRadius: .5,
                peakRadius: 0,
                height: 1
            }),
            i = {
                x: 2.54,
                y: 2.54,
                z: 2.54,
                uv: 1 / 3 + 1 / 3 / 3
            };
            break;
        case "cylinder":
            s = wA(a, {
                radius: .5,
                height: 1
            }),
            i = {
                x: Math.PI,
                y: .79 * 2,
                z: Math.PI,
                uv: 1 / 3 + 1 / 3 / 3 * 2
            };
            break;
        case "plane":
            s = EA(a, {
                halfExtents: new P(.5,.5),
                widthSegments: 1,
                lengthSegments: 1
            }),
            i = {
                x: 0,
                y: 1,
                z: 0,
                uv: 1
            };
            break;
        case "sphere":
            s = CA(a, {
                radius: .5
            }),
            i = {
                x: Math.PI,
                y: Math.PI,
                z: Math.PI,
                uv: 1
            };
            break;
        case "torus":
            s = xA(a, {
                tubeRadius: .2,
                ringRadius: .3
            }),
            i = {
                x: Math.PI * .5 * .5 - Math.PI * .1 * .1,
                y: .4,
                z: .4,
                uv: 1
            };
            break;
        default:
            throw new Error("Invalid primitive type: " + e)
        }
        s.incRefCount(),
        t = {
            mesh: s,
            area: i
        },
        pl.push({
            type: e,
            device: a,
            primData: t
        })
    }
    return t
}
var AA = `
uniform float alpha_ref;
void alphaTest(float a) {
	if (a < alpha_ref) discard;
}
`
  , MA = `
void addAmbient(vec3 worldNormal) {
	dDiffuseLight += light_globalAmbient;
}
`
  , PA = `
#ifndef ENV_ATLAS
#define ENV_ATLAS
uniform sampler2D texture_envAtlas;
#endif
void addAmbient(vec3 worldNormal) {
	vec3 dir = normalize(cubeMapRotate(worldNormal) * vec3(-1.0, 1.0, 1.0));
	vec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);
	vec4 raw = texture2D(texture_envAtlas, uv);
	vec3 linear = $DECODE(raw);
	dDiffuseLight += processEnvironment(linear);
}
`
  , RA = `
uniform vec3 ambientSH[9];
void addAmbient(vec3 worldNormal) {
	vec3 n = cubeMapRotate(worldNormal);
	vec3 color =
		ambientSH[0] +
		ambientSH[1] * n.x +
		ambientSH[2] * n.y +
		ambientSH[3] * n.z +
		ambientSH[4] * n.x * n.z +
		ambientSH[5] * n.z * n.y +
		ambientSH[6] * n.y * n.x +
		ambientSH[7] * (3.0 * n.z * n.z - 1.0) +
		ambientSH[8] * (n.x * n.x - n.y * n.y);
	dDiffuseLight += processEnvironment(max(color, vec3(0.0)));
}
`
  , IA = `
void getAO() {
	dAo = 1.0;
	#ifdef MAPTEXTURE
	float aoBase = texture2DBias($SAMPLER, $UV, textureBias).$CH;
	dAo *= addAoDetail(aoBase);
	#endif
	#ifdef MAPVERTEX
	dAo *= saturate(vVertexColor.$VC);
	#endif
}
`
  , LA = `
float addAoDetail(float ao) {
#ifdef MAPTEXTURE
	float aoDetail = texture2DBias($SAMPLER, $UV, textureBias).$CH;
	return detailMode_$DETAILMODE(vec3(ao), vec3(aoDetail)).r;
#else
	return ao;
#endif
}
`
  , DA = `
void occludeDiffuse(float ao) {
	dDiffuseLight *= ao;
}
`
  , OA = `
uniform float material_occludeSpecularIntensity;
void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
	float specPow = exp2(gloss * 11.0);
	float specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01*specPow) - 1.0 + ao);
	specOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);
	dSpecularLight *= specOcc;
	dReflection *= specOcc;
	
#ifdef LIT_SHEEN
	sSpecularLight *= specOcc;
	sReflection *= specOcc;
#endif
}
`
  , FA = `
void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
	float specPow = exp2(gloss * 11.0);
	float specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01*specPow) - 1.0 + ao);
	dSpecularLight *= specOcc;
	dReflection *= specOcc;
	
#ifdef LIT_SHEEN
	sSpecularLight *= specOcc;
	sReflection *= specOcc;
#endif
}
`
  , BA = `
void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
	dSpecularLight *= ao;
	dReflection *= ao;
#ifdef LIT_SHEEN
	sSpecularLight *= ao;
	sReflection *= ao;
#endif
}
`
  , kA = `
uniform float material_occludeSpecularIntensity;
void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
	float specOcc = mix(1.0, ao, material_occludeSpecularIntensity);
	dSpecularLight *= specOcc;
	dReflection *= specOcc;
#ifdef LIT_SHEEN
	sSpecularLight *= specOcc;
	sReflection *= specOcc;
#endif
}
`
  , NA = `
uniform vec3 view_position;
uniform vec3 light_globalAmbient;
float square(float x) {
	return x*x;
}
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
vec3 saturate(vec3 x) {
	return clamp(x, vec3(0.0), vec3(1.0));
}
`
  , UA = `
attribute vec3 vertex_position;
attribute vec3 vertex_normal;
attribute vec4 vertex_tangent;
attribute vec2 vertex_texCoord0;
attribute vec2 vertex_texCoord1;
attribute vec4 vertex_color;
uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;
uniform mat3 matrix_normal;
vec3 dPositionW;
mat4 dModelMatrix;
mat3 dNormalMatrix;
`
  , zA = `
#define NINESLICED
varying vec2 vMask;
varying vec2 vTiledUv;
uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;
vec2 nineSlicedUv;
`
  , VA = `
#define NINESLICED
varying vec2 vMask;
varying vec2 vTiledUv;
uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;
`
  , GA = `
#define NINESLICED
#define NINESLICETILED
varying vec2 vMask;
varying vec2 vTiledUv;
uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;
vec2 nineSlicedUv;
`
  , HA = `
float bayer2(vec2 p) {
	return mod(2.0 * p.y + p.x + 1.0, 4.0);
}
float bayer4(vec2 p) {
	vec2 p1 = mod(p, 2.0);
	vec2 p2 = floor(0.5 * mod(p, 4.0));
	return 4.0 * bayer2(p1) + bayer2(p2);
}
float bayer8(vec2 p) {
	vec2 p1 = mod(p, 2.0);
	vec2 p2 = floor(0.5 * mod(p, 4.0));
	vec2 p4 = floor(0.25 * mod(p, 8.0));
	return 4.0 * (4.0 * bayer2(p1) + bayer2(p2)) + bayer2(p4);
}
`
  , WA = `
#define SHADOWBIAS
#define SHADOW_SAMPLE_Z_BIAS
float getShadowBias(float resolution, float maxBias) {
	return maxBias;
}
`
  , XA = `
varying vec2 vUv0;
uniform sampler2D source;
uniform vec2 pixelOffset;
#ifdef GAUSS
uniform float weight[SAMPLES];
#endif
#ifdef PACKED
float decodeFloatRG(vec2 rg) {
	return rg.y*(1.0/255.0) + rg.x;
}
vec2 encodeFloatRG( float v ) {
	vec2 enc = vec2(1.0, 255.0) * v;
	enc = fract(enc);
	enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);
	return enc;
}
#endif
void main(void) {
	vec3 moments = vec3(0.0);
	vec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);
	for (int i=0; i<SAMPLES; i++) {
		vec4 c = texture2D(source, uv + pixelOffset * float(i));
		#ifdef PACKED
		c.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));
		#endif
		#ifdef GAUSS
		moments += c.xyz * weight[i];
		#else
		moments += c.xyz;
		#endif
	}
	#ifndef GAUSS
	moments /= float(SAMPLES);
	#endif
	#ifdef PACKED
	gl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));
	#else
	gl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);
	#endif
}
`
  , jA = `
#ifdef MAPFLOAT
uniform float material_clearCoat;
#endif
void getClearCoat() {
	ccSpecularity = 1.0;
	#ifdef MAPFLOAT
	ccSpecularity *= material_clearCoat;
	#endif
	#ifdef MAPTEXTURE
	ccSpecularity *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	ccSpecularity *= saturate(vVertexColor.$VC);
	#endif
}
`
  , $A = `
#ifdef MAPFLOAT
uniform float material_clearCoatGloss;
#endif
void getClearCoatGlossiness() {
	ccGlossiness = 1.0;
	#ifdef MAPFLOAT
	ccGlossiness *= material_clearCoatGloss;
	#endif
	#ifdef MAPTEXTURE
	ccGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	ccGlossiness *= saturate(vVertexColor.$VC);
	#endif
	#ifdef MAPINVERT
	ccGlossiness = 1.0 - ccGlossiness;
	#endif
	ccGlossiness += 0.0000001;
}
`
  , qA = `
#ifdef MAPTEXTURE
uniform float material_clearCoatBumpiness;
#endif
void getClearCoatNormal() {
#ifdef MAPTEXTURE
	vec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));
	normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness);
	ccNormalW = normalize(dTBN * normalMap);
#else
	ccNormalW = dVertexNormalW;
#endif
}
`
  , YA = `
vec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)
{
	vec3 vAbs = abs(dir);
	float ma;
	vec2 uv;
	if (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {
		faceIndex = dir.z < 0.0 ? 5.0 : 4.0;
		ma = 0.5 / vAbs.z;
		uv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);
		tileOffset.x = 2.0;
		tileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;
	} else if(vAbs.y >= vAbs.x) {
		faceIndex = dir.y < 0.0 ? 3.0 : 2.0;
		ma = 0.5 / vAbs.y;
		uv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);
		tileOffset.x = 1.0;
		tileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;
	} else {
		faceIndex = dir.x < 0.0 ? 1.0 : 0.0;
		ma = 0.5 / vAbs.x;
		uv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);
		tileOffset.x = 0.0;
		tileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;
	}
	return uv * ma + 0.5;
}
vec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {
	float faceIndex;
	vec2 tileOffset;
	vec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);
	float atlasFaceSize = omniAtlasViewport.z;
	float tileSize = shadowTextureResolution * atlasFaceSize;
	float offset = shadowEdgePixels / tileSize;
	uv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);
	uv *= atlasFaceSize;
	uv += tileOffset * atlasFaceSize;
	uv += omniAtlasViewport.xy;
	return uv;
}
`
  , KA = `
vec3 _getCookieClustered(TEXTURE_ACCEPT(tex), vec2 uv, float intensity, bool isRgb, vec4 cookieChannel) {
	vec4 pixel = mix(vec4(1.0), texture2DLodEXT(tex, uv, 0.0), intensity);
	return isRgb == true ? pixel.rgb : vec3(dot(pixel, cookieChannel));
}
vec3 getCookie2DClustered(TEXTURE_ACCEPT(tex), mat4 transform, vec3 worldPosition, float intensity, bool isRgb, vec4 cookieChannel) {
	vec4 projPos = transform * vec4(worldPosition, 1.0);
	return _getCookieClustered(TEXTURE_PASS(tex), projPos.xy / projPos.w, intensity, isRgb, cookieChannel);
}
vec3 getCookieCubeClustered(TEXTURE_ACCEPT(tex), vec3 dir, float intensity, bool isRgb, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {
	vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);
	return _getCookieClustered(TEXTURE_PASS(tex), uv, intensity, isRgb, cookieChannel);
}
`
  , ZA = `
void _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {
	vec4 projPos = shadowMatrix * vec4(wPos, 1.0);
	projPos.xyz /= projPos.w;
	dShadowCoord = projPos.xyz;
}
void getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams, vec3 normal) {
	vec3 wPos = vPositionW + normal * shadowParams.y;
	_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);
}
vec3 normalOffsetPointShadow(vec4 shadowParams, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {
	float distScale = length(lightDir);
	vec3 wPos = vPositionW + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
	vec3 dir = wPos - lightPos;
	return dir;
}
#ifdef GL2
	#if defined(CLUSTER_SHADOW_TYPE_PCF1)
	float getShadowOmniClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {
		float shadowTextureResolution = shadowParams.x;
		vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
		float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
		return textureShadow(shadowMap, vec3(uv, shadowZ));
	}
	#endif
	#if defined(CLUSTER_SHADOW_TYPE_PCF3)
	float getShadowOmniClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {
		float shadowTextureResolution = shadowParams.x;
		vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
		float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
		vec3 shadowCoord = vec3(uv, shadowZ);
		return getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
	}
	#endif
	#if defined(CLUSTER_SHADOW_TYPE_PCF5)
	float getShadowOmniClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {
		float shadowTextureResolution = shadowParams.x;
		vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
		float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
		vec3 shadowCoord = vec3(uv, shadowZ);
		return getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
	}
	#endif
#else
	#if defined(CLUSTER_SHADOW_TYPE_PCF1)
	float getShadowOmniClusteredPCF1(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {
		float shadowTextureResolution = shadowParams.x;
		vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
		float depth = unpackFloat(textureShadow(shadowMap, uv));
		float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
		return depth > shadowZ ? 1.0 : 0.0;
	}
	#endif
	#if defined(CLUSTER_SHADOW_TYPE_PCF3)
	float getShadowOmniClusteredPCF3(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {
		float shadowTextureResolution = shadowParams.x;
		vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
		float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
		vec3 shadowCoord = vec3(uv, shadowZ);
		return getShadowPCF3x3(shadowMap, shadowCoord, shadowParams);
	}
	#endif
	#if defined(CLUSTER_SHADOW_TYPE_PCF5)
	float getShadowOmniClusteredPCF5(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {
		float shadowTextureResolution = shadowParams.x;
		vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
		float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
		vec3 shadowCoord = vec3(uv, shadowZ);
		return getShadowPCF3x3(shadowMap, shadowCoord, shadowParams);
	}
	#endif
#endif
#ifdef GL2
	#if defined(CLUSTER_SHADOW_TYPE_PCF1)
	float getShadowSpotClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
		return textureShadow(shadowMap, shadowCoord);
	}
	#endif
	#if defined(CLUSTER_SHADOW_TYPE_PCF3)
	float getShadowSpotClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
		return getShadowSpotPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
	}
	#endif
	#if defined(CLUSTER_SHADOW_TYPE_PCF5)
	float getShadowSpotClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
		return getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
	}
	#endif
#else
	#if defined(CLUSTER_SHADOW_TYPE_PCF1)
	float getShadowSpotClusteredPCF1(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
		float depth = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));
		return depth > shadowCoord.z ? 1.0 : 0.0;
	}
	#endif
	#if defined(CLUSTER_SHADOW_TYPE_PCF3)
	float getShadowSpotClusteredPCF3(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
		return getShadowSpotPCF3x3(shadowMap, shadowCoord, shadowParams);
	}
	#endif
	#if defined(CLUSTER_SHADOW_TYPE_PCF5)
	float getShadowSpotClusteredPCF5(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
		return getShadowSpotPCF3x3(shadowMap, shadowCoord, shadowParams);
	}
	#endif
#endif
`
  , QA = `
uniform highp sampler2D clusterWorldTexture;
uniform highp sampler2D lightsTexture8;
uniform highp sampler2D lightsTextureFloat;
#if defined(CLUSTER_COOKIES)
	#define CLUSTER_COOKIES_OR_SHADOWS
#endif
#if defined(CLUSTER_SHADOWS)
	#define CLUSTER_COOKIES_OR_SHADOWS
#endif
#ifdef CLUSTER_SHADOWS
	#ifdef GL2
		uniform sampler2DShadow shadowAtlasTexture;
	#else
		uniform sampler2D shadowAtlasTexture;
	#endif
#endif
#ifdef CLUSTER_COOKIES
	uniform sampler2D cookieAtlasTexture;
#endif
#ifdef GL2
	uniform int clusterMaxCells;
#else
	uniform float clusterMaxCells;
	uniform vec4 lightsTextureInvSize;
#endif
uniform float clusterSkip;
uniform vec3 clusterCellsCountByBoundsSize;
uniform vec3 clusterTextureSize;
uniform vec3 clusterBoundsMin;
uniform vec3 clusterBoundsDelta;
uniform vec3 clusterCellsDot;
uniform vec3 clusterCellsMax;
uniform vec2 clusterCompressionLimit0;
uniform vec2 shadowAtlasParams;
struct ClusterLightData {
	vec3 halfWidth;
	float lightType;
	vec3 halfHeight;
	#ifdef GL2
		int lightIndex;
	#else
		float lightV;
	#endif
	vec3 position;
	float shape;
	vec3 direction;
	float falloffMode;
	vec3 color;
	float shadowIntensity;
	vec3 omniAtlasViewport;
	float range;
	vec4 cookieChannelMask;
	float shadowBias;
	float shadowNormalBias;
	float innerConeAngleCos;
	float outerConeAngleCos;
	float cookie;
	float cookieRgb;
	float cookieIntensity;
	float mask;
};
mat4 lightProjectionMatrix;
#define isClusteredLightCastShadow(light) ( light.shadowIntensity > 0.0 )
#define isClusteredLightCookie(light) (light.cookie > 0.5 )
#define isClusteredLightCookieRgb(light) (light.cookieRgb > 0.5 )
#define isClusteredLightSpot(light) ( light.lightType > 0.5 )
#define isClusteredLightFalloffLinear(light) ( light.falloffMode < 0.5 )
#define isClusteredLightArea(light) ( light.shape > 0.1 )
#define isClusteredLightRect(light) ( light.shape < 0.3 )
#define isClusteredLightDisk(light) ( light.shape < 0.6 )
#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS
	#define acceptLightMask(light) ( light.mask < 0.75)
#else
	#define acceptLightMask(light) ( light.mask > 0.25)
#endif
vec4 decodeClusterLowRange4Vec4(vec4 d0, vec4 d1, vec4 d2, vec4 d3) {
	return vec4(
		bytes2floatRange4(d0, -2.0, 2.0),
		bytes2floatRange4(d1, -2.0, 2.0),
		bytes2floatRange4(d2, -2.0, 2.0),
		bytes2floatRange4(d3, -2.0, 2.0)
	);
}
#ifdef GL2
	vec4 sampleLightsTexture8(const ClusterLightData clusterLightData, int index) {
		return texelFetch(lightsTexture8, ivec2(index, clusterLightData.lightIndex), 0);
	}
	vec4 sampleLightTextureF(const ClusterLightData clusterLightData, int index) {
		return texelFetch(lightsTextureFloat, ivec2(index, clusterLightData.lightIndex), 0);
	}
#else
	vec4 sampleLightsTexture8(const ClusterLightData clusterLightData, float index) {
		return texture2DLodEXT(lightsTexture8, vec2(index * lightsTextureInvSize.z, clusterLightData.lightV), 0.0);
	}
	vec4 sampleLightTextureF(const ClusterLightData clusterLightData, float index) {
		return texture2DLodEXT(lightsTextureFloat, vec2(index * lightsTextureInvSize.x, clusterLightData.lightV), 0.0);
	}
#endif
void decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {
	#ifdef GL2
		clusterLightData.lightIndex = int(lightIndex);
	#else
		clusterLightData.lightV = (lightIndex + 0.5) * lightsTextureInvSize.w;
	#endif
	vec4 lightInfo = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_FLAGS);
	clusterLightData.lightType = lightInfo.x;
	clusterLightData.shape = lightInfo.y;
	clusterLightData.falloffMode = lightInfo.z;
	clusterLightData.shadowIntensity = lightInfo.w;
	vec4 colorA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_A);
	vec4 colorB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_B);
	clusterLightData.color = vec3(bytes2float2(colorA.xy), bytes2float2(colorA.zw), bytes2float2(colorB.xy)) * clusterCompressionLimit0.y;
	clusterLightData.cookie = colorB.z;
	clusterLightData.mask = colorB.w;
	#ifdef CLUSTER_TEXTURE_FLOAT
		vec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_POSITION_RANGE);
		clusterLightData.position = lightPosRange.xyz;
		clusterLightData.range = lightPosRange.w;
		vec4 lightDir_Unused = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_SPOT_DIRECTION);
		clusterLightData.direction = lightDir_Unused.xyz;
	#else
		vec4 encPosX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_X);
		vec4 encPosY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Y);
		vec4 encPosZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Z);
		clusterLightData.position = vec3(bytes2float4(encPosX), bytes2float4(encPosY), bytes2float4(encPosZ)) * clusterBoundsDelta + clusterBoundsMin;
		vec4 encRange = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_RANGE);
		clusterLightData.range = bytes2float4(encRange) * clusterCompressionLimit0.x;
		vec4 encDirX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_X);
		vec4 encDirY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Y);
		vec4 encDirZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Z);
		clusterLightData.direction = vec3(bytes2float4(encDirX), bytes2float4(encDirY), bytes2float4(encDirZ)) * 2.0 - 1.0;
	#endif
}
void decodeClusterLightSpot(inout ClusterLightData clusterLightData) {
	vec4 coneAngle = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_ANGLES);
	clusterLightData.innerConeAngleCos = bytes2float2(coneAngle.xy) * 2.0 - 1.0;
	clusterLightData.outerConeAngleCos = bytes2float2(coneAngle.zw) * 2.0 - 1.0;
}
void decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {
	#ifdef CLUSTER_TEXTURE_FLOAT
		clusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0).xyz;
	#else
		vec4 viewportA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_A);
		vec4 viewportB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_B);
		clusterLightData.omniAtlasViewport = vec3(bytes2float2(viewportA.xy), bytes2float2(viewportA.zw), bytes2float2(viewportB.xy));
	#endif
}
void decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {
	#ifdef CLUSTER_TEXTURE_FLOAT
		clusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_WIDTH).xyz;
		clusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_HEIGHT).xyz;
	#else
		vec4 areaWidthX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_X);
		vec4 areaWidthY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Y);
		vec4 areaWidthZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Z);
		clusterLightData.halfWidth = vec3(mantissaExponent2Float(areaWidthX), mantissaExponent2Float(areaWidthY), mantissaExponent2Float(areaWidthZ));
		vec4 areaHeightX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_X);
		vec4 areaHeightY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Y);
		vec4 areaHeightZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Z);
		clusterLightData.halfHeight = vec3(mantissaExponent2Float(areaHeightX), mantissaExponent2Float(areaHeightY), mantissaExponent2Float(areaHeightZ));
	#endif
}
void decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {
	
	#ifdef CLUSTER_TEXTURE_FLOAT
		vec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0);
		vec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_1);
		vec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_2);
		vec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_3);
	#else
		vec4 m00 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_00);
		vec4 m01 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_01);
		vec4 m02 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_02);
		vec4 m03 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_03);
		vec4 m0 = decodeClusterLowRange4Vec4(m00, m01, m02, m03);
		vec4 m10 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_10);
		vec4 m11 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_11);
		vec4 m12 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_12);
		vec4 m13 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_13);
		vec4 m1 = decodeClusterLowRange4Vec4(m10, m11, m12, m13);
		vec4 m20 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_20);
		vec4 m21 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_21);
		vec4 m22 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_22);
		vec4 m23 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_23);
		vec4 m2 = decodeClusterLowRange4Vec4(m20, m21, m22, m23);
		vec4 m30 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_30);
		vec4 m31 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_31);
		vec4 m32 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_32);
		vec4 m33 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_33);
		vec4 m3 = vec4(mantissaExponent2Float(m30), mantissaExponent2Float(m31), mantissaExponent2Float(m32), mantissaExponent2Float(m33));
	#endif
	
	lightProjectionMatrix = mat4(m0, m1, m2, m3);
}
void decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {
	
	vec4 biases = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SHADOW_BIAS);
	clusterLightData.shadowBias = bytes2floatRange2(biases.xy, -1.0, 20.0),
	clusterLightData.shadowNormalBias = bytes2float2(biases.zw);
}
void decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {
	vec4 cookieA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_A);
	clusterLightData.cookieIntensity = cookieA.x;
	clusterLightData.cookieRgb = cookieA.y;
	clusterLightData.cookieChannelMask = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_B);
}
void evaluateLight(
	ClusterLightData light, 
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir,
#if defined(LIT_CLEARCOAT)
	vec3 clearcoatReflectionDir,
#endif
	float gloss, 
	vec3 specularity, 
	vec3 geometricNormal, 
	mat3 tbn, 
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel,
#endif
	vec3 clearcoat_worldNormal,
	float clearcoat_gloss,
	float sheen_gloss,
	float iridescence_intensity
) {
	vec3 cookieAttenuation = vec3(1.0);
	float diffuseAttenuation = 1.0;
	float falloffAttenuation = 1.0;
	getLightDirPoint(light.position);
	#ifdef CLUSTER_AREALIGHTS
	if (isClusteredLightArea(light)) {
		decodeClusterLightAreaData(light);
		if (isClusteredLightRect(light)) {
			calcRectLightValues(light.position, light.halfWidth, light.halfHeight);
		} else if (isClusteredLightDisk(light)) {
			calcDiskLightValues(light.position, light.halfWidth, light.halfHeight);
		} else {
			calcSphereLightValues(light.position, light.halfWidth, light.halfHeight);
		}
		falloffAttenuation = getFalloffWindow(light.range, dLightDirW);
	} else
	#endif
	{
		if (isClusteredLightFalloffLinear(light))
			falloffAttenuation = getFalloffLinear(light.range, dLightDirW);
		else
			falloffAttenuation = getFalloffInvSquared(light.range, dLightDirW);
	}
	if (falloffAttenuation > 0.00001) {
		#ifdef CLUSTER_AREALIGHTS
		if (isClusteredLightArea(light)) {
			if (isClusteredLightRect(light)) {
				diffuseAttenuation = getRectLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;
			} else if (isClusteredLightDisk(light)) {
				diffuseAttenuation = getDiskLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;
			} else {
				diffuseAttenuation = getSphereLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;
			}
		} else
		#endif
		{
			falloffAttenuation *= getLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW); 
		}
		if (isClusteredLightSpot(light)) {
			decodeClusterLightSpot(light);
			falloffAttenuation *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos, dLightDirNormW);
		}
		#if defined(CLUSTER_COOKIES_OR_SHADOWS)
		if (falloffAttenuation > 0.00001) {
			if (isClusteredLightCastShadow(light) || isClusteredLightCookie(light)) {
				if (isClusteredLightSpot(light)) {
					decodeClusterLightProjectionMatrixData(light);
				} else {
					decodeClusterLightOmniAtlasViewport(light);
				}
				float shadowTextureResolution = shadowAtlasParams.x;
				float shadowEdgePixels = shadowAtlasParams.y;
				#ifdef CLUSTER_COOKIES
				if (isClusteredLightCookie(light)) {
					decodeClusterLightCookieData(light);
					if (isClusteredLightSpot(light)) {
						cookieAttenuation = getCookie2DClustered(TEXTURE_PASS(cookieAtlasTexture), lightProjectionMatrix, vPositionW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask);
					} else {
						cookieAttenuation = getCookieCubeClustered(TEXTURE_PASS(cookieAtlasTexture), dLightDirW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);
					}
				}
				#endif
				#ifdef CLUSTER_SHADOWS
				if (isClusteredLightCastShadow(light)) {
					decodeClusterLightShadowData(light);
					vec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);
					if (isClusteredLightSpot(light)) {
						getShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams, geometricNormal);
						
						#if defined(CLUSTER_SHADOW_TYPE_PCF1)
							float shadow = getShadowSpotClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF3)
							float shadow = getShadowSpotClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF5)
							float shadow = getShadowSpotClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
						#elif defined(CLUSTER_SHADOW_TYPE_PCSS)
							float shadow = getShadowSpotClusteredPCSS(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
						#endif
						falloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);
					} else {
						vec3 dir = normalOffsetPointShadow(shadowParams, dLightPosW, dLightDirW, dLightDirNormW, geometricNormal);
						#if defined(CLUSTER_SHADOW_TYPE_PCF1)
							float shadow = getShadowOmniClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF3)
							float shadow = getShadowOmniClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF5)
							float shadow = getShadowOmniClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
						#endif
						falloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);
					}
				}
				#endif
			}
		}
		#endif
		#ifdef CLUSTER_AREALIGHTS
		if (isClusteredLightArea(light)) {
			{
				vec3 areaDiffuse = (diffuseAttenuation * falloffAttenuation) * light.color * cookieAttenuation;
				#if defined(LIT_SPECULAR)
					#if defined(LIT_CONSERVE_ENERGY)
						areaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);
					#endif
				#endif
				dDiffuseLight += areaDiffuse;
			}
			#ifdef LIT_SPECULAR
				float areaLightSpecular;
				if (isClusteredLightRect(light)) {
					areaLightSpecular = getRectLightSpecular(worldNormal, viewDir);
				} else if (isClusteredLightDisk(light)) {
					areaLightSpecular = getDiskLightSpecular(worldNormal, viewDir);
				} else {
					areaLightSpecular = getSphereLightSpecular(worldNormal, viewDir);
				}
				dSpecularLight += dLTCSpecFres * areaLightSpecular * falloffAttenuation * light.color * cookieAttenuation;
				#ifdef LIT_CLEARCOAT
					float areaLightSpecularCC;
					if (isClusteredLightRect(light)) {
						areaLightSpecularCC = getRectLightSpecular(clearcoat_worldNormal, viewDir);
					} else if (isClusteredLightDisk(light)) {
						areaLightSpecularCC = getDiskLightSpecular(clearcoat_worldNormal, viewDir);
					} else {
						areaLightSpecularCC = getSphereLightSpecular(clearcoat_worldNormal, viewDir);
					}
					ccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * falloffAttenuation * light.color  * cookieAttenuation;
				#endif
			#endif
		} else
		#endif
		{
			{
				vec3 punctualDiffuse = falloffAttenuation * light.color * cookieAttenuation;
				#if defined(CLUSTER_AREALIGHTS)
				#if defined(LIT_SPECULAR)
				#if defined(LIT_CONSERVE_ENERGY)
					punctualDiffuse = mix(punctualDiffuse, vec3(0), specularity);
				#endif
				#endif
				#endif
				dDiffuseLight += punctualDiffuse;
			}
	 
			#ifdef LIT_SPECULAR
				vec3 halfDir = normalize(-dLightDirNormW + viewDir);
				
				#ifdef LIT_SPECULAR_FRESNEL
					dSpecularLight += 
						getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dLightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * 
						getFresnel(
							dot(viewDir, halfDir), 
							gloss, 
							specularity
						#if defined(LIT_IRIDESCENCE)
							, iridescenceFresnel,
							iridescence_intensity
						#endif
							);
				#else
					dSpecularLight += getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dLightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * specularity;
				#endif
				#ifdef LIT_CLEARCOAT
					#ifdef LIT_SPECULAR_FRESNEL
						ccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, dLightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * getFresnelCC(dot(viewDir, halfDir));
					#else
						ccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, dLightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation; 
					#endif
				#endif
				#ifdef LIT_SHEEN
					sSpecularLight += getLightSpecularSheen(halfDir, worldNormal, viewDir, dLightDirNormW, sheen_gloss) * falloffAttenuation * light.color * cookieAttenuation;
				#endif
			#endif
		}
	}
	dAtten = falloffAttenuation;
	dAttenD = diffuseAttenuation;
	dAtten3 = cookieAttenuation;
}
void evaluateClusterLight(
	float lightIndex, 
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir, 
#if defined(LIT_CLEARCOAT)
	vec3 clearcoatReflectionDir,
#endif
	float gloss, 
	vec3 specularity, 
	vec3 geometricNormal, 
	mat3 tbn, 
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel,
#endif
	vec3 clearcoat_worldNormal,
	float clearcoat_gloss,
	float sheen_gloss,
	float iridescence_intensity
) {
	ClusterLightData clusterLightData;
	decodeClusterLightCore(clusterLightData, lightIndex);
	if (acceptLightMask(clusterLightData))
		evaluateLight(
			clusterLightData, 
			worldNormal, 
			viewDir, 
			reflectionDir, 
#if defined(LIT_CLEARCOAT)
			clearcoatReflectionDir, 
#endif
			gloss, 
			specularity, 
			geometricNormal, 
			tbn, 
#if defined(LIT_IRIDESCENCE)
			iridescenceFresnel,
#endif
			clearcoat_worldNormal,
			clearcoat_gloss,
			sheen_gloss,
			iridescence_intensity
		);
}
void addClusteredLights(
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir, 
#if defined(LIT_CLEARCOAT)
	vec3 clearcoatReflectionDir,
#endif
	float gloss, 
	vec3 specularity, 
	vec3 geometricNormal, 
	mat3 tbn, 
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel,
#endif
	vec3 clearcoat_worldNormal,
	float clearcoat_gloss,
	float sheen_gloss,
	float iridescence_intensity
) {
	if (clusterSkip > 0.5)
		return;
	vec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);
	if (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {
		float cellIndex = dot(clusterCellsDot, cellCoords);
		float clusterV = floor(cellIndex * clusterTextureSize.y);
		float clusterU = cellIndex - (clusterV * clusterTextureSize.x);
		#ifdef GL2
			for (int lightCellIndex = 0; lightCellIndex < clusterMaxCells; lightCellIndex++) {
				float lightIndex = texelFetch(clusterWorldTexture, ivec2(int(clusterU) + lightCellIndex, clusterV), 0).x;
				if (lightIndex <= 0.0)
						return;
				evaluateClusterLight(
					lightIndex * 255.0, 
					worldNormal, 
					viewDir, 
					reflectionDir,
#if defined(LIT_CLEARCOAT)
					clearcoatReflectionDir,
#endif
					gloss, 
					specularity, 
					geometricNormal, 
					tbn, 
#if defined(LIT_IRIDESCENCE)
					iridescenceFresnel,
#endif
					clearcoat_worldNormal,
					clearcoat_gloss,
					sheen_gloss,
					iridescence_intensity
				); 
			}
		#else
			clusterV = (clusterV + 0.5) * clusterTextureSize.z;
			const float maxLightCells = 256.0;
			for (float lightCellIndex = 0.5; lightCellIndex < maxLightCells; lightCellIndex++) {
				float lightIndex = texture2DLodEXT(clusterWorldTexture, vec2(clusterTextureSize.y * (clusterU + lightCellIndex), clusterV), 0.0).x;
				if (lightIndex <= 0.0)
					return;
				
				evaluateClusterLight(
					lightIndex * 255.0, 
					worldNormal, 
					viewDir, 
					reflectionDir,
#if defined(LIT_CLEARCOAT)
					clearcoatReflectionDir,
#endif
					gloss, 
					specularity, 
					geometricNormal, 
					tbn, 
#if defined(LIT_IRIDESCENCE)
					iridescenceFresnel,
#endif
					clearcoat_worldNormal,
					clearcoat_gloss,
					sheen_gloss,
					iridescence_intensity
				); 
				if (lightCellIndex >= clusterMaxCells) {
					break;
				}
			}
		#endif
	}
}
`
  , JA = `
vec3 combineColor(vec3 albedo, vec3 sheenSpecularity, float clearcoatSpecularity) {
	vec3 ret = vec3(0);
#ifdef LIT_OLD_AMBIENT
	ret += (dDiffuseLight - light_globalAmbient) * albedo + material_ambient * light_globalAmbient;
#else
	ret += albedo * dDiffuseLight;
#endif
#ifdef LIT_SPECULAR
	ret += dSpecularLight;
#endif
#ifdef LIT_REFLECTIONS
	ret += dReflection.rgb * dReflection.a;
#endif
#ifdef LIT_SHEEN
	float sheenScaling = 1.0 - max(max(sheenSpecularity.r, sheenSpecularity.g), sheenSpecularity.b) * 0.157;
	ret = ret * sheenScaling + (sSpecularLight + sReflection.rgb) * sheenSpecularity;
#endif
#ifdef LIT_CLEARCOAT
	float clearCoatScaling = 1.0 - ccFresnel * clearcoatSpecularity;
	ret = ret * clearCoatScaling + (ccSpecularLight + ccReflection.rgb) * clearcoatSpecularity;
#endif
	return ret;
}
`
  , e1 = `
vec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {
	vec4 projPos = transform * vec4(vPositionW, 1.0);
	projPos.xy /= projPos.w;
	return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);
}
vec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {
	vec4 projPos = transform * vec4(vPositionW, 1.0);
	projPos.xy /= projPos.w;
	if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);
	return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);
}
vec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {
	vec4 projPos = transform * vec4(vPositionW, 1.0);
	projPos.xy /= projPos.w;
	projPos.xy += cookieOffset;
	vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);
	return mix(vec4(1.0), texture2D(tex, uv), intensity);
}
vec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {
	vec4 projPos = transform * vec4(vPositionW, 1.0);
	projPos.xy /= projPos.w;
	projPos.xy += cookieOffset;
	if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);
	vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);
	return mix(vec4(1.0), texture2D(tex, uv), intensity);
}
vec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {
	return mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);
}
`
  , t1 = `
uniform vec3 envBoxMin;
uniform vec3 envBoxMax;
vec3 cubeMapProject(vec3 nrdir) {
	nrdir = cubeMapRotate(nrdir);
	vec3 rbmax = (envBoxMax - vPositionW) / nrdir;
	vec3 rbmin = (envBoxMin - vPositionW) / nrdir;
	vec3 rbminmax;
	rbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;
	rbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;
	rbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;
	float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);
	vec3 posonbox = vPositionW + nrdir * fa;
	vec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;
	return normalize(posonbox - envBoxPos);
}
`
  , s1 = `
vec3 cubeMapProject(vec3 dir) {
	return cubeMapRotate(dir);
}
`
  , i1 = `
#ifdef CUBEMAP_ROTATION
uniform mat3 cubeMapRotationMatrix;
#endif
vec3 cubeMapRotate(vec3 refDir) {
#ifdef CUBEMAP_ROTATION
	return refDir * cubeMapRotationMatrix;
#else
	return refDir;
#endif
}
`
  , n1 = `
#ifdef DEBUG_ALBEDO_PASS
gl_FragColor = vec4(gammaCorrectOutput(litArgs_albedo), 1.0);
#endif
#ifdef DEBUG_UV0_PASS
gl_FragColor = vec4(litArgs_albedo , 1.0);
#endif
#ifdef DEBUG_WORLD_NORMAL_PASS
gl_FragColor = vec4(litArgs_worldNormal * 0.5 + 0.5, 1.0);
#endif
#ifdef DEBUG_OPACITY_PASS
gl_FragColor = vec4(vec3(litArgs_opacity) , 1.0);
#endif
#ifdef DEBUG_SPECULARITY_PASS
gl_FragColor = vec4(litArgs_specularity, 1.0);
#endif
#ifdef DEBUG_GLOSS_PASS
gl_FragColor = vec4(vec3(litArgs_gloss) , 1.0);
#endif
#ifdef DEBUG_METALNESS_PASS
gl_FragColor = vec4(vec3(litArgs_metalness) , 1.0);
#endif
#ifdef DEBUG_AO_PASS
gl_FragColor = vec4(vec3(litArgs_ao) , 1.0);
#endif
#ifdef DEBUG_EMISSION_PASS
gl_FragColor = vec4(gammaCorrectOutput(litArgs_emission), 1.0);
#endif
`
  , r1 = `
#ifdef DEBUG_LIGHTING_PASS
litArgs_albedo = vec3(0.5);
#endif
#ifdef DEBUG_UV0_PASS
#ifdef VARYING_VUV0
litArgs_albedo = vec3(vUv0, 0);
#else
litArgs_albedo = vec3(0);
#endif
#endif
`
  , lx = `
vec3 decodeLinear(vec4 raw) {
	return raw.rgb;
}
float decodeGamma(float raw) {
	return pow(raw, 2.2);
}
vec3 decodeGamma(vec3 raw) {
	return pow(raw, vec3(2.2));
}
vec3 decodeGamma(vec4 raw) {
	return pow(raw.xyz, vec3(2.2));
}
vec3 decodeRGBM(vec4 raw) {
	vec3 color = (8.0 * raw.a) * raw.rgb;
	return color * color;
}
vec3 decodeRGBP(vec4 raw) {
	vec3 color = raw.rgb * (-raw.a * 7.0 + 8.0);
	return color * color;
}
vec3 decodeRGBE(vec4 raw) {
	if (raw.a == 0.0) {
		return vec3(0.0, 0.0, 0.0);
	} else {
		return raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);
	}
}
vec4 passThrough(vec4 raw) {
	return raw;
}
`
  , a1 = `
vec3 detailMode_mul(vec3 c1, vec3 c2) {
	return c1 * c2;
}
vec3 detailMode_add(vec3 c1, vec3 c2) {
	return c1 + c2;
}
vec3 detailMode_screen(vec3 c1, vec3 c2) {
	return 1.0 - (1.0 - c1)*(1.0 - c2);
}
vec3 detailMode_overlay(vec3 c1, vec3 c2) {
	return mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));
}
vec3 detailMode_min(vec3 c1, vec3 c2) {
	return min(c1, c2);
}
vec3 detailMode_max(vec3 c1, vec3 c2) {
	return max(c1, c2);
}
`
  , o1 = `
#ifdef MAPCOLOR
uniform vec3 material_diffuse;
#endif
void getAlbedo() {
	dAlbedo = vec3(1.0);
#ifdef MAPCOLOR
	dAlbedo *= material_diffuse.rgb;
#endif
#ifdef MAPTEXTURE
	vec3 albedoBase = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
	dAlbedo *= addAlbedoDetail(albedoBase);
#endif
#ifdef MAPVERTEX
	dAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));
#endif
}
`
  , l1 = `
vec3 addAlbedoDetail(vec3 albedo) {
#ifdef MAPTEXTURE
	vec3 albedoDetail = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
	return detailMode_$DETAILMODE(albedo, albedoDetail);
#else
	return albedo;
#endif
}
`
  , h1 = `
#ifdef MAPCOLOR
uniform vec3 material_emissive;
#endif
#ifdef MAPFLOAT
uniform float material_emissiveIntensity;
#endif
void getEmission() {
	dEmission = vec3(1.0);
	#ifdef MAPFLOAT
	dEmission *= material_emissiveIntensity;
	#endif
	#ifdef MAPCOLOR
	dEmission *= material_emissive;
	#endif
	#ifdef MAPTEXTURE
	dEmission *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
	#endif
	#ifdef MAPVERTEX
	dEmission *= gammaCorrectInput(saturate(vVertexColor.$VC));
	#endif
}
`
  , hx = `
vec4 encodeLinear(vec3 source) {
	return vec4(source, 1.0);
}
vec4 encodeGamma(vec3 source) {
	return vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);
}
vec4 encodeRGBM(vec3 source) {
	vec4 result;
	result.rgb = pow(source.rgb, vec3(0.5));
	result.rgb *= 1.0 / 8.0;
	result.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );
	result.a = ceil(result.a * 255.0) / 255.0;
	result.rgb /= result.a;
	return result;
}
vec4 encodeRGBP(vec3 source) {
	vec3 gamma = pow(source, vec3(0.5));
	float maxVal = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));
	float v = 1.0 - ((maxVal - 1.0) / 7.0);
	v = ceil(v * 255.0) / 255.0;
	return vec4(gamma / (-v * 7.0 + 8.0), v);	
}
vec4 encodeRGBE(vec3 source) {
	float maxVal = max(source.x, max(source.y, source.z));
	if (maxVal < 1e-32) {
		return vec4(0, 0, 0, 0);
	} else {
		float e = ceil(log2(maxVal));
		return vec4(source / pow(2.0, e), (e + 128.0) / 255.0);
	}
}
`
  , c1 = `
	gl_FragColor.rgb = combineColor(litArgs_albedo, litArgs_sheen_specularity, litArgs_clearcoat_specularity);
	gl_FragColor.rgb += litArgs_emission;
	gl_FragColor.rgb = addFog(gl_FragColor.rgb);
	#ifndef HDR
	gl_FragColor.rgb = toneMap(gl_FragColor.rgb);
	gl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);
	#endif
`
  , d1 = `
`
  , u1 = `
const float atlasSize = 512.0;
const float seamSize = 1.0 / atlasSize;
vec2 mapUv(vec2 uv, vec4 rect) {
	return vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),
				mix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));
}
vec2 mapRoughnessUv(vec2 uv, float level) {
	float t = 1.0 / exp2(level);
	return mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));
}
vec2 mapShinyUv(vec2 uv, float level) {
	float t = 1.0 / exp2(level);
	return mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));
}
`
  , f1 = `
vec3 processEnvironment(vec3 color) {
	return color;
}
`
  , p1 = `
uniform float skyboxIntensity;
vec3 processEnvironment(vec3 color) {
	return color * skyboxIntensity;
}
`
  , m1 = `
`
  , _1 = `
`
  , g1 = `
float getFalloffWindow(float lightRadius, vec3 lightDir) {
	float sqrDist = dot(lightDir, lightDir);
	float invRadius = 1.0 / lightRadius;
	return square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );
}
float getFalloffInvSquared(float lightRadius, vec3 lightDir) {
	float sqrDist = dot(lightDir, lightDir);
	float falloff = 1.0 / (sqrDist + 1.0);
	float invRadius = 1.0 / lightRadius;
	falloff *= 16.0;
	falloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );
	return falloff;
}
`
  , y1 = `
float getFalloffLinear(float lightRadius, vec3 lightDir) {
	float d = length(lightDir);
	return max(((lightRadius - d) / lightRadius), 0.0);
}
`
  , v1 = `
vec3 fixSeams(vec3 vec, float mipmapIndex) {
	return vec;
}
vec3 fixSeams(vec3 vec) {
	return vec;
}
vec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {
	return vec;
}
vec3 calcSeam(vec3 vec) {
	return vec3(0);
}
vec3 applySeam(vec3 vec, vec3 seam, float scale) {
	return vec;
}
`
  , S1 = `
vec3 fixSeams(vec3 vec, float mipmapIndex) {
	vec3 avec = abs(vec);
	float scale = 1.0 - exp2(mipmapIndex) / 128.0;
	float M = max(max(avec.x, avec.y), avec.z);
	if (avec.x != M) vec.x *= scale;
	if (avec.y != M) vec.y *= scale;
	if (avec.z != M) vec.z *= scale;
	return vec;
}
vec3 fixSeams(vec3 vec) {
	vec3 avec = abs(vec);
	float scale = 1.0 - 1.0 / 128.0;
	float M = max(max(avec.x, avec.y), avec.z);
	if (avec.x != M) vec.x *= scale;
	if (avec.y != M) vec.y *= scale;
	if (avec.z != M) vec.z *= scale;
	return vec;
}
vec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {
	vec3 avec = abs(vec);
	float scale = invRecMipSize;
	float M = max(max(avec.x, avec.y), avec.z);
	if (avec.x != M) vec.x *= scale;
	if (avec.y != M) vec.y *= scale;
	if (avec.z != M) vec.z *= scale;
	return vec;
}
vec3 calcSeam(vec3 vec) {
	vec3 avec = abs(vec);
	float M = max(avec.x, max(avec.y, avec.z));
	return vec3(avec.x != M ? 1.0 : 0.0,
				avec.y != M ? 1.0 : 0.0,
				avec.z != M ? 1.0 : 0.0);
}
vec3 applySeam(vec3 vec, vec3 seam, float scale) {
	return vec * (seam * -scale + vec3(1.0));
}
`
  , x1 = `
float bytes2float2(vec2 data) {
	return dot(data, vec2(1.0, 1.0 / 255.0));
}
float bytes2float3(vec3 data) {
	return dot(data, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));
}
float bytes2float4(vec4 data) {
	return dot(data, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
}
float bytes2floatRange2(vec2 data, float min, float max) {
	return mix(min, max, bytes2float2(data));
}
float bytes2floatRange3(vec3 data, float min, float max) {
	return mix(min, max, bytes2float3(data));
}
float bytes2floatRange4(vec4 data, float min, float max) {
	return mix(min, max, bytes2float4(data));
}
float mantissaExponent2Float(vec4 pack)
{
	float value = bytes2floatRange3(pack.xyz, -1.0, 1.0);
	float exponent = floor(pack.w * 255.0 - 127.0);
	return value * exp2(exponent);
}
`
  , w1 = `
uniform vec3 fog_color;
uniform float fog_density;
float dBlendModeFogFactor = 1.0;
vec3 addFog(vec3 color) {
	float depth = gl_FragCoord.z / gl_FragCoord.w;
	float fogFactor = exp(-depth * fog_density);
	fogFactor = clamp(fogFactor, 0.0, 1.0);
	return mix(fog_color * dBlendModeFogFactor, color, fogFactor);
}
`
  , b1 = `
uniform vec3 fog_color;
uniform float fog_density;
float dBlendModeFogFactor = 1.0;
vec3 addFog(vec3 color) {
	float depth = gl_FragCoord.z / gl_FragCoord.w;
	float fogFactor = exp(-depth * depth * fog_density * fog_density);
	fogFactor = clamp(fogFactor, 0.0, 1.0);
	return mix(fog_color * dBlendModeFogFactor, color, fogFactor);
}
`
  , T1 = `
uniform vec3 fog_color;
uniform float fog_start;
uniform float fog_end;
float dBlendModeFogFactor = 1.0;
vec3 addFog(vec3 color) {
	float depth = gl_FragCoord.z / gl_FragCoord.w;
	float fogFactor = (fog_end - depth) / (fog_end - fog_start);
	fogFactor = clamp(fogFactor, 0.0, 1.0);
	return mix(fog_color * dBlendModeFogFactor, color, fogFactor);
}
`
  , C1 = `
float dBlendModeFogFactor = 1.0;
vec3 addFog(vec3 color) {
	return color;
}
`
  , E1 = `
vec3 getFresnel(
		float cosTheta, 
		float gloss, 
		vec3 specularity
#if defined(LIT_IRIDESCENCE)
		, vec3 iridescenceFresnel, 
		float iridescenceIntensity
#endif
	) {
	float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);
	float glossSq = gloss * gloss;
	vec3 ret = specularity + (max(vec3(glossSq), specularity) - specularity) * fresnel;
#if defined(LIT_IRIDESCENCE)
	return mix(ret, iridescenceFresnel, iridescenceIntensity);
#else
	return ret;
#endif	
}
float getFresnelCC(float cosTheta) {
	float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);
	return 0.04 + (1.0 - 0.04) * fresnel;
}
`
  , A1 = `
varying vec2 vUv0;
uniform sampler2D source;
void main(void) {
	gl_FragColor = texture2D(source, vUv0);
}
`
  , M1 = `
attribute vec2 vertex_position;
varying vec2 vUv0;
void main(void)
{
	gl_Position = vec4(vertex_position, 0.5, 1.0);
	vUv0 = vertex_position.xy*0.5+0.5;
}
`
  , P1 = `
float gammaCorrectInput(float color) {
	return color;
}
vec3 gammaCorrectInput(vec3 color) {
	return color;
}
vec4 gammaCorrectInput(vec4 color) {
	return color;
}
vec3 gammaCorrectOutput(vec3 color) {
	return color;
}
`
  , R1 = `
float gammaCorrectInput(float color) {
	return decodeGamma(color);
}
vec3 gammaCorrectInput(vec3 color) {
	return decodeGamma(color);
}
vec4 gammaCorrectInput(vec4 color) {
	return vec4(decodeGamma(color.xyz), color.w);
}
vec3 gammaCorrectOutput(vec3 color) {
#ifdef HDR
	return color;
#else
	return pow(color + 0.0000001, vec3(1.0 / 2.2));
#endif
}
`
  , I1 = `
#ifdef MAPFLOAT
uniform float material_gloss;
#endif
void getGlossiness() {
	dGlossiness = 1.0;
	#ifdef MAPFLOAT
	dGlossiness *= material_gloss;
	#endif
	#ifdef MAPTEXTURE
	dGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	dGlossiness *= saturate(vVertexColor.$VC);
	#endif
	#ifdef MAPINVERT
	dGlossiness = 1.0 - dGlossiness;
	#endif
	dGlossiness += 0.0000001;
}
`
  , L1 = `
uniform float material_iridescenceRefractionIndex;
#ifndef PI
#define PI 3.14159265
#endif
float iridescence_iorToFresnel(float transmittedIor, float incidentIor) {
	return pow((transmittedIor - incidentIor) / (transmittedIor + incidentIor), 2.0);
}
vec3 iridescence_iorToFresnel(vec3 transmittedIor, float incidentIor) {
	return pow((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)), vec3(2.0));
}
vec3 iridescence_fresnelToIor(vec3 f0) {
	vec3 sqrtF0 = sqrt(f0);
	return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}
vec3 iridescence_sensitivity(float opd, vec3 shift) {
	float phase = 2.0 * PI * opd * 1.0e-9;
	const vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);
	const vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);
	const vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);
	vec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-pow(phase, 2.0) * var);
	xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * pow(phase, 2.0));
	xyz /= vec3(1.0685e-07);
	const mat3 XYZ_TO_REC709 = mat3(
		3.2404542, -0.9692660,  0.0556434,
	   -1.5371385,  1.8760108, -0.2040259,
	   -0.4985314,  0.0415560,  1.0572252
	);
	return XYZ_TO_REC709 * xyz;
}
float iridescence_fresnel(float cosTheta, float f0) {
	float x = clamp(1.0 - cosTheta, 0.0, 1.0);
	float x2 = x * x;
	float x5 = x * x2 * x2;
	return f0 + (1.0 - f0) * x5;
} 
vec3 iridescence_fresnel(float cosTheta, vec3 f0) {
	float x = clamp(1.0 - cosTheta, 0.0, 1.0);
	float x2 = x * x;
	float x5 = x * x2 * x2; 
	return f0 + (vec3(1.0) - f0) * x5;
}
vec3 calcIridescence(float outsideIor, float cosTheta, vec3 base_f0, float iridescenceThickness) {
	float iridescenceIor = mix(outsideIor, material_iridescenceRefractionIndex, smoothstep(0.0, 0.03, iridescenceThickness));
	float sinTheta2Sq = pow(outsideIor / iridescenceIor, 2.0) * (1.0 - pow(cosTheta, 2.0));
	float cosTheta2Sq = 1.0 - sinTheta2Sq;
	if (cosTheta2Sq < 0.0) {
		return vec3(1.0);
	}
	float cosTheta2 = sqrt(cosTheta2Sq);
	float r0 = iridescence_iorToFresnel(iridescenceIor, outsideIor);
	float r12 = iridescence_fresnel(cosTheta, r0);
	float r21 = r12;
	float t121 = 1.0 - r12;
	float phi12 = iridescenceIor < outsideIor ? PI : 0.0;
	float phi21 = PI - phi12;
	vec3 baseIor = iridescence_fresnelToIor(base_f0 + vec3(0.0001));
	vec3 r1 = iridescence_iorToFresnel(baseIor, iridescenceIor);
	vec3 r23 = iridescence_fresnel(cosTheta2, r1);
	vec3 phi23 = vec3(0.0);
	if (baseIor[0] < iridescenceIor) phi23[0] = PI;
	if (baseIor[1] < iridescenceIor) phi23[1] = PI;
	if (baseIor[2] < iridescenceIor) phi23[2] = PI;
	float opd = 2.0 * iridescenceIor * iridescenceThickness * cosTheta2;
	vec3 phi = vec3(phi21) + phi23; 
	vec3 r123Sq = clamp(r12 * r23, 1e-5, 0.9999);
	vec3 r123 = sqrt(r123Sq);
	vec3 rs = pow(t121, 2.0) * r23 / (1.0 - r123Sq);
	vec3 c0 = r12 + rs;
	vec3 i = c0;
	vec3 cm = rs - t121;
	for (int m = 1; m <= 2; m++) {
		cm *= r123;
		vec3 sm = 2.0 * iridescence_sensitivity(float(m) * opd, float(m) * phi);
		i += cm * sm;
	}
	return max(i, vec3(0.0));
}
vec3 getIridescence(float cosTheta, vec3 specularity, float iridescenceThickness) {
	return calcIridescence(1.0, cosTheta, specularity, iridescenceThickness);
}
`
  , D1 = `
#ifdef MAPFLOAT
uniform float material_iridescence;
#endif
void getIridescence() {
	float iridescence = 1.0;
	#ifdef MAPFLOAT
	iridescence *= material_iridescence;
	#endif
	#ifdef MAPTEXTURE
	iridescence *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	dIridescence = iridescence; 
}
`
  , O1 = `
uniform float material_iridescenceThicknessMax;
#ifdef MAPTEXTURE
uniform float material_iridescenceThicknessMin;
#endif
void getIridescenceThickness() {
	#ifdef MAPTEXTURE
	float blend = texture2DBias($SAMPLER, $UV, textureBias).$CH;
	float iridescenceThickness = mix(material_iridescenceThicknessMin, material_iridescenceThicknessMax, blend);
	#else
	float iridescenceThickness = material_iridescenceThicknessMax;
	#endif
	dIridescenceThickness = iridescenceThickness; 
}
`
  , F1 = `
attribute vec4 instance_line1;
attribute vec4 instance_line2;
attribute vec4 instance_line3;
attribute vec4 instance_line4;
`
  , B1 = `
#ifdef MAPFLOAT
uniform float material_refractionIndex;
#endif
void getIor() {
#ifdef MAPFLOAT
	dIor = material_refractionIndex;
#else
	dIor = 1.0 / 1.5;
#endif
}
`
  , k1 = `
float getLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
	return max(dot(worldNormal, -lightDirNorm), 0.0);
}
`
  , N1 = `
void getLightDirPoint(vec3 lightPosW) {
	dLightDirW = vPositionW - lightPosW;
	dLightDirNormW = normalize(dLightDirW);
	dLightPosW = lightPosW;
}
`
  , U1 = `
void addLightMap(
	vec3 lightmap, 
	vec3 dir, 
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir, 
	float gloss, 
	vec3 specularity, 
	vec3 vertexNormal, 
	mat3 tbn
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel, 
	float iridescenceIntensity
#endif
) {
	dDiffuseLight += lightmap;
}
`
  , z1 = `
void addLightMap(
	vec3 lightmap, 
	vec3 dir, 
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir, 
	float gloss, 
	vec3 specularity, 
	vec3 vertexNormal, 
	mat3 tbn
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel, 
	float iridescenceIntensity
#endif
) {
	if (dot(dir, dir) < 0.0001) {
		dDiffuseLight += lightmap;
	} else {
		float vlight = saturate(dot(dir, -vertexNormal));
		float flight = saturate(dot(dir, -worldNormal));
		float nlight = (flight / max(vlight, 0.01)) * 0.5;
		dDiffuseLight += lightmap * nlight * 2.0;
		vec3 halfDir = normalize(-dir + viewDir);
		vec3 specularLight = lightmap * getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dir, gloss, tbn);
#ifdef LIT_SPECULAR_FRESNEL
		specularLight *= 
			getFresnel(dot(viewDir, halfDir), 
			gloss, 
			specularity
		#if defined(LIT_IRIDESCENCE)
			, iridescenceFresnel,
			iridescenceIntensity
		#endif
			);
#endif
		dSpecularLight += specularLight;
	}
}
`
  , V1 = `
uniform sampler2D texture_lightMap;
uniform sampler2D texture_dirLightMap;
void getLightMap() {
	dLightmap = $DECODE(texture2DBias(texture_lightMap, $UV, textureBias)).$CH;
	vec3 dir = texture2DBias(texture_dirLightMap, $UV, textureBias).xyz * 2.0 - 1.0;
	float dirDot = dot(dir, dir);
	dLightmapDir = (dirDot > 0.001) ? dir / sqrt(dirDot) : vec3(0.0);
}
`
  , G1 = `
void getLightMap() {
	dLightmap = vec3(1.0);
	#ifdef MAPTEXTURE
	dLightmap *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
	#endif
	#ifdef MAPVERTEX
	dLightmap *= saturate(vVertexColor.$VC);
	#endif
}
`
  , H1 = `
float calcLightSpecular(float gloss, vec3 worldNormal, vec3 viewDir, vec3 h, vec3 lightDirNorm, mat3 tbn) {
	float PI = 3.141592653589793;
	float roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);
	float anisotropy = material_anisotropy * roughness;
 
	float at = max((roughness + anisotropy), roughness / 4.0);
	float ab = max((roughness - anisotropy), roughness / 4.0);
	float NoH = dot(worldNormal, h);
	float ToH = dot(tbn[0], h);
	float BoH = dot(tbn[1], h);
	float a2 = at * ab;
	vec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);
	float v2 = dot(v, v);
	float w2 = a2 / v2;
	float D = a2 * w2 * w2 * (1.0 / PI);
	float ToV = dot(tbn[0], viewDir);
	float BoV = dot(tbn[1], viewDir);
	float ToL = dot(tbn[0], -lightDirNorm);
	float BoL = dot(tbn[1], -lightDirNorm);
	float NoV = dot(worldNormal, viewDir);
	float NoL = dot(worldNormal, -lightDirNorm);
	float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));
	float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));
	float G = 0.5 / (lambdaV + lambdaL);
	return D * G;
}
float getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {
	return calcLightSpecular(gloss, worldNormal, viewDir, h, lightDirNorm, tbn);
}
`
  , W1 = `
float calcLightSpecular(float gloss, vec3 worldNormal, vec3 h) {
	float nh = max( dot( h, worldNormal ), 0.0 );
	float specPow = exp2(gloss * 11.0);
	specPow = max(specPow, 0.0001);
	return pow(nh, specPow) * (specPow + 2.0) / 8.0;
}
float getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {
	return calcLightSpecular(gloss, worldNormal, h);
}
`
  , X1 = `
float calcLightSpecular(float gloss, vec3 reflDir, vec3 lightDirNorm) {
	float specPow = gloss;
	return pow(max(dot(reflDir, -lightDirNorm), 0.0), specPow + 0.0001);
}
float getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {
	return calcLightSpecular(gloss, reflDir, lightDirNorm);
}
`
  , j1 = `
float sheenD(vec3 normal, vec3 h, float roughness) {
	float invR = 1.0 / (roughness * roughness);
	float cos2h = max(dot(normal, h), 0.0);
	cos2h *= cos2h;
	float sin2h = max(1.0 - cos2h, 0.0078125);
	return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);
}
float sheenV(vec3 normal, vec3 viewDir, vec3 light) {
	float NoV = max(dot(normal, viewDir), 0.000001);
	float NoL = max(dot(normal, light), 0.000001);
	return 1.0 / (4.0 * (NoL + NoV - NoL * NoV));
}
float getLightSpecularSheen(vec3 h, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float sheenGloss) {
	float D = sheenD(worldNormal, h, sheenGloss);
	float V = sheenV(worldNormal, viewDir, -lightDirNorm);
	return D * V;
}
`
  , $1 = `
#ifndef LINEARIZE_DEPTH
#define LINEARIZE_DEPTH
float linearizeDepth(float z, vec4 cameraParams) {
	if (cameraParams.w == 0.0)
		return (cameraParams.z * cameraParams.y) / (cameraParams.y + z * (cameraParams.z - cameraParams.y));
	else
		return cameraParams.z + z * (cameraParams.y - cameraParams.z);
}
#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params;
#endif
#ifdef GL2
float linearizeDepth(float z) {
	return linearizeDepth(z, camera_params);
}
#else
#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
	const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
	return dot(rgbaDepth, bitShift);
}
#endif
#endif
#endif
`
  , q1 = `
vec3 litArgs_albedo;
float litArgs_opacity;
vec3 litArgs_emission;
vec3 litArgs_worldNormal;
float litArgs_ao;
vec3 litArgs_lightmap;
vec3 litArgs_lightmapDir;
float litArgs_metalness;
vec3 litArgs_specularity;
float litArgs_specularityFactor;
float litArgs_gloss;
float litArgs_sheen_gloss;
vec3 litArgs_sheen_specularity;
float litArgs_transmission;
float litArgs_thickness;
float litArgs_ior;
float litArgs_iridescence_intensity;
float litArgs_iridescence_thickness;
vec3 litArgs_clearcoat_worldNormal;
float litArgs_clearcoat_specularity;
float litArgs_clearcoat_gloss;
`
  , Y1 = `
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
struct Coords {
	vec3 coord0;
	vec3 coord1;
	vec3 coord2;
	vec3 coord3;
};
float LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {
	vec3 v1 = rectCoords.coord1 - rectCoords.coord0;
	vec3 v2 = rectCoords.coord3 - rectCoords.coord0;
	
	vec3 lightNormal = cross( v1, v2 );
	float factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 =  factor * cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords.coord0 - P );
	coords[ 1 ] = mat * ( rectCoords.coord1 - P );
	coords[ 2 ] = mat * ( rectCoords.coord2 - P );
	coords[ 3 ] = mat * ( rectCoords.coord3 - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return result;
}
Coords dLTCCoords;
Coords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){
	Coords coords;
	coords.coord0 = lightPos + halfWidth - halfHeight;
	coords.coord1 = lightPos - halfWidth - halfHeight;
	coords.coord2 = lightPos - halfWidth + halfHeight;
	coords.coord3 = lightPos + halfWidth + halfHeight;
	return coords;
}
float dSphereRadius;
Coords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){
	dSphereRadius = max(length(halfWidth), length(halfHeight));
	vec3 f = reflect(normalize(lightPos - view_position), vNormalW);
	vec3 w = normalize(cross(f, halfHeight));
	vec3 h = normalize(cross(f, w));
	return getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);
}
vec2 dLTCUV;
#ifdef LIT_CLEARCOAT
vec2 ccLTCUV;
#endif
vec2 getLTCLightUV(float gloss, vec3 worldNormal, vec3 viewDir)
{
	float roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);
	return LTC_Uv( worldNormal, viewDir, roughness );
}
vec3 dLTCSpecFres;
#ifdef LIT_CLEARCOAT
vec3 ccLTCSpecFres;
#endif
vec3 getLTCLightSpecFres(vec2 uv, vec3 specularity)
{
	vec4 t2 = texture2DLodEXT(areaLightsLutTex2, uv, 0.0);
	#ifdef AREA_R8_G8_B8_A8_LUTS
	t2 *= vec4(0.693103,1,1,1);
	t2 += vec4(0.306897,0,0,0);
	#endif
	return specularity * t2.x + ( vec3( 1.0 ) - specularity) * t2.y;
}
void calcLTCLightValues(float gloss, vec3 worldNormal, vec3 viewDir, vec3 specularity, float clearcoatGloss, vec3 clearcoatWorldNormal, float clearcoatSpecularity)
{
	dLTCUV = getLTCLightUV(gloss, worldNormal, viewDir);
	dLTCSpecFres = getLTCLightSpecFres(dLTCUV, specularity); 
#ifdef LIT_CLEARCOAT
	ccLTCUV = getLTCLightUV(clearcoatGloss, clearcoatWorldNormal, viewDir);
	ccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(clearcoatSpecularity));
#endif
}
void calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)
{
	dLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);
}
void calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)
{
	calcRectLightValues(lightPos, halfWidth, halfHeight);
}
void calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)
{
	dLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);
}
vec3 SolveCubic(vec4 Coefficient)
{
	float pi = 3.14159;
	Coefficient.xyz /= Coefficient.w;
	Coefficient.yz /= 3.0;
	float A = Coefficient.w;
	float B = Coefficient.z;
	float C = Coefficient.y;
	float D = Coefficient.x;
	vec3 Delta = vec3(
		-Coefficient.z * Coefficient.z + Coefficient.y,
		-Coefficient.y * Coefficient.z + Coefficient.x,
		dot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)
	);
	float Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);
	vec3 RootsA, RootsD;
	vec2 xlc, xsc;
	{
		float A_a = 1.0;
		float C_a = Delta.x;
		float D_a = -2.0 * B * Delta.x + Delta.y;
		float Theta = atan(sqrt(Discriminant), -D_a) / 3.0;
		float x_1a = 2.0 * sqrt(-C_a) * cos(Theta);
		float x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);
		float xl;
		if ((x_1a + x_3a) > 2.0 * B)
			xl = x_1a;
		else
			xl = x_3a;
		xlc = vec2(xl - B, A);
	}
	{
		float A_d = D;
		float C_d = Delta.z;
		float D_d = -D * Delta.y + 2.0 * C * Delta.z;
		float Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;
		float x_1d = 2.0 * sqrt(-C_d) * cos(Theta);
		float x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);
		float xs;
		if (x_1d + x_3d < 2.0 * C)
			xs = x_1d;
		else
			xs = x_3d;
		xsc = vec2(-D, xs + C);
	}
	float E =  xlc.y * xsc.y;
	float F = -xlc.x * xsc.y - xlc.y * xsc.x;
	float G =  xlc.x * xsc.x;
	vec2 xmc = vec2(C * F - B * G, -B * F + C * E);
	vec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);
	if (Root.x < Root.y && Root.x < Root.z)
		Root.xyz = Root.yxz;
	else if (Root.z < Root.x && Root.z < Root.y)
		Root.xyz = Root.xzy;
	return Root;
}
float LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)
{
	vec3 T1, T2;
	T1 = normalize(V - N * dot(V, N));
	T2 = cross(N, T1);
	mat3 R = transposeMat3( mat3( T1, T2, N ) );
	vec3 L_[ 3 ];
	L_[ 0 ] = R * ( points.coord0 - P );
	L_[ 1 ] = R * ( points.coord1 - P );
	L_[ 2 ] = R * ( points.coord2 - P );
	vec3 Lo_i = vec3(0);
	vec3 C  = 0.5 * (L_[0] + L_[2]);
	vec3 V1 = 0.5 * (L_[1] - L_[2]);
	vec3 V2 = 0.5 * (L_[1] - L_[0]);
	C  = Minv * C;
	V1 = Minv * V1;
	V2 = Minv * V2;
	float a, b;
	float d11 = dot(V1, V1);
	float d22 = dot(V2, V2);
	float d12 = dot(V1, V2);
	if (abs(d12) / sqrt(d11 * d22) > 0.0001)
	{
		float tr = d11 + d22;
		float det = -d12 * d12 + d11 * d22;
		det = sqrt(det);
		float u = 0.5 * sqrt(tr - 2.0 * det);
		float v = 0.5 * sqrt(tr + 2.0 * det);
		float e_max = (u + v) * (u + v);
		float e_min = (u - v) * (u - v);
		vec3 V1_, V2_;
		if (d11 > d22)
		{
			V1_ = d12 * V1 + (e_max - d11) * V2;
			V2_ = d12 * V1 + (e_min - d11) * V2;
		}
		else
		{
			V1_ = d12*V2 + (e_max - d22)*V1;
			V2_ = d12*V2 + (e_min - d22)*V1;
		}
		a = 1.0 / e_max;
		b = 1.0 / e_min;
		V1 = normalize(V1_);
		V2 = normalize(V2_);
	}
	else
	{
		a = 1.0 / dot(V1, V1);
		b = 1.0 / dot(V2, V2);
		V1 *= sqrt(a);
		V2 *= sqrt(b);
	}
	vec3 V3 = cross(V1, V2);
	if (dot(C, V3) < 0.0)
		V3 *= -1.0;
	float L  = dot(V3, C);
	float x0 = dot(V1, C) / L;
	float y0 = dot(V2, C) / L;
	float E1 = inversesqrt(a);
	float E2 = inversesqrt(b);
	a *= L * L;
	b *= L * L;
	float c0 = a * b;
	float c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;
	float c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);
	float c3 = 1.0;
	vec3 roots = SolveCubic(vec4(c0, c1, c2, c3));
	float e1 = roots.x;
	float e2 = roots.y;
	float e3 = roots.z;
	vec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);
	mat3 rotate = mat3(V1, V2, V3);
	avgDir = rotate * avgDir;
	avgDir = normalize(avgDir);
	float L1 = sqrt(-e2 / e3);
	float L2 = sqrt(-e2 / e1);
	float formFactor = L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2));
	
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	vec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);
	uv = uv*LUT_SCALE + LUT_BIAS;
	float scale = texture2DLodEXT(areaLightsLutTex2, uv, 0.0).w;
	return formFactor*scale;
}
float getRectLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
	return LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );
}
float getDiskLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
	return LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );
}
float getSphereLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
	float falloff = dSphereRadius / (dot(lightDir, lightDir) + dSphereRadius);
	return getLightDiffuse(worldNormal, viewDir, lightDir, lightDirNorm) * falloff;
}
mat3 getLTCLightInvMat(vec2 uv)
{
	vec4 t1 = texture2DLodEXT(areaLightsLutTex1, uv, 0.0);
	#ifdef AREA_R8_G8_B8_A8_LUTS
	t1 *= vec4(1.001, 0.3239, 0.60437568, 1.0);
	t1 += vec4(0.0, -0.2976, -0.01381, 0.0);
	#endif
	return mat3(
		vec3( t1.x, 0, t1.y ),
		vec3(	0, 1,	0 ),
		vec3( t1.z, 0, t1.w )
	);
}
float calcRectLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {
	mat3 mInv = getLTCLightInvMat(uv);
	return LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );
}
float getRectLightSpecular(vec3 worldNormal, vec3 viewDir) {
	return calcRectLightSpecular(worldNormal, viewDir, dLTCUV);
}
float calcDiskLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {
	mat3 mInv = getLTCLightInvMat(uv);
	return LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );
}
float getDiskLightSpecular(vec3 worldNormal, vec3 viewDir) {
	return calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);
}
float getSphereLightSpecular(vec3 worldNormal, vec3 viewDir) {
	return calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);
}
`
  , K1 = `
#ifdef MAPFLOAT
uniform float material_metalness;
#endif
void getMetalness() {
	float metalness = 1.0;
	#ifdef MAPFLOAT
	metalness *= material_metalness;
	#endif
	#ifdef MAPTEXTURE
	metalness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	metalness *= saturate(vVertexColor.$VC);
	#endif
	dMetalness = metalness;
}
`
  , Z1 = `
uniform sampler2D texture_msdfMap;
#ifdef GL_OES_standard_derivatives
#define USE_FWIDTH
#endif
#ifdef GL2
#define USE_FWIDTH
#endif
float median(float r, float g, float b) {
	return max(min(r, g), min(max(r, g), b));
}
float map (float min, float max, float v) {
	return (v - min) / (max - min);
}
uniform float font_sdfIntensity;
uniform float font_pxrange;
uniform float font_textureWidth;
#ifdef UNIFORM_TEXT_PARAMETERS
uniform vec4 outline_color;
uniform float outline_thickness;
uniform vec4 shadow_color;
uniform vec2 shadow_offset;
#else
varying vec4 outline_color;
varying float outline_thickness;
varying vec4 shadow_color;
varying vec2 shadow_offset;
#endif
vec4 applyMsdf(vec4 color) {
	vec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;
	vec2 uvShdw = vUv0 - shadow_offset;
	vec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;
	float sigDist = median(tsample.r, tsample.g, tsample.b);
	float sigDistShdw = median(ssample.r, ssample.g, ssample.b);
	float smoothingMax = 0.2;
	#ifdef USE_FWIDTH
	vec2 w = fwidth(vUv0);
	float smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);
	#else
	float font_size = 16.0;
	float smoothing = clamp(font_pxrange / font_size, 0.0, smoothingMax);
	#endif
	float mapMin = 0.05;
	float mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);
	float sigDistInner = map(mapMin, mapMax, sigDist);
	float sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);
	sigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);
	float center = 0.5;
	float inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);
	float outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);
	float shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);
	vec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);
	tcolor = mix(tcolor, color, inside);
	vec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;
	tcolor = mix(scolor, tcolor, outline);
	
	return tcolor;
}
`
  , Q1 = `
vec3 getSpecularModulate(in vec3 specularity, in vec3 albedo, in float metalness, in float f0) {
	vec3 dielectricF0 = f0 * specularity;
	return mix(dielectricF0, albedo, metalness);
}
vec3 getAlbedoModulate(in vec3 albedo, in float metalness) {
	return albedo * (1.0 - metalness);
}
`
  , J1 = `
attribute vec3 vertex_outlineParameters;
attribute vec3 vertex_shadowParameters;
varying vec4 outline_color;
varying float outline_thickness;
varying vec4 shadow_color;
varying vec2 shadow_offset;
void unpackMsdfParams() {
	vec3 little = mod(vertex_outlineParameters, 256.);
	vec3 big = (vertex_outlineParameters - little) / 256.;
	outline_color.rb = little.xy / 255.;
	outline_color.ga = big.xy / 255.;
	outline_thickness = little.z / 255. * 0.2;
	little = mod(vertex_shadowParameters, 256.);
	big = (vertex_shadowParameters - little) / 256.;
	shadow_color.rb = little.xy / 255.;
	shadow_color.ga = big.xy / 255.;
	shadow_offset = (vec2(little.z, big.z) / 127. - 1.) * 0.005;
}
`
  , eM = `
#ifdef MORPHING_TEXTURE_BASED_NORMAL
uniform highp sampler2D morphNormalTex;
#endif
vec3 getNormal() {
	#ifdef SKIN
	dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);
	#elif defined(INSTANCING)
	dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);
	#else
	dNormalMatrix = matrix_normal;
	#endif
	vec3 tempNormal = vertex_normal;
	#ifdef MORPHING
	#ifdef MORPHING_NRM03
	tempNormal += morph_weights_a[0] * morph_nrm0;
	tempNormal += morph_weights_a[1] * morph_nrm1;
	tempNormal += morph_weights_a[2] * morph_nrm2;
	tempNormal += morph_weights_a[3] * morph_nrm3;
	#endif
	#ifdef MORPHING_NRM47
	tempNormal += morph_weights_b[0] * morph_nrm4;
	tempNormal += morph_weights_b[1] * morph_nrm5;
	tempNormal += morph_weights_b[2] * morph_nrm6;
	tempNormal += morph_weights_b[3] * morph_nrm7;
	#endif
	#endif
	#ifdef MORPHING_TEXTURE_BASED_NORMAL
		#ifdef WEBGPU
			ivec2 morphUV = getTextureMorphCoords();
			vec3 morphNormal = texelFetch(morphNormalTex, ivec2(morphUV), 0).xyz;
		#else
			vec2 morphUV = getTextureMorphCoords();
			vec3 morphNormal = texture2D(morphNormalTex, morphUV).xyz;
		#endif
	tempNormal += morphNormal;
	#endif
	return normalize(dNormalMatrix * tempNormal);
}
`
  , tM = `
#ifdef MAPTEXTURE
uniform float material_normalDetailMapBumpiness;
vec3 blendNormals(vec3 n1, vec3 n2) {
	n1 += vec3(0, 0, 1);
	n2 *= vec3(-1, -1, 1);
	return n1 * dot(n1, n2) / n1.z - n2;
}
#endif
vec3 addNormalDetail(vec3 normalMap) {
#ifdef MAPTEXTURE
	vec3 normalDetailMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));
	normalDetailMap = mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness);
	return blendNormals(normalMap, normalDetailMap);
#else
	return normalMap;
#endif
}
`
  , sM = `
vec3 getNormal() {
	dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);
	return normalize(dNormalMatrix * vertex_normal);
}
`
  , iM = `
#ifdef MAPTEXTURE
uniform float material_bumpiness;
#endif
void getNormal() {
#ifdef MAPTEXTURE
	vec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));
	normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness);
	dNormalW = normalize(dTBN * addNormalDetail(normalMap));
#else
	dNormalW = dVertexNormalW;
#endif
}
`
  , nM = `
vec3 getNormal() {
	dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);
	return normalize(dNormalMatrix * vertex_normal);
}
`
  , rM = `
vec3 unpackNormal(vec4 nmap) {
	vec3 normal;
	normal.xy = nmap.wy * 2.0 - 1.0;
	normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));
	return normal;
}
`
  , aM = `
vec3 unpackNormal(vec4 nmap) {
	return nmap.xyz * 2.0 - 1.0;
}
`
  , oM = `
#ifdef MAPFLOAT
uniform float material_opacity;
#endif
void getOpacity() {
	dAlpha = 1.0;
	#ifdef MAPFLOAT
	dAlpha *= material_opacity;
	#endif
	#ifdef MAPTEXTURE
	dAlpha *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	dAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);
	#endif
}
`
  , lM = `
uniform vec4 blueNoiseJitter;
#ifndef DITHER_BAYER8
	uniform sampler2D blueNoiseTex32;
#endif
void opacityDither(float alpha, float id) {
	#ifdef DITHER_BAYER8
		float noise = bayer8(floor(mod(gl_FragCoord.xy + blueNoiseJitter.xy + id, 8.0))) / 64.0;
	#else
		vec2 uv = fract(gl_FragCoord.xy / 32.0 + blueNoiseJitter.xy + id);
		float noise = texture2DLodEXT(blueNoiseTex32, uv, 0.0).y;
	#endif
	if (alpha < noise)
		discard;
}
`
  , hM = `
`
  , cM = `
gl_FragColor.a = litArgs_opacity;
`
  , dM = `
	gl_FragColor.a = 1.0;
`
  , uM = `
gl_FragColor.rgb *= litArgs_opacity;
gl_FragColor.a = litArgs_opacity;
`
  , fM = `
varying vec2 vUv0;
uniform sampler2D source;
void main(void) {
	gl_FragColor = texture2D(source, vUv0);
}
`
  , pM = `
vec4 packFloat(float depth) {
	const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
	const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
	vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);
	res -= res.xxyz * bit_mask;
	return res;
}
`
  , mM = `
#ifdef MAPCOLOR
uniform vec3 material_sheen;
#endif
void getSheen() {
	vec3 sheenColor = vec3(1, 1, 1);
	#ifdef MAPCOLOR
	sheenColor *= material_sheen;
	#endif
	#ifdef MAPTEXTURE
	sheenColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
	#endif
	#ifdef MAPVERTEX
	sheenColor *= saturate(vVertexColor.$VC);
	#endif
	sSpecularity = sheenColor;
}
`
  , _M = `
#ifdef MAPFLOAT
uniform float material_sheenGloss;
#endif
void getSheenGlossiness() {
	float sheenGlossiness = 1.0;
	#ifdef MAPFLOAT
	sheenGlossiness *= material_sheenGloss;
	#endif
	#ifdef MAPTEXTURE
	sheenGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	sheenGlossiness *= saturate(vVertexColor.$VC);
	#endif
	#ifdef MAPINVERT
	sheenGlossiness = 1.0 - sheenGlossiness;
	#endif
	sheenGlossiness += 0.0000001;
	sGlossiness = sheenGlossiness;
}
`
  , gM = `
uniform float material_heightMapFactor;
void getParallax() {
	float parallaxScale = material_heightMapFactor;
	float height = texture2DBias($SAMPLER, $UV, textureBias).$CH;
	height = height * parallaxScale - parallaxScale*0.5;
	vec3 viewDirT = dViewDirW * dTBN;
	viewDirT.z += 0.42;
	dUvOffset = height * (viewDirT.xy / viewDirT.z);
}
`
  , yM = `
varying vec4 texCoordsAlphaLife;
uniform sampler2D colorMap;
uniform sampler2D colorParam;
uniform float graphSampleSize;
uniform float graphNumSamples;
#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params;
#endif
uniform float softening;
uniform float colorMult;
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
	const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
	float depth = dot(rgbaDepth, bitShift);
	return depth;
}
#endif
void main(void) {
	vec4 tex  = gammaCorrectInput(texture2D(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)));
	vec4 ramp = gammaCorrectInput(texture2D(colorParam, vec2(texCoordsAlphaLife.w, 0.0)));
	ramp.rgb *= colorMult;
	ramp.a += texCoordsAlphaLife.z;
	vec3 rgb = tex.rgb * ramp.rgb;
	float a  = tex.a * ramp.a;
`
  , vM = `
vec3 unpack3NFloats(float src) {
	float r = fract(src);
	float g = fract(src * 256.0);
	float b = fract(src * 65536.0);
	return vec3(r, g, b);
}
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
vec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc) {
	return mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );
}
vec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {
	vec4 a = texture2D(tex,tc);
	vec4 b = texture2D(tex,tc + graphSampleSize);
	float c = fract(tc.x*graphNumSamples);
	vec3 unpackedA = unpack3NFloats(a.w);
	vec3 unpackedB = unpack3NFloats(b.w);
	w = mix(unpackedA, unpackedB, c);
	return mix(a, b, c);
}
vec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {
	float c = cos(pRotation);
	float s = sin(pRotation);
	mat2 m = mat2(c, -s, s, c);
	rotMatrix = m;
	return m * quadXY;
}
vec3 billboard(vec3 InstanceCoords, vec2 quadXY) {
	#ifdef SCREEN_SPACE
		vec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;
	#else
		vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;
	#endif
	return pos;
}
vec3 customFace(vec3 InstanceCoords, vec2 quadXY) {
	vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;
	return pos;
}
vec2 safeNormalize(vec2 v) {
	float l = length(v);
	return (l > 1e-06) ? v / l : v;
}
void main(void) {
	vec3 meshLocalPos = particle_vertexData.xyz;
	float id = floor(particle_vertexData.w);
	float rndFactor = fract(sin(id + 1.0 + seed));
	vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));
	float uv = id / numParticlesPot;
	readInput(uv);
#ifdef LOCAL_SPACE
	inVel = mat3(matrix_model) * inVel;
#endif
	vec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy);
	float particleLifetime = lifetime;
	if (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);
	vec2 quadXY = meshLocalPos.xy;
	float nlife = clamp(inLife / particleLifetime, 0.0, 1.0);
	vec3 paramDiv;
	vec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);
	float scale = params.y;
	float scaleDiv = paramDiv.x;
	float alphaDiv = paramDiv.z;
	scale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);
#ifndef USE_MESH
	texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);
#else
	texCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);
#endif
	vec3 particlePos = inPos;
	vec3 particlePosMoved = vec3(0.0);
	mat2 rotMatrix;
`
  , SM = `
	float animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);
`
  , xM = `
	float animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));
`
  , wM = `
	float animationIndex;
	if (animTexIndexParams.y == 1.0) {
		animationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);
	} else {
		animationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);
	}
	float atlasX = (animationIndex + animFrame) * animTexTilesParams.x;
	float atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;
	atlasX = fract(atlasX);
	texCoordsAlphaLife.xy *= animTexTilesParams.xy;
	texCoordsAlphaLife.xy += vec2(atlasX, atlasY);
`
  , bM = `
void readInput(float uv) {
	vec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));
	vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));
	inPos = tex.xyz;
	inVel = tex2.xyz;
	inAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;
	inShow = tex.w >= 0.0;
	inLife = tex2.w;
}
`
  , TM = `
#define PI2 6.283185307179586
uniform vec3 inBoundsSize;
uniform vec3 inBoundsCenter;
uniform float maxVel;
float decodeFloatRG(vec2 rg) {
	return rg.y*(1.0/255.0) + rg.x;
}
float decodeFloatRGBA( vec4 rgba ) {
	return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );
}
void readInput(float uv) {
	vec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));
	vec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));
	vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));
	vec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));
	inPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));
	inPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;
	inVel = tex2.xyz;
	inVel = (inVel - vec3(0.5)) * maxVel;
	inAngle = decodeFloatRG(tex1.ba) * PI2;
	inShow = tex2.a > 0.5;
	inLife = decodeFloatRGBA(tex3);
	float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));
	float maxPosLife = lifetime+1.0;
	inLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;
}
`
  , CM = `
void writeOutput() {
	if (gl_FragCoord.y<1.0) {
		gl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);
	} else {
		gl_FragColor = vec4(outVel, outLife);
	}
}
`
  , EM = `
uniform vec3 outBoundsMul;
uniform vec3 outBoundsAdd;
vec2 encodeFloatRG( float v ) {
	vec2 enc = vec2(1.0, 255.0) * v;
	enc = fract(enc);
	enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);
	return enc;
}
vec4 encodeFloatRGBA( float v ) {
	vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;
	enc = fract(enc);
	enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
	return enc;
}
void writeOutput() {
	outPos = outPos * outBoundsMul + outBoundsAdd;
	outAngle = fract(outAngle / PI2);
	outVel = (outVel / maxVel) + vec3(0.5);
	float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));
	float maxPosLife = lifetime+1.0;
	outLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);
	if (gl_FragCoord.y < 1.0) {
		gl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));
	} else if (gl_FragCoord.y < 2.0) {
		gl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));
	} else if (gl_FragCoord.y < 3.0) {
		gl_FragColor = vec4(outVel, visMode*0.5+0.5);
	} else {
		gl_FragColor = encodeFloatRGBA(outLife);
	}
}
`
  , AM = `
uniform mat3 spawnBounds;
uniform vec3 spawnPosInnerRatio;
vec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {
	vec3 pos = inBounds - vec3(0.5);
	vec3 posAbs = abs(pos);
	vec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));
	vec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;
	pos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);
	pos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);
	pos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);
#ifndef LOCAL_SPACE
	return emitterPos + spawnBounds * pos;
#else
	return spawnBounds * pos;
#endif
}
void addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {
	localVelocity -= vec3(0, 0, initialVelocity);
}
`
  , MM = `
	writeOutput();
}
`
  , PM = `
varying vec2 vUv0;
uniform highp sampler2D particleTexIN;
uniform highp sampler2D internalTex0;
uniform highp sampler2D internalTex1;
uniform highp sampler2D internalTex2;
uniform highp sampler2D internalTex3;
uniform mat3 emitterMatrix, emitterMatrixInv;
uniform vec3 emitterScale;
uniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;
uniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, radialSpeedDivMult, seed;
uniform float startAngle, startAngle2;
uniform float initialVelocity;
uniform float graphSampleSize;
uniform float graphNumSamples;
vec3 inPos;
vec3 inVel;
float inAngle;
bool inShow;
float inLife;
float visMode;
vec3 outPos;
vec3 outVel;
float outAngle;
bool outShow;
float outLife;
`
  , RM = `
	if (outLife >= lifetime) {
		outLife -= max(lifetime, (numParticles - 1.0) * particleRate);
		visMode = -1.0;
	}
`
  , IM = `
	visMode = outLife < 0.0? -1.0: visMode;
`
  , LM = `
	if (outLife >= lifetime) {
		outLife -= max(lifetime, (numParticles - 1.0) * particleRate);
		visMode = 1.0;
	}
	visMode = outLife < 0.0? 1.0: visMode;
`
  , DM = `
uniform float spawnBoundsSphere;
uniform float spawnBoundsSphereInnerRatio;
vec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {
	float rnd4 = fract(rndFactor * 1000.0);
	vec3 norm = normalize(inBounds.xyz - vec3(0.5));
	float r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;
#ifndef LOCAL_SPACE
	return emitterPos + norm * r * spawnBoundsSphere;
#else
	return norm * r * spawnBoundsSphere;
#endif
}
void addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {
	localVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;
}
`
  , OM = `
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
vec3 unpack3NFloats(float src) {
	float r = fract(src);
	float g = fract(src * 256.0);
	float b = fract(src * 65536.0);
	return vec3(r, g, b);
}
vec3 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {
	vec4 a = texture2D(tex, tc);
	vec4 b = texture2D(tex, tc + graphSampleSize);
	float c = fract(tc.x * graphNumSamples);
	vec3 unpackedA = unpack3NFloats(a.w);
	vec3 unpackedB = unpack3NFloats(b.w);
	w = mix(unpackedA, unpackedB, c);
	return mix(a.xyz, b.xyz, c);
}
#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)
vec4 hash41(float p) {
	vec4 p4 = fract(vec4(p) * HASHSCALE4);
	p4 += dot(p4, p4.wzxy+19.19);
	return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));
}
void main(void) {
	if (gl_FragCoord.x > numParticles) discard;
	readInput(vUv0.x);
	visMode = inShow? 1.0 : -1.0;
	vec4 rndFactor = hash41(gl_FragCoord.x + seed);
	float particleRate = rate + rateDiv * rndFactor.x;
	outLife = inLife + delta;
	float nlife = clamp(outLife / lifetime, 0.0, 1.0);
	vec3 localVelocityDiv;
	vec3 velocityDiv;
	vec3 paramDiv;
	vec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);
	vec3 velocity =	  tex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);
	vec3 params =		tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);
	float rotSpeed = params.x;
	float rotSpeedDiv = paramDiv.y;
	vec3 radialParams = tex1Dlod_lerp(internalTex3, vec2(nlife, 0), paramDiv);
	float radialSpeed = radialParams.x;
	float radialSpeedDiv = radialParams.y;
	bool respawn = inLife <= 0.0 || outLife >= lifetime;
	inPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;
	inAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;
#ifndef LOCAL_SPACE
	vec3 radialVel = inPos - emitterPos;
#else
	vec3 radialVel = inPos;
#endif
	radialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);
	radialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;
	localVelocity +=	(localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;
	velocity +=		 (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;
	rotSpeed +=		 (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;
	addInitialVelocity(localVelocity, rndFactor.xyz);
#ifndef LOCAL_SPACE
	outVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;
#else
	outVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;
#endif
	outPos = inPos + outVel * delta;
	outAngle = inAngle + rotSpeed * delta;
`
  , FM = `
	quadXY = rotate(quadXY, inAngle, rotMatrix);
	vec3 localPos = billboard(particlePos, quadXY);
`
  , BM = `
	dBlendModeFogFactor = 0.0;
	rgb *= saturate(gammaCorrectInput(max(a, 0.0)));
	if ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;
`
  , kM = `
	rgb = mix(vec3(1.0), rgb, vec3(a));
	if (rgb.r + rgb.g + rgb.b > 2.99) discard;
`
  , NM = `
	if (a < 0.01) discard;
`
  , UM = `
attribute vec4 particle_vertexData;
attribute vec4 particle_vertexData2;
attribute vec4 particle_vertexData3;
attribute float particle_vertexData4;
#ifndef USE_MESH
attribute vec2 particle_vertexData5;
#else
attribute vec4 particle_vertexData5;
#endif
uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
uniform mat3 matrix_normal;
uniform mat4 matrix_viewInverse;
uniform float numParticles;
uniform float lifetime;
uniform float stretch;
uniform float seed;
uniform vec3 wrapBounds;
uniform vec3 emitterScale;
uniform vec3 faceTangent;
uniform vec3 faceBinorm;
uniform highp sampler2D internalTex0;
uniform highp sampler2D internalTex1;
uniform highp sampler2D internalTex2;
uniform vec3 emitterPos;
varying vec4 texCoordsAlphaLife;
vec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)
{
	float c = cos(pRotation);
	float s = sin(pRotation);
	mat2 m = mat2(c, -s, s, c);
	rotMatrix = m;
	return m * quadXY;
}
vec3 billboard(vec3 InstanceCoords, vec2 quadXY)
{
	vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;
	return pos;
}
vec3 customFace(vec3 InstanceCoords, vec2 quadXY)
{
	vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;
	return pos;
}
void main(void)
{
	vec3 particlePos = particle_vertexData.xyz;
	vec3 inPos = particlePos;
	vec3 vertPos = particle_vertexData3.xyz;
	vec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);
	float id = floor(particle_vertexData4);
	float rndFactor = fract(sin(id + 1.0 + seed));
	vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));
#ifdef LOCAL_SPACE
	inVel = mat3(matrix_model) * inVel;
#endif
	vec2 velocityV = normalize((mat3(matrix_view) * inVel).xy);
	vec2 quadXY = vertPos.xy;
#ifdef USE_MESH
	texCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);
#else
	texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);
#endif
	mat2 rotMatrix;
	float inAngle = particle_vertexData2.x;
	vec3 particlePosMoved = vec3(0.0);
	vec3 meshLocalPos = particle_vertexData3.xyz;
`
  , zM = `
	localPos *= particle_vertexData2.y * emitterScale;
	localPos += particlePos;
	gl_Position = matrix_viewProjection * vec4(localPos, 1.0);
`
  , VM = `
	quadXY = rotate(quadXY, inAngle, rotMatrix);
	vec3 localPos = customFace(particlePos, quadXY);
`
  , GM = `
	rgb = addFog(rgb);
	rgb = toneMap(rgb);
	rgb = gammaCorrectOutput(rgb);
	gl_FragColor = vec4(rgb, a);
}
`
  , HM = `
	localPos *= scale * emitterScale;
	localPos += particlePos;
	#ifdef SCREEN_SPACE
	gl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);
	#else
	gl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);
	#endif
`
  , WM = `
	vec3 negNormal = normal*0.5+0.5;
	vec3 posNormal = -normal*0.5+0.5;
	negNormal *= negNormal;
	posNormal *= posNormal;
`
  , XM = `
attribute vec4 particle_vertexData;
#ifdef USE_MESH
attribute vec2 particle_uv;
#endif
uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;
uniform mat3 matrix_normal;
uniform mat4 matrix_viewInverse;
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
uniform float numParticles, numParticlesPot;
uniform float graphSampleSize;
uniform float graphNumSamples;
uniform float stretch;
uniform vec3 wrapBounds;
uniform vec3 emitterScale, emitterPos, faceTangent, faceBinorm;
uniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;
uniform sampler2D particleTexOUT, particleTexIN;
uniform highp sampler2D internalTex0;
uniform highp sampler2D internalTex1;
uniform highp sampler2D internalTex2;
#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params;
#endif
varying vec4 texCoordsAlphaLife;
vec3 inPos;
vec3 inVel;
float inAngle;
bool inShow;
float inLife;
`
  , jM = `
	vec3 negNormal = max(normal, vec3(0.0));
	vec3 posNormal = max(-normal, vec3(0.0));
`
  , $M = `
	vec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +
						negNormal.y*lightCube[2] + posNormal.y*lightCube[3] +
						negNormal.z*lightCube[4] + posNormal.z*lightCube[5];
	rgb *= light;
`
  , qM = `
	particlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;
`
  , YM = `
	vec3 localPos = meshLocalPos;
	localPos.xy = rotate(localPos.xy, inAngle, rotMatrix);
	localPos.yz = rotate(localPos.yz, inAngle, rotMatrix);
	billboard(particlePos, quadXY);
`
  , KM = `
	Normal = normalize(localPos + matrix_viewInverse[2].xyz);
`
  , ZM = `
	vec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);
	vec3 normal = ParticleMat * normalMap;
`
  , QM = `
	inAngle = atan(velocityV.x, velocityV.y);
`
  , JM = `
	float depth = getLinearScreenDepth();
	float particleDepth = vDepth;
	float depthDiff = saturate(abs(particleDepth - depth) * softening);
	a *= depthDiff;
`
  , eP = `
	vDepth = getLinearDepth(localPos);
`
  , tP = `
	vec3 moveDir = inVel * stretch;
	vec3 posPrev = particlePos - moveDir;
	posPrev += particlePosMoved;
	vec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);
	float interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;
	particlePos = mix(particlePos, posPrev, interpolation);
`
  , sP = `
	mat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);
	ParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;
`
  , iP = `
	vec3 origParticlePos = particlePos;
	particlePos -= matrix_model[3].xyz;
	particlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;
	particlePos += matrix_model[3].xyz;
	particlePosMoved = particlePos - origParticlePos;
`
  , nP = `
void getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {
	dReflDirW = normalize(-reflect(viewDir, worldNormal));
}
`
  , rP = `
void getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {
	float roughness = sqrt(1.0 - min(gloss, 1.0));
	float anisotropy = material_anisotropy * roughness;
	vec3 anisotropicDirection = anisotropy >= 0.0 ? tbn[1] : tbn[0];
	vec3 anisotropicTangent = cross(anisotropicDirection, viewDir);
	vec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);
	vec3 bentNormal = normalize(mix(normalize(worldNormal), normalize(anisotropicNormal), anisotropy));
	dReflDirW = reflect(-viewDir, bentNormal);
}
`
  , aP = `
#ifdef LIT_CLEARCOAT
void addReflectionCC(vec3 reflDir, float gloss) {
	ccReflection += calcReflection(reflDir, gloss);
}
#endif
`
  , oP = `
uniform samplerCube texture_cubeMap;
uniform float material_reflectivity;
vec3 calcReflection(vec3 reflDir, float gloss) {
	vec3 lookupVec = fixSeams(cubeMapProject(reflDir));
	lookupVec.x *= -1.0;
	return $DECODE(textureCube(texture_cubeMap, lookupVec));
}
void addReflection(vec3 reflDir, float gloss) {   
	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`
  , lP = `
#ifndef ENV_ATLAS
#define ENV_ATLAS
uniform sampler2D texture_envAtlas;
#endif
uniform samplerCube texture_cubeMap;
uniform float material_reflectivity;
vec3 calcReflection(vec3 reflDir, float gloss) {
	vec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);
	vec2 uv = toSphericalUv(dir);
	float level = saturate(1.0 - gloss) * 5.0;
	float ilevel = floor(level);
	float flevel = level - ilevel;
	vec3 sharp = $DECODE_CUBEMAP(textureCube(texture_cubeMap, fixSeams(dir)));
	vec3 roughA = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel)));
	vec3 roughB = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));
	return processEnvironment(mix(sharp, mix(roughA, roughB, flevel), min(level, 1.0)));
}
void addReflection(vec3 reflDir, float gloss) {   
	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`
  , hP = `
#ifndef ENV_ATLAS
#define ENV_ATLAS
uniform sampler2D texture_envAtlas;
#endif
uniform float material_reflectivity;
float shinyMipLevel(vec2 uv) {
	vec2 dx = dFdx(uv);
	vec2 dy = dFdy(uv);
	vec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);
	vec2 dx2 = dFdx(uv2);
	vec2 dy2 = dFdy(uv2);
	float maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));
	return clamp(0.5 * log2(maxd) - 1.0 + textureBias, 0.0, 5.0);
}
vec3 calcReflection(vec3 reflDir, float gloss) {
	vec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);
	vec2 uv = toSphericalUv(dir);
	float level = saturate(1.0 - gloss) * 5.0;
	float ilevel = floor(level);
	float level2 = shinyMipLevel(uv * atlasSize);
	float ilevel2 = floor(level2);
	vec2 uv0, uv1;
	float weight;
	if (ilevel == 0.0) {
		uv0 = mapShinyUv(uv, ilevel2);
		uv1 = mapShinyUv(uv, ilevel2 + 1.0);
		weight = level2 - ilevel2;
	} else {
		uv0 = uv1 = mapRoughnessUv(uv, ilevel);
		weight = 0.0;
	}
	vec3 linearA = $DECODE(texture2D(texture_envAtlas, uv0));
	vec3 linearB = $DECODE(texture2D(texture_envAtlas, uv1));
	vec3 linear0 = mix(linearA, linearB, weight);
	vec3 linear1 = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));
	return processEnvironment(mix(linear0, linear1, level - ilevel));
}
void addReflection(vec3 reflDir, float gloss) {   
	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`
  , cP = `
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
uniform sampler2D texture_sphereMap;
uniform float material_reflectivity;
vec3 calcReflection(vec3 reflDir, float gloss) {
	vec3 reflDirV = (mat3(matrix_view) * reflDir).xyz;
	float m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );
	vec2 sphereMapUv = reflDirV.xy / m + 0.5;
	return $DECODE(texture2D(texture_sphereMap, sphereMapUv));
}
void addReflection(vec3 reflDir, float gloss) {   
	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`
  , dP = `
void addReflectionSheen(vec3 worldNormal, vec3 viewDir, float gloss) {
	float NoV = dot(worldNormal, viewDir);
	float alphaG = gloss * gloss;
	float a = gloss < 0.25 ? -339.2 * alphaG + 161.4 * gloss - 25.9 : -8.48 * alphaG + 14.3 * gloss - 9.95;
	float b = gloss < 0.25 ? 44.0 * alphaG - 23.7 * gloss + 3.26 : 1.97 * alphaG - 3.27 * gloss + 0.72;
	float DG = exp( a * NoV + b ) + ( gloss < 0.25 ? 0.0 : 0.1 * ( gloss - 0.25 ) );
	sReflection += calcReflection(worldNormal, 0.0) * saturate(DG);
}
`
  , uP = `
vec3 refract2(vec3 viewVec, vec3 normal, float IOR) {
	float vn = dot(viewVec, normal);
	float k = 1.0 - IOR * IOR * (1.0 - vn * vn);
	vec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * normal;
	return refrVec;
}
void addRefraction(
	vec3 worldNormal, 
	vec3 viewDir, 
	float thickness, 
	float gloss, 
	vec3 specularity, 
	vec3 albedo, 
	float transmission,
	float refractionIndex
#if defined(LIT_IRIDESCENCE)
	, vec3 iridescenceFresnel,
	float iridescenceIntensity
#endif 
) {
	vec4 tmpRefl = dReflection;
	vec3 reflectionDir = refract2(-viewDir, worldNormal, refractionIndex);
	dReflection = vec4(0);
	addReflection(reflectionDir, gloss);
	dDiffuseLight = mix(dDiffuseLight, dReflection.rgb * albedo, transmission);
	dReflection = tmpRefl;
}
`
  , fP = `
uniform float material_invAttenuationDistance;
uniform vec3 material_attenuation;
void addRefraction(
	vec3 worldNormal, 
	vec3 viewDir, 
	float thickness, 
	float gloss, 
	vec3 specularity, 
	vec3 albedo, 
	float transmission,
	float refractionIndex
#if defined(LIT_IRIDESCENCE)
	, vec3 iridescenceFresnel,
	float iridescenceIntensity
#endif
) {
	vec3 modelScale;
	modelScale.x = length(vec3(matrix_model[0].xyz));
	modelScale.y = length(vec3(matrix_model[1].xyz));
	modelScale.z = length(vec3(matrix_model[2].xyz));
	vec3 refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndex)) * thickness * modelScale;
	vec4 pointOfRefraction = vec4(vPositionW + refractionVector, 1.0);
	vec4 projectionPoint = matrix_viewProjection * pointOfRefraction;
	vec2 uv = getGrabScreenPos(projectionPoint);
	#ifdef SUPPORTS_TEXLOD
		float iorToRoughness = (1.0 - gloss) * clamp((1.0 / refractionIndex) * 2.0 - 2.0, 0.0, 1.0);
		float refractionLod = log2(uScreenSize.x) * iorToRoughness;
		vec3 refraction = texture2DLodEXT(uSceneColorMap, uv, refractionLod).rgb;
	#else
		vec3 refraction = texture2D(uSceneColorMap, uv).rgb;
	#endif
	vec3 transmittance;
	if (material_invAttenuationDistance != 0.0)
	{
		vec3 attenuation = -log(material_attenuation) * material_invAttenuationDistance;
		transmittance = exp(-attenuation * length(refractionVector));
	}
	else
	{
		transmittance = refraction;
	}
	vec3 fresnel = vec3(1.0) - 
		getFresnel(
			dot(viewDir, worldNormal), 
			gloss, 
			specularity
		#if defined(LIT_IRIDESCENCE)
			, iridescenceFresnel,
			iridescenceIntensity
		#endif
		);
	dDiffuseLight = mix(dDiffuseLight, refraction * transmittance * fresnel, transmission);
}
`
  , pP = `
varying vec2 vUv0;
#ifdef CUBEMAP_SOURCE
	uniform samplerCube sourceCube;
#else
	uniform sampler2D sourceTex;
#endif
#ifdef USE_SAMPLES_TEX
	uniform sampler2D samplesTex;
	uniform vec2 samplesTexInverseSize;
#endif
uniform vec4 params;
uniform vec2 params2;
float targetFace() { return params.x; }
float specularPower() { return params.y; }
float sourceCubeSeamScale() { return params.z; }
float targetCubeSeamScale() { return params.w; }
float targetTotalPixels() { return params2.x; }
float sourceTotalPixels() { return params2.y; }
float PI = 3.141592653589793;
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
${lx}
${hx}
vec3 modifySeams(vec3 dir, float scale) {
	vec3 adir = abs(dir);
	float M = max(max(adir.x, adir.y), adir.z);
	return dir / M * vec3(
		adir.x == M ? 1.0 : scale,
		adir.y == M ? 1.0 : scale,
		adir.z == M ? 1.0 : scale
	);
}
vec2 toSpherical(vec3 dir) {
	return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));
}
vec3 fromSpherical(vec2 uv) {
	return vec3(cos(uv.y) * sin(uv.x),
				sin(uv.y),
				cos(uv.y) * cos(uv.x));
}
vec3 getDirectionEquirect() {
	return fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));
}
float signNotZero(float k){
	return(k >= 0.0) ? 1.0 : -1.0;
}
vec2 signNotZero(vec2 v) {
	return vec2(signNotZero(v.x), signNotZero(v.y));
}
vec3 octDecode(vec2 o) {
	vec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);
	if (v.y < 0.0) {
		v.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);
	}
	return normalize(v);
}
vec3 getDirectionOctahedral() {
	return octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);
}
vec2 octEncode(in vec3 v) {
	float l1norm = abs(v.x) + abs(v.y) + abs(v.z);
	vec2 result = v.xz * (1.0 / l1norm);
	if (v.y < 0.0) {
		result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
	}
	return result;
}
#ifdef CUBEMAP_SOURCE
	vec4 sampleCubemap(vec3 dir) {
		return textureCube(sourceCube, modifySeams(dir, 1.0 - sourceCubeSeamScale()));
	}
	vec4 sampleCubemap(vec2 sph) {
	return sampleCubemap(fromSpherical(sph));
}
	vec4 sampleCubemap(vec3 dir, float mipLevel) {
		return textureCubeLodEXT(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()), mipLevel);
	}
	vec4 sampleCubemap(vec2 sph, float mipLevel) {
		return sampleCubemap(fromSpherical(sph), mipLevel);
	}
#else
	vec4 sampleEquirect(vec2 sph) {
		vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;
		return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));
	}
	vec4 sampleEquirect(vec3 dir) {
		return sampleEquirect(toSpherical(dir));
	}
	vec4 sampleEquirect(vec2 sph, float mipLevel) {
		vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;
		return texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);
	}
	vec4 sampleEquirect(vec3 dir, float mipLevel) {
		return sampleEquirect(toSpherical(dir), mipLevel);
	}
	vec4 sampleOctahedral(vec3 dir) {
		vec2 uv = octEncode(dir) * 0.5 + 0.5;
		return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));
	}
	vec4 sampleOctahedral(vec2 sph) {
		return sampleOctahedral(fromSpherical(sph));
	}
	vec4 sampleOctahedral(vec3 dir, float mipLevel) {
		vec2 uv = octEncode(dir) * 0.5 + 0.5;
		return texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);
	}
	vec4 sampleOctahedral(vec2 sph, float mipLevel) {
		return sampleOctahedral(fromSpherical(sph), mipLevel);
	}
#endif
vec3 getDirectionCubemap() {
	vec2 st = vUv0 * 2.0 - 1.0;
	float face = targetFace();
	vec3 vec;
	if (face == 0.0) {
		vec = vec3(1, -st.y, -st.x);
	} else if (face == 1.0) {
		vec = vec3(-1, -st.y, st.x);
	} else if (face == 2.0) {
		vec = vec3(st.x, 1, st.y);
	} else if (face == 3.0) {
		vec = vec3(st.x, -1, -st.y);
	} else if (face == 4.0) {
		vec = vec3(st.x, -st.y, 1);
	} else {
		vec = vec3(-st.x, -st.y, -1);
	}
	return normalize(modifySeams(vec, 1.0 / (1.0 - targetCubeSeamScale())));
}
mat3 matrixFromVector(vec3 n) {
	float a = 1.0 / (1.0 + n.z);
	float b = -n.x * n.y * a;
	vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);
	vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);
	return mat3(b1, b2, n);
}
mat3 matrixFromVectorSlow(vec3 n) {
	vec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);
	vec3 x = normalize(cross(up, n));
	vec3 y = cross(n, x);
	return mat3(x, y, n);
}
vec4 reproject() {
	if (NUM_SAMPLES <= 1) {
		return ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));
	} else {
		vec3 t = TARGET_FUNC();
		vec3 tu = dFdx(t);
		vec3 tv = dFdy(t);
		vec3 result = vec3(0.0);
		for (float u = 0.0; u < NUM_SAMPLES_SQRT; ++u) {
			for (float v = 0.0; v < NUM_SAMPLES_SQRT; ++v) {
				result += DECODE_FUNC(SOURCE_FUNC(normalize(t +
															tu * (u / NUM_SAMPLES_SQRT - 0.5) +
															tv * (v / NUM_SAMPLES_SQRT - 0.5))));
			}
		}
		return ENCODE_FUNC(result / (NUM_SAMPLES_SQRT * NUM_SAMPLES_SQRT));
	}
}
vec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);
#ifdef USE_SAMPLES_TEX
	void unpackSample(int i, out vec3 L, out float mipLevel) {
		float u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;
		float v = (floor(u) + 0.5) * samplesTexInverseSize.y;
		vec4 raw;
		raw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
		raw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
		raw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
		raw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);
		L.xyz = raw.xyz * 2.0 - 1.0;
		mipLevel = raw.w * 8.0;
	}
	vec4 prefilterSamples() {
		mat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());
		vec3 L;
		float mipLevel;
		vec3 result = vec3(0.0);
		float totalWeight = 0.0;
		for (int i = 0; i < NUM_SAMPLES; ++i) {
			unpackSample(i, L, mipLevel);
			result += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel)) * L.z;
			totalWeight += L.z;
		}
		return ENCODE_FUNC(result / totalWeight);
	}
	vec4 prefilterSamplesUnweighted() {
		mat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());
		vec3 L;
		float mipLevel;
		vec3 result = vec3(0.0);
		float totalWeight = 0.0;
		for (int i = 0; i < NUM_SAMPLES; ++i) {
			unpackSample(i, L, mipLevel);
			result += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel));
		}
		return ENCODE_FUNC(result / float(NUM_SAMPLES));
	}
#endif
void main(void) {
	gl_FragColor = PROCESS_FUNC();
}
`
  , mP = `
uniform highp sampler2D uSceneDepthMap;
#ifndef SCREENSIZE
#define SCREENSIZE
uniform vec4 uScreenSize;
#endif
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
#ifndef LINEARIZE_DEPTH
#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params;
#endif
#define LINEARIZE_DEPTH
#ifdef GL2
float linearizeDepth(float z) {
	if (camera_params.w == 0.0)
		return (camera_params.z * camera_params.y) / (camera_params.y + z * (camera_params.z - camera_params.y));
	else
		return camera_params.z + z * (camera_params.y - camera_params.z);
}
#else
#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
	const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
	return dot(rgbaDepth, bitShift);
}
#endif
#endif
#endif
float getLinearScreenDepth(vec2 uv) {
	#ifdef GL2
		return linearizeDepth(texture2D(uSceneDepthMap, uv).r);
	#else
		return unpackFloat(texture2D(uSceneDepthMap, uv)) * camera_params.y;
	#endif
}
#ifndef VERTEXSHADER
float getLinearScreenDepth() {
	vec2 uv = gl_FragCoord.xy * uScreenSize.zw;
	return getLinearScreenDepth(uv);
}
#endif
float getLinearDepth(vec3 pos) {
	return -(matrix_view * vec4(pos, 1.0)).z;
}
`
  , _P = `
const float maxCascades = 4.0;
mat4 cascadeShadowMat;
void getShadowCascadeMatrix(mat4 shadowMatrixPalette[4], float shadowCascadeDistances[4], float shadowCascadeCount) {
	float depth = 1.0 / gl_FragCoord.w;
	float cascadeIndex = 0.0;
	for (float i = 0.0; i < maxCascades; i++) {
		if (depth < shadowCascadeDistances[int(i)]) {
			cascadeIndex = i;
			break;
		}
	}
	cascadeIndex = min(cascadeIndex, shadowCascadeCount - 1.0);
	#ifdef GL2
		cascadeShadowMat = shadowMatrixPalette[int(cascadeIndex)];
	#else
		if (cascadeIndex == 0.0) {
			cascadeShadowMat = shadowMatrixPalette[0];
		}
		else if (cascadeIndex == 1.0) {
			cascadeShadowMat = shadowMatrixPalette[1];
		}
		else if (cascadeIndex == 2.0) {
			cascadeShadowMat = shadowMatrixPalette[2];
		}
		else {
			cascadeShadowMat = shadowMatrixPalette[3];
		}
	#endif
}
void fadeShadow(float shadowCascadeDistances[4]) {				  
	float depth = 1.0 / gl_FragCoord.w;
	if (depth > shadowCascadeDistances[int(maxCascades - 1.0)]) {
		dShadowCoord.z = -9999999.0;
	}
}
`
  , gP = `
float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
	vec3 moments = texture2D(tex, texCoords).xyz;
	return calculateEVSM(moments, Z, vsmBias, exponent);
}
float getShadowVSM$(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM$(shadowMap, shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);
}
float getShadowSpotVSM$(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM$(shadowMap, shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);
}
`
  , yP = `
float VSM$(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
	float pixelSize = 1.0 / resolution;
	texCoords -= vec2(pixelSize);
	vec3 s00 = texture2D(tex, texCoords).xyz;
	vec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;
	vec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;
	vec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;
	vec2 fr = fract(texCoords * resolution);
	vec3 h0 = mix(s00, s10, fr.x);
	vec3 h1 = mix(s01, s11, fr.x);
	vec3 moments = mix(h0, h1, fr.y);
	return calculateEVSM(moments, Z, vsmBias, exponent);
}
float getShadowVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);
}
float getShadowSpotVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);
}
`
  , vP = `
#define PCSS_SAMPLE_COUNT 16
uniform float pcssDiskSamples[PCSS_SAMPLE_COUNT];
uniform float pcssSphereSamples[PCSS_SAMPLE_COUNT];
vec2 vogelDisk(int sampleIndex, float count, float phi, float r) {
	const float GoldenAngle = 2.4;
	float theta = float(sampleIndex) * GoldenAngle + phi;
	float sine = sin(theta);
	float cosine = cos(theta);
	return vec2(r * cosine, r * sine);
}
vec3 vogelSphere(int sampleIndex, float count, float phi, float r) {
	const float GoldenAngle = 2.4;
	float theta = float(sampleIndex) * GoldenAngle + phi;
	float weight = float(sampleIndex) / count;
	return vec3(cos(theta) * r, weight, sin(theta) * r);
}
float noise(vec2 screenPos) {
	const float PHI = 1.61803398874989484820459;
	return fract(sin(dot(screenPos * PHI, screenPos)) * screenPos.x);
}
#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
	const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
	return dot(rgbaDepth, bitShift);
}
#endif
float viewSpaceDepth(float depth, mat4 invProjection) {
	float z = depth * 2.0 - 1.0;
	vec4 clipSpace = vec4(0.0, 0.0, z, 1.0);
	vec4 viewSpace = invProjection * clipSpace;
	return viewSpace.z;
}
float PCSSBlockerDistance(TEXTURE_ACCEPT(shadowMap), vec2 sampleCoords[PCSS_SAMPLE_COUNT], vec2 shadowCoords, vec2 searchSize, float z) {
	float blockers = 0.0;
	float averageBlocker = 0.0;
	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
		vec2 offset = sampleCoords[i] * searchSize;
		vec2 sampleUV = shadowCoords + offset;
	#ifdef GL2
		float blocker = textureLod(shadowMap, sampleUV, 0.0).r;
	#else
		float blocker = unpackFloat(texture2D(shadowMap, sampleUV));
	#endif		
		float isBlocking = step(blocker, z);
		blockers += isBlocking;
		averageBlocker += blocker * isBlocking;
	}
	if (blockers > 0.0)
		return averageBlocker /= blockers;
	return -1.0;
}
float PCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoords, vec4 cameraParams, vec2 shadowSearchArea) {
	float receiverDepth = shadowCoords.z;
#ifndef GL2
	receiverDepth *= 1.0 / (cameraParams.y - cameraParams.z);
#endif
	vec2 samplePoints[PCSS_SAMPLE_COUNT];
	float noise = noise( gl_FragCoord.xy ) * 2.0 * PI;
	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
		float pcssPresample = pcssDiskSamples[i];
		samplePoints[i] = vogelDisk(i, float(PCSS_SAMPLE_COUNT), noise, pcssPresample);
	}
	float averageBlocker = PCSSBlockerDistance(TEXTURE_PASS(shadowMap), samplePoints, shadowCoords.xy, shadowSearchArea, receiverDepth);
	if (averageBlocker == -1.0) {
		return 1.0;
	} else {
		vec2 filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea * cameraParams.x;
		float shadow = 0.0;
		for (int i = 0; i < PCSS_SAMPLE_COUNT; i ++)
		{
			vec2 sampleUV = samplePoints[i] * filterRadius;
			sampleUV = shadowCoords.xy + sampleUV;
		#ifdef GL2
			float depth = textureLod(shadowMap, sampleUV, 0.0).r;
		#else
			float depth = unpackFloat(texture2D(shadowMap, sampleUV));
		#endif
			shadow += step(receiverDepth, depth);
		}
		return shadow / float(PCSS_SAMPLE_COUNT);
	} 
}
float PCSSCubeBlockerDistance(samplerCube shadowMap, vec3 lightDirNorm, vec3 samplePoints[PCSS_SAMPLE_COUNT], float z, float shadowSearchArea) {
	float blockers = 0.0;
	float averageBlocker = 0.0;
	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
		vec3 sampleDir = lightDirNorm + samplePoints[i] * shadowSearchArea;
		sampleDir = normalize(sampleDir);
	#ifdef GL2
		float blocker = textureCubeLodEXT(shadowMap, sampleDir, 0.0).r;
	#else
		float blocker = unpackFloat(textureCube(shadowMap, sampleDir));
	#endif
		float isBlocking = step(blocker, z);
		blockers += isBlocking;
		averageBlocker += blocker * isBlocking;
	}
	if (blockers > 0.0)
		return averageBlocker /= float(blockers);
	return -1.0;
}
float PCSSCube(samplerCube shadowMap, vec4 shadowParams, vec3 shadowCoords, vec4 cameraParams, float shadowSearchArea, vec3 lightDir) {
	
	vec3 samplePoints[PCSS_SAMPLE_COUNT];
	float noise = noise( gl_FragCoord.xy ) * 2.0 * PI;
	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
		float r = pcssSphereSamples[i];
		samplePoints[i] = vogelSphere(i, float(PCSS_SAMPLE_COUNT), noise, r);
	}
	float receiverDepth = length(lightDir) * shadowParams.w + shadowParams.z;
	vec3 lightDirNorm = normalize(lightDir);
	
	float averageBlocker = PCSSCubeBlockerDistance(shadowMap, lightDirNorm, samplePoints, receiverDepth, shadowSearchArea);
	if (averageBlocker == -1.0) {
		return 1.0;
	} else {
		float filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea;
		float shadow = 0.0;
		for (int i = 0; i < PCSS_SAMPLE_COUNT; i++)
		{
			vec3 offset = samplePoints[i] * filterRadius;
			vec3 sampleDir = lightDirNorm + offset;
			sampleDir = normalize(sampleDir);
			#ifdef GL2
				float depth = textureCubeLodEXT(shadowMap, sampleDir, 0.0).r;
			#else
				float depth = unpackFloat(textureCube(shadowMap, sampleDir));
			#endif
			shadow += step(receiverDepth, depth);
		}
		return shadow / float(PCSS_SAMPLE_COUNT);
	}
}
float getShadowPointPCSS(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {
	return PCSSCube(shadowMap, shadowParams, shadowCoord, cameraParams, shadowSearchArea.x, lightDir);
}
float getShadowSpotPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {
	return PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);
}
float getShadowPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {
	return PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);
}
`
  , SP = `
vec3 getShadowSampleCoord$LIGHT(mat4 shadowTransform, vec4 shadowParams, vec3 worldPosition, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {
	vec3 surfacePosition = worldPosition;
#ifdef SHADOW_SAMPLE_POINT
	#ifdef SHADOW_SAMPLE_NORMAL_OFFSET
		float distScale = length(lightDir);
		surfacePosition = worldPosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
		lightDir = surfacePosition - lightPos;
		return lightDir;
	#endif
#else
	#ifdef SHADOW_SAMPLE_SOURCE_ZBUFFER
		#ifdef SHADOW_SAMPLE_NORMAL_OFFSET
			surfacePosition = worldPosition + normal * shadowParams.y;
		#endif
	#else
		#ifdef SHADOW_SAMPLE_NORMAL_OFFSET
			#ifdef SHADOW_SAMPLE_ORTHO
				float distScale = 1.0;
			#else
				float distScale = abs(dot(vPositionW - lightPos, lightDirNorm));
			#endif
			surfacePosition = worldPosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
		#endif
	#endif
	vec4 positionInShadowSpace = shadowTransform * vec4(surfacePosition, 1.0);
	#ifdef SHADOW_SAMPLE_ORTHO
		positionInShadowSpace.z = saturate(positionInShadowSpace.z) - 0.0001;
	#else
		#ifdef SHADOW_SAMPLE_SOURCE_ZBUFFER
			positionInShadowSpace.xyz /= positionInShadowSpace.w;
		#else
			positionInShadowSpace.xy /= positionInShadowSpace.w;
			positionInShadowSpace.z = length(lightDir) * shadowParams.w;
		#endif
	#endif
	#ifdef SHADOW_SAMPLE_Z_BIAS
		positionInShadowSpace.z += getShadowBias(shadowParams.x, shadowParams.z);
	#endif
	surfacePosition = positionInShadowSpace.xyz;
#endif
	return surfacePosition;
}
`
  , xP = `
vec3 lessThan2(vec3 a, vec3 b) {
	return clamp((b - a)*1000.0, 0.0, 1.0);
}
#ifndef UNPACKFLOAT
#define UNPACKFLOAT
	float unpackFloat(vec4 rgbaDepth) {
		const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
		return dot(rgbaDepth, bitShift);
	}
#endif
#ifdef GL2
float _getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {
	float z = shadowCoord.z;
	vec2 uv = shadowCoord.xy * shadowParams.x;
	float shadowMapSizeInv = 1.0 / shadowParams.x;
	vec2 base_uv = floor(uv + 0.5);
	float s = (uv.x + 0.5 - base_uv.x);
	float t = (uv.y + 0.5 - base_uv.y);
	base_uv -= vec2(0.5);
	base_uv *= shadowMapSizeInv;
	float sum = 0.0;
	float uw0 = (3.0 - 2.0 * s);
	float uw1 = (1.0 + 2.0 * s);
	float u0 = (2.0 - s) / uw0 - 1.0;
	float u1 = s / uw1 + 1.0;
	float vw0 = (3.0 - 2.0 * t);
	float vw1 = (1.0 + 2.0 * t);
	float v0 = (2.0 - t) / vw0 - 1.0;
	float v1 = t / vw1 + 1.0;
	u0 = u0 * shadowMapSizeInv + base_uv.x;
	v0 = v0 * shadowMapSizeInv + base_uv.y;
	u1 = u1 * shadowMapSizeInv + base_uv.x;
	v1 = v1 * shadowMapSizeInv + base_uv.y;
	sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));
	sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));
	sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));
	sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));
	sum *= 1.0f / 16.0;
	return sum;
}
float getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}
float getShadowSpotPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}
float getShadowPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return textureShadow(shadowMap, shadowCoord);
}
float getShadowSpotPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return textureShadow(shadowMap, shadowCoord);
}
#else
float _xgetShadowPCF3x3(mat3 depthKernel, vec3 shadowCoord, sampler2D shadowMap, vec3 shadowParams) {
	mat3 shadowKernel;
	vec3 shadowZ = vec3(shadowCoord.z);
	shadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));
	shadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));
	shadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));
	vec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );
	shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);
	shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);
	vec4 shadowValues;
	shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);
	shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);
	shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);
	shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);
	return dot( shadowValues, vec4( 1.0 ) ) * 0.25;
}
float _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowCoord, vec3 shadowParams) {
	float xoffset = 1.0 / shadowParams.x;
	float dx0 = -xoffset;
	float dx1 = xoffset;
	mat3 depthKernel;
	depthKernel[0][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));
	depthKernel[0][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));
	depthKernel[0][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));
	depthKernel[1][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));
	depthKernel[1][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));
	depthKernel[1][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));
	depthKernel[2][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));
	depthKernel[2][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));
	depthKernel[2][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));
	return _xgetShadowPCF3x3(depthKernel, shadowCoord, shadowMap, shadowParams);
}
float getShadowPCF3x3(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF3x3(shadowMap, shadowCoord, shadowParams.xyz);
}
float getShadowSpotPCF3x3(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF3x3(shadowMap, shadowCoord, shadowParams.xyz);
}
float _getShadowPCF1x1(sampler2D shadowMap, vec3 shadowCoord) {
	float shadowSample = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));
	return shadowSample > shadowCoord.z ? 1.0 : 0.0;
}
float getShadowPCF1x1(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF1x1(shadowMap, shadowCoord);
}
float getShadowSpotPCF1x1(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF1x1(shadowMap, shadowCoord);
}
#endif
#ifndef WEBGPU
float _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {
	vec3 tc = normalize(dir);
	vec3 tcAbs = abs(tc);
	vec4 dirX = vec4(1,0,0, tc.x);
	vec4 dirY = vec4(0,1,0, tc.y);
	float majorAxisLength = tc.z;
	if ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {
		dirX = vec4(0,0,1, tc.z);
		dirY = vec4(0,1,0, tc.y);
		majorAxisLength = tc.x;
	} else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {
		dirX = vec4(1,0,0, tc.x);
		dirY = vec4(0,0,1, tc.z);
		majorAxisLength = tc.y;
	}
	float shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);
	vec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);
	vec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);
	vec3 dx0 = -xoffset;
	vec3 dy0 = -yoffset;
	vec3 dx1 = xoffset;
	vec3 dy1 = yoffset;
	mat3 shadowKernel;
	mat3 depthKernel;
	depthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));
	depthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));
	depthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));
	depthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));
	depthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));
	depthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));
	depthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));
	depthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));
	depthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));
	vec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);
	shadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));
	shadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));
	shadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));
	vec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;
	vec2 fractionalCoord = fract( uv * shadowParams.x );
	shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);
	shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);
	vec4 shadowValues;
	shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);
	shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);
	shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);
	shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);
	return 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;
}
float getShadowPointPCF3x3(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {
	return _getShadowPoint(shadowMap, shadowParams, lightDir);
}
#endif
`
  , wP = `
float _getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {
	float z = shadowCoord.z;
	vec2 uv = shadowCoord.xy * shadowParams.x;
	float shadowMapSizeInv = 1.0 / shadowParams.x;
	vec2 base_uv = floor(uv + 0.5);
	float s = (uv.x + 0.5 - base_uv.x);
	float t = (uv.y + 0.5 - base_uv.y);
	base_uv -= vec2(0.5);
	base_uv *= shadowMapSizeInv;
	float uw0 = (4.0 - 3.0 * s);
	float uw1 = 7.0;
	float uw2 = (1.0 + 3.0 * s);
	float u0 = (3.0 - 2.0 * s) / uw0 - 2.0;
	float u1 = (3.0 + s) / uw1;
	float u2 = s / uw2 + 2.0;
	float vw0 = (4.0 - 3.0 * t);
	float vw1 = 7.0;
	float vw2 = (1.0 + 3.0 * t);
	float v0 = (3.0 - 2.0 * t) / vw0 - 2.0;
	float v1 = (3.0 + t) / vw1;
	float v2 = t / vw2 + 2.0;
	float sum = 0.0;
	u0 = u0 * shadowMapSizeInv + base_uv.x;
	v0 = v0 * shadowMapSizeInv + base_uv.y;
	u1 = u1 * shadowMapSizeInv + base_uv.x;
	v1 = v1 * shadowMapSizeInv + base_uv.y;
	u2 = u2 * shadowMapSizeInv + base_uv.x;
	v2 = v2 * shadowMapSizeInv + base_uv.y;
	sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));
	sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));
	sum += uw2 * vw0 * textureShadow(shadowMap, vec3(u2, v0, z));
	sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));
	sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));
	sum += uw2 * vw1 * textureShadow(shadowMap, vec3(u2, v1, z));
	sum += uw0 * vw2 * textureShadow(shadowMap, vec3(u0, v2, z));
	sum += uw1 * vw2 * textureShadow(shadowMap, vec3(u1, v2, z));
	sum += uw2 * vw2 * textureShadow(shadowMap, vec3(u2, v2, z));
	sum *= 1.0f / 144.0;
	sum = saturate(sum);
	return sum;
}
float getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}
float getShadowSpotPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}
`
  , bP = `
float calculateVSM8(vec3 moments, float Z, float vsmBias) {
	float VSMBias = vsmBias;
	float depthScale = VSMBias * Z;
	float minVariance1 = depthScale * depthScale;
	return chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);
}
float decodeFloatRG(vec2 rg) {
	return rg.y*(1.0/255.0) + rg.x;
}
float VSM8(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
	vec4 c = texture2D(tex, texCoords);
	vec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);
	return calculateVSM8(moments, Z, vsmBias);
}
float getShadowVSM8(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM8(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, 0.0);
}
float getShadowSpotVSM8(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM8(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);
}
`
  , TP = `
float linstep(float a, float b, float v) {
	return saturate((v - a) / (b - a));
}
float reduceLightBleeding(float pMax, float amount) {
	 return linstep(amount, 1.0, pMax);
}
float chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {
	float variance = moments.y - (moments.x * moments.x);
	variance = max(variance, minVariance);
	float d = mean - moments.x;
	float pMax = variance / (variance + (d * d));
	pMax = reduceLightBleeding(pMax, lightBleedingReduction);
	return (mean <= moments.x ? 1.0 : pMax);
}
float calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {
	Z = 2.0 * Z - 1.0;
	float warpedDepth = exp(exponent * Z);
	moments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);
	float VSMBias = vsmBias;
	float depthScale = VSMBias * exponent * warpedDepth;
	float minVariance1 = depthScale * depthScale;
	return chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);
}
`
  , CP = `
attribute float vertex_boneIndices;
uniform vec4 matrix_pose[BONE_LIMIT * 3];
mat4 getBoneMatrix(const in float i) {
	vec4 v1 = matrix_pose[int(3.0 * i)];
	vec4 v2 = matrix_pose[int(3.0 * i + 1.0)];
	vec4 v3 = matrix_pose[int(3.0 * i + 2.0)];
	return mat4(
		v1.x, v2.x, v3.x, 0,
		v1.y, v2.y, v3.y, 0,
		v1.z, v2.z, v3.z, 0,
		v1.w, v2.w, v3.w, 1
	);
}
`
  , EP = `
attribute float vertex_boneIndices;
uniform highp sampler2D texture_poseMap;
uniform vec4 texture_poseMapSize;
mat4 getBoneMatrix(const in float i) {
	float j = i * 3.0;
	float dx = texture_poseMapSize.z;
	float dy = texture_poseMapSize.w;
	float y = floor(j * dx);
	float x = j - (y * texture_poseMapSize.x);
	y = dy * (y + 0.5);
	vec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));
	vec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));
	vec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));
	return mat4(
		v1.x, v2.x, v3.x, 0,
		v1.y, v2.y, v3.y, 0,
		v1.z, v2.z, v3.z, 0,
		v1.w, v2.w, v3.w, 1
	);
}
`
  , AP = `
attribute vec4 vertex_boneWeights;
attribute vec4 vertex_boneIndices;
uniform vec4 matrix_pose[BONE_LIMIT * 3];
void getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {
	v1 = matrix_pose[int(3.0 * i)];
	v2 = matrix_pose[int(3.0 * i + 1.0)];
	v3 = matrix_pose[int(3.0 * i + 2.0)];
}
mat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {
	vec4 a1, a2, a3;
	getBoneMatrix(indices.x, a1, a2, a3);
	vec4 b1, b2, b3;
	getBoneMatrix(indices.y, b1, b2, b3);
	vec4 c1, c2, c3;
	getBoneMatrix(indices.z, c1, c2, c3);
	vec4 d1, d2, d3;
	getBoneMatrix(indices.w, d1, d2, d3);
	vec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;
	vec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;
	vec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;
	float one = dot(weights, vec4(1.0));
	return mat4(
		v1.x, v2.x, v3.x, 0,
		v1.y, v2.y, v3.y, 0,
		v1.z, v2.z, v3.z, 0,
		v1.w, v2.w, v3.w, one
	);
}
`
  , MP = `
attribute vec4 vertex_boneWeights;
attribute vec4 vertex_boneIndices;
uniform highp sampler2D texture_poseMap;
uniform vec4 texture_poseMapSize;
void getBoneMatrix(const in float index, out vec4 v1, out vec4 v2, out vec4 v3) {
	float i = float(index);
	float j = i * 3.0;
	float dx = texture_poseMapSize.z;
	float dy = texture_poseMapSize.w;
	
	float y = floor(j * dx);
	float x = j - (y * texture_poseMapSize.x);
	y = dy * (y + 0.5);
	v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));
	v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));
	v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));
}
mat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {
	vec4 a1, a2, a3;
	getBoneMatrix(indices.x, a1, a2, a3);
	vec4 b1, b2, b3;
	getBoneMatrix(indices.y, b1, b2, b3);
	vec4 c1, c2, c3;
	getBoneMatrix(indices.z, c1, c2, c3);
	vec4 d1, d2, d3;
	getBoneMatrix(indices.w, d1, d2, d3);
	vec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;
	vec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;
	vec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;
	float one = dot(weights, vec4(1.0));
	return mat4(
		v1.x, v2.x, v3.x, 0,
		v1.y, v2.y, v3.y, 0,
		v1.z, v2.z, v3.z, 0,
		v1.w, v2.w, v3.w, one
	);
}
`
  , PP = `
varying vec3 vViewDir;
uniform sampler2D texture_envAtlas;
uniform float mipLevel;
void main(void) {
	vec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);
	vec2 uv = toSphericalUv(normalize(dir));
	vec3 linear = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));
	gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);
}
`
  , RP = `
varying vec3 vViewDir;
uniform samplerCube texture_cubeMap;
#ifdef SKYMESH
	varying vec3 vWorldPos;
	uniform mat3 cubeMapRotationMatrix;
	uniform vec3 projectedSkydomeCenter;
#endif
void main(void) {
	#ifdef SKYMESH
		vec3 envDir = normalize(vWorldPos - projectedSkydomeCenter);
		vec3 dir = envDir * cubeMapRotationMatrix;
	#else
		vec3 dir = vViewDir;
	#endif
	dir.x *= -1.0;
	vec3 linear = $DECODE(textureCube(texture_cubeMap, fixSeamsStatic(dir, $FIXCONST)));
	gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);
}
`
  , IP = `
attribute vec3 aPosition;
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
uniform mat4 matrix_projectionSkybox;
uniform mat3 cubeMapRotationMatrix;
varying vec3 vViewDir;
#ifdef SKYMESH
	uniform mat4 matrix_model;
	varying vec3 vWorldPos;
#endif
void main(void) {
	mat4 view = matrix_view;
	#ifdef SKYMESH
		vec4 worldPos = matrix_model * vec4(aPosition, 1.0);
		vWorldPos = worldPos.xyz;
		gl_Position = matrix_projectionSkybox * view * worldPos;
	#else
		view[3][0] = view[3][1] = view[3][2] = 0.0;
		gl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);
		vViewDir = aPosition * cubeMapRotationMatrix;
	#endif
	gl_Position.z = gl_Position.w - 0.00001;
}
`
  , LP = `
#ifdef MAPCOLOR
uniform vec3 material_specular;
#endif
void getSpecularity() {
	vec3 specularColor = vec3(1,1,1);
	#ifdef MAPCOLOR
	specularColor *= material_specular;
	#endif
	#ifdef MAPTEXTURE
	specularColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
	#endif
	#ifdef MAPVERTEX
	specularColor *= saturate(vVertexColor.$VC);
	#endif
	dSpecularity = specularColor;
}
`
  , DP = `
const float PI = 3.141592653589793;
vec2 toSpherical(vec3 dir) {
	return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));
}
vec2 toSphericalUv(vec3 dir) {
	vec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;
	return vec2(uv.x, 1.0 - uv.y);
}
`
  , OP = `
#ifdef MAPFLOAT
uniform float material_specularityFactor;
#endif
void getSpecularityFactor() {
	float specularityFactor = 1.0;
	#ifdef MAPFLOAT
	specularityFactor *= material_specularityFactor;
	#endif
	#ifdef MAPTEXTURE
	specularityFactor *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	specularityFactor *= saturate(vVertexColor.$VC);
	#endif
	dSpecularityFactor = specularityFactor;
}
`
  , FP = `
float getSpotEffect(vec3 lightSpotDir, float lightInnerConeAngle, float lightOuterConeAngle, vec3 lightDirNorm) {
	float cosAngle = dot(lightDirNorm, lightSpotDir);
	return smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);
}
`
  , BP = `
void main(void) {
	dReflection = vec4(0);
	#ifdef LIT_CLEARCOAT
	ccSpecularLight = vec3(0);
	ccReflection = vec3(0);
	#endif
`
  , kP = `
void main(void) {
	gl_Position = getPosition();
`
  , NP = `
	nineSlicedUv = vUv0;
	nineSlicedUv.y = 1.0 - nineSlicedUv.y;
`
  , UP = `
	vec2 tileMask = step(vMask, vec2(0.99999));
	vec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);
	vec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);
	vec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));
	clampedUv = clampedUv * atlasRect.zw + atlasRect.xy;
	nineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);
	nineSlicedUv.y = 1.0 - nineSlicedUv.y;
	
`
  , zP = `
float exponent = VSM_EXPONENT;
depth = 2.0 * depth - 1.0;
depth =  exp(exponent * depth);
gl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);
`
  , VP = `
vec3 getTangent() {
	return normalize(dNormalMatrix * vertex_tangent.xyz);
}
vec3 getBinormal() {
	return cross(vNormalW, vTangentW) * vertex_tangent.w;
}
`
  , GP = `
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {
	dTBN = mat3(normalize(tangent), normalize(binormal), normalize(normal));
}
`
  , HP = `
uniform float tbnBasis;
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {
	vec2 uv = $UV;
	vec3 dp1 = dFdx( vPositionW );
	vec3 dp2 = dFdy( vPositionW );
	vec2 duv1 = dFdx( uv );
	vec2 duv2 = dFdy( uv );
	vec3 dp2perp = cross( dp2, normal );
	vec3 dp1perp = cross( normal, dp1 );
	vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
	vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
	float denom = max( dot(T,T), dot(B,B) );
	float invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );
	dTBN = mat3(T * invmax, -B * invmax, normal );
}
`
  , WP = `
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {
	dTBN = mat3(tangent, binormal, normal);
}
`
  , XP = `
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {
	vec3 B = cross(normal, vObjectSpaceUpW);
	vec3 T = cross(normal, B);
	if (dot(B,B)==0.0)
	{
		float major=max(max(normal.x, normal.y), normal.z);
		if (normal.x == major)
		{
			B=cross(normal, vec3(0,1,0));
			T=cross(normal, B);
		}
		else if (normal.y == major)
		{
			B=cross(normal, vec3(0,0,1));
			T=cross(normal, B);
		}
		else if (normal.z == major)
		{
			B=cross(normal, vec3(1,0,0));
			T=cross(normal, B);
		}
	}
	dTBN = mat3(normalize(T), normalize(B), normalize(normal));
}
`
  , jP = `
vec4 texture2DSRGB(sampler2D tex, vec2 uv) {
	return gammaCorrectInput(texture2D(tex, uv));
}
vec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {
	return gammaCorrectInput(texture2D(tex, uv, bias));
}
vec3 texture2DRGBM(sampler2D tex, vec2 uv) {
	return decodeRGBM(texture2D(tex, uv));
}
vec3 texture2DRGBM(sampler2D tex, vec2 uv, float bias) {
	return decodeRGBM(texture2D(tex, uv, bias));
}
vec3 texture2DRGBE(sampler2D tex, vec2 uv) {
	return decodeRGBM(texture2D(tex, uv));
}
vec3 texture2DRGBE(sampler2D tex, vec2 uv, float bias) {
	return decodeRGBM(texture2D(tex, uv, bias));
}
`
  , $P = `
#ifdef MAPFLOAT
uniform float material_thickness;
#endif
void getThickness() {
	dThickness = 1.0;
	#ifdef MAPFLOAT
	dThickness *= material_thickness;
	#endif
	#ifdef MAPTEXTURE
	dThickness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	dThickness *= saturate(vVertexColor.$VC);
	#endif
}
`
  , qP = `
uniform float exposure;
vec3 toneMap(vec3 color) {
	float tA = 2.51;
	float tB = 0.03;
	float tC = 2.43;
	float tD = 0.59;
	float tE = 0.14;
	vec3 x = color * exposure;
	return (x*(tA*x+tB))/(x*(tC*x+tD)+tE);
}
`
  , YP = `
uniform float exposure;
const mat3 ACESInputMat = mat3(
	0.59719, 0.35458, 0.04823,
	0.07600, 0.90834, 0.01566,
	0.02840, 0.13383, 0.83777
);
const mat3 ACESOutputMat = mat3(
	 1.60475, -0.53108, -0.07367,
	-0.10208,  1.10813, -0.00605,
	-0.00327, -0.07276,  1.07602
);
vec3 RRTAndODTFit(vec3 v) {
	vec3 a = v * (v + 0.0245786) - 0.000090537;
	vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
	return a / b;
}
vec3 toneMap(vec3 color) {
	color *= exposure / 0.6;
	color = color * ACESInputMat;
	color = RRTAndODTFit(color);
	color = color * ACESOutputMat;
	color = clamp(color, 0.0, 1.0);
	return color;
}
`
  , KP = `
const float A =  0.15;
const float B =  0.50;
const float C =  0.10;
const float D =  0.20;
const float E =  0.02;
const float F =  0.30;
const float W =  11.2;
uniform float exposure;
vec3 uncharted2Tonemap(vec3 x) {
	 return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}
vec3 toneMap(vec3 color) {
	color = uncharted2Tonemap(color * exposure);
	vec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));
	color = color * whiteScale;
	return color;
}
`
  , ZP = `
uniform float exposure;
vec3 toneMap(vec3 color) {
	color *= exposure;
	const float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;
	const float Scl = 1.25;
	vec3 h = max( vec3(0.0), color - vec3(0.004) );
	return (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);
}
`
  , QP = `
uniform float exposure;
vec3 toneMap(vec3 color) {
	return color * exposure;
}
`
  , JP = `
vec3 toneMap(vec3 color) {
	return color;
}
`
  , eR = `
#ifdef PIXELSNAP
uniform vec4 uScreenSize;
#endif
#ifdef SCREENSPACE
uniform float projectionFlipY;
#endif
#ifdef MORPHING
uniform vec4 morph_weights_a;
uniform vec4 morph_weights_b;
#endif
#ifdef MORPHING_TEXTURE_BASED
	uniform vec4 morph_tex_params;
	#ifdef WEBGPU
		ivec2 getTextureMorphCoords() {
			ivec2 textureSize = ivec2(morph_tex_params.xy);
			int morphGridV = int(morph_vertex_id / textureSize.x);
			int morphGridU = int(morph_vertex_id - (morphGridV * textureSize.x));
			morphGridV = textureSize.y - morphGridV - 1;
			return ivec2(morphGridU, morphGridV);
		}
	#else
		vec2 getTextureMorphCoords() {
			vec2 textureSize = morph_tex_params.xy;
			vec2 invTextureSize = morph_tex_params.zw;
			float morphGridV = floor(morph_vertex_id * invTextureSize.x);
			float morphGridU = morph_vertex_id - (morphGridV * textureSize.x);
			return vec2(morphGridU, morphGridV) * invTextureSize + (0.5 * invTextureSize);
		}
	#endif
#endif
#ifdef MORPHING_TEXTURE_BASED_POSITION
uniform highp sampler2D morphPositionTex;
#endif
mat4 getModelMatrix() {
	#ifdef DYNAMICBATCH
	return getBoneMatrix(vertex_boneIndices);
	#elif defined(SKIN)
	return matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);
	#elif defined(INSTANCING)
	return mat4(instance_line1, instance_line2, instance_line3, instance_line4);
	#else
	return matrix_model;
	#endif
}
vec4 getPosition() {
	dModelMatrix = getModelMatrix();
	vec3 localPos = vertex_position;
	#ifdef NINESLICED
	localPos.xz *= outerScale;
	vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));
	vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));
	localPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;
	vTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0;
	localPos.xz *= -0.5;
	localPos = localPos.xzy;
	#endif
	#ifdef MORPHING
	#ifdef MORPHING_POS03
	localPos.xyz += morph_weights_a[0] * morph_pos0;
	localPos.xyz += morph_weights_a[1] * morph_pos1;
	localPos.xyz += morph_weights_a[2] * morph_pos2;
	localPos.xyz += morph_weights_a[3] * morph_pos3;
	#endif
	#ifdef MORPHING_POS47
	localPos.xyz += morph_weights_b[0] * morph_pos4;
	localPos.xyz += morph_weights_b[1] * morph_pos5;
	localPos.xyz += morph_weights_b[2] * morph_pos6;
	localPos.xyz += morph_weights_b[3] * morph_pos7;
	#endif
	#endif
	#ifdef MORPHING_TEXTURE_BASED_POSITION
		#ifdef WEBGPU
			ivec2 morphUV = getTextureMorphCoords();
			vec3 morphPos = texelFetch(morphPositionTex, ivec2(morphUV), 0).xyz;
		#else
			vec2 morphUV = getTextureMorphCoords();
			vec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;
		#endif
		localPos += morphPos;
	#endif
	vec4 posW = dModelMatrix * vec4(localPos, 1.0);
	#ifdef SCREENSPACE
	posW.zw = vec2(0.0, 1.0);
	#endif
	dPositionW = posW.xyz;
	vec4 screenPos;
	#ifdef UV1LAYOUT
	screenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);
		#ifdef WEBGPU
		screenPos.y *= -1.0;
		#endif
	#else
	#ifdef SCREENSPACE
	screenPos = posW;
	screenPos.y *= projectionFlipY;
	#else
	screenPos = matrix_viewProjection * posW;
	#endif
	#ifdef PIXELSNAP
	screenPos.xy = (screenPos.xy * 0.5) + 0.5;
	screenPos.xy *= uScreenSize.xy;
	screenPos.xy = floor(screenPos.xy);
	screenPos.xy *= uScreenSize.zw;
	screenPos.xy = (screenPos.xy * 2.0) - 1.0;
	#endif
	#endif
	return screenPos;
}
vec3 getWorldPosition() {
	return dPositionW;
}
`
  , tR = `
attribute vec3 vertex_position;
uniform mat4 matrix_model;
uniform mat4 matrix_viewProjection;
vec3 dPositionW;
mat4 dModelMatrix;
`
  , sR = `
#ifdef MAPFLOAT
uniform float material_refraction;
#endif
void getRefraction() {
	float refraction = 1.0;
	#ifdef MAPFLOAT
	refraction = material_refraction;
	#endif
	#ifdef MAPTEXTURE
	refraction *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	refraction *= saturate(vVertexColor.$VC);
	#endif
	dTransmission = refraction;
}
`
  , iR = `
#ifdef NINESLICED
vec2 getUv0() {
	vec2 uv = vertex_position.xz;
	vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));
	vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));
	uv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;
	uv = uv * -0.5 + 0.5;
	uv = uv * atlasRect.zw + atlasRect.xy;
	vMask = vertex_texCoord0.xy;
	return uv;
}
#else
vec2 getUv0() {
	return vertex_texCoord0;
}
#endif
`
  , nR = `
vec2 getUv1() {
	return vertex_texCoord1;
}
`
  , rR = `
void getViewDir() {
	dViewDirW = normalize(view_position - vPositionW);
}
`
  , aR = `
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
vec3 getViewNormal() {
	return mat3(matrix_view) * vNormalW;
}
`;
const $ = {
    alphaTestPS: AA,
    ambientConstantPS: MA,
    ambientEnvPS: PA,
    ambientSHPS: RA,
    aoPS: IA,
    aoDetailMapPS: LA,
    aoDiffuseOccPS: DA,
    aoSpecOccPS: OA,
    aoSpecOccConstPS: FA,
    aoSpecOccConstSimplePS: BA,
    aoSpecOccSimplePS: kA,
    basePS: NA,
    baseVS: UA,
    baseNineSlicedPS: zA,
    baseNineSlicedVS: VA,
    baseNineSlicedTiledPS: GA,
    bayerPS: HA,
    biasConstPS: WA,
    blurVSMPS: XA,
    clearCoatPS: jA,
    clearCoatGlossPS: $A,
    clearCoatNormalPS: qA,
    clusteredLightCookiesPS: KA,
    clusteredLightShadowsPS: ZA,
    clusteredLightUtilsPS: YA,
    clusteredLightPS: QA,
    combinePS: JA,
    cookiePS: e1,
    cubeMapProjectBoxPS: t1,
    cubeMapProjectNonePS: s1,
    cubeMapRotatePS: i1,
    debugOutputPS: n1,
    debugProcessFrontendPS: r1,
    detailModesPS: a1,
    diffusePS: o1,
    diffuseDetailMapPS: l1,
    decodePS: lx,
    emissivePS: h1,
    encodePS: hx,
    endPS: c1,
    endVS: d1,
    envAtlasPS: u1,
    envConstPS: f1,
    envMultiplyPS: p1,
    extensionPS: m1,
    extensionVS: _1,
    falloffInvSquaredPS: g1,
    falloffLinearPS: y1,
    fixCubemapSeamsNonePS: v1,
    fixCubemapSeamsStretchPS: S1,
    floatUnpackingPS: x1,
    fogExpPS: w1,
    fogExp2PS: b1,
    fogLinearPS: T1,
    fogNonePS: C1,
    fresnelSchlickPS: E1,
    fullscreenQuadPS: A1,
    fullscreenQuadVS: M1,
    gamma1_0PS: P1,
    gamma2_2PS: R1,
    gles2PS: WS,
    gles3PS: XS,
    gles3VS: jS,
    glossPS: I1,
    iridescenceDiffractionPS: L1,
    iridescencePS: D1,
    iridescenceThicknessPS: O1,
    instancingVS: F1,
    iorPS: B1,
    lightDiffuseLambertPS: k1,
    lightDirPointPS: N1,
    lightmapAddPS: U1,
    lightmapDirAddPS: z1,
    lightmapDirPS: V1,
    lightmapSinglePS: G1,
    lightSpecularAnisoGGXPS: H1,
    lightSpecularBlinnPS: W1,
    lightSpecularPhongPS: X1,
    lightSheenPS: j1,
    linearizeDepthPS: $1,
    litShaderArgsPS: q1,
    ltcPS: Y1,
    metalnessPS: K1,
    metalnessModulatePS: Q1,
    msdfPS: Z1,
    msdfVS: J1,
    normalVS: eM,
    normalDetailMapPS: tM,
    normalInstancedVS: sM,
    normalMapPS: iM,
    normalSkinnedVS: nM,
    normalXYPS: rM,
    normalXYZPS: aM,
    opacityPS: oM,
    opacityDitherPS: lM,
    outputPS: hM,
    outputAlphaPS: cM,
    outputAlphaOpaquePS: dM,
    outputAlphaPremulPS: uM,
    outputTex2DPS: fM,
    packDepthPS: pM,
    sheenPS: mM,
    sheenGlossPS: _M,
    parallaxPS: gM,
    particlePS: yM,
    particleVS: vM,
    particleAnimFrameClampVS: SM,
    particleAnimFrameLoopVS: xM,
    particleAnimTexVS: wM,
    particleInputFloatPS: bM,
    particleInputRgba8PS: TM,
    particleOutputFloatPS: CM,
    particleOutputRgba8PS: EM,
    particleUpdaterAABBPS: AM,
    particleUpdaterEndPS: MM,
    particleUpdaterInitPS: PM,
    particleUpdaterNoRespawnPS: RM,
    particleUpdaterOnStopPS: IM,
    particleUpdaterRespawnPS: LM,
    particleUpdaterSpherePS: DM,
    particleUpdaterStartPS: OM,
    particle_billboardVS: FM,
    particle_blendAddPS: BM,
    particle_blendMultiplyPS: kM,
    particle_blendNormalPS: NM,
    particle_cpuVS: UM,
    particle_cpu_endVS: zM,
    particle_customFaceVS: VM,
    particle_endPS: GM,
    particle_endVS: HM,
    particle_halflambertPS: WM,
    particle_initVS: XM,
    particle_lambertPS: jM,
    particle_lightingPS: $M,
    particle_localShiftVS: qM,
    particle_meshVS: YM,
    particle_normalVS: KM,
    particle_normalMapPS: ZM,
    particle_pointAlongVS: QM,
    particle_softPS: JM,
    particle_softVS: eP,
    particle_stretchVS: tP,
    particle_TBNVS: sP,
    particle_wrapVS: iP,
    reflDirPS: nP,
    reflDirAnisoPS: rP,
    reflectionCCPS: aP,
    reflectionCubePS: oP,
    reflectionEnvHQPS: lP,
    reflectionEnvPS: hP,
    reflectionSpherePS: cP,
    reflectionSheenPS: dP,
    refractionCubePS: uP,
    refractionDynamicPS: fP,
    reprojectPS: pP,
    screenDepthPS: mP,
    shadowCascadesPS: _P,
    shadowEVSMPS: gP,
    shadowEVSMnPS: yP,
    shadowPCSSPS: vP,
    shadowSampleCoordPS: SP,
    shadowStandardPS: xP,
    shadowStandardGL2PS: wP,
    shadowVSM8PS: bP,
    shadowVSM_commonPS: TP,
    skinBatchConstVS: CP,
    skinBatchTexVS: EP,
    skinConstVS: AP,
    skinTexVS: MP,
    skyboxEnvPS: PP,
    skyboxHDRPS: RP,
    skyboxVS: IP,
    specularPS: LP,
    sphericalPS: DP,
    specularityFactorPS: OP,
    spotPS: FP,
    startPS: BP,
    startVS: kP,
    startNineSlicedPS: NP,
    startNineSlicedTiledPS: UP,
    storeEVSMPS: zP,
    tangentBinormalVS: VP,
    TBNPS: GP,
    TBNderivativePS: HP,
    TBNfastPS: WP,
    TBNObjectSpacePS: XP,
    textureSamplePS: jP,
    thicknessPS: $P,
    tonemappingAcesPS: qP,
    tonemappingAces2PS: YP,
    tonemappingFilmicPS: KP,
    tonemappingHejlPS: ZP,
    tonemappingLinearPS: QP,
    tonemappingNonePS: JP,
    transformVS: eR,
    transformDeclVS: tR,
    transmissionPS: sR,
    uv0VS: iR,
    uv1VS: nR,
    viewDirPS: rR,
    viewNormalVS: aR,
    webgpuPS: $S,
    webgpuVS: qS
}
  , cx = new Os;
function Cr(a) {
    return cx.get(a)
}
function oR(a, e) {
    cx.get(a, () => e)
}
class Ue {
    static begin() {
        return `void main(void)
{
`
    }
    static end() {
        return `}
`
    }
    static skinCode(e, t=$) {
        return e.supportsBoneTextures ? t.skinTexVS : "#define BONE_LIMIT " + e.getBoneLimit() + `
` + t.skinConstVS
    }
    static fogCode(e, t=$) {
        return e === "linear" ? t.fogLinearPS ? t.fogLinearPS : $.fogLinearPS : e === "exp" ? t.fogExpPS ? t.fogExpPS : $.fogExpPS : e === "exp2" ? t.fogExp2PS ? t.fogExp2PS : $.fogExp2PS : t.fogNonePS ? t.fogNonePS : $.fogNonePS
    }
    static gammaCode(e, t=$) {
        return e === Z_ || e === aA ? t.gamma2_2PS ? t.gamma2_2PS : $.gamma2_2PS : e === uc ? `#define HDR
` + (t.gamma2_2PS ? t.gamma2_2PS : $.gamma2_2PS) : t.gamma1_0PS ? t.gamma1_0PS : $.gamma1_0PS
    }
    static tonemapCode(e, t=$) {
        return e === oA ? t.tonemappingFilmicPS ? t.tonemappingFilmicPS : $.tonemappingFilmicPS : e === fc ? t.tonemappingLinearPS ? t.tonemappingLinearPS : $.tonemappingLinearPS : e === lA ? t.tonemappingHejlPS ? t.tonemappingHejlPS : $.tonemappingHejlPS : e === hA ? t.tonemappingAcesPS ? t.tonemappingAcesPS : $.tonemappingAcesPS : e === cA ? t.tonemappingAces2PS ? t.tonemappingAces2PS : $.tonemappingAces2PS : t.tonemapingNonePS ? t.tonemapingNonePS : $.tonemappingNonePS
    }
}
function lR(a, e, t, s=!1, i={}) {
    return typeof s == "boolean" ? i.useTransformFeedback = s : typeof s == "object" && (i = Bt({}, i, s)),
    new Xi(a,Pt.createDefinition(a, Bt({}, i, {
        name: `${e}_${t}`,
        vertexCode: $[e],
        fragmentCode: $[t]
    })))
}
function Ys(a, e, t, s, i, n=!1, r={}) {
    typeof n == "boolean" ? r.useTransformFeedback = n : typeof n == "object" && (r = Bt({}, r, n));
    const o = Cr(a);
    let l = o.getCachedShader(s);
    return l || (l = new Xi(a,Pt.createDefinition(a, Bt({}, r, {
        name: s,
        vertexCode: e,
        fragmentCode: t,
        attributes: i
    }))),
    o.setCachedShader(s, l)),
    l
}
class hR extends Ue {
    constructor(e, t) {
        super(),
        this.key = e,
        this.shaderDefinition = t
    }
    generateKey(e) {
        return this.key
    }
    createShaderDefinition(e, t) {
        return this.shaderDefinition
    }
}
function dx(a, e) {
    var t;
    const s = a.definition
      , n = `${(t = s.name) != null ? t : "shader"}-id-${a.id}`
      , r = new hR(n,s)
      , o = "shader"
      , l = Cr(a.device);
    l.register(o, r);
    const c = l.getProgram(o, {}, e);
    return l.unregister(o),
    c
}
$.createShader = lR;
$.createShaderFromCode = Ys;
const cR = {
    type: Ks,
    base: 0,
    count: 4,
    indexed: !1
}
  , ml = new M
  , _l = new M;
class Mm {
    constructor(e) {
        this.uniformBuffer = void 0,
        this.bindGroup = void 0;
        const t = e.device;
        if (this.shader = e,
        t.supportsUniformBuffers) {
            const s = new Aa;
            this.shader = dx(e, s);
            const i = this.shader.meshUniformBufferFormat;
            i && (this.uniformBuffer = new bf(t,i,!1));
            const n = this.shader.meshBindGroupFormat;
            this.bindGroup = new lc(t,n,this.uniformBuffer)
        }
    }
    destroy() {
        var e, t;
        (e = this.uniformBuffer) == null || e.destroy(),
        this.uniformBuffer = null,
        (t = this.bindGroup) == null || t.destroy(),
        this.bindGroup = null
    }
    render(e, t) {
        const s = this.shader.device;
        if (e) {
            var i;
            ml.set(s.vx, s.vy, s.vw, s.vh),
            _l.set(s.sx, s.sy, s.sw, s.sh),
            t = (i = t) != null ? i : e,
            s.setViewport(e.x, e.y, e.z, e.w),
            s.setScissor(t.x, t.y, t.z, t.w)
        }
        s.setVertexBuffer(s.quadVertexBuffer, 0);
        const n = this.shader;
        if (s.setShader(n),
        s.supportsUniformBuffers) {
            var r;
            const o = this.bindGroup;
            (r = o.defaultUniformBuffer) == null || r.update(),
            o.update(),
            s.setBindGroup(vh, o)
        }
        s.draw(cR),
        e && (s.setViewport(ml.x, ml.y, ml.z, ml.w),
        s.setScissor(_l.x, _l.y, _l.z, _l.w))
    }
}
class dR extends Js {
    constructor(e, t, s, i) {
        super(e),
        this.quad = t,
        this.rect = s,
        this.scissorRect = i
    }
    execute() {
        const {device: e} = this;
        e.setCullMode(bt),
        e.setDepthState($t.NODEPTH),
        e.setStencilState(null, null),
        this.quad.render(this.rect, this.scissorRect)
    }
}
const uR = new M;
function ya(a, e, t, s, i) {
    const n = new Mm(t);
    s || (s = uR,
    s.x = 0,
    s.y = 0,
    s.z = e ? e.width : a.width,
    s.w = e ? e.height : a.height);
    const r = new dR(a,n,s,i);
    r.init(e),
    r.colorOps.clear = !1,
    r.depthStencilOps.clearDepth = !1,
    a.isWebGPU && e === null && a.samples > 1 && (r.colorOps.store = !0),
    r.render(),
    n.destroy()
}
const fR = new Os;
class pR {
    constructor(e, t, s={}) {
        this.index = void 0,
        this.name = void 0,
        this.shaderDefines = void 0,
        this.name = e,
        this.index = t,
        Object.assign(this, s),
        this.shaderDefines = this.buildShaderDefines()
    }
    buildShaderDefines() {
        let e;
        this.isShadow ? e = "SHADOW" : this.isForward ? e = "FORWARD" : this.index === Vi ? e = "DEPTH" : this.index === mc && (e = "PICK");
        const t = e ? `#define ${e}_PASS
` : ""
          , s = `#define ${this.name.toUpperCase()}_PASS
`;
        return t + s
    }
}
class wi {
    constructor() {
        this.passesNamed = new Map,
        this.passesIndexed = [],
        this.nextIndex = 0;
        const e = (t, s, i) => {
            this.allocate(t, i)
        }
        ;
        e("forward", pc, {
            isForward: !0
        }),
        e("forward_hdr", $i, {
            isForward: !0
        }),
        e("depth"),
        e("pick"),
        e("shadow")
    }
    static get(e) {
        return fR.get(e, () => new wi)
    }
    allocate(e, t) {
        let s = this.passesNamed.get(e);
        return s === void 0 && (s = new pR(e,this.nextIndex,t),
        this.passesNamed.set(s.name, s),
        this.passesIndexed[s.index] = s,
        this.nextIndex++),
        s
    }
    getByIndex(e) {
        return this.passesIndexed[e]
    }
    getByName(e) {
        return this.passesNamed.get(e)
    }
}
class mR extends Ue {
    generateKey(e) {
        let t = "basic";
        return e.fog && (t += "_fog"),
        e.alphaTest && (t += "_atst"),
        e.vertexColors && (t += "_vcol"),
        e.diffuseMap && (t += "_diff"),
        e.skin && (t += "_skin"),
        e.screenSpace && (t += "_ss"),
        e.useInstancing && (t += "_inst"),
        e.useMorphPosition && (t += "_morphp"),
        e.useMorphNormal && (t += "_morphn"),
        e.useMorphTextureBased && (t += "_morpht"),
        t += "_" + e.pass,
        t
    }
    createShaderDefinition(e, t) {
        const s = {
            vertex_position: ut
        };
        t.skin && (s.vertex_boneWeights = Ji,
        s.vertex_boneIndices = Ps),
        t.vertexColors && (s.vertex_color = jt),
        t.diffuseMap && (s.vertex_texCoord0 = Ls);
        const n = wi.get(e).getByIndex(t.pass).shaderDefines;
        let r = n;
        r += $.transformDeclVS,
        t.skin ? (r += Ue.skinCode(e),
        r += $.transformSkinnedVS) : r += $.transformVS,
        t.vertexColors && (r += `attribute vec4 vertex_color;
`,
        r += `varying vec4 vColor;
`),
        t.diffuseMap && (r += `attribute vec2 vertex_texCoord0;
`,
        r += `varying vec2 vUv0;
`),
        t.pass === Vi && (r += `varying float vDepth;
`,
        r += `#ifndef VIEWMATRIX
`,
        r += `#define VIEWMATRIX
`,
        r += `uniform mat4 matrix_view;
`,
        r += `#endif
`,
        r += `#ifndef CAMERAPLANES
`,
        r += `#define CAMERAPLANES
`,
        r += `uniform vec4 camera_params;

`,
        r += `#endif
`),
        r += Ue.begin(),
        r += `   gl_Position = getPosition();
`,
        t.pass === Vi && (r += `    vDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;
`),
        t.vertexColors && (r += `    vColor = vertex_color;
`),
        t.diffuseMap && (r += `    vUv0 = vertex_texCoord0;
`),
        r += Ue.end();
        let o = n;
        return t.vertexColors ? o += `varying vec4 vColor;
` : o += `uniform vec4 uColor;
`,
        t.diffuseMap && (o += `varying vec2 vUv0;
`,
        o += `uniform sampler2D texture_diffuseMap;
`),
        t.fog && (o += Ue.fogCode(t.fog)),
        t.alphaTest && (o += $.alphaTestPS),
        t.pass === Vi && (o += `varying float vDepth;
`,
        o += $.packDepthPS),
        o += Ue.begin(),
        t.vertexColors ? o += `    gl_FragColor = vColor;
` : o += `    gl_FragColor = uColor;
`,
        t.diffuseMap && (o += `    gl_FragColor *= texture2D(texture_diffuseMap, vUv0);
`),
        t.alphaTest && (o += `   alphaTest(gl_FragColor.a);
`),
        t.pass !== mc && (t.pass === Vi ? o += `    gl_FragColor = packFloat(vDepth);
` : t.fog && (o += `   glFragColor.rgb = addFog(gl_FragColor.rgb);
`)),
        o += Ue.end(),
        Pt.createDefinition(e, {
            name: "BasicShader",
            attributes: s,
            vertexCode: r,
            fragmentCode: o
        })
    }
}
const _R = new mR
  , ux = new Os;
function _c(a) {
    return ux.get(a)
}
function gR(a, e) {
    ux.get(a, () => e)
}
const ds = [];
ds[KS] = {
    src: Ut,
    dst: Ut,
    op: lT
};
ds[ls] = {
    src: Ut,
    dst: T_,
    op: Qs
};
ds[ps] = {
    src: C_,
    dst: E_,
    op: Qs
};
ds[_a] = {
    src: Ut,
    dst: E_,
    op: Qs
};
ds[hc] = {
    src: Ut,
    dst: Ut,
    op: Qs
};
ds[fi] = {
    src: C_,
    dst: Ut,
    op: Qs
};
ds[ZS] = {
    src: PS,
    dst: aT,
    op: Qs
};
ds[QS] = {
    src: oT,
    dst: Ut,
    op: Qs
};
ds[H_] = {
    src: PS,
    dst: T_,
    op: Qs
};
ds[JS] = {
    src: Ut,
    dst: Ut,
    op: hT
};
ds[ex] = {
    src: Ut,
    dst: Ut,
    op: cT
};
let yR = 0;
class Yi {
    constructor() {
        this._shader = null,
        this.meshInstances = [],
        this.name = "Untitled",
        this.userId = "",
        this.id = yR++,
        this.variants = new Map,
        this.parameters = {},
        this.alphaTest = 0,
        this.alphaToCoverage = !1,
        this._blendState = new ft,
        this._depthState = new $t,
        this.cull = dr,
        this.stencilFront = null,
        this.stencilBack = null,
        this._shaderVersion = 0,
        this._scene = null,
        this.dirty = !0
    }
    set depthBias(e) {
        this._depthState.depthBias = e
    }
    get depthBias() {
        return this._depthState.depthBias
    }
    set slopeDepthBias(e) {
        this._depthState.depthBiasSlope = e
    }
    get slopeDepthBias() {
        return this._depthState.depthBiasSlope
    }
    set redWrite(e) {
        this._blendState.redWrite = e
    }
    get redWrite() {
        return this._blendState.redWrite
    }
    set greenWrite(e) {
        this._blendState.greenWrite = e
    }
    get greenWrite() {
        return this._blendState.greenWrite
    }
    set blueWrite(e) {
        this._blendState.blueWrite = e
    }
    get blueWrite() {
        return this._blendState.blueWrite
    }
    set alphaWrite(e) {
        this._blendState.alphaWrite = e
    }
    get alphaWrite() {
        return this._blendState.alphaWrite
    }
    set shader(e) {
        this._shader = e
    }
    get shader() {
        return this._shader
    }
    get transparent() {
        return this._blendState.blend
    }
    _updateTransparency() {
        const e = this.transparent
          , t = this.meshInstances;
        for (let s = 0; s < t.length; s++)
            t[s].transparent = e
    }
    set blendState(e) {
        this._blendState.copy(e),
        this._updateTransparency()
    }
    get blendState() {
        return this._blendState
    }
    set blendType(e) {
        const t = ds[e];
        this._blendState.setColorBlend(t.op, t.src, t.dst),
        this._blendState.setAlphaBlend(t.op, t.src, t.dst);
        const s = e !== ls;
        this._blendState.blend !== s && (this._blendState.blend = s,
        this._updateTransparency()),
        this._updateMeshInstanceKeys()
    }
    get blendType() {
        if (!this.transparent)
            return ls;
        const {colorOp: e, colorSrcFactor: t, colorDstFactor: s, alphaOp: i, alphaSrcFactor: n, alphaDstFactor: r} = this._blendState;
        for (let o = 0; o < ds.length; o++) {
            const l = ds[o];
            if (l.src === t && l.dst === s && l.op === e && l.src === n && l.dst === r && l.op === i)
                return o
        }
        return ps
    }
    set depthState(e) {
        this._depthState.copy(e)
    }
    get depthState() {
        return this._depthState
    }
    set depthTest(e) {
        this._depthState.test = e
    }
    get depthTest() {
        return this._depthState.test
    }
    set depthFunc(e) {
        this._depthState.func = e
    }
    get depthFunc() {
        return this._depthState.func
    }
    set depthWrite(e) {
        this._depthState.write = e
    }
    get depthWrite() {
        return this._depthState.write
    }
    copy(e) {
        var t;
        return this.name = e.name,
        this._shader = e._shader,
        this.alphaTest = e.alphaTest,
        this.alphaToCoverage = e.alphaToCoverage,
        this._blendState.copy(e._blendState),
        this._depthState.copy(e._depthState),
        this.cull = e.cull,
        this.stencilFront = (t = e.stencilFront) == null ? void 0 : t.clone(),
        e.stencilBack && (this.stencilBack = e.stencilFront === e.stencilBack ? this.stencilFront : e.stencilBack.clone()),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    _updateMeshInstanceKeys() {
        const e = this.meshInstances;
        for (let t = 0; t < e.length; t++)
            e[t].updateKey()
    }
    updateUniforms(e, t) {}
    getShaderVariant(e, t, s, i, n, r, o, l, c) {
        const d = new Aa(o,l,c);
        return dx(this._shader, d)
    }
    update() {
        this.dirty = !0,
        this._shader && (this._shader.failed = !1)
    }
    clearParameters() {
        this.parameters = {}
    }
    getParameters() {
        return this.parameters
    }
    clearVariants() {
        this.variants.clear();
        const e = this.meshInstances
          , t = e.length;
        for (let s = 0; s < t; s++)
            e[s].clearShaders()
    }
    getParameter(e) {
        return this.parameters[e]
    }
    setParameter(e, t) {
        if (t === void 0 && typeof e == "object") {
            const i = e;
            if (i.length) {
                for (let n = 0; n < i.length; n++)
                    this.setParameter(i[n]);
                return
            }
            e = i.name,
            t = i.value
        }
        const s = this.parameters[e];
        s ? s.data = t : this.parameters[e] = {
            scopeId: null,
            data: t
        }
    }
    deleteParameter(e) {
        this.parameters[e] && delete this.parameters[e]
    }
    setParameters(e, t) {
        const s = this.parameters;
        t === void 0 && (t = s);
        for (const i in t) {
            const n = s[i];
            n && (n.scopeId || (n.scopeId = e.scope.resolve(i)),
            n.scopeId.setValue(n.data))
        }
    }
    destroy() {
        this.variants.clear(),
        this._shader = null;
        for (let e = 0; e < this.meshInstances.length; e++) {
            const t = this.meshInstances[e];
            if (t.clearShaders(),
            t._material = null,
            t.mesh) {
                const s = _c(t.mesh.device);
                this !== s && (t.material = s)
            }
        }
        this.meshInstances.length = 0
    }
    addMeshInstanceRef(e) {
        this.meshInstances.push(e)
    }
    removeMeshInstanceRef(e) {
        const t = this.meshInstances
          , s = t.indexOf(e);
        s !== -1 && t.splice(s, 1)
    }
}
class vR extends Yi {
    constructor(...e) {
        super(...e),
        this.color = new z(1,1,1,1),
        this.colorUniform = new Float32Array(4),
        this.colorMap = null,
        this.vertexColors = !1
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.colorMap = e.colorMap,
        this.vertexColors = e.vertexColors,
        this
    }
    updateUniforms(e, t) {
        this.clearParameters(),
        this.colorUniform[0] = this.color.r,
        this.colorUniform[1] = this.color.g,
        this.colorUniform[2] = this.color.b,
        this.colorUniform[3] = this.color.a,
        this.setParameter("uColor", this.colorUniform),
        this.colorMap && this.setParameter("texture_diffuseMap", this.colorMap)
    }
    getShaderVariant(e, t, s, i, n, r, o, l, c) {
        const d = {
            skin: s && (s & Ch) !== 0,
            screenSpace: s && (s & Ah) !== 0,
            useInstancing: s && (s & Eh) !== 0,
            useMorphPosition: s && (s & Mh) !== 0,
            useMorphNormal: s && (s & Ph) !== 0,
            useMorphTextureBased: s && (s & Rh) !== 0,
            alphaTest: this.alphaTest > 0,
            vertexColors: this.vertexColors,
            diffuseMap: !!this.colorMap,
            pass: n
        }
          , h = new Aa(o,l,c)
          , u = Cr(e);
        return u.register("basic", _R),
        u.getProgram("basic", d, h, this.userId)
    }
}
class Hy {
    constructor(e, t, s) {
        this._aabb = new Pe,
        this.origMeshInstances = void 0,
        this.meshInstance = null,
        this.dynamic = void 0,
        this.batchGroupId = void 0,
        this.origMeshInstances = e,
        this.dynamic = t,
        this.batchGroupId = s
    }
    destroy(e, t) {
        this.meshInstance && (this.removeFromLayers(e, t),
        this.meshInstance.destroy(),
        this.meshInstance = null)
    }
    addToLayers(e, t) {
        for (let s = 0; s < t.length; s++) {
            const i = e.layers.getLayerById(t[s]);
            i && i.addMeshInstances([this.meshInstance])
        }
    }
    removeFromLayers(e, t) {
        for (let s = 0; s < t.length; s++) {
            const i = e.layers.getLayerById(t[s]);
            i && i.removeMeshInstances([this.meshInstance])
        }
    }
    updateBoundingBox() {
        this._aabb.copy(this.origMeshInstances[0].aabb);
        for (let e = 1; e < this.origMeshInstances.length; e++)
            this._aabb.add(this.origMeshInstances[e].aabb);
        this.meshInstance.aabb = this._aabb,
        this.meshInstance._aabbVer = 0
    }
}
class gt {
    constructor(e, t, s, i, n=[Bn]) {
        this._ui = !1,
        this._sprite = !1,
        this._obj = {
            model: [],
            element: [],
            sprite: [],
            render: []
        },
        this.id = void 0,
        this.name = void 0,
        this.dynamic = void 0,
        this.maxAabbSize = void 0,
        this.layers = void 0,
        this.id = e,
        this.name = t,
        this.dynamic = s,
        this.maxAabbSize = i,
        this.layers = n
    }
}
gt.MODEL = "model";
gt.ELEMENT = "element";
gt.SPRITE = "sprite";
gt.RENDER = "render";
const Wy = new ee;
class gc {
    constructor(e) {
        this.bones = void 0,
        this._dirty = !0,
        this._rootBone = null,
        this._skinUpdateIndex = -1,
        this._updateBeforeCull = !0,
        e && this.initSkin(e)
    }
    set rootBone(e) {
        this._rootBone = e
    }
    get rootBone() {
        return this._rootBone
    }
    init(e, t) {
        if (e.supportsBoneTextures) {
            const s = t * 3;
            let i = Math.ceil(Math.sqrt(s));
            i = W.roundUp(i, 3);
            const n = Math.ceil(s / i);
            this.boneTexture = new ge(e,{
                width: i,
                height: n,
                format: lt,
                mipmaps: !1,
                minFilter: be,
                magFilter: be,
                name: "skin"
            }),
            this.matrixPalette = this.boneTexture.lock()
        } else
            this.matrixPalette = new Float32Array(t * 12)
    }
    destroy() {
        this.boneTexture && (this.boneTexture.destroy(),
        this.boneTexture = null)
    }
    resolve(e, t) {
        this.rootBone = e;
        const s = this.skin
          , i = [];
        for (let n = 0; n < s.boneNames.length; n++) {
            const r = s.boneNames[n];
            let o = e.findByName(r);
            o || (o = t),
            i.push(o)
        }
        this.bones = i
    }
    initSkin(e) {
        this.skin = e,
        this.bones = [];
        const t = e.inverseBindPose.length;
        this.init(e.device, t),
        this.matrices = [];
        for (let s = 0; s < t; s++)
            this.matrices[s] = new ee
    }
    uploadBones(e) {
        e.supportsBoneTextures && (this.boneTexture.lock(),
        this.boneTexture.unlock())
    }
    _updateMatrices(e, t) {
        if (this._skinUpdateIndex !== t) {
            this._skinUpdateIndex = t,
            Wy.copy(e.getWorldTransform()).invert();
            for (let s = this.bones.length - 1; s >= 0; s--)
                this.matrices[s].mulAffine2(Wy, this.bones[s].getWorldTransform()),
                this.matrices[s].mulAffine2(this.matrices[s], this.skin.inverseBindPose[s])
        }
    }
    updateMatrices(e, t) {
        this._updateBeforeCull && this._updateMatrices(e, t)
    }
    updateMatrixPalette(e, t) {
        this._updateMatrices(e, t);
        const s = this.matrixPalette
          , i = this.bones.length;
        for (let n = 0; n < i; n++) {
            const r = this.matrices[n].data
              , o = n * 12;
            s[o] = r[0],
            s[o + 1] = r[4],
            s[o + 2] = r[8],
            s[o + 3] = r[12],
            s[o + 4] = r[1],
            s[o + 5] = r[5],
            s[o + 6] = r[9],
            s[o + 7] = r[13],
            s[o + 8] = r[2],
            s[o + 9] = r[6],
            s[o + 10] = r[10],
            s[o + 11] = r[14]
        }
        this.uploadBones(this.skin.device)
    }
}
class Xy extends gc {
    constructor(e, t, s) {
        super();
        const i = t.length;
        this.init(e, i),
        this.device = e,
        this.rootNode = s,
        this.bones = t
    }
    updateMatrices(e, t) {}
    updateMatrixPalette(e, t) {
        const s = this.matrixPalette
          , i = this.bones.length;
        for (let n = 0; n < i; n++) {
            const r = this.bones[n].getWorldTransform().data
              , o = n * 12;
            s[o] = r[0],
            s[o + 1] = r[4],
            s[o + 2] = r[8],
            s[o + 3] = r[12],
            s[o + 4] = r[1],
            s[o + 5] = r[5],
            s[o + 6] = r[9],
            s[o + 7] = r[13],
            s[o + 8] = r[2],
            s[o + 9] = r[6],
            s[o + 10] = r[10],
            s[o + 11] = r[14]
        }
        this.uploadBones(this.device)
    }
}
const jy = new ee
  , $f = new y
  , $y = new ne
  , qf = new ne
  , qy = new y
  , Yy = new y
  , SR = new ee
  , xR = new ne
  , _s = new y
  , Ky = new ee
  , gs = new ne
  , Na = new ne
  , Zy = new ee
  , Yf = new y
  , Hc = new y;
function Qy(a, e) {
    return a instanceof Function ? a : t => {
        let s = t[a];
        return s instanceof Function && (s = s()),
        s === e
    }
}
function fx(a, e) {
    if (e(a))
        return a;
    const t = a._children
      , s = t.length;
    for (let i = 0; i < s; ++i) {
        const n = fx(t[i], e);
        if (n)
            return n
    }
    return null
}
class yt extends fe {
    constructor(e="Untitled") {
        super(),
        this.name = void 0,
        this.tags = new zh(this),
        this._labels = {},
        this.localPosition = new y,
        this.localRotation = new ne,
        this.localScale = new y(1,1,1),
        this.localEulerAngles = new y,
        this.position = new y,
        this.rotation = new ne,
        this.eulerAngles = new y,
        this._scale = null,
        this.localTransform = new ee,
        this._dirtyLocal = !1,
        this._aabbVer = 0,
        this._frozen = !1,
        this.worldTransform = new ee,
        this._dirtyWorld = !1,
        this._worldScaleSign = 0,
        this._normalMatrix = new Ci,
        this._dirtyNormal = !0,
        this._right = null,
        this._up = null,
        this._forward = null,
        this._parent = null,
        this._children = [],
        this._graphDepth = 0,
        this._enabled = !0,
        this._enabledInHierarchy = !1,
        this.scaleCompensation = !1,
        this.name = e
    }
    get right() {
        return this._right || (this._right = new y),
        this.getWorldTransform().getX(this._right).normalize()
    }
    get up() {
        return this._up || (this._up = new y),
        this.getWorldTransform().getY(this._up).normalize()
    }
    get forward() {
        return this._forward || (this._forward = new y),
        this.getWorldTransform().getZ(this._forward).normalize().mulScalar(-1)
    }
    get normalMatrix() {
        const e = this._normalMatrix;
        return this._dirtyNormal && (e.invertMat4(this.getWorldTransform()).transpose(),
        this._dirtyNormal = !1),
        e
    }
    set enabled(e) {
        if (this._enabled !== e) {
            var t;
            this._enabled = e,
            (e && (t = this._parent) != null && t.enabled || !e) && this._notifyHierarchyStateChanged(this, e)
        }
    }
    get enabled() {
        return this._enabled && this._enabledInHierarchy
    }
    get parent() {
        return this._parent
    }
    get path() {
        let e = this._parent;
        if (!e)
            return "";
        let t = this.name;
        for (; e && e._parent; )
            t = `${e.name}/${t}`,
            e = e._parent;
        return t
    }
    get root() {
        let e = this;
        for (; e._parent; )
            e = e._parent;
        return e
    }
    get children() {
        return this._children
    }
    get graphDepth() {
        return this._graphDepth
    }
    _notifyHierarchyStateChanged(e, t) {
        e._onHierarchyStateChanged(t);
        const s = e._children;
        for (let i = 0, n = s.length; i < n; i++)
            s[i]._enabled && this._notifyHierarchyStateChanged(s[i], t)
    }
    _onHierarchyStateChanged(e) {
        this._enabledInHierarchy = e,
        e && !this._frozen && this._unfreezeParentToRoot()
    }
    _cloneInternal(e) {
        e.name = this.name;
        const t = this.tags._list;
        e.tags.clear();
        for (let s = 0; s < t.length; s++)
            e.tags.add(t[s]);
        e._labels = Object.assign({}, this._labels),
        e.localPosition.copy(this.localPosition),
        e.localRotation.copy(this.localRotation),
        e.localScale.copy(this.localScale),
        e.localEulerAngles.copy(this.localEulerAngles),
        e.position.copy(this.position),
        e.rotation.copy(this.rotation),
        e.eulerAngles.copy(this.eulerAngles),
        e.localTransform.copy(this.localTransform),
        e._dirtyLocal = this._dirtyLocal,
        e.worldTransform.copy(this.worldTransform),
        e._dirtyWorld = this._dirtyWorld,
        e._dirtyNormal = this._dirtyNormal,
        e._aabbVer = this._aabbVer + 1,
        e._enabled = this._enabled,
        e.scaleCompensation = this.scaleCompensation,
        e._enabledInHierarchy = !1
    }
    clone() {
        const e = new this.constructor;
        return this._cloneInternal(e),
        e
    }
    copy(e) {
        return e._cloneInternal(this),
        this
    }
    destroy() {
        this.remove();
        const e = this._children;
        for (; e.length; ) {
            const t = e.pop();
            t._parent = null,
            t.destroy()
        }
        this.fire("destroy", this),
        this.off()
    }
    find(e, t) {
        const s = []
          , i = Qy(e, t);
        return this.forEach(n => {
            i(n) && s.push(n)
        }
        ),
        s
    }
    findOne(e, t) {
        const s = Qy(e, t);
        return fx(this, s)
    }
    findByTag() {
        const e = arguments
          , t = []
          , s = (i, n) => {
            n && i.tags.has(...e) && t.push(i);
            for (let r = 0; r < i._children.length; r++)
                s(i._children[r], !0)
        }
        ;
        return s(this, !1),
        t
    }
    findByName(e) {
        return this.findOne("name", e)
    }
    findByPath(e) {
        const t = Array.isArray(e) ? e : e.split("/");
        let s = this;
        for (let i = 0, n = t.length; i < n; ++i)
            if (s = s.children.find(r => r.name === t[i]),
            !s)
                return null;
        return s
    }
    forEach(e, t) {
        e.call(t, this);
        const s = this._children
          , i = s.length;
        for (let n = 0; n < i; ++n)
            s[n].forEach(e, t)
    }
    isDescendantOf(e) {
        let t = this._parent;
        for (; t; ) {
            if (t === e)
                return !0;
            t = t._parent
        }
        return !1
    }
    isAncestorOf(e) {
        return e.isDescendantOf(this)
    }
    getEulerAngles() {
        return this.getWorldTransform().getEulerAngles(this.eulerAngles),
        this.eulerAngles
    }
    getLocalEulerAngles() {
        return this.localRotation.getEulerAngles(this.localEulerAngles),
        this.localEulerAngles
    }
    getLocalPosition() {
        return this.localPosition
    }
    getLocalRotation() {
        return this.localRotation
    }
    getLocalScale() {
        return this.localScale
    }
    getLocalTransform() {
        return this._dirtyLocal && (this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale),
        this._dirtyLocal = !1),
        this.localTransform
    }
    getPosition() {
        return this.getWorldTransform().getTranslation(this.position),
        this.position
    }
    getRotation() {
        return this.rotation.setFromMat4(this.getWorldTransform()),
        this.rotation
    }
    getScale() {
        return this._scale || (this._scale = new y),
        this.getWorldTransform().getScale(this._scale)
    }
    getWorldTransform() {
        return !this._dirtyLocal && !this._dirtyWorld ? this.worldTransform : (this._parent && this._parent.getWorldTransform(),
        this._sync(),
        this.worldTransform)
    }
    get worldScaleSign() {
        return this._worldScaleSign === 0 && (this._worldScaleSign = this.getWorldTransform().scaleSign),
        this._worldScaleSign
    }
    remove() {
        var e;
        (e = this._parent) == null || e.removeChild(this)
    }
    reparent(e, t) {
        this.remove(),
        e && (t >= 0 ? e.insertChild(this, t) : e.addChild(this))
    }
    setLocalEulerAngles(e, t, s) {
        this.localRotation.setFromEulerAngles(e, t, s),
        this._dirtyLocal || this._dirtifyLocal()
    }
    setLocalPosition(e, t, s) {
        e instanceof y ? this.localPosition.copy(e) : this.localPosition.set(e, t, s),
        this._dirtyLocal || this._dirtifyLocal()
    }
    setLocalRotation(e, t, s, i) {
        e instanceof ne ? this.localRotation.copy(e) : this.localRotation.set(e, t, s, i),
        this._dirtyLocal || this._dirtifyLocal()
    }
    setLocalScale(e, t, s) {
        e instanceof y ? this.localScale.copy(e) : this.localScale.set(e, t, s),
        this._dirtyLocal || this._dirtifyLocal()
    }
    _dirtifyLocal() {
        this._dirtyLocal || (this._dirtyLocal = !0,
        this._dirtyWorld || this._dirtifyWorld())
    }
    _unfreezeParentToRoot() {
        let e = this._parent;
        for (; e; )
            e._frozen = !1,
            e = e._parent
    }
    _dirtifyWorld() {
        this._dirtyWorld || this._unfreezeParentToRoot(),
        this._dirtifyWorldInternal()
    }
    _dirtifyWorldInternal() {
        if (!this._dirtyWorld) {
            this._frozen = !1,
            this._dirtyWorld = !0;
            for (let e = 0; e < this._children.length; e++)
                this._children[e]._dirtyWorld || this._children[e]._dirtifyWorldInternal()
        }
        this._dirtyNormal = !0,
        this._worldScaleSign = 0,
        this._aabbVer++
    }
    setPosition(e, t, s) {
        e instanceof y ? _s.copy(e) : _s.set(e, t, s),
        this._parent === null ? this.localPosition.copy(_s) : (Ky.copy(this._parent.getWorldTransform()).invert(),
        Ky.transformPoint(_s, this.localPosition)),
        this._dirtyLocal || this._dirtifyLocal()
    }
    setRotation(e, t, s, i) {
        if (e instanceof ne ? gs.copy(e) : gs.set(e, t, s, i),
        this._parent === null)
            this.localRotation.copy(gs);
        else {
            const n = this._parent.getRotation();
            Na.copy(n).invert(),
            this.localRotation.copy(Na).mul(gs)
        }
        this._dirtyLocal || this._dirtifyLocal()
    }
    setEulerAngles(e, t, s) {
        if (this.localRotation.setFromEulerAngles(e, t, s),
        this._parent !== null) {
            const i = this._parent.getRotation();
            Na.copy(i).invert(),
            this.localRotation.mul2(Na, this.localRotation)
        }
        this._dirtyLocal || this._dirtifyLocal()
    }
    addChild(e) {
        this._prepareInsertChild(e),
        this._children.push(e),
        this._onInsertChild(e)
    }
    addChildAndSaveTransform(e) {
        const t = e.getPosition()
          , s = e.getRotation();
        this._prepareInsertChild(e),
        e.setPosition(SR.copy(this.worldTransform).invert().transformPoint(t)),
        e.setRotation(xR.copy(this.getRotation()).invert().mul(s)),
        this._children.push(e),
        this._onInsertChild(e)
    }
    insertChild(e, t) {
        this._prepareInsertChild(e),
        this._children.splice(t, 0, e),
        this._onInsertChild(e)
    }
    _prepareInsertChild(e) {
        e.remove()
    }
    _fireOnHierarchy(e, t, s) {
        this.fire(e, s);
        for (let i = 0; i < this._children.length; i++)
            this._children[i]._fireOnHierarchy(t, t, s)
    }
    _onInsertChild(e) {
        e._parent = this;
        const t = e._enabled && this.enabled;
        e._enabledInHierarchy !== t && (e._enabledInHierarchy = t,
        e._notifyHierarchyStateChanged(e, t)),
        e._updateGraphDepth(),
        e._dirtifyWorld(),
        this._frozen && e._unfreezeParentToRoot(),
        e._fireOnHierarchy("insert", "inserthierarchy", this),
        this.fire && this.fire("childinsert", e)
    }
    _updateGraphDepth() {
        this._graphDepth = this._parent ? this._parent._graphDepth + 1 : 0;
        for (let e = 0, t = this._children.length; e < t; e++)
            this._children[e]._updateGraphDepth()
    }
    removeChild(e) {
        const t = this._children.indexOf(e);
        t !== -1 && (this._children.splice(t, 1),
        e._parent = null,
        e._fireOnHierarchy("remove", "removehierarchy", this),
        this.fire("childremove", e))
    }
    _sync() {
        if (this._dirtyLocal && (this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale),
        this._dirtyLocal = !1),
        this._dirtyWorld) {
            if (this._parent === null)
                this.worldTransform.copy(this.localTransform);
            else if (this.scaleCompensation) {
                let e;
                const t = this._parent;
                let s = this.localScale
                  , i = t;
                if (i) {
                    for (; i && i.scaleCompensation; )
                        i = i._parent;
                    i && (i = i._parent,
                    i && (e = i.worldTransform.getScale(),
                    qy.mul2(e, this.localScale),
                    s = qy))
                }
                qf.setFromMat4(t.worldTransform),
                $y.mul2(qf, this.localRotation);
                let n = t.worldTransform;
                t.scaleCompensation && (Yy.mul2(e, t.getLocalScale()),
                jy.setTRS(t.worldTransform.getTranslation($f), qf, Yy),
                n = jy),
                n.transformPoint(this.localPosition, $f),
                this.worldTransform.setTRS($f, $y, s)
            } else
                this.worldTransform.mulAffine2(this._parent.worldTransform, this.localTransform);
            this._dirtyWorld = !1
        }
    }
    syncHierarchy() {
        if (!this._enabled || this._frozen)
            return;
        this._frozen = !0,
        (this._dirtyLocal || this._dirtyWorld) && this._sync();
        const e = this._children;
        for (let t = 0, s = e.length; t < s; t++)
            e[t].syncHierarchy()
    }
    lookAt(e, t, s, i=0, n=1, r=0) {
        if (e instanceof y)
            Yf.copy(e),
            t instanceof y ? Hc.copy(t) : Hc.copy(y.UP);
        else {
            if (s === void 0)
                return;
            Yf.set(e, t, s),
            Hc.set(i, n, r)
        }
        Zy.setLookAt(this.getPosition(), Yf, Hc),
        gs.setFromMat4(Zy),
        this.setRotation(gs)
    }
    translate(e, t, s) {
        e instanceof y ? _s.copy(e) : _s.set(e, t, s),
        _s.add(this.getPosition()),
        this.setPosition(_s)
    }
    translateLocal(e, t, s) {
        e instanceof y ? _s.copy(e) : _s.set(e, t, s),
        this.localRotation.transformVector(_s, _s),
        this.localPosition.add(_s),
        this._dirtyLocal || this._dirtifyLocal()
    }
    rotate(e, t, s) {
        if (gs.setFromEulerAngles(e, t, s),
        this._parent === null)
            this.localRotation.mul2(gs, this.localRotation);
        else {
            const i = this.getRotation()
              , n = this._parent.getRotation();
            Na.copy(n).invert(),
            gs.mul2(Na, gs),
            this.localRotation.mul2(gs, i)
        }
        this._dirtyLocal || this._dirtifyLocal()
    }
    rotateLocal(e, t, s) {
        gs.setFromEulerAngles(e, t, s),
        this.localRotation.mul(gs),
        this._dirtyLocal || this._dirtifyLocal()
    }
}
class wR {
    constructor() {
        this.cache = new Map
    }
    destroy() {
        this.cache.forEach( (e, t) => {
            t.destroy()
        }
        ),
        this.cache.clear()
    }
    incRef(e) {
        const t = (this.cache.get(e) || 0) + 1;
        this.cache.set(e, t)
    }
    decRef(e) {
        if (e) {
            let t = this.cache.get(e);
            t && (t--,
            t === 0 ? (this.cache.delete(e),
            e.destroy()) : this.cache.set(e, t))
        }
    }
}
class pn {
    static incRef(e) {
        this.cache.incRef(e)
    }
    static decRef(e) {
        this.cache.decRef(e)
    }
    static destroy() {
        this.cache.destroy()
    }
}
pn.cache = new wR;
let bR = 0;
const TR = new Pe
  , Wc = new Pe
  , Kf = new b_
  , Zf = new Set;
class CR {
    constructor(e) {
        this.vertexBuffer = null,
        this.count = e
    }
}
class ER {
    constructor() {
        this.shader = void 0,
        this.bindGroup = null
    }
    getBindGroup(e) {
        if (!this.bindGroup) {
            const t = this.shader
              , s = t.meshUniformBufferFormat
              , i = new bf(e,s,!1)
              , n = t.meshBindGroupFormat;
            this.bindGroup = new lc(e,n,i)
        }
        return this.bindGroup
    }
    destroy() {
        const e = this.bindGroup;
        if (e) {
            var t;
            (t = e.defaultUniformBuffer) == null || t.destroy(),
            e.destroy(),
            this.bindGroup = null
        }
    }
}
class AR {
    constructor() {
        this.shaderInstances = new Map
    }
    destroy() {
        this.shaderInstances.forEach(e => e.destroy()),
        this.shaderInstances.clear()
    }
}
class Fe {
    constructor(e, t, s=null) {
        if (this.visible = !0,
        this.castShadow = !1,
        this.transparent = !1,
        this._material = null,
        this._shaderCache = [],
        this.id = bR++,
        this.pick = !0,
        e instanceof yt) {
            const i = e;
            e = t,
            t = s,
            s = i
        }
        this._key = [0, 0],
        this.node = s,
        this._mesh = e,
        e.incRefCount(),
        this.material = t,
        this._shaderDefs = Rs << 16,
        this._shaderDefs |= e.vertexBuffer.format.hasUv0 ? ix : 0,
        this._shaderDefs |= e.vertexBuffer.format.hasUv1 ? nx : 0,
        this._shaderDefs |= e.vertexBuffer.format.hasColor ? rx : 0,
        this._shaderDefs |= e.vertexBuffer.format.hasTangents ? J_ : 0,
        this.layer = X_,
        this._renderStyle = nh,
        this._receiveShadow = !0,
        this._screenSpace = !1,
        this._noDepthDrawGl1 = !1,
        this.cull = !0,
        this._updateAabb = !0,
        this._updateAabbFunc = null,
        this._calculateSortDistance = null,
        this.updateKey(),
        this._skinInstance = null,
        this._morphInstance = null,
        this.gsplatInstance = null,
        this.instancingData = null,
        this._customAabb = null,
        this.aabb = new Pe,
        this._aabbVer = -1,
        this._aabbMeshVer = -1,
        this.drawOrder = 0,
        this.visibleThisFrame = !1,
        this.isVisibleFunc = null,
        this.parameters = {},
        this.stencilFront = null,
        this.stencilBack = null,
        this.flipFacesFactor = 1
    }
    set renderStyle(e) {
        this._renderStyle = e,
        this.mesh.prepareRenderState(e)
    }
    get renderStyle() {
        return this._renderStyle
    }
    set mesh(e) {
        e !== this._mesh && (this._mesh && this._mesh.decRefCount(),
        this._mesh = e,
        e && e.incRefCount())
    }
    get mesh() {
        return this._mesh
    }
    set aabb(e) {
        this._aabb = e
    }
    get aabb() {
        if (!this._updateAabb)
            return this._aabb;
        if (this._updateAabbFunc)
            return this._updateAabbFunc(this._aabb);
        let e = this._customAabb
          , t = !!e;
        if (!e) {
            if (e = TR,
            this.skinInstance) {
                if (!this.mesh.boneAabb) {
                    const n = this._morphInstance ? this._morphInstance.morph._targets : null;
                    this.mesh._initBoneAabbs(n)
                }
                const s = this.mesh.boneUsed;
                let i = !0;
                for (let n = 0; n < this.mesh.boneAabb.length; n++)
                    s[n] && (Wc.setFromTransformedAabb(this.mesh.boneAabb[n], this.skinInstance.matrices[n]),
                    i ? (i = !1,
                    e.center.copy(Wc.center),
                    e.halfExtents.copy(Wc.halfExtents)) : e.add(Wc));
                t = !0
            } else if (this.node._aabbVer !== this._aabbVer || this.mesh._aabbVer !== this._aabbMeshVer) {
                if (this.mesh ? (e.center.copy(this.mesh.aabb.center),
                e.halfExtents.copy(this.mesh.aabb.halfExtents)) : (e.center.set(0, 0, 0),
                e.halfExtents.set(0, 0, 0)),
                this.mesh && this.mesh.morph) {
                    const s = this.mesh.morph.aabb;
                    e._expand(s.getMin(), s.getMax())
                }
                t = !0,
                this._aabbVer = this.node._aabbVer,
                this._aabbMeshVer = this.mesh._aabbVer
            }
        }
        return t && this._aabb.setFromTransformedAabb(e, this.node.getWorldTransform()),
        this._aabb
    }
    clearShaders() {
        const e = this._shaderCache;
        for (let s = 0; s < e.length; s++) {
            var t;
            (t = e[s]) == null || t.destroy(),
            e[s] = null
        }
    }
    getShaderInstance(e, t, s, i, n, r) {
        let o, l = this._shaderCache[e];
        if (l ? o = l.shaderInstances.get(t) : (l = new AR,
        this._shaderCache[e] = l),
        !o) {
            const c = this._material
              , d = this._shaderDefs
              , h = e + "_" + d + "_" + t;
            if (o = new ER,
            o.shader = c.variants.get(h),
            !o.shader) {
                const u = c.getShaderVariant(this.mesh.device, s, d, null, e, r, i, n, this._mesh.vertexBuffer.format);
                c.variants.set(h, u),
                o.shader = u
            }
            l.shaderInstances.set(t, o)
        }
        return o
    }
    set material(e) {
        this.clearShaders();
        const t = this._material;
        t && t.removeMeshInstanceRef(this),
        this._material = e,
        e && (e.addMeshInstanceRef(this),
        this.transparent = e.transparent,
        this.updateKey())
    }
    get material() {
        return this._material
    }
    set layer(e) {
        this._layer = e,
        this.updateKey()
    }
    get layer() {
        return this._layer
    }
    _updateShaderDefs(e) {
        e !== this._shaderDefs && (this._shaderDefs = e,
        this.clearShaders())
    }
    set calculateSortDistance(e) {
        this._calculateSortDistance = e
    }
    get calculateSortDistance() {
        return this._calculateSortDistance
    }
    set receiveShadow(e) {
        this._receiveShadow !== e && (this._receiveShadow = e,
        this._updateShaderDefs(e ? this._shaderDefs & ~nu : this._shaderDefs | nu))
    }
    get receiveShadow() {
        return this._receiveShadow
    }
    set skinInstance(e) {
        this._skinInstance = e,
        this._updateShaderDefs(e ? this._shaderDefs | Ch : this._shaderDefs & ~Ch),
        this._setupSkinUpdate()
    }
    get skinInstance() {
        return this._skinInstance
    }
    set morphInstance(e) {
        var t;
        (t = this._morphInstance) == null || t.destroy(),
        this._morphInstance = e;
        let s = this._shaderDefs;
        s = e && e.morph.useTextureMorph ? s | Rh : s & ~Rh,
        s = e && e.morph.morphPositions ? s | Mh : s & ~Mh,
        s = e && e.morph.morphNormals ? s | Ph : s & ~Ph,
        this._updateShaderDefs(s)
    }
    get morphInstance() {
        return this._morphInstance
    }
    set screenSpace(e) {
        this._screenSpace !== e && (this._screenSpace = e,
        this._updateShaderDefs(e ? this._shaderDefs | Ah : this._shaderDefs & ~Ah))
    }
    get screenSpace() {
        return this._screenSpace
    }
    set key(e) {
        this._key[Sn] = e
    }
    get key() {
        return this._key[Sn]
    }
    set mask(e) {
        const t = this._shaderDefs & 65535;
        this._updateShaderDefs(t | e << 16)
    }
    get mask() {
        return this._shaderDefs >> 16
    }
    set instancingCount(e) {
        this.instancingData && (this.instancingData.count = e)
    }
    get instancingCount() {
        return this.instancingData ? this.instancingData.count : 0
    }
    destroy() {
        var e, t;
        const s = this.mesh;
        s && (this.mesh = null,
        s.refCount < 1 && s.destroy()),
        this.setRealtimeLightmap(Fe.lightmapParamNames[0], null),
        this.setRealtimeLightmap(Fe.lightmapParamNames[1], null),
        (e = this._skinInstance) == null || e.destroy(),
        this._skinInstance = null,
        (t = this.morphInstance) == null || t.destroy(),
        this.morphInstance = null,
        this.clearShaders(),
        this.material = null
    }
    static _prepareRenderStyleForArray(e, t) {
        if (e) {
            for (let s = 0; s < e.length; s++) {
                e[s]._renderStyle = t;
                const i = e[s].mesh;
                Zf.has(i) || (Zf.add(i),
                i.prepareRenderState(t))
            }
            Zf.clear()
        }
    }
    _isVisible(e) {
        return this.visible ? this.isVisibleFunc ? this.isVisibleFunc(e) : (Kf.center = this.aabb.center,
        Kf.radius = this._aabb.halfExtents.length(),
        e.frustum.containsSphere(Kf)) : !1
    }
    updateKey() {
        const e = this.material
          , t = e.alphaToCoverage || e.alphaTest ? ps : e.blendType;
        this._key[Sn] = (this.layer & 15) << 27 | (t === ls ? 1 : 0) << 26 | (e.id & 33554431) << 0
    }
    setInstancing(e, t=!1) {
        e ? (this.instancingData = new CR(e.numVertices),
        this.instancingData.vertexBuffer = e,
        e.format.instancing = !0,
        this.cull = t) : (this.instancingData = null,
        this.cull = !0),
        this._updateShaderDefs(e ? this._shaderDefs | Eh : this._shaderDefs & ~Eh)
    }
    ensureMaterial(e) {
        this.material || (this.material = _c(e))
    }
    clearParameters() {
        this.parameters = {}
    }
    getParameters() {
        return this.parameters
    }
    getParameter(e) {
        return this.parameters[e]
    }
    setParameter(e, t, s=-262141) {
        if (t === void 0 && typeof e == "object") {
            const n = e;
            if (n.length) {
                for (let r = 0; r < n.length; r++)
                    this.setParameter(n[r]);
                return
            }
            e = n.name,
            t = n.value
        }
        const i = this.parameters[e];
        i ? (i.data = t,
        i.passFlags = s) : this.parameters[e] = {
            scopeId: null,
            data: t,
            passFlags: s
        }
    }
    setRealtimeLightmap(e, t) {
        const s = this.getParameter(e);
        s !== t && (s && pn.decRef(s.data),
        t ? (pn.incRef(t),
        this.setParameter(e, t)) : this.deleteParameter(e))
    }
    deleteParameter(e) {
        this.parameters[e] && delete this.parameters[e]
    }
    setParameters(e, t) {
        const s = this.parameters;
        for (const i in s) {
            const n = s[i];
            n.passFlags & t && (n.scopeId || (n.scopeId = e.scope.resolve(i)),
            n.scopeId.setValue(n.data))
        }
    }
    setLightmapped(e) {
        e ? this.mask = (this.mask | Ui) & ~(Rs | zi) : (this.setRealtimeLightmap(Fe.lightmapParamNames[0], null),
        this.setRealtimeLightmap(Fe.lightmapParamNames[1], null),
        this._shaderDefs &= ~(ru | Q_ | eg),
        this.mask = (this.mask | Rs) & ~(Ui | zi))
    }
    setCustomAabb(e) {
        e ? this._customAabb ? this._customAabb.copy(e) : this._customAabb = e.clone() : (this._customAabb = null,
        this._aabbVer = -1),
        this._setupSkinUpdate()
    }
    _setupSkinUpdate() {
        this._skinInstance && (this._skinInstance._updateBeforeCull = !this._customAabb)
    }
}
Fe.lightmapParamNames = ["texture_lightMap", "texture_dirLightMap"];
function Jy(a, e) {
    if (a && !e || !a && e)
        return !1;
    if (a = a.data,
    e = e.data,
    a === e)
        return !0;
    if (a instanceof Float32Array && e instanceof Float32Array) {
        if (a.length !== e.length)
            return !1;
        for (let t = 0; t < a.length; t++)
            if (a[t] !== e[t])
                return !1;
        return !0
    }
    return !1
}
function MR(a, e) {
    for (const t in a)
        if (a.hasOwnProperty(t) && !Jy(a[t], e[t]))
            return !1;
    for (const t in e)
        if (e.hasOwnProperty(t) && !Jy(e[t], a[t]))
            return !1;
    return !0
}
const PR = [0, 1, 3, 2, 3, 1]
  , RR = [0, 1, 3, 0, 3, 2]
  , e0 = new Ci;
function Qf(a) {
    return a.node.worldTransform.scaleSign
}
class IR {
    constructor(e, t, s) {
        this.device = e,
        this.rootNode = t,
        this.scene = s,
        this._init = !1,
        this._batchGroups = {},
        this._batchGroupCounter = 0,
        this._batchList = [],
        this._dirtyGroups = []
    }
    destroy() {
        this.device = null,
        this.rootNode = null,
        this.scene = null,
        this._batchGroups = {},
        this._batchList = [],
        this._dirtyGroups = []
    }
    addGroup(e, t, s, i, n) {
        if (i === void 0 && (i = this._batchGroupCounter,
        this._batchGroupCounter++),
        this._batchGroups[i])
            return;
        const r = new gt(i,e,t,s,n);
        return this._batchGroups[i] = r,
        r
    }
    removeGroup(e) {
        if (!this._batchGroups[e])
            return;
        const t = [];
        for (let s = 0; s < this._batchList.length; s++)
            this._batchList[s].batchGroupId === e ? this.destroyBatch(this._batchList[s]) : t.push(this._batchList[s]);
        this._batchList = t,
        this._removeModelsFromBatchGroup(this.rootNode, e),
        delete this._batchGroups[e]
    }
    markGroupDirty(e) {
        this._dirtyGroups.indexOf(e) < 0 && this._dirtyGroups.push(e)
    }
    getGroupByName(e) {
        const t = this._batchGroups;
        for (const s in t)
            if (t.hasOwnProperty(s) && t[s].name === e)
                return t[s];
        return null
    }
    getBatches(e) {
        const t = []
          , s = this._batchList.length;
        for (let i = 0; i < s; i++) {
            const n = this._batchList[i];
            n.batchGroupId === e && t.push(n)
        }
        return t
    }
    _removeModelsFromBatchGroup(e, t) {
        if (e.enabled) {
            e.model && e.model.batchGroupId === t && (e.model.batchGroupId = -1),
            e.render && e.render.batchGroupId === t && (e.render.batchGroupId = -1),
            e.element && e.element.batchGroupId === t && (e.element.batchGroupId = -1),
            e.sprite && e.sprite.batchGroupId === t && (e.sprite.batchGroupId = -1);
            for (let s = 0; s < e._children.length; s++)
                this._removeModelsFromBatchGroup(e._children[s], t)
        }
    }
    insert(e, t, s) {
        const i = this._batchGroups[t];
        i && i._obj[e].indexOf(s) < 0 && (i._obj[e].push(s),
        this.markGroupDirty(t))
    }
    remove(e, t, s) {
        const i = this._batchGroups[t];
        if (i) {
            const n = i._obj[e].indexOf(s);
            n >= 0 && (i._obj[e].splice(n, 1),
            this.markGroupDirty(t))
        }
    }
    _extractRender(e, t, s, i) {
        return e.render && (t = i[e.render.batchGroupId] = t.concat(e.render.meshInstances),
        e.render.removeFromLayers()),
        t
    }
    _extractModel(e, t, s, i) {
        return e.model && e.model.model && (t = i[e.model.batchGroupId] = t.concat(e.model.meshInstances),
        e.model.removeModelFromLayers()),
        t
    }
    _extractElement(e, t, s) {
        if (!e.element)
            return;
        let i = !1;
        e.element._text && e.element._text._model.meshInstances.length > 0 ? (t.push(e.element._text._model.meshInstances[0]),
        e.element.removeModelFromLayers(e.element._text._model),
        i = !0) : e.element._image && (t.push(e.element._image._renderable.meshInstance),
        e.element.removeModelFromLayers(e.element._image._renderable.model),
        e.element._image._renderable.unmaskMeshInstance && (t.push(e.element._image._renderable.unmaskMeshInstance),
        (!e.element._image._renderable.unmaskMeshInstance.stencilFront || !e.element._image._renderable.unmaskMeshInstance.stencilBack) && (e.element._dirtifyMask(),
        e.element._onPrerender())),
        i = !0),
        i && (s._ui = !0)
    }
    _collectAndRemoveMeshInstances(e, t) {
        for (let s = 0; s < t.length; s++) {
            const i = t[s]
              , n = this._batchGroups[i];
            if (!n)
                continue;
            let r = e[i];
            r || (r = e[i] = []);
            for (let o = 0; o < n._obj.model.length; o++)
                r = this._extractModel(n._obj.model[o], r, n, e);
            for (let o = 0; o < n._obj.render.length; o++)
                r = this._extractRender(n._obj.render[o], r, n, e);
            for (let o = 0; o < n._obj.element.length; o++)
                this._extractElement(n._obj.element[o], r, n);
            for (let o = 0; o < n._obj.sprite.length; o++) {
                const l = n._obj.sprite[o];
                l.sprite && l.sprite._meshInstance && (n.dynamic || l.sprite.sprite._renderMode === gn) && (r.push(l.sprite._meshInstance),
                l.sprite.removeModelFromLayers(),
                n._sprite = !0,
                l.sprite._batchGroup = n)
            }
        }
    }
    generate(e) {
        const t = {};
        e || (e = Object.keys(this._batchGroups));
        const s = [];
        for (let l = 0; l < this._batchList.length; l++) {
            if (e.indexOf(this._batchList[l].batchGroupId) < 0) {
                s.push(this._batchList[l]);
                continue
            }
            this.destroyBatch(this._batchList[l])
        }
        if (this._batchList = s,
        this._collectAndRemoveMeshInstances(t, e),
        e === this._dirtyGroups)
            this._dirtyGroups.length = 0;
        else {
            const l = [];
            for (let c = 0; c < this._dirtyGroups.length; c++)
                e.indexOf(this._dirtyGroups[c]) < 0 && l.push(this._dirtyGroups[c]);
            this._dirtyGroups = l
        }
        let i, n, r, o;
        for (const l in t)
            if (t.hasOwnProperty(l) && (i = t[l],
            r = this._batchGroups[l],
            !!r)) {
                n = this.prepare(i, r.dynamic, r.maxAabbSize, r._ui || r._sprite);
                for (let c = 0; c < n.length; c++)
                    o = this.create(n[c], r.dynamic, parseInt(l, 10)),
                    o && o.addToLayers(this.scene, r.layers)
            }
    }
    prepare(e, t, s=Number.POSITIVE_INFINITY, i) {
        if (e.length === 0)
            return [];
        const n = s * .5
          , r = this.device.supportsBoneTextures ? 1024 : this.device.boneLimit
          , o = this.device.extUintElement ? 4294967295 : 65535
          , l = new Pe
          , c = new Pe;
        let d = null, h;
        const u = [];
        let f = 0;
        i && e.sort(function(g, v) {
            return g.drawOrder - v.drawOrder
        });
        let p = e, _;
        const m = i ? function(g) {
            d ? d.add(g.aabb) : d = g.aabb.clone(),
            _.push(g)
        }
        : function(g) {
            _.push(g)
        }
        ;
        for (; p.length > 0; ) {
            u[f] = [p[0]],
            _ = [];
            const g = p[0].material
              , v = p[0].layer
              , x = p[0]._shaderDefs
              , S = p[0].parameters
              , w = p[0].stencilFront;
            let T = p[0].mesh.vertexBuffer.getNumVertices();
            const b = p[0].drawOrder;
            l.copy(p[0].aabb);
            const E = Qf(p[0])
              , C = p[0].mesh.vertexBuffer.format.batchingHash
              , R = p[0].mesh.primitive[0].indexed;
            d = null;
            for (let F = 1; F < p.length; F++) {
                const L = p[F];
                if (t && u[f].length >= r) {
                    _ = _.concat(p.slice(F));
                    break
                }
                if (g !== L.material || v !== L.layer || C !== L.mesh.vertexBuffer.format.batchingHash || R !== L.mesh.primitive[0].indexed || x !== L._shaderDefs || T + L.mesh.vertexBuffer.getNumVertices() > o) {
                    m(L);
                    continue
                }
                if (c.copy(l),
                c.add(L.aabb),
                c.halfExtents.x > n || c.halfExtents.y > n || c.halfExtents.z > n) {
                    m(L);
                    continue
                }
                if (w && (!(h = L.stencilFront) || w.func !== h.func || w.zpass !== h.zpass)) {
                    m(L);
                    continue
                }
                if (E !== Qf(L)) {
                    m(L);
                    continue
                }
                if (!MR(S, L.parameters)) {
                    m(L);
                    continue
                }
                if (i && d && d.intersects(L.aabb) && L.drawOrder !== b) {
                    m(L);
                    continue
                }
                l.add(L.aabb),
                T += L.mesh.vertexBuffer.getNumVertices(),
                u[f].push(L)
            }
            f++,
            p = _
        }
        return u
    }
    collectBatchedMeshData(e, t) {
        let s = null
          , i = 0
          , n = 0
          , r = null;
        for (let o = 0; o < e.length; o++)
            if (e[o].visible) {
                const l = e[o].mesh
                  , c = l.vertexBuffer.numVertices;
                if (i += c,
                l.primitive[0].indexed)
                    n += l.primitive[0].count;
                else {
                    const d = l.primitive[0].type;
                    (d === Zr || d === Ks) && l.primitive[0].count === 4 && (n += 6)
                }
                if (!s) {
                    r = e[o].material,
                    s = {};
                    const d = l.vertexBuffer.format.elements;
                    for (let h = 0; h < d.length; h++) {
                        const u = d[h].name;
                        s[u] = {
                            numComponents: d[h].numComponents,
                            dataType: d[h].dataType,
                            normalize: d[h].normalize,
                            count: 0
                        }
                    }
                    t && (s[Ps] = {
                        numComponents: 1,
                        dataType: Me,
                        normalize: !1,
                        count: 0
                    })
                }
            }
        return {
            streams: s,
            batchNumVerts: i,
            batchNumIndices: n,
            material: r
        }
    }
    create(e, t, s) {
        if (!this._init) {
            const d = "#define BONE_LIMIT " + this.device.getBoneLimit() + `
`;
            this.transformVS = d + `#define DYNAMICBATCH
` + $.transformVS,
            this.skinTexVS = $.skinBatchTexVS,
            this.skinConstVS = $.skinBatchConstVS,
            this.vertexFormats = {},
            this._init = !0
        }
        let i = null, n, r, o, l = null;
        const c = this.collectBatchedMeshData(e, t);
        if (c.streams) {
            const d = c.streams;
            let h = c.material;
            const u = c.batchNumVerts
              , f = c.batchNumIndices;
            l = new Hy(e,t,s),
            this._batchList.push(l);
            let p, _, m, g = 0, v = 0, x;
            const S = new y
              , w = u <= 65535 ? Uint16Array : Uint32Array
              , T = new w(f);
            for (n in d)
                i = d[n],
                i.typeArrayType = bo[i.dataType],
                i.elementByteSize = th[i.dataType],
                i.buffer = new i.typeArrayType(u * i.numComponents);
            for (let C = 0; C < e.length; C++)
                if (e[C].visible) {
                    r = e[C].mesh,
                    o = r.vertexBuffer.numVertices,
                    t || (x = e[C].node.getWorldTransform());
                    for (n in d)
                        if (n !== Ps) {
                            i = d[n];
                            const R = new i.typeArrayType(i.buffer.buffer,i.elementByteSize * i.count)
                              , F = r.getVertexStream(n, R) * i.numComponents;
                            if (i.count += F,
                            !t && i.numComponents >= 3) {
                                if (n === ut)
                                    for (let L = 0; L < F; L += i.numComponents)
                                        S.set(R[L], R[L + 1], R[L + 2]),
                                        x.transformPoint(S, S),
                                        R[L] = S.x,
                                        R[L + 1] = S.y,
                                        R[L + 2] = S.z;
                                else if (n === Is || n === Qi) {
                                    e0.invertMat4(x).transpose();
                                    for (let L = 0; L < F; L += i.numComponents)
                                        S.set(R[L], R[L + 1], R[L + 2]),
                                        e0.transformVector(S, S),
                                        R[L] = S.x,
                                        R[L + 1] = S.y,
                                        R[L + 2] = S.z
                                }
                            }
                        }
                    if (t) {
                        i = d[Ps];
                        for (let R = 0; R < o; R++)
                            i.buffer[i.count++] = C
                    }
                    if (r.primitive[0].indexed) {
                        p = r.primitive[0].base,
                        _ = r.primitive[0].count;
                        const R = r.indexBuffer[0].getFormat();
                        m = new ym[R](r.indexBuffer[0].storage)
                    } else {
                        const R = r.primitive[0].type;
                        if (R === Zr || R === Ks)
                            if (r.primitive[0].count === 4)
                                p = 0,
                                _ = 6,
                                m = R === Zr ? PR : RR;
                            else {
                                _ = 0;
                                continue
                            }
                    }
                    for (let R = 0; R < _; R++)
                        T[R + v] = m[p + R] + g;
                    v += _,
                    g += o
                }
            r = new ms(this.device);
            for (n in d)
                i = d[n],
                r.setVertexStream(n, i.buffer, i.numComponents, void 0, i.dataType, i.normalize);
            T.length > 0 && r.setIndices(T),
            r.update(xn, !1),
            t && (h = h.clone(),
            h.chunks.transformVS = this.transformVS,
            h.chunks.skinTexVS = this.skinTexVS,
            h.chunks.skinConstVS = this.skinConstVS,
            h.update());
            const b = new Fe(r,h,this.rootNode);
            b.castShadow = l.origMeshInstances[0].castShadow,
            b.parameters = l.origMeshInstances[0].parameters,
            b.layer = l.origMeshInstances[0].layer,
            b._shaderDefs = l.origMeshInstances[0]._shaderDefs,
            b.cull = l.origMeshInstances[0].cull;
            const E = this._batchGroups[s];
            if (E && E._ui && (b.cull = !1),
            t) {
                const C = [];
                for (let R = 0; R < l.origMeshInstances.length; R++)
                    C.push(l.origMeshInstances[R].node);
                b.skinInstance = new Xy(this.device,C,this.rootNode)
            }
            b._updateAabb = !1,
            b.drawOrder = l.origMeshInstances[0].drawOrder,
            b.stencilFront = l.origMeshInstances[0].stencilFront,
            b.stencilBack = l.origMeshInstances[0].stencilBack,
            b.flipFacesFactor = Qf(l.origMeshInstances[0]),
            b.castShadow = l.origMeshInstances[0].castShadow,
            l.meshInstance = b,
            l.updateBoundingBox()
        }
        return l
    }
    updateAll() {
        this._dirtyGroups.length > 0 && this.generate(this._dirtyGroups);
        for (let e = 0; e < this._batchList.length; e++)
            this._batchList[e].dynamic && this._batchList[e].updateBoundingBox()
    }
    clone(e, t) {
        const s = new Hy(t,e.dynamic,e.batchGroupId);
        this._batchList.push(s);
        const i = [];
        for (let n = 0; n < t.length; n++)
            i.push(t[n].node);
        return s.meshInstance = new Fe(e.meshInstance.mesh,e.meshInstance.material,e.meshInstance.node),
        s.meshInstance._updateAabb = !1,
        s.meshInstance.parameters = t[0].parameters,
        s.meshInstance.cull = t[0].cull,
        s.meshInstance.layer = t[0].layer,
        e.dynamic && (s.meshInstance.skinInstance = new Xy(this.device,i,this.rootNode)),
        s.meshInstance.castShadow = e.meshInstance.castShadow,
        s.meshInstance._shader = e.meshInstance._shader.slice(),
        s.meshInstance.castShadow = e.meshInstance.castShadow,
        s
    }
    destroyBatch(e) {
        e.destroy(this.scene, this._batchGroups[e.batchGroupId].layers)
    }
}
const t0 = ["uSceneColorMap", "texture_grabPass"];
class LR extends Js {
    constructor(...e) {
        super(...e),
        this.colorRenderTarget = null,
        this.source = null
    }
    destroy() {
        super.destroy(),
        this.releaseRenderTarget(this.colorRenderTarget)
    }
    shouldReallocate(e, t, s) {
        if ((e == null ? void 0 : e.colorBuffer.format) !== s)
            return !0;
        const n = (t == null ? void 0 : t.width) || this.device.width
          , r = (t == null ? void 0 : t.height) || this.device.height;
        return !e || n !== e.width || r !== e.height
    }
    allocateRenderTarget(e, t, s, i) {
        const n = s.isWebGL2
          , r = new ge(s,{
            name: t0[0],
            format: i,
            width: t ? t.colorBuffer.width : s.width,
            height: t ? t.colorBuffer.height : s.height,
            mipmaps: n,
            minFilter: n ? ur : ot,
            magFilter: ot,
            addressU: oe,
            addressV: oe
        });
        return e ? (e.destroyFrameBuffers(),
        e._colorBuffer = r,
        e._colorBuffers = [r]) : e = new It({
            name: "ColorGrabRT",
            colorBuffer: r,
            depth: !1,
            stencil: !1,
            autoResolve: !1
        }),
        e
    }
    releaseRenderTarget(e) {
        e && (e.destroyTextureBuffers(),
        e.destroy())
    }
    frameUpdate() {
        var e;
        const t = this.device
          , s = this.source
          , i = (e = s == null ? void 0 : s.colorBuffer.format) != null ? e : this.device.backBufferFormat;
        this.shouldReallocate(this.colorRenderTarget, s == null ? void 0 : s.colorBuffer, i) && (this.releaseRenderTarget(this.colorRenderTarget),
        this.colorRenderTarget = this.allocateRenderTarget(this.colorRenderTarget, s, t, i));
        const n = this.colorRenderTarget.colorBuffer;
        t0.forEach(r => t.scope.resolve(r).setValue(n))
    }
    execute() {
        const e = this.device
          , t = this.source
          , s = this.colorRenderTarget.colorBuffer;
        if (e.isWebGPU)
            e.copyRenderTarget(t, this.colorRenderTarget, !0, !1),
            e.mipmapRenderer.generate(this.colorRenderTarget.colorBuffer.impl);
        else if (e.isWebGL2)
            e.copyRenderTarget(t, this.colorRenderTarget, !0, !1),
            e.activeTexture(e.maxCombinedTextures - 1),
            e.bindTexture(s),
            e.gl.generateMipmap(s.impl._glTarget);
        else {
            s.impl._glTexture || s.impl.initialize(e, s),
            e.bindTexture(s);
            const i = e.gl;
            i.copyTexImage2D(i.TEXTURE_2D, 0, s.impl._glFormat, 0, 0, s.width, s.height, 0),
            s._needsUpload = !1,
            s._needsMipmapsUpload = !1
        }
    }
}
const s0 = ["uSceneDepthMap", "uDepthMap"];
class DR extends Js {
    constructor(e, t) {
        super(e),
        this.depthRenderTarget = null,
        this.camera = null,
        this.camera = t
    }
    destroy() {
        super.destroy(),
        this.releaseRenderTarget(this.depthRenderTarget)
    }
    shouldReallocate(e, t) {
        const s = (t == null ? void 0 : t.width) || this.device.width
          , i = (t == null ? void 0 : t.height) || this.device.height;
        return !e || s !== e.width || i !== e.height
    }
    allocateRenderTarget(e, t, s, i, n) {
        const r = new ge(s,{
            name: s0[0],
            format: i,
            width: t ? t.colorBuffer.width : s.width,
            height: t ? t.colorBuffer.height : s.height,
            mipmaps: !1,
            minFilter: be,
            magFilter: be,
            addressU: oe,
            addressV: oe
        });
        return e ? (e.destroyFrameBuffers(),
        n ? e._depthBuffer = r : (e._colorBuffer = r,
        e._colorBuffers = [r])) : e = new It({
            name: "DepthGrabRT",
            colorBuffer: n ? null : r,
            depthBuffer: n ? r : null,
            depth: !n,
            stencil: s.supportsStencil,
            autoResolve: !1
        }),
        e
    }
    releaseRenderTarget(e) {
        e && (e.destroyTextureBuffers(),
        e.destroy())
    }
    before() {
        var e, t, s, i;
        const n = this.camera
          , r = this.device
          , o = (e = n == null ? void 0 : n.renderTarget) != null ? e : r.backBuffer;
        let l = !0
          , c = o.stencil ? ua : da;
        r.isWebGPU && o.samples > 1 && (c = ca,
        l = !1);
        const d = (t = (s = n.renderTarget) == null ? void 0 : s.depthBuffer) != null ? t : (i = n.renderTarget) == null ? void 0 : i.colorBuffer;
        this.shouldReallocate(this.depthRenderTarget, d) && (this.releaseRenderTarget(this.depthRenderTarget),
        this.depthRenderTarget = this.allocateRenderTarget(this.depthRenderTarget, n.renderTarget, r, c, l));
        const h = l ? this.depthRenderTarget.depthBuffer : this.depthRenderTarget.colorBuffer;
        s0.forEach(u => r.scope.resolve(u).setValue(h))
    }
    execute() {
        const e = this.device;
        if (e.isWebGL2 && e.renderTarget.samples > 1) {
            const t = e.renderTarget.impl._glFrameBuffer
              , s = this.depthRenderTarget;
            e.renderTarget = s,
            e.updateBegin(),
            this.depthRenderTarget.impl.internalResolve(e, t, s.impl._glFrameBuffer, this.depthRenderTarget, e.gl.DEPTH_BUFFER_BIT)
        } else
            e.copyRenderTarget(e.renderTarget, this.depthRenderTarget, !1, !0)
    }
}
const OR = new z(254 / 255,254 / 255,254 / 255,254 / 255)
  , Jf = []
  , FR = [[], [], []]
  , ep = ["uSceneDepthMap", "uDepthMap"];
class BR extends Js {
    constructor(e, t, s) {
        super(e),
        this.renderer = t,
        this.camera = s
    }
    destroy() {
        super.destroy(),
        this.releaseRenderTarget(this.renderTarget)
    }
    update(e) {
        this.scene = e
    }
    shouldReallocate(e, t) {
        const s = t.width
          , i = t.height;
        return !e || s !== e.width || i !== e.height
    }
    allocateRenderTarget(e, t, s) {
        var i, n;
        const r = new ge(s,{
            name: ep[0],
            format: ve,
            width: (i = t == null ? void 0 : t.width) != null ? i : this.device.width,
            height: (n = t == null ? void 0 : t.height) != null ? n : this.device.height,
            mipmaps: !1,
            minFilter: be,
            magFilter: be,
            addressU: oe,
            addressV: oe
        });
        return e ? (e.destroyFrameBuffers(),
        e._colorBuffer = r,
        e._colorBuffers = [r]) : e = new It({
            name: `${ep[0]}RT}`,
            colorBuffer: r,
            depth: !0,
            stencil: !1
        }),
        e
    }
    releaseRenderTarget(e) {
        e && (e.destroyTextureBuffers(),
        e.destroy())
    }
    before() {
        var e;
        const t = this.camera
          , s = this.device
          , i = (e = t.renderTarget) != null ? e : s.backBuffer;
        if (this.shouldReallocate(this.renderTarget, i)) {
            var n;
            (n = this.renderTarget) == null || n.destroyTextureBuffers();
            const o = this.allocateRenderTarget(this.renderTarget, t.renderTarget, s);
            this.renderTarget ? this.renderTarget = o : (this.init(o),
            this.setClearColor(OR),
            this.setClearDepth(1))
        }
        const r = this.renderTarget.colorBuffer;
        ep.forEach(o => s.scope.resolve(o).setValue(r))
    }
    execute() {
        const {device: e, renderer: t, camera: s, scene: i, renderTarget: n} = this
          , r = i.layers.layerList
          , o = i.layers.subLayerEnabled
          , l = i.layers.subLayerList;
        for (let d = 0; d < r.length; d++) {
            const h = r[d];
            if (h.enabled && o[d] && h.camerasSet.has(s)) {
                if (h.id === hs)
                    break;
                const u = h.getCulledInstances(s)
                  , f = l[d] ? u.transparent : u.opaque;
                for (let p = 0; p < f.length; p++) {
                    var c;
                    const _ = f[p];
                    (c = _.material) != null && c.depthWrite && !_._noDepthDrawGl1 && Jf.push(_)
                }
                t.setCameraUniforms(s, n),
                t.renderForward(s, Jf, FR, Vi, p => {
                    e.setBlendState(ft.NOBLEND)
                }
                , h),
                Jf.length = 0
            }
        }
    }
}
const Ua = new y
  , gl = new y
  , i0 = new y
  , n0 = new ee
  , kR = [new y, new y, new y, new y, new y, new y, new y, new y];
let rg = class px {
    constructor() {
        this.shaderPassInfo = null,
        this.renderPassColorGrab = null,
        this.renderPassDepthGrab = null,
        this.renderPasses = [],
        this.jitter = 0,
        this._aspectRatio = 16 / 9,
        this._aspectRatioMode = sg,
        this._calculateProjection = null,
        this._calculateTransform = null,
        this._clearColor = new z(.75,.75,.75,1),
        this._clearColorBuffer = !0,
        this._clearDepth = 1,
        this._clearDepthBuffer = !0,
        this._clearStencil = 0,
        this._clearStencilBuffer = !0,
        this._cullFaces = !0,
        this._farClip = 1e3,
        this._flipFaces = !1,
        this._fov = 45,
        this._frustumCulling = !0,
        this._horizontalFov = !1,
        this._layers = [Bn, hs, j_, Cf, $_],
        this._layersSet = new Set(this._layers),
        this._nearClip = .1,
        this._node = null,
        this._orthoHeight = 10,
        this._projection = Di,
        this._rect = new M(0,0,1,1),
        this._renderTarget = null,
        this._scissorRect = new M(0,0,1,1),
        this._scissorRectClear = !1,
        this._aperture = 16,
        this._shutter = 1 / 1e3,
        this._sensitivity = 1e3,
        this._projMat = new ee,
        this._projMatDirty = !0,
        this._projMatSkybox = new ee,
        this._viewMat = new ee,
        this._viewMatDirty = !0,
        this._viewProjMat = new ee,
        this._viewProjMatDirty = !0,
        this.frustum = new nT,
        this._xr = null,
        this._xrProperties = {
            horizontalFov: this._horizontalFov,
            fov: this._fov,
            aspectRatio: this._aspectRatio,
            farClip: this._farClip,
            nearClip: this._nearClip
        }
    }
    destroy() {
        var e, t;
        (e = this.renderPassColorGrab) == null || e.destroy(),
        this.renderPassColorGrab = null,
        (t = this.renderPassDepthGrab) == null || t.destroy(),
        this.renderPassDepthGrab = null,
        this.renderPasses.length = 0
    }
    get fullSizeClearRect() {
        const e = this._scissorRectClear ? this.scissorRect : this._rect;
        return e.x === 0 && e.y === 0 && e.z === 1 && e.w === 1
    }
    set aspectRatio(e) {
        this._aspectRatio !== e && (this._aspectRatio = e,
        this._projMatDirty = !0)
    }
    get aspectRatio() {
        var e;
        return (e = this.xr) != null && e.active ? this._xrProperties.aspectRatio : this._aspectRatio
    }
    set aspectRatioMode(e) {
        this._aspectRatioMode !== e && (this._aspectRatioMode = e,
        this._projMatDirty = !0)
    }
    get aspectRatioMode() {
        return this._aspectRatioMode
    }
    set calculateProjection(e) {
        this._calculateProjection = e,
        this._projMatDirty = !0
    }
    get calculateProjection() {
        return this._calculateProjection
    }
    set calculateTransform(e) {
        this._calculateTransform = e
    }
    get calculateTransform() {
        return this._calculateTransform
    }
    set clearColor(e) {
        this._clearColor.copy(e)
    }
    get clearColor() {
        return this._clearColor
    }
    set clearColorBuffer(e) {
        this._clearColorBuffer = e
    }
    get clearColorBuffer() {
        return this._clearColorBuffer
    }
    set clearDepth(e) {
        this._clearDepth = e
    }
    get clearDepth() {
        return this._clearDepth
    }
    set clearDepthBuffer(e) {
        this._clearDepthBuffer = e
    }
    get clearDepthBuffer() {
        return this._clearDepthBuffer
    }
    set clearStencil(e) {
        this._clearStencil = e
    }
    get clearStencil() {
        return this._clearStencil
    }
    set clearStencilBuffer(e) {
        this._clearStencilBuffer = e
    }
    get clearStencilBuffer() {
        return this._clearStencilBuffer
    }
    set cullFaces(e) {
        this._cullFaces = e
    }
    get cullFaces() {
        return this._cullFaces
    }
    set farClip(e) {
        this._farClip !== e && (this._farClip = e,
        this._projMatDirty = !0)
    }
    get farClip() {
        var e;
        return (e = this.xr) != null && e.active ? this._xrProperties.farClip : this._farClip
    }
    set flipFaces(e) {
        this._flipFaces = e
    }
    get flipFaces() {
        return this._flipFaces
    }
    set fov(e) {
        this._fov !== e && (this._fov = e,
        this._projMatDirty = !0)
    }
    get fov() {
        var e;
        return (e = this.xr) != null && e.active ? this._xrProperties.fov : this._fov
    }
    set frustumCulling(e) {
        this._frustumCulling = e
    }
    get frustumCulling() {
        return this._frustumCulling
    }
    set horizontalFov(e) {
        this._horizontalFov !== e && (this._horizontalFov = e,
        this._projMatDirty = !0)
    }
    get horizontalFov() {
        var e;
        return (e = this.xr) != null && e.active ? this._xrProperties.horizontalFov : this._horizontalFov
    }
    set layers(e) {
        this._layers = e.slice(0),
        this._layersSet = new Set(this._layers)
    }
    get layers() {
        return this._layers
    }
    get layersSet() {
        return this._layersSet
    }
    set nearClip(e) {
        this._nearClip !== e && (this._nearClip = e,
        this._projMatDirty = !0)
    }
    get nearClip() {
        var e;
        return (e = this.xr) != null && e.active ? this._xrProperties.nearClip : this._nearClip
    }
    set node(e) {
        this._node = e
    }
    get node() {
        return this._node
    }
    set orthoHeight(e) {
        this._orthoHeight !== e && (this._orthoHeight = e,
        this._projMatDirty = !0)
    }
    get orthoHeight() {
        return this._orthoHeight
    }
    set projection(e) {
        this._projection !== e && (this._projection = e,
        this._projMatDirty = !0)
    }
    get projection() {
        return this._projection
    }
    get projectionMatrix() {
        return this._evaluateProjectionMatrix(),
        this._projMat
    }
    set rect(e) {
        this._rect.copy(e)
    }
    get rect() {
        return this._rect
    }
    set renderTarget(e) {
        this._renderTarget = e
    }
    get renderTarget() {
        return this._renderTarget
    }
    set scissorRect(e) {
        this._scissorRect.copy(e)
    }
    get scissorRect() {
        return this._scissorRect
    }
    get viewMatrix() {
        if (this._viewMatDirty) {
            const e = this._node.getWorldTransform();
            this._viewMat.copy(e).invert(),
            this._viewMatDirty = !1
        }
        return this._viewMat
    }
    set aperture(e) {
        this._aperture = e
    }
    get aperture() {
        return this._aperture
    }
    set sensitivity(e) {
        this._sensitivity = e
    }
    get sensitivity() {
        return this._sensitivity
    }
    set shutter(e) {
        this._shutter = e
    }
    get shutter() {
        return this._shutter
    }
    set xr(e) {
        this._xr !== e && (this._xr = e,
        this._projMatDirty = !0)
    }
    get xr() {
        return this._xr
    }
    clone() {
        return new px().copy(this)
    }
    copy(e) {
        return this._aspectRatio = e._aspectRatio,
        this._farClip = e._farClip,
        this._fov = e._fov,
        this._horizontalFov = e._horizontalFov,
        this._nearClip = e._nearClip,
        this._xrProperties.aspectRatio = e._xrProperties.aspectRatio,
        this._xrProperties.farClip = e._xrProperties.farClip,
        this._xrProperties.fov = e._xrProperties.fov,
        this._xrProperties.horizontalFov = e._xrProperties.horizontalFov,
        this._xrProperties.nearClip = e._xrProperties.nearClip,
        this.aspectRatioMode = e.aspectRatioMode,
        this.calculateProjection = e.calculateProjection,
        this.calculateTransform = e.calculateTransform,
        this.clearColor = e.clearColor,
        this.clearColorBuffer = e.clearColorBuffer,
        this.clearDepth = e.clearDepth,
        this.clearDepthBuffer = e.clearDepthBuffer,
        this.clearStencil = e.clearStencil,
        this.clearStencilBuffer = e.clearStencilBuffer,
        this.cullFaces = e.cullFaces,
        this.flipFaces = e.flipFaces,
        this.frustumCulling = e.frustumCulling,
        this.layers = e.layers,
        this.orthoHeight = e.orthoHeight,
        this.projection = e.projection,
        this.rect = e.rect,
        this.renderTarget = e.renderTarget,
        this.scissorRect = e.scissorRect,
        this.aperture = e.aperture,
        this.shutter = e.shutter,
        this.sensitivity = e.sensitivity,
        this.shaderPassInfo = e.shaderPassInfo,
        this.jitter = e.jitter,
        this._projMatDirty = !0,
        this
    }
    _enableRenderPassColorGrab(e, t) {
        if (t)
            this.renderPassColorGrab || (this.renderPassColorGrab = new LR(e));
        else {
            var s;
            (s = this.renderPassColorGrab) == null || s.destroy(),
            this.renderPassColorGrab = null
        }
    }
    _enableRenderPassDepthGrab(e, t, s) {
        if (s)
            this.renderPassDepthGrab || (this.renderPassDepthGrab = e.isWebGL1 ? new BR(e,t,this) : new DR(e,this));
        else {
            var i;
            (i = this.renderPassDepthGrab) == null || i.destroy(),
            this.renderPassDepthGrab = null
        }
    }
    _updateViewProjMat() {
        (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) && (this._viewProjMat.mul2(this.projectionMatrix, this.viewMatrix),
        this._viewProjMatDirty = !1)
    }
    worldToScreen(e, t, s, i=new y) {
        this._updateViewProjMat(),
        this._viewProjMat.transformPoint(e, i);
        const n = this._viewProjMat.data
          , r = e.x * n[3] + e.y * n[7] + e.z * n[11] + 1 * n[15];
        return i.x = (i.x / r + 1) * .5 * t,
        i.y = (1 - i.y / r) * .5 * s,
        i
    }
    screenToWorld(e, t, s, i, n, r=new y) {
        const o = this.farClip - this.nearClip;
        if (Ua.set(e / i, (n - t) / n, s / o),
        Ua.mulScalar(2),
        Ua.sub(y.ONE),
        this._projection === Di) {
            ee._getPerspectiveHalfSize(gl, this.fov, this.aspectRatio, this.nearClip, this.horizontalFov),
            gl.x *= Ua.x,
            gl.y *= Ua.y;
            const l = this._node.getWorldTransform();
            gl.z = -this.nearClip,
            l.transformPoint(gl, i0);
            const c = this._node.getPosition();
            r.sub2(i0, c),
            r.normalize(),
            r.mulScalar(s),
            r.add(c)
        } else
            this._updateViewProjMat(),
            n0.copy(this._viewProjMat).invert(),
            n0.transformPoint(Ua, r);
        return r
    }
    _evaluateProjectionMatrix() {
        if (this._projMatDirty) {
            if (this._projection === Di)
                this._projMat.setPerspective(this.fov, this.aspectRatio, this.nearClip, this.farClip, this.horizontalFov),
                this._projMatSkybox.copy(this._projMat);
            else {
                const e = this._orthoHeight
                  , t = e * this.aspectRatio;
                this._projMat.setOrtho(-t, t, -e, e, this.nearClip, this.farClip),
                this._projMatSkybox.setPerspective(this.fov, this.aspectRatio, this.nearClip, this.farClip)
            }
            this._projMatDirty = !1
        }
    }
    getProjectionMatrixSkybox() {
        return this._evaluateProjectionMatrix(),
        this._projMatSkybox
    }
    getExposure() {
        const e = Math.log2(this._aperture * this._aperture / this._shutter * 100 / this._sensitivity);
        return 1 / (Math.pow(2, e) * 1.2)
    }
    getScreenSize(e) {
        if (this._projection === Di) {
            const t = this._node.getPosition().distance(e.center);
            if (t < e.radius)
                return 1;
            const s = Math.asin(e.radius / t)
              , i = Math.tan(s)
              , n = Math.tan(this.fov / 2 * W.DEG_TO_RAD);
            return Math.min(i / n, 1)
        }
        return W.clamp(e.radius / this._orthoHeight, 0, 1)
    }
    getFrustumCorners(e=this.nearClip, t=this.farClip) {
        const s = this.fov * Math.PI / 180;
        let i = this._projection === Di ? Math.tan(s / 2) * e : this._orthoHeight
          , n = i * this.aspectRatio;
        const r = kR;
        return r[0].x = n,
        r[0].y = -i,
        r[0].z = -e,
        r[1].x = n,
        r[1].y = i,
        r[1].z = -e,
        r[2].x = -n,
        r[2].y = i,
        r[2].z = -e,
        r[3].x = -n,
        r[3].y = -i,
        r[3].z = -e,
        this._projection === Di && (i = Math.tan(s / 2) * t,
        n = i * this.aspectRatio),
        r[4].x = n,
        r[4].y = -i,
        r[4].z = -t,
        r[5].x = n,
        r[5].y = i,
        r[5].z = -t,
        r[6].x = -n,
        r[6].y = i,
        r[6].z = -t,
        r[7].x = -n,
        r[7].y = -i,
        r[7].z = -t,
        r
    }
    setXrProperties(e) {
        Object.assign(this._xrProperties, e),
        this._projMatDirty = !0
    }
}
;
class NR {
    constructor() {
        this.hasTangents = !1,
        this.chunks = {},
        this.pass = 0,
        this.alphaTest = !1,
        this.blendType = ls,
        this.separateAmbient = !1,
        this.screenSpace = !1,
        this.skin = !1,
        this.useInstancing = !1,
        this.useMorphPosition = !1,
        this.useMorphNormal = !1,
        this.useMorphTextureBased = !1,
        this.nineSlicedMode = 0,
        this.clusteredLightingEnabled = !0,
        this.clusteredLightingCookiesEnabled = !1,
        this.clusteredLightingShadowsEnabled = !1,
        this.clusteredLightingShadowType = 0,
        this.clusteredLightingAreaLightsEnabled = !1,
        this.vertexColors = !1,
        this.lightMapEnabled = !1,
        this.dirLightMapEnabled = !1,
        this.useHeights = !1,
        this.useNormals = !1,
        this.useClearCoatNormals = !1,
        this.useAo = !1,
        this.diffuseMapEnabled = !1,
        this.useAmbientTint = !1,
        this.customFragmentShader = null,
        this.pixelSnap = !1,
        this.shadingModel = 0,
        this.ambientSH = !1,
        this.fastTbn = !1,
        this.twoSidedLighting = !1,
        this.occludeDirect = !1,
        this.occludeSpecular = 0,
        this.occludeSpecularFloat = !1,
        this.useMsdf = !1,
        this.msdfTextAttribute = !1,
        this.alphaToCoverage = !1,
        this.opacityFadesSpecular = !1,
        this.opacityDither = cs,
        this.opacityShadowDither = cs,
        this.cubeMapProjection = 0,
        this.conserveEnergy = !1,
        this.useSpecular = !1,
        this.useSpecularityFactor = !1,
        this.enableGGXSpecular = !1,
        this.fresnelModel = 0,
        this.useRefraction = !1,
        this.useClearCoat = !1,
        this.useSheen = !1,
        this.useIridescence = !1,
        this.useMetalness = !1,
        this.useDynamicRefraction = !1,
        this.fog = Tf,
        this.gamma = dc,
        this.toneMap = -1,
        this.fixSeams = !1,
        this.reflectionSource = null,
        this.reflectionEncoding = null,
        this.reflectionCubemapEncoding = null,
        this.ambientSource = "constant",
        this.ambientEncoding = null,
        this.skyboxIntensity = 1,
        this.useCubeMapRotation = !1,
        this.lightMapWithoutAmbient = !1,
        this.lights = [],
        this.noShadow = !1,
        this.lightMaskDynamic = 0,
        this.userAttributes = {}
    }
}
class ui {
    static update(e, t, s, i, n, r) {
        ui.updateSharedOptions(e, t, s, i, n),
        ui.updateMaterialOptions(e, t),
        ui.updateEnvOptions(e, t, s),
        ui.updateLightingOptions(e, t, i, r),
        n === $i && (e.gamma = uc,
        e.toneMap = fc)
    }
    static updateSharedOptions(e, t, s, i, n) {
        e.chunks = t.chunks,
        e.pass = n,
        e.alphaTest = t.alphaTest > 0,
        e.blendType = t.blendType,
        e.screenSpace = i && (i & Ah) !== 0,
        e.skin = i && (i & Ch) !== 0,
        e.useInstancing = i && (i & Eh) !== 0,
        e.useMorphPosition = i && (i & Mh) !== 0,
        e.useMorphNormal = i && (i & Ph) !== 0,
        e.useMorphTextureBased = i && (i & Rh) !== 0,
        e.hasTangents = i && (i & J_) !== 0,
        e.nineSlicedMode = t.nineSlicedMode || gn,
        t.useLighting && s.clusteredLightingEnabled ? (e.clusteredLightingEnabled = !0,
        e.clusteredLightingCookiesEnabled = s.lighting.cookiesEnabled,
        e.clusteredLightingShadowsEnabled = s.lighting.shadowsEnabled,
        e.clusteredLightingShadowType = s.lighting.shadowType,
        e.clusteredLightingAreaLightsEnabled = s.lighting.areaLightsEnabled) : (e.clusteredLightingEnabled = !1,
        e.clusteredLightingCookiesEnabled = !1,
        e.clusteredLightingShadowsEnabled = !1,
        e.clusteredLightingAreaLightsEnabled = !1)
    }
    static updateMaterialOptions(e, t) {
        e.useAmbientTint = !1,
        e.separateAmbient = !1,
        e.customFragmentShader = null,
        e.pixelSnap = t.pixelSnap,
        e.shadingModel = t.shadingModel,
        e.ambientSH = t.ambientSH,
        e.fastTbn = t.fastTbn,
        e.twoSidedLighting = t.twoSidedLighting,
        e.occludeDirect = t.occludeDirect,
        e.occludeSpecular = t.occludeSpecular,
        e.occludeSpecularFloat = t.occludeSpecularIntensity !== 1,
        e.useMsdf = !1,
        e.msdfTextAttribute = !1,
        e.alphaToCoverage = t.alphaToCoverage,
        e.opacityFadesSpecular = t.opacityFadesSpecular,
        e.opacityDither = t.opacityDither,
        e.opacityShadowDither = t.opacityShadowDither,
        e.cubeMapProjection = sx,
        e.conserveEnergy = t.conserveEnergy && t.shadingModel === cc,
        e.useSpecular = t.hasSpecular,
        e.useSpecularityFactor = t.hasSpecularityFactor,
        e.enableGGXSpecular = t.ggxSpecular,
        e.fresnelModel = t.fresnelModel,
        e.useRefraction = t.hasRefraction,
        e.useClearCoat = t.hasClearCoat,
        e.useSheen = t.hasSheen,
        e.useIridescence = t.hasIrridescence,
        e.useMetalness = t.hasMetalness,
        e.useDynamicRefraction = t.dynamicRefraction,
        e.vertexColors = !1,
        e.lightMapEnabled = t.hasLighting,
        e.dirLightMapEnabled = t.dirLightMap,
        e.useHeights = t.hasHeights,
        e.useNormals = t.hasNormals,
        e.useClearCoatNormals = t.hasClearCoatNormals,
        e.useAo = t.hasAo,
        e.diffuseMapEnabled = t.hasDiffuseMap
    }
    static updateEnvOptions(e, t, s) {
        e.fog = t.useFog ? s.fog : "none",
        e.gamma = t.useGammaTonemap ? s.gammaCorrection : dc,
        e.toneMap = t.useGammaTonemap ? s.toneMapping : -1,
        e.fixSeams = !1,
        t.useSkybox && s.envAtlas && s.skybox ? (e.reflectionSource = "envAtlasHQ",
        e.reflectionEncoding = s.envAtlas.encoding,
        e.reflectionCubemapEncoding = s.skybox.encoding) : t.useSkybox && s.envAtlas ? (e.reflectionSource = "envAtlas",
        e.reflectionEncoding = s.envAtlas.encoding) : t.useSkybox && s.skybox ? (e.reflectionSource = "cubeMap",
        e.reflectionEncoding = s.skybox.encoding) : (e.reflectionSource = null,
        e.reflectionEncoding = null),
        t.ambientSH ? (e.ambientSource = "ambientSH",
        e.ambientEncoding = null) : e.reflectionSource && s.envAtlas ? (e.ambientSource = "envAtlas",
        e.ambientEncoding = s.envAtlas.encoding) : (e.ambientSource = "constant",
        e.ambientEncoding = null);
        const i = !!e.reflectionSource;
        e.skyboxIntensity = i && (s.skyboxIntensity !== 1 || s.physicalUnits),
        e.useCubeMapRotation = i && s._skyboxRotationShaderInclude
    }
    static updateLightingOptions(e, t, s, i) {
        if (e.lightMapWithoutAmbient = !1,
        t.useLighting) {
            const n = []
              , r = s ? s >> 16 : Rs;
            e.lightMaskDynamic = !!(r & Rs),
            e.lightMapWithoutAmbient = !1,
            i && (ui.collectLights(pe, i[pe], n, r),
            ui.collectLights(Oe, i[Oe], n, r),
            ui.collectLights(He, i[He], n, r)),
            e.lights = n
        } else
            e.lights = [];
        (e.lights.length === 0 || s & nu) && (e.noShadow = !0)
    }
    static collectLights(e, t, s, i) {
        for (let n = 0; n < t.length; n++) {
            const r = t[n];
            r.enabled && r.mask & i && s.push(r)
        }
    }
}
class rr {
    constructor() {
        this.code = ""
    }
    append(...e) {
        e.forEach(t => {
            t.endsWith(`
`) ? this.code += t : this.code += t + `
`
        }
        )
    }
    prepend(...e) {
        e.forEach(t => {
            t.endsWith(`
`) ? this.code = t + this.code : this.code = t + `
` + this.code
        }
        )
    }
}
const UR = {
    linear: "decodeLinear",
    srgb: "decodeGamma",
    rgbm: "decodeRGBM",
    rgbe: "decodeRGBE",
    rgbp: "decodeRGBP"
}
  , zR = {
    linear: "encodeLinear",
    srgb: "encodeGamma",
    rgbm: "encodeRGBM",
    rgbe: "encodeRGBE",
    rgbp: "encodeRGBP"
};
class mi {
    static decodeFunc(e) {
        return UR[e] || "decodeGamma"
    }
    static encodeFunc(e) {
        return zR[e] || "encodeGamma"
    }
}
const r0 = new ee
  , a0 = new ee
  , o0 = new ee;
class vi {
    static create(e, t, s) {
        const i = new rg;
        switch (i.node = new yt(e),
        i.aspectRatio = 1,
        i.aspectRatioMode = Am,
        i._scissorRectClear = !0,
        t) {
        case Oe:
            i.node.setRotation(vi.pointLightRotations[s]),
            i.fov = 90,
            i.projection = Di;
            break;
        case He:
            i.projection = Di;
            break;
        case pe:
            i.projection = Co;
            break
        }
        return i
    }
    static evalSpotCookieMatrix(e) {
        let t = vi._spotCookieCamera;
        t || (t = vi.create("SpotCookieCamera", He),
        vi._spotCookieCamera = t),
        t.fov = e._outerConeAngle * 2;
        const s = t._node;
        s.setPosition(e._node.getPosition()),
        s.setRotation(e._node.getRotation()),
        s.rotateLocal(-90, 0, 0),
        r0.setTRS(s.getPosition(), s.getRotation(), y.ONE).invert(),
        a0.mul2(t.projectionMatrix, r0);
        const i = e.cookieMatrix
          , n = e.atlasViewport;
        return o0.setViewport(n.x, n.y, n.z, n.w),
        i.mul2(o0, a0),
        i
    }
}
vi.pointLightRotations = [new ne().setFromEulerAngles(0, 90, 180), new ne().setFromEulerAngles(0, -90, 180), new ne().setFromEulerAngles(90, 0, 0), new ne().setFromEulerAngles(-90, 0, 0), new ne().setFromEulerAngles(0, 180, 180), new ne().setFromEulerAngles(0, 0, 180)];
vi._spotCookieCamera = null;
const yl = 1e-6
  , kt = new y
  , Pr = new Float32Array(6)
  , VR = new y(-.5,0,0)
  , GR = new y(0,0,.5)
  , ys = {
    FLAGS: 0,
    COLOR_A: 1,
    COLOR_B: 2,
    SPOT_ANGLES: 3,
    SHADOW_BIAS: 4,
    COOKIE_A: 5,
    COOKIE_B: 6,
    COUNT_ALWAYS: 7,
    POSITION_X: 7,
    POSITION_Y: 8,
    POSITION_Z: 9,
    RANGE: 10,
    SPOT_DIRECTION_X: 11,
    SPOT_DIRECTION_Y: 12,
    SPOT_DIRECTION_Z: 13,
    PROJ_MAT_00: 14,
    ATLAS_VIEWPORT_A: 14,
    PROJ_MAT_01: 15,
    ATLAS_VIEWPORT_B: 15,
    PROJ_MAT_02: 16,
    PROJ_MAT_03: 17,
    PROJ_MAT_10: 18,
    PROJ_MAT_11: 19,
    PROJ_MAT_12: 20,
    PROJ_MAT_13: 21,
    PROJ_MAT_20: 22,
    PROJ_MAT_21: 23,
    PROJ_MAT_22: 24,
    PROJ_MAT_23: 25,
    PROJ_MAT_30: 26,
    PROJ_MAT_31: 27,
    PROJ_MAT_32: 28,
    PROJ_MAT_33: 29,
    AREA_DATA_WIDTH_X: 30,
    AREA_DATA_WIDTH_Y: 31,
    AREA_DATA_WIDTH_Z: 32,
    AREA_DATA_HEIGHT_X: 33,
    AREA_DATA_HEIGHT_Y: 34,
    AREA_DATA_HEIGHT_Z: 35,
    COUNT: 36
}
  , Et = {
    POSITION_RANGE: 0,
    SPOT_DIRECTION: 1,
    PROJ_MAT_0: 2,
    ATLAS_VIEWPORT: 2,
    PROJ_MAT_1: 3,
    PROJ_MAT_2: 4,
    PROJ_MAT_3: 5,
    AREA_DATA_WIDTH: 6,
    AREA_DATA_HEIGHT: 7,
    COUNT: 8
}
  , vl = 0
  , HR = 1
  , WR = new Os;
class Ih {
    static getLightTextureFormat(e) {
        return e.extTextureFloat && e.maxTextures > 8 ? vl : HR
    }
    static getShaderDefines(e) {
        return WR.get(e, () => {
            const t = (r, o, l, c) => Object.keys(o).map(d => `#define ${l}${d} ${o[d]}${c}`).join(`
`)
              , i = Ih.getLightTextureFormat(e) === vl ? "FLOAT" : "8BIT"
              , n = e.supportsTextureFetch ? "" : ".5";
            return `
								
#define CLUSTER_TEXTURE_${i}
								${t(e, ys, "CLUSTER_TEXTURE_8_", n)}
								${t(e, Et, "CLUSTER_TEXTURE_F_", n)}
						`
        }
        )
    }
    constructor(e) {
        this.device = e,
        this.cookiesEnabled = !1,
        this.shadowsEnabled = !1,
        this.areaLightsEnabled = !1,
        this.maxLights = 255;
        let t = ys.COUNT_ALWAYS
          , s = 0;
        this.lightTextureFormat = Ih.getLightTextureFormat(e),
        this.lightTextureFormat === vl ? s = Et.COUNT : t = ys.COUNT,
        this.lights8 = new Uint8ClampedArray(4 * t * this.maxLights),
        this.lightsTexture8 = this.createTexture(this.device, t, this.maxLights, ve, "LightsTexture8"),
        this._lightsTexture8Id = this.device.scope.resolve("lightsTexture8"),
        s ? (this.lightsFloat = new Float32Array(4 * s * this.maxLights),
        this.lightsTextureFloat = this.createTexture(this.device, s, this.maxLights, lt, "LightsTextureFloat"),
        this._lightsTextureFloatId = this.device.scope.resolve("lightsTextureFloat")) : (this.lightsFloat = null,
        this.lightsTextureFloat = null,
        this._lightsTextureFloatId = void 0),
        this._lightsTextureInvSizeId = this.device.scope.resolve("lightsTextureInvSize"),
        this._lightsTextureInvSizeData = new Float32Array(4),
        this._lightsTextureInvSizeData[0] = s ? 1 / this.lightsTextureFloat.width : 0,
        this._lightsTextureInvSizeData[1] = s ? 1 / this.lightsTextureFloat.height : 0,
        this._lightsTextureInvSizeData[2] = 1 / this.lightsTexture8.width,
        this._lightsTextureInvSizeData[3] = 1 / this.lightsTexture8.height,
        this.invMaxColorValue = 0,
        this.invMaxAttenuation = 0,
        this.boundsMin = new y,
        this.boundsDelta = new y
    }
    destroy() {
        this.lightsTexture8 && (this.lightsTexture8.destroy(),
        this.lightsTexture8 = null),
        this.lightsTextureFloat && (this.lightsTextureFloat.destroy(),
        this.lightsTextureFloat = null)
    }
    createTexture(e, t, s, i, n) {
        return new ge(e,{
            name: n,
            width: t,
            height: s,
            mipmaps: !1,
            format: i,
            addressU: oe,
            addressV: oe,
            type: $s,
            magFilter: be,
            minFilter: be,
            anisotropy: 1
        })
    }
    setCompressionRanges(e, t) {
        this.invMaxColorValue = 1 / t,
        this.invMaxAttenuation = 1 / e
    }
    setBounds(e, t) {
        this.boundsMin.copy(e),
        this.boundsDelta.copy(t)
    }
    uploadTextures() {
        this.lightsTextureFloat && (this.lightsTextureFloat.lock().set(this.lightsFloat),
        this.lightsTextureFloat.unlock()),
        this.lightsTexture8.lock().set(this.lights8),
        this.lightsTexture8.unlock()
    }
    updateUniforms() {
        this._lightsTexture8Id.setValue(this.lightsTexture8),
        this.lightTextureFormat === vl && this._lightsTextureFloatId.setValue(this.lightsTextureFloat),
        this._lightsTextureInvSizeId.setValue(this._lightsTextureInvSizeData)
    }
    getSpotDirection(e, t) {
        t._node.getWorldTransform().getY(e).mulScalar(-1),
        e.normalize()
    }
    getLightAreaSizes(e) {
        const t = e._node.getWorldTransform();
        return t.transformVector(VR, kt),
        Pr[0] = kt.x,
        Pr[1] = kt.y,
        Pr[2] = kt.z,
        t.transformVector(GR, kt),
        Pr[3] = kt.x,
        Pr[4] = kt.y,
        Pr[5] = kt.z,
        Pr
    }
    addLightDataFlags(e, t, s, i, n, r) {
        e[t + 0] = i ? 255 : 0,
        e[t + 1] = s._shape * 64,
        e[t + 2] = s._falloffMode * 255,
        e[t + 3] = n ? r * 255 : 0
    }
    addLightDataColor(e, t, s, i, n) {
        const r = this.invMaxColorValue
          , o = i ? s._linearFinalColor : s._finalColor;
        Ge.float2Bytes(o[0] * r, e, t + 0, 2),
        Ge.float2Bytes(o[1] * r, e, t + 2, 2),
        Ge.float2Bytes(o[2] * r, e, t + 4, 2),
        e[t + 6] = n ? 255 : 0;
        const l = !!(s.mask & Rs)
          , c = !!(s.mask & Ui);
        e[t + 7] = l && c ? 127 : c ? 255 : 0
    }
    addLightDataSpotAngles(e, t, s) {
        Ge.float2Bytes(s._innerConeAngleCos * (.5 - yl) + .5, e, t + 0, 2),
        Ge.float2Bytes(s._outerConeAngleCos * (.5 - yl) + .5, e, t + 2, 2)
    }
    addLightDataShadowBias(e, t, s) {
        const i = s.getRenderData(null, 0)
          , n = s._getUniformBiasValues(i);
        Ge.float2BytesRange(n.bias, e, t, -1, 20, 2),
        Ge.float2Bytes(n.normalBias, e, t + 2, 2)
    }
    addLightDataPositionRange(e, t, s, i) {
        const n = kt.sub2(i, this.boundsMin).div(this.boundsDelta);
        Ge.float2Bytes(n.x, e, t + 0, 4),
        Ge.float2Bytes(n.y, e, t + 4, 4),
        Ge.float2Bytes(n.z, e, t + 8, 4),
        Ge.float2Bytes(s.attenuationEnd * this.invMaxAttenuation, e, t + 12, 4)
    }
    addLightDataSpotDirection(e, t, s) {
        this.getSpotDirection(kt, s),
        Ge.float2Bytes(kt.x * (.5 - yl) + .5, e, t + 0, 4),
        Ge.float2Bytes(kt.y * (.5 - yl) + .5, e, t + 4, 4),
        Ge.float2Bytes(kt.z * (.5 - yl) + .5, e, t + 8, 4)
    }
    addLightDataLightProjMatrix(e, t, s) {
        const i = s.data;
        for (let n = 0; n < 12; n++)
            Ge.float2BytesRange(i[n], e, t + 4 * n, -2, 2, 4);
        for (let n = 12; n < 16; n++)
            Ge.float2MantissaExponent(i[n], e, t + 4 * n, 4)
    }
    addLightDataCookies(e, t, s) {
        const i = s._cookieChannel === "rgb";
        if (e[t + 0] = Math.floor(s.cookieIntensity * 255),
        e[t + 1] = i ? 255 : 0,
        !i) {
            const n = s._cookieChannel;
            e[t + 4] = n === "rrr" ? 255 : 0,
            e[t + 5] = n === "ggg" ? 255 : 0,
            e[t + 6] = n === "bbb" ? 255 : 0,
            e[t + 7] = n === "aaa" ? 255 : 0
        }
    }
    addLightAtlasViewport(e, t, s) {
        Ge.float2Bytes(s.x, e, t + 0, 2),
        Ge.float2Bytes(s.y, e, t + 2, 2),
        Ge.float2Bytes(s.z / 3, e, t + 4, 2)
    }
    addLightAreaSizes(e, t, s) {
        const i = this.getLightAreaSizes(s);
        for (let n = 0; n < 6; n++)
            Ge.float2MantissaExponent(i[n], e, t + 4 * n, 4)
    }
    addLightData(e, t, s) {
        const i = e._type === He
          , n = e.atlasViewportAllocated
          , r = this.cookiesEnabled && !!e._cookie && n
          , o = this.areaLightsEnabled && e.shape !== Nt
          , l = this.shadowsEnabled && e.castShadows && n
          , c = e._node.getPosition();
        let d = null
          , h = null;
        i ? l ? d = e.getRenderData(null, 0).shadowMatrix : r && (d = vi.evalSpotCookieMatrix(e)) : (l || r) && (h = e.atlasViewport);
        const u = this.lights8
          , f = t * this.lightsTexture8.width * 4;
        if (this.addLightDataFlags(u, f + 4 * ys.FLAGS, e, i, l, e.shadowIntensity),
        this.addLightDataColor(u, f + 4 * ys.COLOR_A, e, s, r),
        i && this.addLightDataSpotAngles(u, f + 4 * ys.SPOT_ANGLES, e),
        e.castShadows && this.addLightDataShadowBias(u, f + 4 * ys.SHADOW_BIAS, e),
        r && this.addLightDataCookies(u, f + 4 * ys.COOKIE_A, e),
        this.lightTextureFormat === vl) {
            const p = this.lightsFloat
              , _ = t * this.lightsTextureFloat.width * 4;
            if (p[_ + 4 * Et.POSITION_RANGE + 0] = c.x,
            p[_ + 4 * Et.POSITION_RANGE + 1] = c.y,
            p[_ + 4 * Et.POSITION_RANGE + 2] = c.z,
            p[_ + 4 * Et.POSITION_RANGE + 3] = e.attenuationEnd,
            i && (this.getSpotDirection(kt, e),
            p[_ + 4 * Et.SPOT_DIRECTION + 0] = kt.x,
            p[_ + 4 * Et.SPOT_DIRECTION + 1] = kt.y,
            p[_ + 4 * Et.SPOT_DIRECTION + 2] = kt.z),
            d) {
                const m = d.data;
                for (let g = 0; g < 16; g++)
                    p[_ + 4 * Et.PROJ_MAT_0 + g] = m[g]
            }
            if (h && (p[_ + 4 * Et.ATLAS_VIEWPORT + 0] = h.x,
            p[_ + 4 * Et.ATLAS_VIEWPORT + 1] = h.y,
            p[_ + 4 * Et.ATLAS_VIEWPORT + 2] = h.z / 3),
            o) {
                const m = this.getLightAreaSizes(e);
                p[_ + 4 * Et.AREA_DATA_WIDTH + 0] = m[0],
                p[_ + 4 * Et.AREA_DATA_WIDTH + 1] = m[1],
                p[_ + 4 * Et.AREA_DATA_WIDTH + 2] = m[2],
                p[_ + 4 * Et.AREA_DATA_HEIGHT + 0] = m[3],
                p[_ + 4 * Et.AREA_DATA_HEIGHT + 1] = m[4],
                p[_ + 4 * Et.AREA_DATA_HEIGHT + 2] = m[5]
            }
        } else
            this.addLightDataPositionRange(u, f + 4 * ys.POSITION_X, e, c),
            i && this.addLightDataSpotDirection(u, f + 4 * ys.SPOT_DIRECTION_X, e),
            d && this.addLightDataLightProjMatrix(u, f + 4 * ys.PROJ_MAT_00, d),
            h && this.addLightAtlasViewport(u, f + 4 * ys.ATLAS_VIEWPORT_A, h),
            o && this.addLightAreaSizes(u, f + 4 * ys.AREA_DATA_WIDTH_X, e)
    }
}
const tp = {
    vertex_normal: Is,
    vertex_tangent: Qi,
    vertex_texCoord0: Ls,
    vertex_texCoord1: xr,
    vertex_color: jt,
    vertex_boneWeights: Ji,
    vertex_boneIndices: Ps
}
  , l0 = {
    vVertexColor: "vec4",
    vPositionW: "vec3",
    vNormalV: "vec3",
    vNormalW: "vec3",
    vTangentW: "vec3",
    vBinormalW: "vec3",
    vObjectSpaceUpW: "vec3",
    vUv0: "vec2",
    vUv1: "vec2"
};
class XR {
    constructor(e, t) {
        if (this.device = e,
        this.options = t,
        this.attributes = {
            vertex_position: ut
        },
        t.userAttributes)
            for (const [s,i] of Object.entries(t.userAttributes))
                this.attributes[i] = s;
        if (t.chunks) {
            const s = t.chunks;
            this.chunks = Object.create($);
            for (const i in $)
                if (s.hasOwnProperty(i)) {
                    const n = s[i];
                    for (const r in tp)
                        tp.hasOwnProperty(r) && n.indexOf(r) >= 0 && (this.attributes[r] = tp[r]);
                    this.chunks[i] = n
                }
        } else
            this.chunks = $;
        this.shaderPassInfo = wi.get(this.device).getByIndex(t.pass),
        this.shadowPass = this.shaderPassInfo.isShadow,
        this.lighting = t.lights.length > 0 || t.dirLightMapEnabled || t.clusteredLightingEnabled,
        this.reflections = !!t.reflectionSource,
        this.needsNormal = this.lighting || this.reflections || t.useSpecular || t.ambientSH || t.useHeights || t.enableGGXSpecular || t.clusteredLightingEnabled && !this.shadowPass || t.useClearCoatNormals,
        this.needsNormal = this.needsNormal && !this.shadowPass,
        this.needsSceneColor = t.useDynamicRefraction,
        this.needsScreenSize = t.useDynamicRefraction,
        this.needsTransforms = t.useDynamicRefraction,
        this.varyings = "",
        this.varyingDefines = "",
        this.vshader = null,
        this.frontendDecl = null,
        this.frontendCode = null,
        this.frontendFunc = null,
        this.lightingUv = null,
        this.defines = [],
        this.fshader = null
    }
    _vsAddBaseCode(e, t, s) {
        return e += t.baseVS,
        (s.nineSlicedMode === xt || s.nineSlicedMode === _t) && (e += t.baseNineSlicedVS),
        e
    }
    _vsAddTransformCode(e, t, s, i) {
        return e += this.chunks.transformVS,
        e
    }
    _setMapTransform(e, t, s, i) {
        const n = s + i * 100;
        if (!e[3][n]) {
            const r = `texture_${t}MapTransform`;
            e[0] += `uniform vec3 ${r}0;
`,
            e[0] += `uniform vec3 ${r}1;
`,
            e[1] += `varying vec2 vUV${i}_${s};
`,
            e[2] += `   vUV${i}_${s} = vec2(dot(vec3(uv${i}, 1), ${r}0), dot(vec3(uv${i}, 1), ${r}1));
`,
            e[3][n] = !0
        }
        return e
    }
    _fsGetBaseCode() {
        const e = this.options
          , t = this.chunks;
        let s = this.chunks.basePS;
        return e.nineSlicedMode === xt ? s += t.baseNineSlicedPS : e.nineSlicedMode === _t && (s += t.baseNineSlicedTiledPS),
        s
    }
    _fsGetStartCode(e, t, s, i) {
        let n = s.startPS;
        return i.nineSlicedMode === xt ? n += s.startNineSlicedPS : i.nineSlicedMode === _t && (n += s.startNineSlicedTiledPS),
        n
    }
    _getLightSourceShapeString(e) {
        switch (e) {
        case eA:
            return "Rect";
        case tA:
            return "Disk";
        case sA:
            return "Sphere";
        default:
            return ""
        }
    }
    generateVertexShader(e, t, s) {
        const i = this.device
          , n = this.options
          , r = this.chunks;
        let o = ""
          , l = "";
        o = this._vsAddBaseCode(o, r, n),
        l += `   vPositionW    = getWorldPosition();
`,
        this.options.pass === Vi && (o += `varying float vDepth;
`,
        o += `#ifndef VIEWMATRIX
`,
        o += `#define VIEWMATRIX
`,
        o += `uniform mat4 matrix_view;
`,
        o += `#endif
`,
        o += `#ifndef CAMERAPLANES
`,
        o += `#define CAMERAPLANES
`,
        o += `uniform vec4 camera_params;

`,
        o += `#endif
`,
        l += `    vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;
`),
        this.options.useInstancing && (this.attributes.instance_line1 = Ql,
        this.attributes.instance_line2 = ea,
        this.attributes.instance_line3 = Jl,
        this.attributes.instance_line4 = $r,
        o += r.instancingVS),
        this.needsNormal && (this.attributes.vertex_normal = Is,
        l += `   vNormalW = getNormal();
`,
        n.reflectionSource === "sphereMap" && i.fragmentUniformsCount <= 16 && (o += r.viewNormalVS,
        l += `   vNormalV    = getViewNormal();
`),
        n.hasTangents && (n.useHeights || n.useNormals || n.enableGGXSpecular) ? (this.attributes.vertex_tangent = Qi,
        o += r.tangentBinormalVS,
        l += `   vTangentW   = getTangent();
`,
        l += `   vBinormalW  = getBinormal();
`) : (n.enableGGXSpecular || !i.extStandardDerivatives) && (l += `   vObjectSpaceUpW = normalize(dNormalMatrix * vec3(0, 1, 0));
`));
        const c = 2;
        for (let u = 0; u < c; u++)
            e[u] && (this.attributes["vertex_texCoord" + u] = "TEXCOORD" + u,
            o += r["uv" + u + "VS"],
            l += "   vec2 uv" + u + " = getUv" + u + `();
`),
            t[u] && (l += "   vUv" + u + " = uv" + u + `;
`);
        const d = [o, this.varyings, l, []];
        if (s.forEach(u => {
            this._setMapTransform(d, u.name, u.id, u.uv)
        }
        ),
        o = d[0],
        this.varyings = d[1],
        l = d[2],
        n.vertexColors && (this.attributes.vertex_color = jt,
        l += `   vVertexColor = vertex_color;
`),
        n.useMsdf && n.msdfTextAttribute && (this.attributes.vertex_outlineParameters = Qr,
        this.attributes.vertex_shadowParameters = Jr,
        l += `    unpackMsdfParams();
`,
        o += r.msdfVS),
        n.useMorphPosition || n.useMorphNormal)
            if (n.useMorphTextureBased) {
                o += `#define MORPHING_TEXTURE_BASED
`,
                n.useMorphPosition && (o += `#define MORPHING_TEXTURE_BASED_POSITION
`),
                n.useMorphNormal && (o += `#define MORPHING_TEXTURE_BASED_NORMAL
`),
                this.attributes.morph_vertex_id = $r;
                const u = i.isWebGPU ? "uint" : "float";
                o += `attribute ${u} morph_vertex_id;
`
            } else
                o += `#define MORPHING
`,
                n.useMorphPosition ? (this.attributes.morph_pos0 = Qr,
                this.attributes.morph_pos1 = Jr,
                this.attributes.morph_pos2 = pm,
                this.attributes.morph_pos3 = mm,
                o += `#define MORPHING_POS03
`,
                o += `attribute vec3 morph_pos0;
`,
                o += `attribute vec3 morph_pos1;
`,
                o += `attribute vec3 morph_pos2;
`,
                o += `attribute vec3 morph_pos3;
`) : n.useMorphNormal && (this.attributes.morph_nrm0 = Qr,
                this.attributes.morph_nrm1 = Jr,
                this.attributes.morph_nrm2 = pm,
                this.attributes.morph_nrm3 = mm,
                o += `#define MORPHING_NRM03
`,
                o += `attribute vec3 morph_nrm0;
`,
                o += `attribute vec3 morph_nrm1;
`,
                o += `attribute vec3 morph_nrm2;
`,
                o += `attribute vec3 morph_nrm3;
`),
                n.useMorphNormal ? (this.attributes.morph_nrm4 = Ql,
                this.attributes.morph_nrm5 = ea,
                this.attributes.morph_nrm6 = Jl,
                this.attributes.morph_nrm7 = $r,
                o += `#define MORPHING_NRM47
`,
                o += `attribute vec3 morph_nrm4;
`,
                o += `attribute vec3 morph_nrm5;
`,
                o += `attribute vec3 morph_nrm6;
`,
                o += `attribute vec3 morph_nrm7;
`) : (this.attributes.morph_pos4 = Ql,
                this.attributes.morph_pos5 = ea,
                this.attributes.morph_pos6 = Jl,
                this.attributes.morph_pos7 = $r,
                o += `#define MORPHING_POS47
`,
                o += `attribute vec3 morph_pos4;
`,
                o += `attribute vec3 morph_pos5;
`,
                o += `attribute vec3 morph_pos6;
`,
                o += `attribute vec3 morph_pos7;
`);
        n.skin ? (this.attributes.vertex_boneWeights = Ji,
        this.attributes.vertex_boneIndices = Ps,
        o += Ue.skinCode(i, r),
        o += `#define SKIN
`) : n.useInstancing && (o += `#define INSTANCING
`),
        n.screenSpace && (o += `#define SCREENSPACE
`),
        n.pixelSnap && (o += `#define PIXELSNAP
`),
        o = this._vsAddTransformCode(o, i, r, n),
        this.needsNormal && (o += r.normalVS),
        o += `
`,
        o += r.startVS,
        o += l,
        o += r.endVS,
        o += "}",
        Object.keys(l0).forEach(u => {
            o.indexOf(u) >= 0 && (this.varyings += `varying ${l0[u]} ${u};
`,
            this.varyingDefines += `#define VARYING_${u.toUpperCase()}
`)
        }
        );
        const h = this.shaderPassInfo.shaderDefines;
        this.vshader = h + this.varyings + o
    }
    _fsGetBeginCode() {
        let e = this.shaderPassInfo.shaderDefines;
        for (let t = 0; t < this.defines.length; t++)
            e += `#define ${this.defines[t]}
`;
        return e
    }
    _fsGetPickPassCode() {
        let e = this._fsGetBeginCode();
        return e += `uniform vec4 uColor;
`,
        e += this.varyings,
        e += this.varyingDefines,
        e += this.frontendDecl,
        e += this.frontendCode,
        e += Ue.begin(),
        e += this.frontendFunc,
        e += `    gl_FragColor = uColor;
`,
        e += Ue.end(),
        e
    }
    _fsGetDepthPassCode() {
        const e = this.chunks;
        let t = this._fsGetBeginCode();
        return t += `varying float vDepth;
`,
        t += this.varyings,
        t += this.varyingDefines,
        t += e.packDepthPS,
        t += this.frontendDecl,
        t += this.frontendCode,
        t += Ue.begin(),
        t += this.frontendFunc,
        t += `    gl_FragColor = packFloat(vDepth);
`,
        t += Ue.end(),
        t
    }
    _fsGetShadowPassCode() {
        const e = this.device
          , t = this.options
          , s = this.chunks
          , i = this.varyings
          , n = this.shaderPassInfo.lightType;
        let r = this.shaderPassInfo.shadowType;
        n !== pe && t.clusteredLightingEnabled && (r === zs || r === pi || r === Hs || r === Kt) && (r = St);
        let o = this._fsGetBeginCode();
        e.extStandardDerivatives && e.isWebGL1 && (o += `uniform vec2 polygonOffset;
`),
        r === Hs ? e.textureFloatHighPrecision ? o += `#define VSM_EXPONENT 15.0

` : o += `#define VSM_EXPONENT 5.54

` : r === pi && (o += `#define VSM_EXPONENT 5.54

`),
        n !== pe && (o += `uniform vec3 view_position;
`,
        o += `uniform float light_radius;
`),
        o += i,
        o += this.varyingDefines,
        o += this.frontendDecl,
        o += this.frontendCode;
        const l = r === Ni || r === St || r === gi || r === Kt
          , c = n === Oe && r !== Kt && !t.clusteredLightingEnabled
          , d = l && !e.supportsDepthShadow || c;
        d ? o += s.packDepthPS : r === zs && (o += `vec2 encodeFloatRG( float v ) {
`,
        o += `    vec2 enc = vec2(1.0, 255.0) * v;
`,
        o += `    enc = fract(enc);
`,
        o += `    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);
`,
        o += `    return enc;
`,
        o += `}

`),
        r === Kt && (o += $.linearizeDepthPS),
        o += Ue.begin(),
        o += this.frontendFunc;
        const h = r === zs || r === pi || r === Hs
          , u = e.isWebGL1 && e.extStandardDerivatives
          , f = n === pe || !h && n === He;
        let p = !1;
        return f ? o += `    float depth = gl_FragCoord.z;
` : (o += `    float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);
`,
        p = !0),
        u && (o += `    float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);
`,
        o += `    depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;
`,
        p = !0),
        d ? o += `    gl_FragColor = packFloat(depth);
` : h ? r === zs ? o += `    gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));
` : o += s.storeEVSMPS : r === Kt ? o += `    gl_FragColor.r = depth;
` : (p && (o += `    gl_FragDepth = depth;
`),
        o += `    gl_FragColor = vec4(1.0);
`),
        o += Ue.end(),
        o
    }
    _fsGetLitPassCode() {
        const e = this.device
          , t = this.options
          , s = this.chunks
          , i = new rr
          , n = new rr
          , r = new rr
          , o = new rr;
        t.opacityFadesSpecular === !1 && i.append("uniform float material_alphaFade;"),
        t.useSpecular && (this.defines.push("LIT_SPECULAR"),
        this.reflections && this.defines.push("LIT_REFLECTIONS"),
        t.useClearCoat && this.defines.push("LIT_CLEARCOAT"),
        t.fresnelModel > 0 && this.defines.push("LIT_SPECULAR_FRESNEL"),
        t.conserveEnergy && this.defines.push("LIT_CONSERVE_ENERGY"),
        t.useSheen && this.defines.push("LIT_SHEEN"),
        t.useIridescence && this.defines.push("LIT_IRIDESCENCE"));
        const l = [];
        let c = 0
          , d = !1
          , h = !1
          , u = !1
          , f = t.lights.some(function(I) {
            return I._shape && I._shape !== Nt
        });
        t.clusteredLightingEnabled && t.clusteredLightingAreaLightsEnabled && (f = !0);
        let p = "highp";
        e.areaLightLutFormat === ve && (i.append("#define AREA_R8_G8_B8_A8_LUTS"),
        p = "lowp"),
        (f || t.clusteredLightingEnabled) && (i.append("#define AREA_LIGHTS"),
        i.append(`uniform ${p} sampler2D areaLightsLutTex1;`),
        i.append(`uniform ${p} sampler2D areaLightsLutTex2;`));
        for (let I = 0; I < t.lights.length; I++) {
            const O = t.lights[I]
              , D = O._type;
            if (t.clusteredLightingEnabled && D !== pe)
                continue;
            const A = f && O._shape ? O._shape : Nt;
            i.append("uniform vec3 light" + I + "_color;"),
            O._shadowType === Kt && O.castShadows && !t.noShadow && (i.append(`uniform float light${I}_shadowSearchArea;`),
            i.append(`uniform vec4 light${I}_cameraParams;`)),
            D === pe ? i.append("uniform vec3 light" + I + "_direction;") : (i.append("uniform vec3 light" + I + "_position;"),
            i.append("uniform float light" + I + "_radius;"),
            D === He && (i.append("uniform vec3 light" + I + "_direction;"),
            i.append("uniform float light" + I + "_innerConeAngle;"),
            i.append("uniform float light" + I + "_outerConeAngle;"))),
            A !== Nt && (D === pe && i.append("uniform vec3 light" + I + "_position;"),
            i.append("uniform vec3 light" + I + "_halfWidth;"),
            i.append("uniform vec3 light" + I + "_halfHeight;")),
            O.castShadows && !t.noShadow && (i.append("uniform mat4 light" + I + "_shadowMatrix;"),
            i.append("uniform float light" + I + "_shadowIntensity;"),
            D === pe && (i.append("uniform mat4 light" + I + "_shadowMatrixPalette[4];"),
            i.append("uniform float light" + I + "_shadowCascadeDistances[4];"),
            i.append("uniform float light" + I + "_shadowCascadeCount;")),
            i.append("uniform vec4 light" + I + "_shadowParams;"),
            D === pe && (d = !0),
            D === Oe ? i.append("uniform samplerCube light" + I + "_shadowMap;") : O._isPcf && e.supportsDepthShadow ? i.append("uniform sampler2DShadow light" + I + "_shadowMap;") : i.append("uniform sampler2D light" + I + "_shadowMap;"),
            c++,
            l[O._shadowType] = !0,
            O._isVsm && (h = !0),
            O._shadowType === Kt && (u = !0)),
            O._cookie && (O._cookie._cubemap ? D === Oe && (i.append("uniform samplerCube light" + I + "_cookie;"),
            i.append("uniform float light" + I + "_cookieIntensity;"),
            (!O.castShadows || t.noShadow) && i.append("uniform mat4 light" + I + "_shadowMatrix;")) : D === He && (i.append("uniform sampler2D light" + I + "_cookie;"),
            i.append("uniform float light" + I + "_cookieIntensity;"),
            (!O.castShadows || t.noShadow) && i.append("uniform mat4 light" + I + "_shadowMatrix;"),
            O._cookieTransform && (i.append("uniform vec4 light" + I + "_cookieMatrix;"),
            i.append("uniform vec2 light" + I + "_cookieOffset;"))))
        }
        const _ = this.needsNormal && (t.useNormals || t.useClearCoatNormals || t.enableGGXSpecular && !t.useHeights);
        if (_ && (t.hasTangents ? n.append(t.fastTbn ? s.TBNfastPS : s.TBNPS) : e.extStandardDerivatives && (t.useNormals || t.useClearCoatNormals) ? n.append(s.TBNderivativePS.replace(/\$UV/g, this.lightingUv)) : n.append(s.TBNObjectSpacePS)),
        n.append(s.sphericalPS),
        n.append(s.decodePS),
        n.append(Ue.gammaCode(t.gamma, s)),
        n.append(Ue.tonemapCode(t.toneMap, s)),
        n.append(Ue.fogCode(t.fog, s)),
        n.append(this.frontendCode),
        t.useCubeMapRotation && i.append("#define CUBEMAP_ROTATION"),
        this.needsNormal && (n.append(s.cubeMapRotatePS),
        n.append(t.cubeMapProjection > 0 ? s.cubeMapProjectBoxPS : s.cubeMapProjectNonePS),
        n.append(t.skyboxIntensity ? s.envMultiplyPS : s.envConstPS)),
        (this.lighting && t.useSpecular || this.reflections) && (t.useMetalness && n.append(s.metalnessModulatePS),
        t.fresnelModel === W_ && n.append(s.fresnelSchlickPS),
        t.useIridescence && n.append(s.iridescenceDiffractionPS)),
        t.useAo)
            switch (n.append(s.aoDiffuseOccPS),
            t.occludeSpecular) {
            case Th:
                n.append(t.occludeSpecularFloat ? s.aoSpecOccSimplePS : s.aoSpecOccConstSimplePS);
                break;
            case Cm:
                n.append(t.occludeSpecularFloat ? s.aoSpecOccPS : s.aoSpecOccConstPS);
                break
            }
        t.reflectionSource === "envAtlasHQ" ? (n.append(t.fixSeams ? s.fixCubemapSeamsStretchPS : s.fixCubemapSeamsNonePS),
        n.append(s.envAtlasPS),
        n.append(s.reflectionEnvHQPS.replace(/\$DECODE_CUBEMAP/g, mi.decodeFunc(t.reflectionCubemapEncoding)).replace(/\$DECODE/g, mi.decodeFunc(t.reflectionEncoding)))) : t.reflectionSource === "envAtlas" ? (n.append(s.envAtlasPS),
        n.append(s.reflectionEnvPS.replace(/\$DECODE/g, mi.decodeFunc(t.reflectionEncoding)))) : t.reflectionSource === "cubeMap" ? (n.append(t.fixSeams ? s.fixCubemapSeamsStretchPS : s.fixCubemapSeamsNonePS),
        n.append(s.reflectionCubePS.replace(/\$DECODE/g, mi.decodeFunc(t.reflectionEncoding)))) : t.reflectionSource === "sphereMap" && n.append(s.reflectionSpherePS.replace(/\$DECODE/g, mi.decodeFunc(t.reflectionEncoding))),
        this.reflections && (t.useClearCoat && n.append(s.reflectionCCPS),
        t.useSheen && n.append(s.reflectionSheenPS)),
        t.useRefraction && (t.useDynamicRefraction ? n.append(s.refractionDynamicPS) : this.reflections && n.append(s.refractionCubePS)),
        t.useSheen && n.append(s.lightSheenPS),
        t.clusteredLightingEnabled && (n.append(s.clusteredLightUtilsPS),
        t.clusteredLightingCookiesEnabled && n.append(s.clusteredLightCookiesPS),
        t.clusteredLightingShadowsEnabled && !t.noShadow && (l[St] = !0,
        l[gi] = !0,
        l[Kt] = !0)),
        (c > 0 || t.clusteredLightingEnabled) && (d && n.append(s.shadowCascadesPS),
        (l[Ni] || l[St]) && n.append(s.shadowStandardPS),
        l[gi] && !e.isWebGL1 && n.append(s.shadowStandardGL2PS),
        h && (n.append(s.shadowVSM_commonPS),
        l[zs] && n.append(s.shadowVSM8PS),
        l[pi] && n.append(e.extTextureHalfFloatLinear ? s.shadowEVSMPS.replace(/\$/g, "16") : s.shadowEVSMnPS.replace(/\$/g, "16")),
        l[Hs] && n.append(e.extTextureFloatLinear ? s.shadowEVSMPS.replace(/\$/g, "32") : s.shadowEVSMnPS.replace(/\$/g, "32"))),
        u && (n.append(s.linearizeDepthPS),
        n.append(s.shadowPCSSPS)),
        e.isWebGL2 || e.isWebGPU || e.extStandardDerivatives || n.append(s.biasConstPS)),
        t.enableGGXSpecular && n.append("uniform float material_anisotropy;"),
        this.lighting && (n.append(s.lightDiffuseLambertPS),
        (f || t.clusteredLightingAreaLightsEnabled) && n.append(s.ltcPS));
        let m = !1;
        t.useSpecular && (this.lighting && n.append(t.shadingModel === ji ? s.lightSpecularPhongPS : t.enableGGXSpecular ? s.lightSpecularAnisoGGXPS : s.lightSpecularBlinnPS),
        !t.fresnelModel && !this.reflections && !t.diffuseMapEnabled && (i.append("uniform vec3 material_ambient;"),
        i.append("#define LIT_OLD_AMBIENT"),
        m = !0)),
        n.append(s.combinePS),
        t.lightMapEnabled && n.append(t.useSpecular && t.dirLightMapEnabled ? s.lightmapDirAddPS : s.lightmapAddPS);
        const g = !t.lightMapEnabled || t.lightMapWithoutAmbient;
        g && (t.ambientSource === "ambientSH" ? n.append(s.ambientSHPS) : t.ambientSource === "envAtlas" ? (t.reflectionSource !== "envAtlas" && t.reflectionSource !== "envAtlasHQ" && n.append(s.envAtlasPS),
        n.append(s.ambientEnvPS.replace(/\$DECODE/g, mi.decodeFunc(t.ambientEncoding)))) : n.append(s.ambientConstantPS)),
        t.useAmbientTint && !m && i.append("uniform vec3 material_ambient;"),
        t.useMsdf && (t.msdfTextAttribute || i.append("#define UNIFORM_TEXT_PARAMETERS"),
        n.append(s.msdfPS)),
        this.needsNormal && (n.append(s.viewDirPS),
        t.useSpecular && n.append(t.enableGGXSpecular ? s.reflDirAnisoPS : s.reflDirPS));
        let v = !1, x = !1, S = !1, w = !1, T = !1, b;
        if (t.clusteredLightingEnabled && this.lighting && (w = !0,
        v = !0,
        x = !0,
        T = !0,
        n.append(s.floatUnpackingPS),
        t.lightMaskDynamic && i.append("#define CLUSTER_MESH_DYNAMIC_LIGHTS"),
        t.clusteredLightingCookiesEnabled && i.append("#define CLUSTER_COOKIES"),
        t.clusteredLightingShadowsEnabled && !t.noShadow && (i.append("#define CLUSTER_SHADOWS"),
        i.append("#define CLUSTER_SHADOW_TYPE_" + Tr[t.clusteredLightingShadowType])),
        t.clusteredLightingAreaLightsEnabled && i.append("#define CLUSTER_AREALIGHTS"),
        i.append(Ih.getShaderDefines(e)),
        t.clusteredLightingShadowsEnabled && !t.noShadow && n.append(s.clusteredLightShadowsPS),
        n.append(s.clusteredLightPS)),
        t.twoSidedLighting && i.append("uniform float twoSidedLightingNegScaleFactor;"),
        o.append(this._fsGetStartCode(o, e, s, t)),
        this.needsNormal && (t.twoSidedLighting ? o.append("    dVertexNormalW = normalize(gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor);") : o.append("    dVertexNormalW = normalize(vNormalW);"),
        (t.useHeights || t.useNormals) && t.hasTangents && (t.twoSidedLighting ? (o.append("    dTangentW = gl_FrontFacing ? vTangentW * twoSidedLightingNegScaleFactor : -vTangentW * twoSidedLightingNegScaleFactor;"),
        o.append("    dBinormalW = gl_FrontFacing ? vBinormalW * twoSidedLightingNegScaleFactor : -vBinormalW * twoSidedLightingNegScaleFactor;")) : (o.append("    dTangentW = vTangentW;"),
        o.append("    dBinormalW = vBinormalW;"))),
        o.append("    getViewDir();"),
        _ && o.append("    getTBN(dTangentW, dBinormalW, dVertexNormalW);")),
        o.append(this.frontendFunc),
        this.needsNormal && (t.useSpecular && r.append("    getReflDir(litArgs_worldNormal, dViewDirW, litArgs_gloss, dTBN);"),
        t.useClearCoat && r.append("    ccReflDirW = normalize(-reflect(dViewDirW, litArgs_clearcoat_worldNormal));")),
        (this.lighting && t.useSpecular || this.reflections) && (t.useMetalness && (r.append("    float f0 = 1.0 / litArgs_ior; f0 = (f0 - 1.0) / (f0 + 1.0); f0 *= f0;"),
        r.append("    litArgs_specularity = getSpecularModulate(litArgs_specularity, litArgs_albedo, litArgs_metalness, f0);"),
        r.append("    litArgs_albedo = getAlbedoModulate(litArgs_albedo, litArgs_metalness);")),
        t.useIridescence && r.append("    vec3 iridescenceFresnel = getIridescence(saturate(dot(dViewDirW, litArgs_worldNormal)), litArgs_specularity, litArgs_iridescence_thickness);")),
        g && (r.append("    addAmbient(litArgs_worldNormal);"),
        t.conserveEnergy && t.useSpecular && r.append("   dDiffuseLight = dDiffuseLight * (1.0 - litArgs_specularity);"),
        t.separateAmbient && r.append(`
										vec3 dAmbientLight = dDiffuseLight;
										dDiffuseLight = vec3(0);
								`)),
        t.useAmbientTint && !m && r.append("    dDiffuseLight *= material_ambient;"),
        t.useAo && !t.occludeDirect && r.append("    occludeDiffuse(litArgs_ao);"),
        t.lightMapEnabled && r.append(`    addLightMap(
								litArgs_lightmap, 
								litArgs_lightmapDir, 
								litArgs_worldNormal, 
								dViewDirW, 
								dReflDirW, 
								litArgs_gloss, 
								litArgs_specularity, 
								dVertexNormalW,
								dTBN
						#if defined(LIT_IRIDESCENCE)
								, iridescenceFresnel,
								litArgs_iridescence_intensity
						#endif
								);`),
        this.lighting || this.reflections) {
            this.reflections && (t.useClearCoat && (r.append("    addReflectionCC(ccReflDirW, litArgs_clearcoat_gloss);"),
            t.fresnelModel > 0 ? (r.append("    ccFresnel = getFresnelCC(dot(dViewDirW, litArgs_clearcoat_worldNormal));"),
            r.append("    ccReflection.rgb *= ccFresnel;")) : r.append("    ccFresnel = 0.0;")),
            t.useSpecularityFactor && r.append("    ccReflection.rgb *= litArgs_specularityFactor;"),
            t.useSheen && r.append("    addReflectionSheen(litArgs_worldNormal, dViewDirW, litArgs_sheen_gloss);"),
            r.append("    addReflection(dReflDirW, litArgs_gloss);"),
            t.fresnelModel > 0 ? r.append(`    dReflection.rgb *= 
												getFresnel(
														dot(dViewDirW, litArgs_worldNormal), 
														litArgs_gloss, 
														litArgs_specularity
												#if defined(LIT_IRIDESCENCE)
														, iridescenceFresnel,
														litArgs_iridescence_intensity
												#endif
														);`) : r.append("    dReflection.rgb *= litArgs_specularity;"),
            t.useSpecularityFactor && r.append("    dReflection.rgb *= litArgs_specularityFactor;")),
            f && (r.append("    dSpecularLight *= litArgs_specularity;"),
            t.useSpecular && r.append("    calcLTCLightValues(litArgs_gloss, litArgs_worldNormal, dViewDirW, litArgs_specularity, litArgs_clearcoat_gloss, litArgs_clearcoat_worldNormal, litArgs_clearcoat_specularity);"));
            for (let I = 0; I < t.lights.length; I++) {
                const O = t.lights[I]
                  , D = O._type;
                if (t.clusteredLightingEnabled && D !== pe)
                    continue;
                b = !1;
                const A = f && O._shape ? O.shape : Nt
                  , k = f && O._shape ? this._getLightSourceShapeString(A) : "";
                if (A !== Nt && r.append("    calc" + k + "LightValues(light" + I + "_position, light" + I + "_halfWidth, light" + I + "_halfHeight);"),
                D === pe ? (r.append("    dLightDirNormW = light" + I + "_direction;"),
                r.append("    dAtten = 1.0;")) : (O._cookie && (D === He && !O._cookie._cubemap || D === Oe && O._cookie._cubemap) && (T = !0,
                b = !0),
                r.append("    getLightDirPoint(light" + I + "_position);"),
                v = !0,
                b && (D === He ? r.append("    dAtten3 = getCookie2D" + (O._cookieFalloff ? "" : "Clip") + (O._cookieTransform ? "Xform" : "") + "(light" + I + "_cookie, light" + I + "_shadowMatrix, light" + I + "_cookieIntensity" + (O._cookieTransform ? ", light" + I + "_cookieMatrix, light" + I + "_cookieOffset" : "") + ")." + O._cookieChannel + ";") : r.append("    dAtten3 = getCookieCube(light" + I + "_cookie, light" + I + "_shadowMatrix, light" + I + "_cookieIntensity)." + O._cookieChannel + ";")),
                A === Nt ? O._falloffMode === q_ ? (r.append("    dAtten = getFalloffLinear(light" + I + "_radius, dLightDirW);"),
                x = !0) : (r.append("    dAtten = getFalloffInvSquared(light" + I + "_radius, dLightDirW);"),
                S = !0) : (r.append("    dAtten = getFalloffWindow(light" + I + "_radius, dLightDirW);"),
                S = !0),
                r.append("    if (dAtten > 0.00001) {"),
                D === He && (b && !O._cookieFalloff || (r.append("    dAtten *= getSpotEffect(light" + I + "_direction, light" + I + "_innerConeAngle, light" + I + "_outerConeAngle, dLightDirNormW);"),
                w = !0))),
                A !== Nt ? D === pe ? r.append("    dAttenD = getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW);") : r.append("    dAttenD = get" + k + "LightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW) * 16.0;") : r.append("    dAtten *= getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW);"),
                O.castShadows && !t.noShadow) {
                    const N = O._shadowType === Kt
                      , H = O._shadowType === zs || O._shadowType === pi || O._shadowType === Hs
                      , K = O._shadowType === Ni || O._shadowType === St || O._shadowType === gi;
                    let q = null, se;
                    switch (O._shadowType) {
                    case zs:
                        q = "VSM8",
                        se = "0.0";
                        break;
                    case pi:
                        q = "VSM16",
                        se = "5.54";
                        break;
                    case Hs:
                        q = "VSM32",
                        e.textureFloatHighPrecision ? se = "15.0" : se = "5.54";
                        break;
                    case Ni:
                        q = "PCF1x1";
                        break;
                    case gi:
                        q = "PCF5x5";
                        break;
                    case Kt:
                        q = "PCSS";
                        break;
                    case St:
                    default:
                        q = "PCF3x3";
                        break
                    }
                    if (q !== null) {
                        O._normalOffsetBias && !O._isVsm && n.append("#define SHADOW_SAMPLE_NORMAL_OFFSET"),
                        D === pe && n.append("#define SHADOW_SAMPLE_ORTHO"),
                        ((K || N) && e.isWebGL2 || e.isWebGPU || e.extStandardDerivatives) && n.append("#define SHADOW_SAMPLE_SOURCE_ZBUFFER"),
                        D === Oe && n.append("#define SHADOW_SAMPLE_POINT");
                        const ie = s.shadowSampleCoordPS;
                        n.append(ie.replace("$LIGHT", I)),
                        n.append("#undef SHADOW_SAMPLE_NORMAL_OFFSET"),
                        n.append("#undef SHADOW_SAMPLE_ORTHO"),
                        n.append("#undef SHADOW_SAMPLE_SOURCE_ZBUFFER"),
                        n.append("#undef SHADOW_SAMPLE_POINT");
                        let ae = `light${I}_shadowMatrix`;
                        D === pe && O.numCascades > 1 && (r.append(`    getShadowCascadeMatrix(light${I}_shadowMatrixPalette, light${I}_shadowCascadeDistances, light${I}_shadowCascadeCount);`),
                        ae = "cascadeShadowMat"),
                        r.append(`    dShadowCoord = getShadowSampleCoord${I}(${ae}, light${I}_shadowParams, vPositionW, dLightPosW, dLightDirW, dLightDirNormW, dVertexNormalW);`),
                        D === pe && r.append(`    fadeShadow(light${I}_shadowCascadeDistances);`);
                        var E = `SHADOWMAP_PASS(light${I}_shadowMap), dShadowCoord, light${I}_shadowParams`;
                        if (H)
                            E = `${E}, ${se}, dLightDirW`;
                        else if (N) {
                            let he = `vec2(light${I}_shadowSearchArea)`;
                            A !== Nt && (he = `vec2(length(light${I}_halfWidth), length(light${I}_halfHeight)) * light${I}_shadowSearchArea`),
                            E = `${E}, light${I}_cameraParams, ${he}, dLightDirW`
                        }
                        D === Oe ? (q = `Point${q}`,
                        N || (E = `${E}, dLightDirW`)) : D === He && (q = `Spot${q}`),
                        r.append(`    float shadow${I} = getShadow${q}(${E});`),
                        r.append(`    dAtten *= mix(1.0, shadow${I}, light${I}_shadowIntensity);`)
                    }
                }
                if (A !== Nt ? t.conserveEnergy && t.useSpecular ? r.append("    dDiffuseLight += ((dAttenD * dAtten) * light" + I + "_color" + (b ? " * dAtten3" : "") + ") * (1.0 - dLTCSpecFres);") : r.append("    dDiffuseLight += (dAttenD * dAtten) * light" + I + "_color" + (b ? " * dAtten3" : "") + ";") : f && t.conserveEnergy && t.useSpecular ? r.append("    dDiffuseLight += (dAtten * light" + I + "_color" + (b ? " * dAtten3" : "") + ") * (1.0 - litArgs_specularity);") : r.append("    dDiffuseLight += dAtten * light" + I + "_color" + (b ? " * dAtten3" : "") + ";"),
                t.useSpecular && r.append("    dHalfDirW = normalize(-dLightDirNormW + dViewDirW);"),
                O.affectSpecularity)
                    if (A !== Nt)
                        t.useClearCoat && r.append(`    ccSpecularLight += ccLTCSpecFres * get${k}LightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * light${I}_color` + (b ? " * dAtten3" : "") + ";"),
                        t.useSpecular && r.append(`    dSpecularLight += dLTCSpecFres * get${k}LightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * light${I}_color` + (b ? " * dAtten3" : "") + ";");
                    else {
                        var C = !1;
                        D === pe && t.fresnelModel > 0 && (C = !0),
                        t.useClearCoat && r.append(`    ccSpecularLight += getLightSpecular(dHalfDirW, ccReflDirW, litArgs_clearcoat_worldNormal, dViewDirW, dLightDirNormW, litArgs_clearcoat_gloss, dTBN) * dAtten * light${I}_color` + (b ? " * dAtten3" : "") + (C ? " * getFresnelCC(dot(dViewDirW, dHalfDirW));" : ";")),
                        t.useSheen && r.append(`    sSpecularLight += getLightSpecularSheen(dHalfDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_sheen_gloss) * dAtten * light${I}_color` + (b ? " * dAtten3;" : ";")),
                        t.useSpecular && r.append(`    dSpecularLight += getLightSpecular(dHalfDirW, dReflDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_gloss, dTBN) * dAtten * light${I}_color` + (b ? " * dAtten3" : "") + (C ? ` 
																		* getFresnel(
																				dot(dViewDirW, dHalfDirW), 
																				litArgs_gloss, 
																				litArgs_specularity
																		#if defined(LIT_IRIDESCENCE)
																				, iridescenceFresnel, 
																				litArgs_iridescence_intensity
																		#endif
																		);` : "* litArgs_specularity;"))
                    }
                D !== pe && r.append("    }")
            }
            t.clusteredLightingEnabled && this.lighting && (x = !0,
            S = !0,
            v = !0,
            r.append(`    addClusteredLights(
																				litArgs_worldNormal, 
																				dViewDirW, 
																				dReflDirW,
																#if defined(LIT_CLEARCOAT)
																				ccReflDirW,
																#endif
																				litArgs_gloss, 
																				litArgs_specularity, 
																				dVertexNormalW, 
																				dTBN, 
																#if defined(LIT_IRIDESCENCE)
																				iridescenceFresnel,
																#endif
																				litArgs_clearcoat_worldNormal, 
																				litArgs_clearcoat_gloss,
																				litArgs_sheen_gloss,
																				litArgs_iridescence_intensity
																		);`)),
            f && (t.useClearCoat && r.append("    litArgs_clearcoat_specularity = 1.0;"),
            t.useSpecular && r.append("    litArgs_specularity = vec3(1);")),
            t.useRefraction && r.append(`    addRefraction(
												litArgs_worldNormal, 
												dViewDirW, 
												litArgs_thickness, 
												litArgs_gloss, 
												litArgs_specularity, 
												litArgs_albedo, 
												litArgs_transmission,
												litArgs_ior
										#if defined(LIT_IRIDESCENCE)
												, iridescenceFresnel, 
												litArgs_iridescence_intensity
										#endif
										);`)
        }
        t.useAo && (t.occludeDirect && r.append("    occludeDiffuse(litArgs_ao);"),
        (t.occludeSpecular === Th || t.occludeSpecular === Cm) && r.append("    occludeSpecular(litArgs_gloss, litArgs_ao, litArgs_worldNormal, dViewDirW);")),
        t.useSpecularityFactor && r.append("    dSpecularLight *= litArgs_specularityFactor;"),
        t.opacityFadesSpecular === !1 && ((t.blendType === ps || t.blendType === _a) && (r.append("float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));"),
        r.append(`#ifdef LIT_CLEARCOAT
 specLum += dot(ccSpecularLight * litArgs_clearcoat_specularity + ccReflection.rgb * litArgs_clearcoat_specularity, vec3( 0.2126, 0.7152, 0.0722 ));
#endif`),
        r.append("litArgs_opacity = clamp(litArgs_opacity + gammaCorrectInput(specLum), 0.0, 1.0);")),
        r.append("litArgs_opacity *= material_alphaFade;")),
        r.append(s.endPS),
        t.blendType === ps || t.blendType === fi || t.alphaToCoverage ? r.append(s.outputAlphaPS) : t.blendType === _a ? r.append(s.outputAlphaPremulPS) : r.append(s.outputAlphaOpaquePS),
        t.useMsdf && r.append("    gl_FragColor = applyMsdf(gl_FragColor);"),
        r.append(s.outputPS),
        r.append(s.debugOutputPS),
        v && n.prepend(s.lightDirPointPS),
        x && n.prepend(s.falloffLinearPS),
        S && n.prepend(s.falloffInvSquaredPS),
        w && n.prepend(s.spotPS),
        T && !t.clusteredLightingEnabled && n.prepend(s.cookiePS);
        let R = "";
        const F = `void evaluateBackend() {
${r.code}
}`;
        n.append(F),
        o.append(s.debugProcessFrontendPS),
        o.append("    evaluateBackend();"),
        o.append(Ue.end());
        const L = i.code + n.code + o.code;
        return L.includes("dTBN") && (R += `mat3 dTBN;
`),
        L.includes("dVertexNormalW") && (R += `vec3 dVertexNormalW;
`),
        L.includes("dTangentW") && (R += `vec3 dTangentW;
`),
        L.includes("dBinormalW") && (R += `vec3 dBinormalW;
`),
        L.includes("dViewDirW") && (R += `vec3 dViewDirW;
`),
        L.includes("dReflDirW") && (R += `vec3 dReflDirW;
`),
        L.includes("dHalfDirW") && (R += `vec3 dHalfDirW;
`),
        L.includes("ccReflDirW") && (R += `vec3 ccReflDirW;
`),
        L.includes("dLightDirNormW") && (R += `vec3 dLightDirNormW;
`),
        L.includes("dLightDirW") && (R += `vec3 dLightDirW;
`),
        L.includes("dLightPosW") && (R += `vec3 dLightPosW;
`),
        L.includes("dShadowCoord") && (R += `vec3 dShadowCoord;
`),
        L.includes("dReflection") && (R += `vec4 dReflection;
`),
        L.includes("dDiffuseLight") && (R += `vec3 dDiffuseLight;
`),
        L.includes("dSpecularLight") && (R += `vec3 dSpecularLight;
`),
        L.includes("dAtten") && (R += `float dAtten;
`),
        L.includes("dAttenD") && (R += `float dAttenD;
`),
        L.includes("dAtten3") && (R += `vec3 dAtten3;
`),
        L.includes("dMsdf") && (R += `vec4 dMsdf;
`),
        L.includes("ccFresnel") && (R += `float ccFresnel;
`),
        L.includes("ccReflection") && (R += `vec3 ccReflection;
`),
        L.includes("ccSpecularLight") && (R += `vec3 ccSpecularLight;
`),
        L.includes("ccSpecularityNoFres") && (R += `float ccSpecularityNoFres;
`),
        L.includes("sSpecularLight") && (R += `vec3 sSpecularLight;
`),
        L.includes("sReflection") && (R += `vec3 sReflection;
`),
        this._fsGetBeginCode() + this.varyings + this.varyingDefines + this._fsGetBaseCode() + R + this.frontendDecl + L
    }
    generateFragmentShader(e, t, s, i) {
        var n;
        const r = this.options;
        this.frontendDecl = e,
        this.frontendCode = t,
        this.frontendFunc = s,
        this.lightingUv = i,
        r.pass === mc ? this.fshader = this._fsGetPickPassCode() : r.pass === Vi ? this.fshader = this._fsGetDepthPassCode() : this.shadowPass ? this.fshader = this._fsGetShadowPassCode() : r.customFragmentShader ? this.fshader = this._fsGetBeginCode() + r.customFragmentShader : this.fshader = this._fsGetLitPassCode(),
        (n = this.handleCompatibility) == null || n.call(this)
    }
    getDefinition() {
        const e = Pt.createDefinition(this.device, {
            name: "LitShader",
            attributes: this.attributes,
            vertexCode: this.vshader,
            fragmentCode: this.fshader
        });
        return this.shaderPassInfo.isForward && (e.tag = bT),
        e
    }
}
const Pm = {
    generateKey(a) {
        return "lit" + Object.keys(a).sort().map(e => e === "chunks" ? Pm.generateChunksKey(a) : e === "lights" ? Pm.generateLightsKey(a) : e + a[e]).join(`
`)
    },
    generateLightsKey(a) {
        return "lights:" + a.lights.map(e => !a.clusteredLightingEnabled || e._type === pe ? `${e.key},` : "").join("")
    },
    generateChunksKey(a) {
        var e;
        return `chunks:
` + Object.keys((e = a.chunks) != null ? e : {}).sort().map(t => t + a.chunks[t]).join("")
    }
}
  , Xc = new y
  , jc = new y
  , $c = new y
  , sp = new Pe
  , h0 = 1e-6;
class c0 {
    constructor() {
        this.light = null,
        this.min = new y,
        this.max = new y
    }
}
class Rm {
    constructor(e) {
        this.clusterTexture = void 0,
        this.device = e,
        this.name = "Untitled",
        this.reportCount = 0,
        this.boundsMin = new y,
        this.boundsMax = new y,
        this.boundsDelta = new y,
        this._cells = new y(1,1,1),
        this._cellsLimit = new y,
        this.cells = this._cells,
        this.maxCellLightCount = 4,
        this._maxAttenuation = 0,
        this._maxColorValue = 0,
        this._usedLights = [],
        this._usedLights.push(new c0),
        this.lightsBuffer = new Ih(e),
        this.registerUniforms(e)
    }
    set maxCellLightCount(e) {
        e !== this._maxCellLightCount && (this._maxCellLightCount = e,
        this._cellsDirty = !0)
    }
    get maxCellLightCount() {
        return this._maxCellLightCount
    }
    set cells(e) {
        Xc.copy(e).floor(),
        this._cells.equals(Xc) || (this._cells.copy(Xc),
        this._cellsLimit.copy(Xc).sub(y.ONE),
        this._cellsDirty = !0)
    }
    get cells() {
        return this._cells
    }
    destroy() {
        this.lightsBuffer.destroy(),
        this.releaseClusterTexture()
    }
    releaseClusterTexture() {
        this.clusterTexture && (this.clusterTexture.destroy(),
        this.clusterTexture = null)
    }
    registerUniforms(e) {
        this._clusterSkipId = e.scope.resolve("clusterSkip"),
        this._clusterMaxCellsId = e.scope.resolve("clusterMaxCells"),
        this._clusterWorldTextureId = e.scope.resolve("clusterWorldTexture"),
        this._clusterTextureSizeId = e.scope.resolve("clusterTextureSize"),
        this._clusterTextureSizeData = new Float32Array(3),
        this._clusterBoundsMinId = e.scope.resolve("clusterBoundsMin"),
        this._clusterBoundsMinData = new Float32Array(3),
        this._clusterBoundsDeltaId = e.scope.resolve("clusterBoundsDelta"),
        this._clusterBoundsDeltaData = new Float32Array(3),
        this._clusterCellsCountByBoundsSizeId = e.scope.resolve("clusterCellsCountByBoundsSize"),
        this._clusterCellsCountByBoundsSizeData = new Float32Array(3),
        this._clusterCellsDotId = e.scope.resolve("clusterCellsDot"),
        this._clusterCellsDotData = new Float32Array(3),
        this._clusterCellsMaxId = e.scope.resolve("clusterCellsMax"),
        this._clusterCellsMaxData = new Float32Array(3),
        this._clusterCompressionLimit0Id = e.scope.resolve("clusterCompressionLimit0"),
        this._clusterCompressionLimit0Data = new Float32Array(2)
    }
    updateParams(e) {
        e && (this.cells = e.cells,
        this.maxCellLightCount = e.maxLightsPerCell,
        this.lightsBuffer.cookiesEnabled = e.cookiesEnabled,
        this.lightsBuffer.shadowsEnabled = e.shadowsEnabled,
        this.lightsBuffer.areaLightsEnabled = e.areaLightsEnabled)
    }
    updateCells() {
        if (this._cellsDirty) {
            this._cellsDirty = !1;
            const e = this._cells.x
              , t = this._cells.y
              , s = this._cells.z
              , i = e * t * s
              , n = this.maxCellLightCount * i;
            let r = Math.ceil(Math.sqrt(n));
            r = W.roundUp(r, this.maxCellLightCount);
            const o = Math.ceil(n / r);
            this._clusterCellsMaxData[0] = e,
            this._clusterCellsMaxData[1] = t,
            this._clusterCellsMaxData[2] = s,
            this._clusterCellsDotData[0] = this.maxCellLightCount,
            this._clusterCellsDotData[1] = e * s * this.maxCellLightCount,
            this._clusterCellsDotData[2] = e * this.maxCellLightCount,
            this.clusters = new Uint8ClampedArray(n),
            this.counts = new Int32Array(i),
            this._clusterTextureSizeData[0] = r,
            this._clusterTextureSizeData[1] = 1 / r,
            this._clusterTextureSizeData[2] = 1 / o,
            this.releaseClusterTexture(),
            this.clusterTexture = this.lightsBuffer.createTexture(this.device, r, o, Bu, "ClusterTexture")
        }
    }
    uploadTextures() {
        this.clusterTexture.lock().set(this.clusters),
        this.clusterTexture.unlock(),
        this.lightsBuffer.uploadTextures()
    }
    updateUniforms() {
        this._clusterSkipId.setValue(this._usedLights.length > 1 ? 0 : 1),
        this.lightsBuffer.updateUniforms(),
        this._clusterWorldTextureId.setValue(this.clusterTexture),
        this._clusterMaxCellsId.setValue(this.maxCellLightCount);
        const e = this.boundsDelta;
        this._clusterCellsCountByBoundsSizeData[0] = this._cells.x / e.x,
        this._clusterCellsCountByBoundsSizeData[1] = this._cells.y / e.y,
        this._clusterCellsCountByBoundsSizeData[2] = this._cells.z / e.z,
        this._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData),
        this._clusterBoundsMinData[0] = this.boundsMin.x,
        this._clusterBoundsMinData[1] = this.boundsMin.y,
        this._clusterBoundsMinData[2] = this.boundsMin.z,
        this._clusterBoundsDeltaData[0] = e.x,
        this._clusterBoundsDeltaData[1] = e.y,
        this._clusterBoundsDeltaData[2] = e.z,
        this._clusterCompressionLimit0Data[0] = this._maxAttenuation,
        this._clusterCompressionLimit0Data[1] = this._maxColorValue,
        this._clusterTextureSizeId.setValue(this._clusterTextureSizeData),
        this._clusterBoundsMinId.setValue(this._clusterBoundsMinData),
        this._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData),
        this._clusterCellsDotId.setValue(this._clusterCellsDotData),
        this._clusterCellsMaxId.setValue(this._clusterCellsMaxData),
        this._clusterCompressionLimit0Id.setValue(this._clusterCompressionLimit0Data)
    }
    evalLightCellMinMax(e, t, s) {
        t.copy(e.min),
        t.sub(this.boundsMin),
        t.div(this.boundsDelta),
        t.mul2(t, this.cells),
        t.floor(),
        s.copy(e.max),
        s.sub(this.boundsMin),
        s.div(this.boundsDelta),
        s.mul2(s, this.cells),
        s.ceil(),
        t.max(y.ZERO),
        s.min(this._cellsLimit)
    }
    collectLights(e) {
        const t = this.lightsBuffer.maxLights
          , s = this._usedLights;
        let i = 1;
        e.forEach(n => {
            const r = !!(n.mask & (Rs | Ui))
              , o = n.type === He && n._outerConeAngle === 0;
            if (n.enabled && n.type !== pe && n.visibleThisFrame && n.intensity > 0 && r && !o && i < t) {
                let l;
                i < s.length ? l = s[i] : (l = new c0,
                s.push(l)),
                l.light = n,
                n.getBoundingBox(sp),
                l.min.copy(sp.getMin()),
                l.max.copy(sp.getMax()),
                i++
            }
        }
        ),
        s.length = i
    }
    evaluateBounds() {
        const e = this._usedLights
          , t = this.boundsMin
          , s = this.boundsMax;
        if (e.length > 1) {
            t.copy(e[1].min),
            s.copy(e[1].max);
            for (let i = 2; i < e.length; i++)
                t.min(e[i].min),
                s.max(e[i].max)
        } else
            t.set(0, 0, 0),
            s.set(1, 1, 1);
        this.boundsDelta.sub2(s, t),
        this.lightsBuffer.setBounds(t, this.boundsDelta)
    }
    evaluateCompressionLimits(e) {
        let t = 0
          , s = 0;
        const i = this._usedLights;
        for (let n = 1; n < i.length; n++) {
            const r = i[n].light;
            t = Math.max(r.attenuationEnd, t);
            const o = e ? r._linearFinalColor : r._finalColor;
            s = Math.max(o[0], s),
            s = Math.max(o[1], s),
            s = Math.max(o[2], s)
        }
        this._maxAttenuation = t + h0,
        this._maxColorValue = s + h0,
        this.lightsBuffer.setCompressionRanges(this._maxAttenuation, this._maxColorValue)
    }
    updateClusters(e) {
        this.counts.fill(0),
        this.clusters.fill(0);
        const t = this._cells.x
          , s = this._cells.z
          , i = this.counts
          , n = this._maxCellLightCount
          , r = this.clusters
          , o = this.maxCellLightCount
          , l = this._usedLights;
        for (let c = 1; c < l.length; c++) {
            const d = l[c]
              , h = d.light;
            this.lightsBuffer.addLightData(h, c, e),
            this.evalLightCellMinMax(d, jc, $c);
            const u = jc.x
              , f = $c.x
              , p = jc.y
              , _ = $c.y
              , m = jc.z
              , g = $c.z;
            for (let v = u; v <= f; v++)
                for (let x = m; x <= g; x++)
                    for (let S = p; S <= _; S++) {
                        const w = v + t * (x + S * s)
                          , T = i[w];
                        T < n && (r[o * w + T] = c,
                        i[w] = T + 1)
                    }
        }
    }
    update(e, t, s) {
        this.updateParams(s),
        this.updateCells(),
        this.collectLights(e),
        this.evaluateBounds(),
        this.evaluateCompressionLimits(t),
        this.updateClusters(t),
        this.uploadTextures()
    }
    activate() {
        this.updateUniforms()
    }
}
class va {
    constructor(e, t) {
        this.texture = e,
        this.cached = !1,
        this.renderTargets = t
    }
    destroy() {
        this.texture && (this.texture.destroy(),
        this.texture = null);
        const e = this.renderTargets;
        for (let t = 0; t < e.length; t++)
            e[t].destroy();
        this.renderTargets.length = 0
    }
    static getShadowFormat(e, t) {
        return t === Hs ? lt : t === pi ? Tt : t === gi || (t === Ni || t === St) && e.supportsDepthShadow ? da : t === Kt && !e.isWebGL1 ? ca : ve
    }
    static getShadowFiltering(e, t) {
        return (t === Ni || t === St || t === Kt) && !e.supportsDepthShadow ? be : t === Hs ? e.extTextureFloatLinear ? ot : be : t === pi ? e.extTextureHalfFloatLinear ? ot : be : ot
    }
    static create(e, t) {
        let s = null;
        return t._type === Oe ? s = this.createCubemap(e, t._shadowResolution, t._shadowType) : s = this.create2dMap(e, t._shadowResolution, t._shadowType),
        s
    }
    static createAtlas(e, t, s) {
        const i = this.create2dMap(e, t, s)
          , n = i.renderTargets
          , r = n[0];
        for (let o = 0; o < 5; o++)
            n.push(r);
        return i
    }
    static create2dMap(e, t, s) {
        const i = this.getShadowFormat(e, s)
          , n = this.getShadowFiltering(e, s)
          , r = new ge(e,{
            format: i,
            width: t,
            height: t,
            mipmaps: !1,
            minFilter: n,
            magFilter: n,
            addressU: oe,
            addressV: oe,
            name: "ShadowMap2D"
        });
        let o = null;
        return s === gi || (s === Ni || s === St) && e.supportsDepthShadow ? (r.compareOnRead = !0,
        r.compareFunc = A_,
        o = new It({
            depthBuffer: r
        })) : o = new It({
            colorBuffer: r,
            depth: !0
        }),
        e.isWebGPU && (o.flipY = !0),
        new va(r,[o])
    }
    static createCubemap(e, t, s) {
        const i = s === Kt && !e.isWebGL1 ? ca : ve
          , n = new ge(e,{
            format: i,
            width: t,
            height: t,
            cubemap: !0,
            mipmaps: !1,
            minFilter: be,
            magFilter: be,
            addressU: oe,
            addressV: oe,
            name: "ShadowMapCube"
        })
          , r = [];
        for (let o = 0; o < 6; o++) {
            const l = new It({
                colorBuffer: n,
                face: o,
                depth: !0
            });
            r.push(l)
        }
        return new va(n,r)
    }
}
const jR = []
  , $R = []
  , tn = new M
  , ip = new M;
class np {
    constructor(e) {
        this.size = Math.floor(e.w * 1024),
        this.used = !1,
        this.lightId = -1,
        this.rect = e
    }
}
class qR {
    constructor(e) {
        this.device = e,
        this.version = 1,
        this.shadowAtlasResolution = 2048,
        this.shadowAtlas = null,
        this.shadowEdgePixels = 3,
        this.cookieAtlasResolution = 4,
        this.cookieAtlas = new ge(this.device,{
            name: "CookieAtlas",
            width: this.cookieAtlasResolution,
            height: this.cookieAtlasResolution,
            format: ve,
            cubemap: !1,
            mipmaps: !1,
            minFilter: be,
            magFilter: be,
            addressU: oe,
            addressV: oe
        }),
        this.cookieRenderTarget = new It({
            colorBuffer: this.cookieAtlas,
            depth: !1,
            flipY: !0
        }),
        this.slots = [],
        this.atlasSplit = [],
        this.cubeSlotsOffsets = [new P(0,0), new P(0,1), new P(1,0), new P(1,1), new P(2,0), new P(2,1)],
        this.scissorVec = new M,
        this.allocateShadowAtlas(1),
        this.allocateCookieAtlas(1),
        this.allocateUniforms()
    }
    destroy() {
        this.destroyShadowAtlas(),
        this.destroyCookieAtlas()
    }
    destroyShadowAtlas() {
        var e;
        (e = this.shadowAtlas) == null || e.destroy(),
        this.shadowAtlas = null
    }
    destroyCookieAtlas() {
        var e, t;
        (e = this.cookieAtlas) == null || e.destroy(),
        this.cookieAtlas = null,
        (t = this.cookieRenderTarget) == null || t.destroy(),
        this.cookieRenderTarget = null
    }
    allocateShadowAtlas(e) {
        if (!this.shadowAtlas || this.shadowAtlas.texture.width !== e) {
            this.version++,
            this.destroyShadowAtlas(),
            this.shadowAtlas = va.createAtlas(this.device, e, St),
            this.shadowAtlas.cached = !0;
            const t = 4 / this.shadowAtlasResolution;
            this.scissorVec.set(t, t, -2 * t, -2 * t)
        }
    }
    allocateCookieAtlas(e) {
        this.cookieAtlas.width !== e && (this.cookieRenderTarget.resize(e, e),
        this.version++)
    }
    allocateUniforms() {
        this._shadowAtlasTextureId = this.device.scope.resolve("shadowAtlasTexture"),
        this._shadowAtlasParamsId = this.device.scope.resolve("shadowAtlasParams"),
        this._shadowAtlasParams = new Float32Array(2),
        this._cookieAtlasTextureId = this.device.scope.resolve("cookieAtlasTexture")
    }
    updateUniforms() {
        const t = this.shadowAtlas.renderTargets[0]
          , i = !this.device.isWebGL1 && !0 ? t.depthBuffer : t.colorBuffer;
        this._shadowAtlasTextureId.setValue(i),
        this._shadowAtlasParams[0] = this.shadowAtlasResolution,
        this._shadowAtlasParams[1] = this.shadowEdgePixels,
        this._shadowAtlasParamsId.setValue(this._shadowAtlasParams),
        this._cookieAtlasTextureId.setValue(this.cookieAtlas)
    }
    subdivide(e, t) {
        let s = t.atlasSplit;
        if (!s) {
            const n = Math.ceil(Math.sqrt(e));
            s = $R,
            s[0] = n,
            s.length = 1
        }
        if (!( (n, r) => n.length === r.length && n.every( (o, l) => o === r[l]))(s, this.atlasSplit)) {
            this.version++,
            this.slots.length = 0,
            this.atlasSplit.length = 0,
            this.atlasSplit.push(...s);
            const n = this.atlasSplit[0];
            if (n > 1) {
                const r = 1 / n;
                for (let o = 0; o < n; o++)
                    for (let l = 0; l < n; l++) {
                        const c = new M(o * r,l * r,r,r)
                          , d = this.atlasSplit[1 + o * n + l];
                        if (d > 1)
                            for (let h = 0; h < d; h++)
                                for (let u = 0; u < d; u++) {
                                    const f = r / d
                                      , p = new M(c.x + h * f,c.y + u * f,f,f);
                                    this.slots.push(new np(p))
                                }
                        else
                            this.slots.push(new np(c))
                    }
            } else
                this.slots.push(new np(new M(0,0,1,1)));
            this.slots.sort( (r, o) => o.size - r.size)
        }
    }
    collectLights(e, t) {
        const s = t.cookiesEnabled
          , i = t.shadowsEnabled;
        let n = !1
          , r = !1;
        const o = jR;
        return o.length = 0,
        (s || i) && (c => {
            for (let d = 0; d < c.length; d++) {
                const h = c[d];
                if (h.visibleThisFrame) {
                    const u = i && h.castShadows
                      , f = s && !!h.cookie;
                    n || (n = u),
                    r || (r = f),
                    (u || f) && o.push(h)
                }
            }
        }
        )(e),
        o.sort( (c, d) => d.maxScreenSize - c.maxScreenSize),
        n && this.allocateShadowAtlas(this.shadowAtlasResolution),
        r && this.allocateCookieAtlas(this.cookieAtlasResolution),
        (n || r) && this.subdivide(o.length, t),
        o
    }
    setupSlot(e, t) {
        e.atlasViewport.copy(t);
        const s = e.numShadowFaces;
        for (let i = 0; i < s; i++)
            if (e.castShadows || e._cookie) {
                if (tn.copy(t),
                ip.copy(t),
                e._type === He && tn.add(this.scissorVec),
                e._type === Oe) {
                    const n = tn.z / 3
                      , r = this.cubeSlotsOffsets[i];
                    tn.x += n * r.x,
                    tn.y += n * r.y,
                    tn.z = n,
                    tn.w = n,
                    ip.copy(tn)
                }
                if (e.castShadows) {
                    const n = e.getRenderData(null, i);
                    n.shadowViewport.copy(tn),
                    n.shadowScissor.copy(ip)
                }
            }
    }
    assignSlot(e, t, s) {
        e.atlasViewportAllocated = !0;
        const i = this.slots[t];
        i.lightId = e.id,
        i.used = !0,
        s && (e.atlasSlotUpdated = !0,
        e.atlasVersion = this.version,
        e.atlasSlotIndex = t)
    }
    update(e, t) {
        this.shadowAtlasResolution = t.shadowAtlasResolution,
        this.cookieAtlasResolution = t.cookieAtlasResolution;
        const s = this.collectLights(e, t);
        if (s.length > 0) {
            const i = this.slots;
            for (let o = 0; o < i.length; o++)
                i[o].used = !1;
            const n = Math.min(s.length, i.length);
            for (let o = 0; o < n; o++) {
                const l = s[o];
                l.castShadows && (l._shadowMap = this.shadowAtlas);
                const c = i[l.atlasSlotIndex];
                if (l.atlasVersion === this.version && l.id === (c == null ? void 0 : c.lightId)) {
                    const d = i[l.atlasSlotIndex];
                    d.size === i[o].size && !d.used && this.assignSlot(l, l.atlasSlotIndex, !1)
                }
            }
            let r = 0;
            for (let o = 0; o < n; o++) {
                for (; r < i.length && i[r].used; )
                    r++;
                const l = s[o];
                l.atlasViewportAllocated || this.assignSlot(l, r, !0);
                const c = i[l.atlasSlotIndex];
                this.setupSlot(l, c.rect)
            }
        }
        this.updateUniforms()
    }
}
const YR = [new y(-1,0,0), new y(1,0,0), new y(0,-1,0), new y(0,1,0), new y(0,0,-1), new y(0,0,1)];
class KR {
    constructor() {
        this.colors = new Float32Array(6 * 3)
    }
    update(e, t) {
        const s = this.colors
          , {r: i, g: n, b: r} = e;
        for (let o = 0; o < 6; o++)
            s[o * 3] = i,
            s[o * 3 + 1] = n,
            s[o * 3 + 2] = r;
        for (let o = 0; o < t.length; o++) {
            const l = t[o];
            if (l._type === pe)
                for (let c = 0; c < 6; c++) {
                    const d = Math.max(YR[c].dot(l._direction), 0) * l._intensity
                      , h = l._color;
                    s[c * 3] += h.r * d,
                    s[c * 3 + 1] += h.g * d,
                    s[c * 3 + 2] += h.b * d
                }
        }
    }
}
class ZR {
    constructor() {
        this.cache = new Map
    }
    destroy() {
        this.clear(),
        this.cache = null
    }
    clear() {
        this.cache.forEach(e => {
            e.forEach(t => {
                t.destroy()
            }
            )
        }
        ),
        this.cache.clear()
    }
    getKey(e) {
        const t = e._type === Oe
          , s = e._shadowType
          , i = e._shadowResolution;
        return `${t}-${s}-${i}`
    }
    get(e, t) {
        const s = this.getKey(t)
          , i = this.cache.get(s);
        if (i && i.length)
            return i.pop();
        const n = va.create(e, t);
        return n.cached = !0,
        n
    }
    add(e, t) {
        const s = this.getKey(e)
          , i = this.cache.get(s);
        i ? i.push(t) : this.cache.set(s, [t])
    }
}
class QR extends Js {
    constructor(e, t, s, i, n) {
        super(e),
        this.requiresCubemaps = !1,
        this.shadowRenderer = t,
        this.light = s,
        this.face = i,
        this.applyVsm = n,
        this.shadowCamera = t.prepareFace(s, null, i),
        t.setupRenderPass(this, this.shadowCamera, !0)
    }
    execute() {
        this.shadowRenderer.renderFace(this.light, null, this.face, !1)
    }
    after() {
        this.applyVsm && this.shadowRenderer.renderVsm(this.light, this.shadowCamera)
    }
}
class JR {
    constructor(e, t) {
        this.shadowLights = [],
        this.renderer = void 0,
        this.shadowRenderer = void 0,
        this.device = void 0,
        this.renderer = e,
        this.shadowRenderer = t,
        this.device = e.device
    }
    cull(e, t, s=null) {
        const i = this.renderer.scene.clusteredLightingEnabled;
        e.visibleThisFrame = !0,
        i || e._shadowMap || (e._shadowMap = va.create(this.device, e));
        const n = e._type
          , r = n === He ? 1 : 6;
        for (let o = 0; o < r; o++) {
            const l = e.getRenderData(null, o)
              , c = l.shadowCamera;
            c.nearClip = e.attenuationEnd / 1e3,
            c.farClip = e.attenuationEnd,
            l.depthRangeCompensation = c.farClip - c.nearClip;
            const d = c._node
              , h = e._node;
            if (d.setPosition(h.getPosition()),
            n === He)
                c.fov = e._outerConeAngle * 2,
                d.setRotation(h.getRotation()),
                d.rotateLocal(-90, 0, 0);
            else if (n === Oe)
                if (i) {
                    const p = 2 / (this.shadowRenderer.lightTextureAtlas.shadowAtlasResolution * e.atlasViewport.z / 3) * this.shadowRenderer.lightTextureAtlas.shadowEdgePixels;
                    c.fov = Math.atan(1 + p) * W.RAD_TO_DEG * 2
                } else
                    c.fov = 90;
            this.renderer.updateCameraFrustum(c),
            this.shadowRenderer.cullShadowCasters(t, e, l.visibleCasters, c, s)
        }
    }
    prepareLights(e, t) {
        let s;
        for (let i = 0; i < t.length; i++) {
            const n = t[i];
            if (this.shadowRenderer.needsShadowRendering(n) && n.atlasViewportAllocated) {
                e.push(n);
                for (let r = 0; r < n.numShadowFaces; r++)
                    s = this.shadowRenderer.prepareFace(n, null, r)
            }
        }
        return s
    }
    buildNonClusteredRenderPasses(e, t) {
        for (let s = 0; s < t.length; s++) {
            const i = t[s];
            if (this.shadowRenderer.needsShadowRendering(i)) {
                const n = i._type === He
                  , r = i.numShadowFaces;
                for (let o = 0; o < r; o++) {
                    const l = new QR(this.device,this.shadowRenderer,i,o,n);
                    e.addRenderPass(l)
                }
            }
        }
    }
}
class eI extends Js {
    constructor(e, t, s, i, n) {
        super(e),
        this.shadowRenderer = t,
        this.light = s,
        this.camera = i,
        this.allCascadesRendering = n
    }
    execute() {
        const {light: e, camera: t, shadowRenderer: s, allCascadesRendering: i} = this
          , n = e.numShadowFaces
          , r = e.shadowUpdateOverrides;
        for (let o = 0; o < n; o++)
            (r == null ? void 0 : r[o]) !== Si && s.renderFace(e, t, o, !i),
            (r == null ? void 0 : r[o]) === ga && (r[o] = Si)
    }
    after() {
        this.shadowRenderer.renderVsm(this.light, this.camera)
    }
}
const qc = new Pe
  , sn = new y
  , d0 = new ee
  , je = [new y, new y, new y, new y, new y, new y, new y, new y]
  , rp = {
    min: 0,
    max: 0
};
function tI(a, e, t) {
    je[0].x = je[1].x = je[2].x = je[3].x = e.x,
    je[1].y = je[3].y = je[7].y = je[5].y = e.y,
    je[2].z = je[3].z = je[6].z = je[7].z = e.z,
    je[4].x = je[5].x = je[6].x = je[7].x = t.x,
    je[0].y = je[2].y = je[4].y = je[6].y = t.y,
    je[0].z = je[1].z = je[4].z = je[5].z = t.z;
    let s = 9999999999
      , i = -9999999999;
    for (let n = 0; n < 8; ++n) {
        a.transformPoint(je[n], je[n]);
        const r = je[n].z;
        r < s && (s = r),
        r > i && (i = r)
    }
    return rp.min = s,
    rp.max = i,
    rp
}
class sI {
    constructor(e, t) {
        this.renderer = void 0,
        this.shadowRenderer = void 0,
        this.device = void 0,
        this.renderer = e,
        this.shadowRenderer = t,
        this.device = e.device
    }
    cull(e, t, s, i=null) {
        e.visibleThisFrame = !0,
        e._shadowMap || (e._shadowMap = va.create(this.device, e));
        const n = s._nearClip;
        this.generateSplitDistances(e, n, Math.min(s._farClip, e.shadowDistance));
        const r = e.shadowUpdateOverrides;
        for (let o = 0; o < e.numCascades && (r == null ? void 0 : r[o]) !== Si; o++) {
            const l = e.getRenderData(s, o)
              , c = l.shadowCamera;
            c.renderTarget = e._shadowMap.renderTargets[0],
            l.shadowViewport.copy(e.cascades[o]),
            l.shadowScissor.copy(e.cascades[o]);
            const d = c._node
              , h = e._node;
            d.setPosition(h.getPosition()),
            d.setRotation(h.getRotation()),
            d.rotateLocal(-90, 0, 0);
            const u = o === 0 ? n : e._shadowCascadeDistances[o - 1]
              , f = e._shadowCascadeDistances[o]
              , p = s.getFrustumCorners(u, f);
            sn.set(0, 0, 0);
            const _ = s.node.getWorldTransform();
            for (let I = 0; I < 8; I++)
                _.transformPoint(p[I], p[I]),
                sn.add(p[I]);
            sn.mulScalar(1 / 8);
            let m = 0;
            for (let I = 0; I < 8; I++) {
                const O = p[I].sub(sn).length();
                O > m && (m = O)
            }
            const g = d.right
              , v = d.up
              , x = d.forward
              , S = .25 * e._shadowResolution / m
              , w = Math.ceil(sn.dot(v) * S) / S
              , T = Math.ceil(sn.dot(g) * S) / S
              , b = v.mulScalar(w)
              , E = g.mulScalar(T)
              , C = sn.dot(x)
              , R = x.mulScalar(C);
            sn.add2(b, E).add(R),
            d.setPosition(sn),
            d.translateLocal(0, 0, 1e6),
            c.nearClip = .01,
            c.farClip = 2e6,
            c.orthoHeight = m,
            this.renderer.updateCameraFrustum(c),
            this.shadowRenderer.cullShadowCasters(t, e, l.visibleCasters, c, i);
            let F = !0;
            const L = l.visibleCasters;
            for (let I = 0; I < L.length; I++) {
                const O = L[I];
                F ? (F = !1,
                qc.copy(O.aabb)) : qc.add(O.aabb)
            }
            d0.copy(d.getWorldTransform()).invert();
            const U = tI(d0, qc.getMin(), qc.getMax());
            d.translateLocal(0, 0, U.max + .1),
            c.farClip = U.max - U.min + .2,
            l.depthRangeCompensation = c.farClip,
            l.projectionCompensation = m
        }
    }
    generateSplitDistances(e, t, s) {
        e._shadowCascadeDistances.fill(s);
        for (let i = 1; i < e.numCascades; i++) {
            const n = i / e.numCascades
              , r = t + (s - t) * n
              , o = t * (s / t) ** n
              , l = W.lerp(r, o, e.cascadeDistribution);
            e._shadowCascadeDistances[i - 1] = l
        }
    }
    getLightRenderPass(e, t) {
        let s = null;
        if (this.shadowRenderer.needsShadowRendering(e)) {
            const i = e.numShadowFaces
              , n = e.shadowUpdateOverrides;
            let r = !0, o;
            for (let l = 0; l < i; l++)
                (n == null ? void 0 : n[l]) === Si && (r = !1),
                o = this.shadowRenderer.prepareFace(e, t, l);
            s = new eI(this.device,this.shadowRenderer,e,t,r),
            this.shadowRenderer.setupRenderPass(s, o, r)
        }
        return s
    }
}
function iI(a, e) {
    return Math.exp(-(a * a) / (2 * e * e))
}
function nI(a) {
    const e = (a - 1) / 6
      , t = (a - 1) * .5
      , s = new Array(a);
    let i = 0;
    for (let n = 0; n < a; ++n)
        s[n] = iI(n - t, e),
        i += s[n];
    for (let n = 0; n < a; ++n)
        s[n] /= i;
    return s
}
const ap = new Set
  , u0 = new ee
  , f0 = new ee
  , Rr = new Float32Array(2)
  , Sl = new M(1,1,0,0)
  , p0 = new ee;
class Ef {
    constructor(e, t) {
        this.shadowPassCache = [],
        this.device = e.device,
        this.renderer = e,
        this.lightTextureAtlas = t;
        const s = this.device.scope;
        this.polygonOffsetId = s.resolve("polygonOffset"),
        this.polygonOffset = new Float32Array(2),
        this.sourceId = s.resolve("source"),
        this.pixelOffsetId = s.resolve("pixelOffset"),
        this.weightId = s.resolve("weight[0]"),
        this.blurVsmShaderCode = [$.blurVSMPS, `#define GAUSS
` + $.blurVSMPS];
        const i = `#define PACKED
`;
        this.blurPackedVsmShaderCode = [i + this.blurVsmShaderCode[0], i + this.blurVsmShaderCode[1]],
        this.blurVsmShader = [{}, {}],
        this.blurPackedVsmShader = [{}, {}],
        this.blurVsmWeights = {},
        this.shadowMapLightRadiusId = s.resolve("light_radius"),
        this.viewUniformFormat = null,
        this.viewBindGroupFormat = null,
        this.blendStateWrite = new ft,
        this.blendStateNoWrite = new ft,
        this.blendStateNoWrite.setColorWrite(!1, !1, !1, !1)
    }
    static createShadowCamera(e, t, s, i) {
        const n = vi.create("ShadowCamera", s, i);
        return t >= zs && t <= Hs ? n.clearColor = new z(0,0,0,0) : n.clearColor = new z(1,1,1,1),
        n.clearDepthBuffer = !0,
        n.clearStencilBuffer = !1,
        n
    }
    static setShadowCameraSettings(e, t, s, i, n) {
        let r = s === gi || (s === Ni || s === St) && t.supportsDepthShadow;
        i === Oe && !n && (r = !1),
        e.clearColorBuffer = !r
    }
    _cullShadowCastersInternal(e, t, s) {
        const i = e.length;
        for (let n = 0; n < i; n++) {
            const r = e[n];
            r.castShadow && (!r.cull || r._isVisible(s)) && (r.visibleThisFrame = !0,
            t.push(r))
        }
    }
    cullShadowCasters(e, t, s, i, n) {
        if (s.length = 0,
        n)
            this._cullShadowCastersInternal(n, s, i);
        else {
            const r = e.layerList
              , o = r.length;
            for (let l = 0; l < o; l++) {
                const c = r[l];
                c._lightsSet.has(t) && (ap.has(c) || (ap.add(c),
                this._cullShadowCastersInternal(c.shadowCasters, s, i)))
            }
            ap.clear()
        }
        s.sort(this.renderer.sortCompareDepth)
    }
    setupRenderState(e, t) {
        e.isWebGL1 && e.extStandardDerivatives && (t._type === Oe ? (this.polygonOffset[0] = 0,
        this.polygonOffset[1] = 0,
        this.polygonOffsetId.setValue(this.polygonOffset)) : (this.polygonOffset[0] = t.shadowBias * -1e3,
        this.polygonOffset[1] = t.shadowBias * -1e3,
        this.polygonOffsetId.setValue(this.polygonOffset)));
        const s = this.renderer.scene.clusteredLightingEnabled
          , i = e.isWebGL2 || e.isWebGPU
          , n = s ? t._isPcf && i : t._isPcf && i && t._type !== Oe;
        e.setBlendState(n ? this.blendStateNoWrite : this.blendStateWrite),
        e.setDepthState(t.shadowDepthState),
        e.setStencilState(null, null)
    }
    dispatchUniforms(e, t, s, i) {
        const n = t._node;
        e._type !== pe && (this.renderer.dispatchViewPos(n.getPosition()),
        this.shadowMapLightRadiusId.setValue(e.attenuationEnd)),
        u0.setTRS(n.getPosition(), n.getRotation(), y.ONE).invert(),
        f0.mul2(t.projectionMatrix, u0);
        const r = s.shadowViewport;
        t.rect = r,
        t.scissorRect = s.shadowScissor,
        p0.setViewport(r.x, r.y, r.z, r.w),
        s.shadowMatrix.mul2(p0, f0),
        e._type === pe && e._shadowMatrixPalette.set(s.shadowMatrix.data, i * 16)
    }
    getShadowPass(e) {
        var t;
        const s = e._type
          , i = e._shadowType;
        let n = (t = this.shadowPassCache[s]) == null ? void 0 : t[i];
        if (!n) {
            const r = `ShadowPass_${s}_${i}`;
            n = wi.get(this.device).allocate(r, {
                isShadow: !0,
                lightType: s,
                shadowType: i
            }),
            this.shadowPassCache[s] || (this.shadowPassCache[s] = []),
            this.shadowPassCache[s][i] = n
        }
        return n.index
    }
    submitCasters(e, t) {
        const s = this.device
          , i = this.renderer
          , n = i.scene
          , r = 1 << ax
          , o = this.getShadowPass(t)
          , l = e.length;
        for (let c = 0; c < l; c++) {
            const d = e[c]
              , h = d.mesh;
            d.ensureMaterial(s);
            const u = d.material;
            i.setBaseConstants(s, u),
            i.setSkinning(s, d),
            u.dirty && (u.updateUniforms(s, n),
            u.dirty = !1),
            u.chunks && (i.setupCullMode(!0, 1, d),
            u.setParameters(s),
            d.setParameters(s, r));
            const f = d.getShaderInstance(o, 0, n, this.viewUniformFormat, this.viewBindGroupFormat)
              , p = f.shader;
            d._key[Em] = p.id,
            !p.failed && s.setShader(p),
            i.setVertexBuffers(s, h),
            i.setMorphing(s, d.morphInstance),
            this.renderer.setupMeshUniformBuffers(f, d);
            const _ = d.renderStyle;
            s.setIndexBuffer(h.indexBuffer[_]),
            i.drawInstance(s, d, h, _),
            i._shadowDrawCalls++
        }
    }
    needsShadowRendering(e) {
        const t = e.enabled && e.castShadows && e.shadowUpdateMode !== Si && e.visibleThisFrame;
        return e.shadowUpdateMode === ga && (e.shadowUpdateMode = Si),
        t && (this.renderer._shadowMapUpdates += e.numShadowFaces),
        t
    }
    getLightRenderData(e, t, s) {
        return e.getRenderData(e._type === pe ? t : null, s)
    }
    setupRenderPass(e, t, s) {
        const i = t.renderTarget;
        e.init(i),
        e.depthStencilOps.clearDepthValue = 1,
        e.depthStencilOps.clearDepth = s,
        i.depthBuffer ? e.depthStencilOps.storeDepth = !0 : (e.colorOps.clearValue.copy(t.clearColor),
        e.colorOps.clear = s,
        e.depthStencilOps.storeDepth = !1),
        e.requiresCubemaps = !1
    }
    prepareFace(e, t, s) {
        const i = e._type
          , n = e._shadowType
          , r = this.renderer.scene.clusteredLightingEnabled
          , l = this.getLightRenderData(e, t, s).shadowCamera;
        Ef.setShadowCameraSettings(l, this.device, n, i, r);
        const c = i === pe ? 0 : s;
        return l.renderTarget = e._shadowMap.renderTargets[c],
        l
    }
    renderFace(e, t, s, i, n=!0) {
        const r = this.device
          , o = this.getLightRenderData(e, t, s)
          , l = o.shadowCamera;
        this.dispatchUniforms(e, l, o, s);
        const c = l.renderTarget
          , d = this.renderer;
        d.setCameraUniforms(l, c),
        r.supportsUniformBuffers && d.setupViewUniformBuffers(o.viewBindGroups, this.viewUniformFormat, this.viewBindGroupFormat, 1),
        n ? (d.setupViewport(l, c),
        i && d.clear(l)) : d.clearView(l, c, !0, !1),
        this.setupRenderState(r, e),
        this.submitCasters(o.visibleCasters, e)
    }
    render(e, t, s=!0) {
        if (this.needsShadowRendering(e)) {
            const i = e.numShadowFaces;
            for (let n = 0; n < i; n++)
                this.prepareFace(e, t, n),
                this.renderFace(e, t, n, !0, s);
            this.renderVsm(e, t)
        }
    }
    renderVsm(e, t) {
        e._isVsm && e._vsmBlurSize > 1 && (!this.renderer.scene.clusteredLightingEnabled || e._type === pe) && this.applyVsmBlur(e, t)
    }
    getVsmBlurShader(e, t, s) {
        let i = (e ? this.blurPackedVsmShader : this.blurVsmShader)[t][s];
        if (!i) {
            this.blurVsmWeights[s] = nI(s);
            const n = $.fullscreenQuadVS;
            let r = "#define SAMPLES " + s + `
`;
            e ? r += this.blurPackedVsmShaderCode[t] : r += this.blurVsmShaderCode[t];
            const o = "blurVsm" + t + s + e;
            i = Ys(this.device, n, r, o),
            e ? this.blurPackedVsmShader[t][s] = i : this.blurVsmShader[t][s] = i
        }
        return i
    }
    applyVsmBlur(e, t) {
        const s = this.device;
        s.setBlendState(ft.NOBLEND);
        const r = e.getRenderData(e._type === pe ? t : null, 0).shadowCamera.renderTarget
          , o = this.renderer.shadowMapCache.get(s, e)
          , l = o.renderTargets[0]
          , c = e._shadowType === zs
          , d = e.vsmBlurMode
          , h = e._vsmBlurSize
          , u = this.getVsmBlurShader(c, d, h);
        Sl.z = e._shadowResolution - 2,
        Sl.w = Sl.z,
        this.sourceId.setValue(r.colorBuffer),
        Rr[0] = 1 / e._shadowResolution,
        Rr[1] = 0,
        this.pixelOffsetId.setValue(Rr),
        d === Y_ && this.weightId.setValue(this.blurVsmWeights[h]),
        ya(s, l, u, null, Sl),
        this.sourceId.setValue(l.colorBuffer),
        Rr[1] = Rr[0],
        Rr[0] = 0,
        this.pixelOffsetId.setValue(Rr),
        ya(s, r, u, null, Sl),
        this.renderer.shadowMapCache.add(e, o)
    }
    initViewBindGroupFormat() {
        this.device.supportsUniformBuffers && !this.viewUniformFormat && (this.viewUniformFormat = new Sf(this.device,[new vt("matrix_viewProjection",No)]),
        this.viewBindGroupFormat = new wf(this.device,[new xf(rc,jo | Cs)],[]))
    }
    frameUpdate() {
        this.initViewBindGroupFormat()
    }
}
const Yc = [];
class rI {
    constructor(e) {
        this._empty = null,
        this._allocated = [],
        this._clusters = new Map,
        this.device = e
    }
    destroy() {
        this._empty && (this._empty.destroy(),
        this._empty = null),
        this._allocated.forEach(e => {
            e.destroy()
        }
        ),
        this._allocated.length = 0
    }
    get count() {
        return this._allocated.length
    }
    get empty() {
        if (!this._empty) {
            const e = new Rm(this.device);
            e.name = "ClusterEmpty",
            e.update([], !1, null),
            this._empty = e
        }
        return this._empty
    }
    assign(e) {
        const t = this.empty;
        Yc.push(...this._allocated),
        this._allocated.length = 0,
        this._clusters.clear();
        const s = e.length;
        for (let n = 0; n < s; n++) {
            const o = e[n].renderActions;
            if (o) {
                const l = o.length;
                for (let c = 0; c < l; c++) {
                    const d = o[c];
                    d.lightClusters = null;
                    const h = d.layer;
                    if (h.hasClusteredLights && h.meshInstances.length) {
                        const u = h.getLightIdHash()
                          , f = this._clusters.get(u);
                        let p = f == null ? void 0 : f.lightClusters;
                        if (!p) {
                            var i;
                            p = (i = Yc.pop()) != null ? i : new Rm(this.device),
                            this._allocated.push(p),
                            this._clusters.set(u, d)
                        }
                        d.lightClusters = p
                    }
                    d.lightClusters || (d.lightClusters = t)
                }
            }
        }
        Yc.forEach(n => n.destroy()),
        Yc.length = 0
    }
    update(e, t, s) {
        this.assign(e),
        this._clusters.forEach(i => {
            const n = i.layer;
            i.lightClusters.update(n.clusteredLightsSet, t, s)
        }
        )
    }
}
const m0 = `
	attribute vec2 vertex_position;
	varying vec2 uv0;
	void main(void) {
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		uv0 = vertex_position.xy * 0.5 + 0.5;
		#ifndef WEBGPU
			uv0.y = 1.0 - uv0.y;
		#endif
	}`
  , aI = `
	varying vec2 uv0;
	uniform sampler2D blitTexture;
	void main(void) {
		gl_FragColor = texture2D(blitTexture, uv0);
	}`
  , oI = `
	varying vec2 uv0;
	uniform samplerCube blitTexture;
	uniform mat4 invViewProj;
	void main(void) {
		vec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);
		vec4 worldPos = invViewProj * projPos;
		gl_FragColor = textureCube(blitTexture, worldPos.xyz);
	}`
  , Xn = new M
  , op = [];
class ag extends Js {
    constructor(e, t) {
        super(e),
        this._quadRenderer2D = null,
        this._quadRendererCube = null,
        this._filteredLights = [],
        this._cubeSlotsOffsets = t,
        this.requiresCubemaps = !1,
        this.blitTextureId = e.scope.resolve("blitTexture"),
        this.invViewProjId = e.scope.resolve("invViewProj")
    }
    destroy() {
        var e, t;
        (e = this._quadRenderer2D) == null || e.destroy(),
        this._quadRenderer2D = null,
        (t = this._quadRendererCube) == null || t.destroy(),
        this._quadRendererCube = null
    }
    static create(e, t) {
        const s = new ag(e.device,t);
        return s.init(e),
        s.colorOps.clear = !1,
        s.depthStencilOps.clearDepth = !1,
        s
    }
    update(e) {
        const t = this._filteredLights;
        this.filter(e, t),
        this.executeEnabled = t.length > 0
    }
    filter(e, t) {
        for (let s = 0; s < e.length; s++) {
            const i = e[s];
            i._type !== pe && i.atlasViewportAllocated && i.atlasSlotUpdated && i.enabled && i.cookie && i.visibleThisFrame && t.push(i)
        }
    }
    initInvViewProjMatrices() {
        if (!op.length)
            for (let e = 0; e < 6; e++) {
                const t = vi.create(null, Oe, e)
                  , s = t.projectionMatrix
                  , i = t.node.getLocalTransform().clone().invert();
                op[e] = new ee().mul2(s, i).invert()
            }
    }
    get quadRenderer2D() {
        if (!this._quadRenderer2D) {
            const e = Ys(this.device, m0, aI, "cookieRenderer2d");
            this._quadRenderer2D = new Mm(e)
        }
        return this._quadRenderer2D
    }
    get quadRendererCube() {
        if (!this._quadRendererCube) {
            const e = Ys(this.device, m0, oI, "cookieRendererCube");
            this._quadRendererCube = new Mm(e)
        }
        return this._quadRendererCube
    }
    execute() {
        const e = this.device;
        e.setBlendState(ft.NOBLEND),
        e.setCullMode(bt),
        e.setDepthState($t.NODEPTH),
        e.setStencilState();
        const t = this.renderTarget.colorBuffer.width
          , s = this._cubeSlotsOffsets
          , i = this._filteredLights;
        for (let n = 0; n < i.length; n++) {
            const r = i[n]
              , o = r.numShadowFaces
              , l = o > 1 ? this.quadRendererCube : this.quadRenderer2D;
            o > 1 && this.initInvViewProjMatrices(),
            this.blitTextureId.setValue(r.cookie);
            for (let c = 0; c < o; c++) {
                if (Xn.copy(r.atlasViewport),
                o > 1) {
                    const d = Xn.z / 3
                      , h = s[c];
                    Xn.x += d * h.x,
                    Xn.y += d * h.y,
                    Xn.z = d,
                    Xn.w = d,
                    this.invViewProjId.setValue(op[c].data)
                }
                Xn.mulScalar(t),
                l.render(Xn)
            }
        }
        i.length = 0
    }
}
class lI extends Js {
    constructor(e, t, s) {
        super(e),
        this.requiresCubemaps = !1,
        this.shadowRenderer = t,
        this.shadowRendererLocal = s
    }
    update(e) {
        const t = this.shadowRendererLocal.shadowLights
          , s = this.shadowRendererLocal.prepareLights(t, e)
          , i = t.length;
        this.enabled = i > 0,
        i && this.shadowRenderer.setupRenderPass(this, s, !1)
    }
    execute() {
        const e = this.shadowRendererLocal.shadowLights
          , t = e.length;
        for (let s = 0; s < t; s++) {
            const i = e[s];
            for (let n = 0; n < i.numShadowFaces; n++)
                this.shadowRenderer.renderFace(i, null, n, !0)
        }
        e.length = 0
    }
}
class hI extends Js {
    constructor(e, t, s, i, n) {
        super(e),
        this.renderer = t,
        this.frameGraph = null,
        this.cookiesRenderPass = ag.create(n.cookieRenderTarget, n.cubeSlotsOffsets),
        this.beforePasses.push(this.cookiesRenderPass),
        this.shadowRenderPass = new lI(e,s,i),
        this.beforePasses.push(this.shadowRenderPass)
    }
    update(e, t, s, i, n) {
        this.frameGraph = e,
        this.cookiesRenderPass.enabled = s,
        s && this.cookiesRenderPass.update(i),
        this.shadowRenderPass.enabled = t,
        t && this.shadowRenderPass.update(n)
    }
    destroy() {
        this.cookiesRenderPass.destroy(),
        this.cookiesRenderPass = null
    }
    execute() {
        const {renderer: e} = this
          , {scene: t} = e;
        e.worldClustersAllocator.update(this.frameGraph.renderPasses, t.gammaCorrection, t.lighting)
    }
}
const cI = "muPIHORMLNDCz4DxVR/ZvYfAUVEFR47KRIC4nwAAAAAP7WxlhD6Ci+2HCe7BF8jRAPZwdH2UPpI5PdLCJdkvG4UTaNDJ/0crAzne71GCrb4kbdMjjCEGzdX6fNxDMLJq5xkeoIVTdfiZkodEeArmZmp/FQzFjD4x8iOW7Dg64n+3mWqyEwLxXT8zoJXfbw8QJKDCaarUYyTlMzNFHbgUe9IQV7g4YOgtSKpIFZJ0qERm7u4PpmiF89ktHWCywaGmD6h+hfh2/Zd8KYlKqqo4Cem4T42bT/Z9FpCQF1hhSjfBzZ5XFn/y3jegWC6u86KuELRundQS/1Rp+XuKKGIgRv3CvP5y749yqLlFO495JOT3+f2CXgd71npU0/KjjpkZucbJ5m78IVyuSrSozc9jgBUhDrz0hFsyb7LFUH9//wJbBgLdNWJZObfKxrNt8TliLA9w9sXFv6g26iXpf6r/BqcAusj/QzGBZuoUGeEtw8BCXCZ3jUiw4hvM18ZVqlUD3C40LAFXW6FRjuAZGRNstb0/qVk4skwyT+MHrvRorI4rKHVMWZmKyAkzL/78u/9pMQuX14pZN50b2PHn6fRxeaCQLsfT4dpvIkWWFuFVENZIh+8xgR6lU+85W0PPdAu1j99kcCG40JBQa4JMyRzq6qriOBLtqF87vpCJan0WEduVr/mOYkS00urVA0mA6M3031+GmGmW48PaJDYOEIb3bIXWPaLoAOEinX1TN3+/vwhG6nqJu0TdHpedS7QsGZIoxH3nQYYjQP1jmbahlbNngw5ogsGk1y50XZyUmQBY+/JBJ3Unu4dApm+WmPwHPU9gLb+4mHh4BiY6M86pq+WeTyWdI3s0CXPEtHGXZ8zMZgUoyRomBi1VdazzuN+WOmQ9Pa0Z0tlNopUi8AJ4x2Xn4mmOKEbXLxlbVsWu8XhuDGYFOGCRVdSqDPXrHU5SDdUlti3k5///SBwzTMwK3L4a1H7w4lnpEas6////AfX8asyIBfeFXVJ3tgvxQ/blZuUKyIODIfr/UzdWNu7pciLBpdZRZ4pIfZ1R6szq+XNxkGG///8EZFpu7VHAhFWqHEOrB9unw+YQa5o8/9IR/V5/zq+986rJSyfgJKt2u9hxU1wzyQWPjJGvzG9+eWWxGFOHVKqI4jBQALwZZswesnvZ2UmmkEXdiRpz8B+oWE7PY70ZTMndisYSXg2TqoI+3y9BxbnY2Y4EfbdcRhAvG59NqDENNYbxKvK5HJfPG5M+Wi2AcpLVJrD6caiEOzgSoVNSgQK8fm2M3zGcF4xtClv/8Hs9oD7C3jitTATYNQxmKqKf1LhIxzf1bmfiNn7UKFmcJu4sLqVLwxGSue3taBEyknkw5hXTsUCvqmmL/f8n/w0giR7Hu/9EHvpkz3yuu64TioMkzdTJ30i0+hFnQqW1+v9mMwq+z9qGX0UFu9MomvVG2xod6vc12AAAAACq7sGa5qptFR0jF3nQt/D+7PibKYahaxP3hEixPbGi9nwNf2LAa7LkEZRKxzXeCD64Xpii5n+8Kpg8eHIv7AWXZltgMoGltmoJ0XGdOCL8WkzphvR9N2o3ARSZ42l5e5Pe4B58MCRlP3EKv+mcloknH+fto5BWsmEutW6KvjOVsznFCktkSczVk4aGvj9VXlRcLeDoKG8RkBgdcNG2bf8HUL4MT2DM+ar7NImJhKpxakX4Vk0CnP+/XNhl5UsP0lXgeZXPoDBMSW5An+DXlTCO5FQGwSPYwHLKYVIimEdAoVe49rQLaaNcye5LxU2/c5TijTgJtD5eQQIe1snxauj5jZsxJBUJdoP/zqpjqv8qBruoPsVsP8N44PCUW5Dd0DzqjSS/Dl5mI9cn1w2ndN/0KAEm1QAAAACwu6KM/083IBbH5bPa/9oHUwcU8I9v3j6/v18QYammrf+P6VL///8BrpuM3fOLCxaLNOFNF1zPbPYTP65ni6njft4eVcyrVXRQFrs52tr35StiSp55edVDCBC0H5rIfac6nzUwxQSt7y15QoKb+5zebEQUmVbrPjXuUa19Ey7sqXMiSUKHaw72PJKDdrutJoQr3u6lEYJ8K0MakWKj9zjTFi4X94TsKYco0GrLeB60M6D8M/80rhXUW8iMequg8y5F838WI0+gp3GBN5Kj/xIOxTWQuUaPV/LwvARr1VH93BFgGZR1MFW0Ua30GbYmdnAgo9VWy8SQtpDUgGE2r2zq2eTEMCL7sMKmE1hchVhuF/TCq9iXKEm86kzOf3Rp9ZnCxbpDUj+FKNxVyXe6pVZkRXv/m95SnB/EB8aME29N85MtAcDoXWlor8De2Q5Dg1tar+8wgiZufbMam81j//ASUohoR/zSh2KG4bvT6mkIPz6C5/98DC3LaWlaEZ1zA5JORZRu6J/a0GY285sEYzw71YqOT1ihAG0z5SDt1xNiDQWZdFpndArp6xWhqSDkRb4kSJEHb9liPvw7uLV/6i5MVf//A9Qjr8xkAEUh+KDI+zdtJ68d6MBOktg1iyp/SCq8O9f5pbamn1VVVQPRTWqNBvhQKa07s6P0lc9Luu/3gw4HeyOUfz8MxMwV4UQhua+t9cr4bz/nIB2wnDSK1K7I94M+s6C84htaX/CNlMQUSs2KJO+yaebfTbkNX5yWcqEJevo0vbKUiETuFXiL019A3E+lmsyZMwXrXLLiQAZ5t9+jI3JobhJTMiDH5ZOQ+8Jau5555NMjHSscP9qCVaa40doh+1a3Ukf6jqBmLddgh79/fwTfCyqiuldNkUoy+nUp+4nerwg0OjtGv2x485PJOJvUEokNhYIdWjpx7BWk0VZGWOp3jSFTJ2bnu6KCduZtG/UcBC9RZ3W/jMSfSMw4Etr/DoD/XYP2V5Ovw+YoM3F5g2dGLdvuG6ZkVGLE6Dk5Zr+sdSyGliJP1y2OFf/KFO0RWO+3gsGhesTnfZVpTd8/HwgO216gwaqo+vY3TljfJWowY+i0p0Os4SLn/1wLqDHMlszggmT/D8MRFzs+pLv6LNJSsNZ/r41mWi/rF6ZcKp/yzJdK0VU44hskq3RGpgO6mIpJDsf/mZkFrz0yYOMLbuaj/wp1v7JMFM5eqvBhmTd7U8frQAtHtys4zgpjZmzUhOVTfNNLifElGXADlqHGKrkBT/nYwX8ZRm3RjvyPvjKyEqEGKUpVnvOGx+NKPHiWM//ZDpDVGvvrjmk8RPF/wiYZD3+Us8YCXjrVOfjdd1UPAfjLp8jgSn4me7DPTpz1Ggy9XL80guFO7ECT10AvILKfD18Qx+KY/f8aRqu0oOO8hfKRFZa9PUJwCsp6VdZz6LFkm2b9Pl2LIifCwzRy7TpdG2uAtOxP2OemY26bJMa9ZGSLIRlMsgpDpnDJwd0oa5pQ13x1hrHf52HpulUWonGWsfXZbSQYKu9bnEN76ciQih0opN3deDVrbrxorfVlnCmL1R9zq3ePGWIv21c7pW8kEiFTM5JX8dAw867s/60cf79/BH+MDFCZBHlz1L+qGOJf/1txhhmrf3//As+RIJwevDb+fgNXVeHw67QptZegayhrEwr5Gy+EPo1RLaMtPbqOZYoVzXzwzjMFWZxyUG9YUIf6////AQWy84iAygLk9COtXt92+0mT/xg0zMzMBeLkb8y9SL2TDXgSX422hDgpGNLJyuPioA+YJ91G8znrpNqHkwYyscaJDEc9Vc+j4cXle3hvcd2JqDQH2lBZxDn6mUTs0b75raMvbs727codX01Anj8f3wir9P2xQaQ22v/TxCMglKDFoTjaP01XTLgxnTvPv02JgEUrW6UDgOnobFpLdvKdlypgIzPcq14fgXU5tvVW0FEs7VRlsG1IyA69fN4n+awHhT34cE+xUvdj86C8LgAsFheTjI9Ht9EyYAAAAAAVBVKRx2wLgUTI0/2QfyJo2riRw3JDqzEShmx/Lifo6mRkQVbS7X53t+EvKxcXogtdts31e9MRHdcHgsA8rt4/mt2unlzQ/wsU8Gu7+W6Oj7eD8EQdDp5XlCsVaS/AV/t5ZpPOHR3rGpyAJe9IPV+xMrBL1Oz/8MQhFs31h0N1cVnq371uqIJYHyafKH1jteAK3VpMXBcuC+yt0ZeKyRUY4QhdrJJ4tJ1wg3Hu6kDsbovxupTMkGdRrm8oZSoYPbJ+PwH/xotgTdkA1205vUEfnqkI04T/fnnd1fiZW5AwNcggd7fi4j5zasmcntZexIxqFZQMzMJpfndmI5jn17cgn5EV5t9XN0C///8Q9wlJpMGXdoiaMTG2sVyHQsn8mWRISCLNG777S0OuDRP2GlLcJ2UeOg7Fo8hTNPeJ//iTJhyqxhKRUntdXOihq2wfKfH///8B0GGrwT+fSOQRdctKxjjGCSS11d6BlQ9BDfE0J6Z25FaNTKGpFKNCMr2G/041KpWwBLVe1k08vncseQbKZdXi8x1t9XA45U/Wd43D9wAh3Tal0aiLVzGPusOZ1F+W3TWoqlX/A95+dNef11TsuGful+ctGssldk3fqpfqh+43XTxL42+leSHoF/dWHYGX6maqUEuLX7UB+r/6Llr4LKocbVIeu+hB9QTPfz9fCP8RyWmX4SmbhMFsNtCijV7lVcwejLKlvl0GfCndnWV7/39VBrtTRuUx92oke3GBgKkC5fdGK0YvNK+xenKaDmsHDjNFUM3NMz3ZiXXFuLgojosPVCDEl2W5BjX3Ms+j0GSqACHmh0+RPWyuNm/Qe8vFf9AW7N1uRaxWirrUytqEJnJ4/Flm8hSoiZ2NQBsS6w/yQlC4gCaFo8q4nyY6AFdo4hiwhBXzbNKKvZvktCjSCukRR/BbYVbNwZi2Yh3hGodEacLW8qijiWJODf0P2bhfaiPspPT4lYJBgi/KfcFwCfvyUIgkJOv///8CG/JEepRBLaMFE+2TgrqsJXOVOWHt6g/bFwVLLMVBsMR50dis/39/AlBX+/rMTJkUQrnlxpR2iu0Tp8tATkRYGmDIrcAiRP8PjoWIlb7/0ecTdSCE9Y58+a+n/FovJQTVF4F2jAxMZhTgrM/KVS5BQu6bVbkWY5HXnxRshks3urDdW4RkWp4M4TeLmFK5KF/uHkkiO5Kv96RioH984v/CSDBnG+BwlnU9B+o7Y+0X0Nob+0pLsStxjvPXMy2eCpzhOWV4XbObBHN4UE2sLQ/DIqXhOzxVf38GlTi6aG7EnePO7TRJm9yOfUUcqq1I2iQHrVDqn3TUNRi/lMw8KbMW/3/nqCz/Ef8PoW5Qxcz2yHR/f78EPB2Stbd+ZFmfNTUYILzsb9YNhpaHcaymYrBiNHmFE3Y4ccYJ25Prqm7zHobGHED8/93ZNlWro9vcKivGZs31UiK1k5zjUhexUgbqJb+fUTjxce/7Zly8a5KMC1fX5nfjPgibdvzbXV1jRT2asXvmSAusaLdq1TSIJ8fXINk5AtT34EWPAsfP9IFQqM5K11O6saoHJA==";
let mn = null;
const mx = () => {
    if (!mn) {
        const a = atob(cI);
        mn = Uint8Array.from(a, e => e.charCodeAt(0))
    }
}
  , dI = () => (mx(),
mn);
class uI {
    constructor(e=0) {
        this.seed = 0,
        this.seed = e * 4,
        mx()
    }
    _next() {
        this.seed = (this.seed + 4) % mn.length
    }
    value() {
        return this._next(),
        mn[this.seed] / 255
    }
    vec4(e=new M) {
        return this._next(),
        e.set(mn[this.seed], mn[this.seed + 1], mn[this.seed + 2], mn[this.seed + 3]).mulScalar(1 / 255)
    }
}
const fI = new Os;
function pI(a) {
    return fI.get(a, () => {
        const e = dI()
          , t = Math.sqrt(e.length / 4)
          , s = new ge(a,{
            name: `BlueNoise${t}`,
            width: t,
            height: t,
            format: ve,
            addressU: wt,
            addressV: wt,
            type: $s,
            magFilter: be,
            minFilter: be,
            anisotropy: 1,
            mipmaps: !1
        });
        return s.lock().set(e),
        s.unlock(),
        s
    }
    )
}
let lp = 0;
const xl = [0, 0, 0, 0]
  , Ir = new ee
  , jn = new ee
  , za = new ee
  , _0 = new Ci
  , hp = new b_
  , g0 = new ee().setScale(1, -1, 1)
  , cp = new Set
  , dp = new Set
  , mI = new M
  , y0 = new ee().set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, .5, 0, 0, 0, .5, 1])
  , v0 = [new P(.5,.333333), new P(.25,.666667), new P(.75,.111111), new P(.125,.444444), new P(.625,.777778), new P(.375,.222222), new P(.875,.555556), new P(.0625,.888889), new P(.5625,.037037), new P(.3125,.37037), new P(.8125,.703704), new P(.1875,.148148), new P(.6875,.481481), new P(.4375,.814815), new P(.9375,.259259), new P(.03125,.592593)]
  , _I = new ee
  , gI = new ee
  , yI = new ee
  , vI = new ee
  , SI = new ee
  , xI = new ee
  , Va = new Set
  , up = []
  , fp = [];
class wI {
    constructor(e) {
        this.clustersDebugRendered = !1,
        this.processingMeshInstances = new Set,
        this.worldClustersAllocator = void 0,
        this.lights = [],
        this.localLights = [],
        this.cameraDirShadowLights = new Map,
        this.dirLightShadows = new Map,
        this.blueNoise = new uI(123),
        this.device = e,
        this.scene = null,
        this.worldClustersAllocator = new rI(e),
        this.lightTextureAtlas = new qR(e),
        this.shadowMapCache = new ZR,
        this.shadowRenderer = new Ef(this,this.lightTextureAtlas),
        this._shadowRendererLocal = new JR(this,this.shadowRenderer),
        this._shadowRendererDirectional = new sI(this,this.shadowRenderer),
        this._renderPassUpdateClustered = new hI(this.device,this,this.shadowRenderer,this._shadowRendererLocal,this.lightTextureAtlas),
        this.viewUniformFormat = null,
        this.viewBindGroupFormat = null,
        this._skinTime = 0,
        this._morphTime = 0,
        this._cullTime = 0,
        this._shadowMapTime = 0,
        this._lightClustersTime = 0,
        this._layerCompositionUpdateTime = 0,
        this._shadowDrawCalls = 0,
        this._skinDrawCalls = 0,
        this._instancedDrawCalls = 0,
        this._shadowMapUpdates = 0,
        this._numDrawCallsCulled = 0,
        this._camerasRendered = 0,
        this._lightClusters = 0;
        const t = e.scope;
        this.boneTextureId = t.resolve("texture_poseMap"),
        this.boneTextureSizeId = t.resolve("texture_poseMapSize"),
        this.poseMatrixId = t.resolve("matrix_pose[0]"),
        this.modelMatrixId = t.resolve("matrix_model"),
        this.normalMatrixId = t.resolve("matrix_normal"),
        this.viewInvId = t.resolve("matrix_viewInverse"),
        this.viewPos = new Float32Array(3),
        this.viewPosId = t.resolve("view_position"),
        this.projId = t.resolve("matrix_projection"),
        this.projSkyboxId = t.resolve("matrix_projectionSkybox"),
        this.viewId = t.resolve("matrix_view"),
        this.viewId3 = t.resolve("matrix_view3"),
        this.viewProjId = t.resolve("matrix_viewProjection"),
        this.flipYId = t.resolve("projectionFlipY"),
        this.tbnBasis = t.resolve("tbnBasis"),
        this.nearClipId = t.resolve("camera_near"),
        this.farClipId = t.resolve("camera_far"),
        this.cameraParams = new Float32Array(4),
        this.cameraParamsId = t.resolve("camera_params"),
        this.viewIndexId = t.resolve("view_index"),
        this.blueNoiseJitterId = t.resolve("blueNoiseJitter"),
        this.blueNoiseTextureId = t.resolve("blueNoiseTex32"),
        this.alphaTestId = t.resolve("alpha_ref"),
        this.opacityMapId = t.resolve("texture_opacityMap"),
        this.exposureId = t.resolve("exposure"),
        this.twoSidedLightingNegScaleFactorId = t.resolve("twoSidedLightingNegScaleFactor"),
        this.twoSidedLightingNegScaleFactorId.setValue(0),
        this.morphWeightsA = t.resolve("morph_weights_a"),
        this.morphWeightsB = t.resolve("morph_weights_b"),
        this.morphPositionTex = t.resolve("morphPositionTex"),
        this.morphNormalTex = t.resolve("morphNormalTex"),
        this.morphTexParams = t.resolve("morph_tex_params"),
        this.lightCube = new KR,
        this.constantLightCube = t.resolve("lightCube[0]")
    }
    destroy() {
        this.shadowRenderer = null,
        this._shadowRendererLocal = null,
        this._shadowRendererDirectional = null,
        this.shadowMapCache.destroy(),
        this.shadowMapCache = null,
        this._renderPassUpdateClustered.destroy(),
        this._renderPassUpdateClustered = null,
        this.lightTextureAtlas.destroy(),
        this.lightTextureAtlas = null
    }
    sortCompare(e, t) {
        if (e.layer === t.layer) {
            if (e.drawOrder && t.drawOrder)
                return e.drawOrder - t.drawOrder;
            if (e.zdist && t.zdist)
                return t.zdist - e.zdist;
            if (e.zdist2 && t.zdist2)
                return e.zdist2 - t.zdist2
        }
        return t._key[Sn] - e._key[Sn]
    }
    sortCompareMesh(e, t) {
        if (e.layer === t.layer) {
            if (e.drawOrder && t.drawOrder)
                return e.drawOrder - t.drawOrder;
            if (e.zdist && t.zdist)
                return t.zdist - e.zdist
        }
        const s = e._key[Sn]
          , i = t._key[Sn];
        return s === i && e.mesh && t.mesh ? t.mesh.id - e.mesh.id : i - s
    }
    sortCompareDepth(e, t) {
        const s = e._key[Em]
          , i = t._key[Em];
        return s === i && e.mesh && t.mesh ? t.mesh.id - e.mesh.id : i - s
    }
    setupViewport(e, t) {
        const s = this.device
          , i = t ? t.width : s.width
          , n = t ? t.height : s.height
          , r = e.rect;
        let o = Math.floor(r.x * i)
          , l = Math.floor(r.y * n)
          , c = Math.floor(r.z * i)
          , d = Math.floor(r.w * n);
        if (s.setViewport(o, l, c, d),
        e._scissorRectClear) {
            const h = e.scissorRect;
            o = Math.floor(h.x * i),
            l = Math.floor(h.y * n),
            c = Math.floor(h.z * i),
            d = Math.floor(h.w * n)
        }
        s.setScissor(o, l, c, d)
    }
    setCameraUniforms(e, t) {
        const s = t == null ? void 0 : t.flipY;
        let i = 1;
        if (e.xr && e.xr.session) {
            var n;
            const l = ((n = e._node) == null || (n = n.parent) == null ? void 0 : n.getWorldTransform()) || null
              , c = e.xr.views;
            i = c.list.length;
            for (let d = 0; d < i; d++) {
                const h = c.list[d];
                h.updateTransforms(l),
                e.frustum.setFromMat4(h.projViewOffMat)
            }
        } else {
            let l = e.projectionMatrix;
            e.calculateProjection && e.calculateProjection(l, Gc);
            let c = e.getProjectionMatrixSkybox();
            s && (l = _I.mul2(g0, l),
            c = gI.mul2(g0, c)),
            this.device.isWebGPU && (l = yI.mul2(y0, l),
            c = vI.mul2(y0, c));
            const {jitter: d} = e;
            let h = M.ZERO;
            if (d > 0) {
                const u = t ? t.width : this.device.width
                  , f = t ? t.height : this.device.height
                  , p = v0[this.device.renderVersion % v0.length]
                  , _ = d * (p.x * 2 - 1) / u
                  , m = d * (p.y * 2 - 1) / f;
                l = SI.copy(l),
                l.data[8] = _,
                l.data[9] = m,
                c = xI.copy(c),
                c.data[8] = _,
                c.data[9] = m,
                h = this.blueNoise.vec4(mI)
            }
            if (this.blueNoiseJitterId.setValue([h.x, h.y, h.z, h.w]),
            this.projId.setValue(l.data),
            this.projSkyboxId.setValue(c.data),
            e.calculateTransform)
                e.calculateTransform(jn, Gc);
            else {
                const u = e._node.getPosition()
                  , f = e._node.getRotation();
                jn.setTRS(u, f, y.ONE)
            }
            this.viewInvId.setValue(jn.data),
            za.copy(jn).invert(),
            this.viewId.setValue(za.data),
            _0.setFromMat4(za),
            this.viewId3.setValue(_0.data),
            Ir.mul2(l, za),
            this.viewProjId.setValue(Ir.data),
            this.flipYId.setValue(s ? -1 : 1),
            this.dispatchViewPos(e._node.getPosition()),
            e.frustum.setFromMat4(Ir)
        }
        this.tbnBasis.setValue(s ? -1 : 1);
        const r = e._nearClip
          , o = e._farClip;
        return this.nearClipId.setValue(r),
        this.farClipId.setValue(o),
        this.cameraParams[0] = 1 / o,
        this.cameraParams[1] = o,
        this.cameraParams[2] = r,
        this.cameraParams[3] = e.projection === Co ? 1 : 0,
        this.cameraParamsId.setValue(this.cameraParams),
        this.exposureId.setValue(this.scene.physicalUnits ? e.getExposure() : this.scene.exposure),
        i
    }
    clear(e, t, s, i) {
        const n = (t ?? e._clearColorBuffer ? Oo : 0) | (s ?? e._clearDepthBuffer ? Fo : 0) | (i ?? e._clearStencilBuffer ? fh : 0);
        n && this.device.clear({
            color: [e._clearColor.r, e._clearColor.g, e._clearColor.b, e._clearColor.a],
            depth: e._clearDepth,
            stencil: e._clearStencil,
            flags: n
        })
    }
    setCamera(e, t, s, i=null) {
        this.setCameraUniforms(e, t),
        this.clearView(e, t, s, !1)
    }
    clearView(e, t, s, i) {
        const n = this.device;
        if (n.setRenderTarget(t),
        n.updateBegin(),
        i && (n.setColorWrite(!0, !0, !0, !0),
        n.setDepthWrite(!0)),
        this.setupViewport(e, t),
        s) {
            const r = e._clearOptions;
            n.clear(r || {
                color: [e._clearColor.r, e._clearColor.g, e._clearColor.b, e._clearColor.a],
                depth: e._clearDepth,
                flags: (e._clearColorBuffer ? Oo : 0) | (e._clearDepthBuffer ? Fo : 0) | (e._clearStencilBuffer ? fh : 0),
                stencil: e._clearStencil
            })
        }
    }
    setupCullMode(e, t, s) {
        const i = s.material;
        let n = bt;
        if (e) {
            let r = 1;
            (i.cull === Zl || i.cull === dr) && (r = t * s.flipFacesFactor * s.node.worldScaleSign),
            r < 0 ? n = i.cull === Zl ? dr : Zl : n = i.cull
        }
        this.device.setCullMode(n),
        n === bt && i.cull === bt && this.twoSidedLightingNegScaleFactorId.setValue(s.node.worldScaleSign)
    }
    updateCameraFrustum(e) {
        if (e.xr && e.xr.views.list.length) {
            const s = e.xr.views.list[0];
            Ir.mul2(s.projMat, s.viewOffMat),
            e.frustum.setFromMat4(Ir);
            return
        }
        const t = e.projectionMatrix;
        if (e.calculateProjection && e.calculateProjection(t, Gc),
        e.calculateTransform)
            e.calculateTransform(jn, Gc);
        else {
            const s = e._node.getPosition()
              , i = e._node.getRotation();
            jn.setTRS(s, i, y.ONE),
            this.viewInvId.setValue(jn.data)
        }
        za.copy(jn).invert(),
        Ir.mul2(t, za),
        e.frustum.setFromMat4(Ir)
    }
    setBaseConstants(e, t) {
        e.setCullMode(t.cull),
        t.opacityMap && this.opacityMapId.setValue(t.opacityMap),
        (t.opacityMap || t.alphaTest > 0) && this.alphaTestId.setValue(t.alphaTest)
    }
    updateCpuSkinMatrices(e) {
        lp++;
        const t = e.length;
        if (t !== 0)
            for (let s = 0; s < t; s++) {
                const i = e[s].skinInstance;
                i && (i.updateMatrices(e[s].node, lp),
                i._dirty = !0)
            }
    }
    updateGpuSkinMatrices(e) {
        for (const t of e) {
            const s = t.skinInstance;
            s && s._dirty && (s.updateMatrixPalette(t.node, lp),
            s._dirty = !1)
        }
    }
    updateMorphing(e) {
        for (const t of e) {
            const s = t.morphInstance;
            s && s._dirty && s.update()
        }
    }
    updateGSplats(e) {
        for (const s of e) {
            var t;
            (t = s.gsplatInstance) == null || t.update()
        }
    }
    gpuUpdate(e) {
        this.updateGpuSkinMatrices(e),
        this.updateMorphing(e),
        this.updateGSplats(e)
    }
    setVertexBuffers(e, t) {
        e.setVertexBuffer(t.vertexBuffer)
    }
    setMorphing(e, t) {
        if (t)
            if (t.morph.useTextureMorph)
                e.setVertexBuffer(t.morph.vertexBufferIds),
                this.morphPositionTex.setValue(t.texturePositions),
                this.morphNormalTex.setValue(t.textureNormals),
                this.morphTexParams.setValue(t._textureParams);
            else {
                for (let s = 0; s < t._activeVertexBuffers.length; s++) {
                    const i = t._activeVertexBuffers[s];
                    if (i) {
                        const n = vT + (s + 8);
                        i.format.elements[0].name = n,
                        i.format.elements[0].scopeId = e.scope.resolve(n),
                        i.format.update(),
                        e.setVertexBuffer(i)
                    }
                }
                this.morphWeightsA.setValue(t._shaderMorphWeightsA),
                this.morphWeightsB.setValue(t._shaderMorphWeightsB)
            }
    }
    setSkinning(e, t) {
        if (t.skinInstance)
            if (this._skinDrawCalls++,
            e.supportsBoneTextures) {
                const s = t.skinInstance.boneTexture;
                this.boneTextureId.setValue(s),
                xl[0] = s.width,
                xl[1] = s.height,
                xl[2] = 1 / s.width,
                xl[3] = 1 / s.height,
                this.boneTextureSizeId.setValue(xl)
            } else
                this.poseMatrixId.setValue(t.skinInstance.matrixPalette)
    }
    dispatchViewPos(e) {
        const t = this.viewPos;
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        this.viewPosId.setValue(t)
    }
    initViewBindGroupFormat(e) {
        if (this.device.supportsUniformBuffers && !this.viewUniformFormat) {
            const t = [new vt("matrix_viewProjection",No), new vt("cubeMapRotationMatrix",yh), new vt("view_position",As), new vt("skyboxIntensity",yi), new vt("exposure",yi), new vt("textureBias",yi)];
            e && t.push(new vt("clusterCellsCountByBoundsSize",As), new vt("clusterTextureSize",As), new vt("clusterBoundsMin",As), new vt("clusterBoundsDelta",As), new vt("clusterCellsDot",As), new vt("clusterCellsMax",As), new vt("clusterCompressionLimit0",mr), new vt("shadowAtlasParams",mr), new vt("clusterMaxCells",pa), new vt("clusterSkip",yi)),
            this.viewUniformFormat = new Sf(this.device,t);
            const s = [new xf(rc,jo | Cs)]
              , i = [new Jn("lightsTextureFloat",Cs,Es,sa), new Jn("lightsTexture8",Cs,Es,sa), new Jn("shadowAtlasTexture",Cs,Es,ko), new Jn("cookieAtlasTexture",Cs,Es,ta), new Jn("areaLightsLutTex1",Cs,Es,ta), new Jn("areaLightsLutTex2",Cs,Es,ta)];
            e && i.push(new Jn("clusterWorldTexture",Cs,Es,sa)),
            this.viewBindGroupFormat = new wf(this.device,s,i)
        }
    }
    setupViewUniformBuffers(e, t, s, i) {
        const n = this.device;
        for (; e.length < i; ) {
            const o = new bf(n,t,!1)
              , l = new lc(n,s,o);
            e.push(l)
        }
        const r = e[0];
        r.defaultUniformBuffer.update(),
        r.update(),
        n.setBindGroup(gm, r)
    }
    setupMeshUniformBuffers(e, t) {
        const s = this.device;
        if (s.supportsUniformBuffers) {
            this.modelMatrixId.setValue(t.node.worldTransform.data),
            this.normalMatrixId.setValue(t.node.normalMatrix.data);
            const i = e.getBindGroup(s);
            i.defaultUniformBuffer.update(),
            i.update(),
            s.setBindGroup(vh, i)
        }
    }
    drawInstance(e, t, s, i, n) {
        const r = t.node.worldTransform;
        this.modelMatrixId.setValue(r.data),
        n && this.normalMatrixId.setValue(t.node.normalMatrix.data);
        const o = t.instancingData;
        o ? o.count > 0 && (this._instancedDrawCalls++,
        e.setVertexBuffer(o.vertexBuffer),
        e.draw(s.primitive[i], o.count)) : e.draw(s.primitive[i])
    }
    drawInstance2(e, t, s, i) {
        const n = t.instancingData;
        n ? n.count > 0 && (this._instancedDrawCalls++,
        e.draw(s.primitive[i], n.count, !0)) : e.draw(s.primitive[i], void 0, !0)
    }
    cull(e, t, s) {
        const i = s.opaque;
        i.length = 0;
        const n = s.transparent;
        n.length = 0;
        const r = e.frustumCulling
          , o = t.length;
        for (let l = 0; l < o; l++) {
            const c = t[l];
            c.visible && (!r || !c.cull || c._isVisible(e)) && (c.visibleThisFrame = !0,
            (c.transparent ? n : i).push(c),
            (c.skinInstance || c.morphInstance || c.gsplatInstance) && (this.processingMeshInstances.add(c),
            c.gsplatInstance && c.gsplatInstance.cameras.push(e)))
        }
    }
    collectLights(e) {
        this.lights.length = 0,
        this.localLights.length = 0;
        const t = this.scene._stats
          , s = e.layerList.length;
        for (let i = 0; i < s; i++) {
            const n = e.layerList[i];
            if (!dp.has(n)) {
                dp.add(n);
                const r = n._lights;
                for (let o = 0; o < r.length; o++) {
                    const l = r[o];
                    cp.has(l) || (cp.add(l),
                    this.lights.push(l),
                    l._type !== pe && this.localLights.push(l))
                }
            }
        }
        t.lights = this.lights.length,
        cp.clear(),
        dp.clear()
    }
    cullLights(e, t) {
        const s = this.scene.clusteredLightingEnabled
          , i = this.scene.physicalUnits;
        for (let n = 0; n < t.length; n++) {
            const r = t[n];
            if (r.enabled)
                if (r._type !== pe)
                    if (r.getBoundingSphere(hp),
                    e.frustum.containsSphere(hp)) {
                        r.visibleThisFrame = !0,
                        r.usePhysicalUnits = i;
                        const o = e.getScreenSize(hp);
                        r.maxScreenSize = Math.max(r.maxScreenSize, o)
                    } else
                        s || r.castShadows && !r.shadowMap && (r.visibleThisFrame = !0);
                else
                    r.usePhysicalUnits = this.scene.physicalUnits
        }
    }
    cullShadowmaps(e) {
        const t = this.scene.clusteredLightingEnabled;
        for (let n = 0; n < this.localLights.length; n++) {
            const r = this.localLights[n];
            r._type !== pe && (t ? r.atlasSlotUpdated && r.shadowUpdateMode === Si && (r.shadowUpdateMode = ga) : r.shadowUpdateMode === Si && r.castShadows && (r.getRenderData(null, 0).shadowCamera.renderTarget || (r.shadowUpdateMode = ga)),
            r.visibleThisFrame && r.castShadows && r.shadowUpdateMode !== Si && this._shadowRendererLocal.cull(r, e))
        }
        this.cameraDirShadowLights.clear();
        const s = e.cameras;
        for (let n = 0; n < s.length; n++) {
            const r = s[n];
            if (r.enabled) {
                const o = r.camera;
                let l;
                const c = o.layers;
                for (let d = 0; d < c.length; d++) {
                    const h = e.getLayerById(c[d]);
                    if (h) {
                        const u = h.splitLights[pe];
                        for (let f = 0; f < u.length; f++) {
                            const p = u[f];
                            if (p.castShadows && !Va.has(p)) {
                                var i;
                                Va.add(p),
                                l = (i = l) != null ? i : [],
                                l.push(p),
                                this._shadowRendererDirectional.cull(p, e, o)
                            }
                        }
                    }
                }
                l && this.cameraDirShadowLights.set(o, l),
                Va.clear()
            }
        }
    }
    cullComposition(e) {
        this.processingMeshInstances.clear();
        const t = e.cameras.length;
        for (let i = 0; i < t; i++) {
            const n = e.cameras[i];
            let r, o = !0;
            this._camerasRendered++;
            const l = n.layers;
            for (let c = 0; c < l.length; c++) {
                const d = e.getLayerById(l[c]);
                if (d && d.enabled) {
                    var s;
                    const h = (s = n.renderTarget) != null ? s : d.renderTarget;
                    (o || h !== r) && (o = !1,
                    r = h,
                    n.frameUpdate(h),
                    this.updateCameraFrustum(n.camera)),
                    this.cullLights(n.camera, d._lights),
                    d.onPreCull == null || d.onPreCull(e.camerasMap.get(n));
                    const u = d.getCulledInstances(n.camera);
                    this.cull(n.camera, d.meshInstances, u),
                    d.onPostCull == null || d.onPostCull(e.camerasMap.get(n))
                }
            }
        }
        this.scene.clusteredLightingEnabled && this.updateLightTextureAtlas(),
        this.cullShadowmaps(e)
    }
    updateShaders(e, t) {
        const s = e.length;
        for (let i = 0; i < s; i++) {
            const n = e[i].material;
            if (n && !Va.has(n) && (Va.add(n),
            n.getShaderVariant !== Yi.prototype.getShaderVariant)) {
                if (t && (!n.useLighting || n.emitter && !n.emitter.lighting))
                    continue;
                n.clearVariants()
            }
        }
        Va.clear()
    }
    updateFrameUniforms() {
        this.blueNoiseTextureId.setValue(pI(this.device))
    }
    beginFrame(e) {
        const t = this.scene
          , s = t.updateShaders
          , i = e.layerList
          , n = i.length;
        for (let l = 0; l < n; l++) {
            const d = i[l].meshInstances
              , h = d.length;
            for (let u = 0; u < h; u++) {
                const f = d[u];
                f.visibleThisFrame = !1,
                s && up.push(f),
                f.skinInstance && fp.push(f)
            }
        }
        if (s) {
            const l = !t.updateShaders;
            this.updateShaders(up, l),
            t.updateShaders = !1,
            t._shaderVersion++
        }
        this.updateFrameUniforms(),
        this.updateCpuSkinMatrices(fp),
        up.length = 0,
        fp.length = 0;
        const r = this.lights
          , o = r.length;
        for (let l = 0; l < o; l++)
            r[l].beginFrame()
    }
    updateLightTextureAtlas() {
        this.lightTextureAtlas.update(this.localLights, this.scene.lighting)
    }
    updateLayerComposition(e) {
        const t = e.layerList.length;
        for (let n = 0; n < t; n++)
            e.layerList[n]._postRenderCounter = 0;
        const i = this.scene._shaderVersion;
        for (let n = 0; n < t; n++) {
            const r = e.layerList[n];
            r._shaderVersion = i,
            r._preRenderCalledForCameras = 0,
            r._postRenderCalledForCameras = 0,
            e.subLayerList[n] ? r._postRenderCounter |= 2 : r._postRenderCounter |= 1,
            r._postRenderCounterMax = r._postRenderCounter
        }
        e._update()
    }
    frameUpdate() {
        this.clustersDebugRendered = !1,
        this.initViewBindGroupFormat(this.scene.clusteredLightingEnabled),
        this.dirLightShadows.clear()
    }
}
class _x {
    constructor() {
        this.layer = null,
        this.transparent = !1,
        this.camera = null,
        this.renderTarget = null,
        this.lightClusters = null,
        this.clearColor = !1,
        this.clearDepth = !1,
        this.clearStencil = !1,
        this.triggerPostprocess = !1,
        this.firstCameraUse = !1,
        this.lastCameraUse = !1,
        this.viewBindGroups = [],
        this.useCameraPasses = !1
    }
    destroy() {
        this.viewBindGroups.forEach(e => {
            e.defaultUniformBuffer.destroy(),
            e.destroy()
        }
        ),
        this.viewBindGroups.length = 0
    }
    setupClears(e, t) {
        this.clearColor = (e == null ? void 0 : e.clearColorBuffer) || t.clearColorBuffer,
        this.clearDepth = (e == null ? void 0 : e.clearDepthBuffer) || t.clearDepthBuffer,
        this.clearStencil = (e == null ? void 0 : e.clearStencilBuffer) || t.clearStencilBuffer
    }
}
const S0 = 2.399963229728653
  , yc = {
    circlePoint(a) {
        const e = Math.sqrt(Math.random())
          , t = Math.random() * 2 * Math.PI;
        a.x = e * Math.cos(t),
        a.y = e * Math.sin(t)
    },
    circlePointDeterministic(a, e, t) {
        const s = e * S0
          , i = Math.sqrt(e) / Math.sqrt(t);
        a.x = i * Math.cos(s),
        a.y = i * Math.sin(s)
    },
    spherePointDeterministic(a, e, t, s=0, i=1) {
        s = 1 - 2 * s,
        i = 1 - 2 * i;
        const n = W.lerp(s, i, e / t)
          , r = Math.sqrt(1 - n * n)
          , o = S0 * e;
        a.x = Math.cos(o) * r,
        a.y = n,
        a.z = Math.sin(o) * r
    },
    radicalInverse(a) {
        let e = (a << 16 | a >>> 16) >>> 0;
        return e = ((e & 1431655765) << 1 | (e & 2863311530) >>> 1) >>> 0,
        e = ((e & 858993459) << 2 | (e & 3435973836) >>> 2) >>> 0,
        e = ((e & 252645135) << 4 | (e & 4042322160) >>> 4) >>> 0,
        e = ((e & 16711935) << 8 | (e & 4278255360) >>> 8) >>> 0,
        e * 23283064365386963e-26
    }
}
  , x0 = a => {
    switch (a) {
    case _m:
        return "Cubemap";
    case PT:
        return "Octahedral";
    default:
        return "Equirect"
    }
}
  , Kc = (a, e, t) => {
    if (a <= 0)
        e[t + 0] = 0,
        e[t + 1] = 0,
        e[t + 2] = 0,
        e[t + 3] = 0;
    else if (a >= 1)
        e[t + 0] = 255,
        e[t + 1] = 0,
        e[t + 2] = 0,
        e[t + 3] = 0;
    else {
        let s = 1 * a % 1
          , i = 255 * a % 1
          , n = 65025 * a % 1;
        const r = 16581375 * a % 1;
        s -= i / 255,
        i -= n / 255,
        n -= r / 255,
        e[t + 0] = Math.min(255, Math.floor(s * 256)),
        e[t + 1] = Math.min(255, Math.floor(i * 256)),
        e[t + 2] = Math.min(255, Math.floor(n * 256)),
        e[t + 3] = Math.min(255, Math.floor(r * 256))
    }
}
  , bI = a => {
    const e = a.length
      , t = Math.min(e, 512)
      , s = Math.ceil(e / t)
      , i = new Uint8Array(t * s * 4);
    let n = 0;
    for (let r = 0; r < e; r += 4)
        Kc(a[r + 0] * .5 + .5, i, n + 0),
        Kc(a[r + 1] * .5 + .5, i, n + 4),
        Kc(a[r + 2] * .5 + .5, i, n + 8),
        Kc(a[r + 3] / 8, i, n + 12),
        n += 16;
    return {
        width: t,
        height: s,
        data: i
    }
}
  , TI = (a, e, t, s) => {
    const i = t * 2 * Math.PI
      , n = Math.pow(1 - e, 1 / (s + 1))
      , r = Math.sqrt(1 - n * n);
    a.set(Math.cos(i) * r, Math.sin(i) * r, n).normalize()
}
  , CI = (a, e, t) => {
    const s = t * 2 * Math.PI
      , i = Math.sqrt(1 - e)
      , n = Math.sqrt(e);
    a.set(Math.cos(s) * n, Math.sin(s) * n, i).normalize()
}
  , EI = (a, e, t, s) => {
    const i = t * 2 * Math.PI
      , n = Math.sqrt((1 - e) / (1 + (s * s - 1) * e))
      , r = Math.sqrt(1 - n * n);
    a.set(Math.cos(i) * r, Math.sin(i) * r, n).normalize()
}
  , AI = (a, e) => {
    const t = a * e
      , s = e / (1 - a * a + t * t);
    return s * s * (1 / Math.PI)
}
  , MI = (a, e) => {
    const t = new y
      , s = [];
    for (let i = 0; i < a; ++i)
        TI(t, i / a, yc.radicalInverse(i), e),
        s.push(t.x, t.y, t.z, 0);
    return s
}
  , PI = (a, e) => {
    const t = e / a
      , s = new y
      , i = [];
    for (let n = 0; n < a; ++n) {
        CI(s, n / a, yc.radicalInverse(n));
        const r = s.z / Math.PI
          , o = .5 * Math.log2(t / r);
        i.push(s.x, s.y, s.z, o)
    }
    return i
}
  , RI = {
    16: {
        2: 26,
        8: 20,
        32: 17,
        128: 16,
        512: 16
    },
    32: {
        2: 53,
        8: 40,
        32: 34,
        128: 32,
        512: 32
    },
    128: {
        2: 214,
        8: 163,
        32: 139,
        128: 130,
        512: 128
    },
    1024: {
        2: 1722,
        8: 1310,
        32: 1114,
        128: 1041,
        512: 1025
    }
}
  , II = (a, e) => {
    const t = RI[a];
    return t && t[e] || a
}
  , LI = (a, e, t) => {
    const s = t / a
      , i = 1 - Math.log2(e) / 11
      , n = i * i
      , r = new y
      , o = new y
      , l = new y(0,0,1)
      , c = []
      , d = II(a, e);
    for (let h = 0; h < d; ++h) {
        EI(r, h / d, yc.radicalInverse(h), n);
        const u = r.z;
        if (o.set(r.x, r.y, r.z).mulScalar(2 * u).sub(l),
        o.z > 0) {
            const f = AI(Math.min(1, u), n) / 4 + .001
              , p = .5 * Math.log2(s / f);
            c.push(o.x, o.y, o.z, p)
        }
    }
    for (; c.length < a * 4; )
        c.push(0, 0, 0, 0);
    return c
}
  , DI = (a, e, t) => {
    const s = bI(t);
    return new ge(a,{
        name: e,
        width: s.width,
        height: s.height,
        mipmaps: !1,
        minFilter: be,
        magFilter: be,
        levels: [s.data]
    })
}
;
class gx {
    constructor(e=!0) {
        this.map = new Map,
        this.destroyContent = e
    }
    destroy() {
        this.destroyContent && this.map.forEach( (e, t) => {
            e.destroy()
        }
        )
    }
    get(e, t) {
        if (!this.map.has(e)) {
            const s = t();
            return this.map.set(e, s),
            s
        }
        return this.map.get(e)
    }
}
const OI = new gx(!1)
  , FI = new Os
  , og = (a, e, t) => FI.get(a, () => new gx).get(e, () => DI(a, e, OI.get(e, t)))
  , BI = (a, e, t) => {
    const s = `lambert-samples-${e}-${t}`;
    return og(a, s, () => PI(e, t))
}
  , kI = (a, e, t) => {
    const s = `phong-samples-${e}-${t}`;
    return og(a, s, () => MI(e, t))
}
  , NI = (a, e, t, s) => {
    const i = `ggx-samples-${e}-${t}-${s}`;
    return og(a, i, () => LI(e, t, s))
}
  , UI = `
attribute vec2 vertex_position;

uniform vec4 uvMod;

varying vec2 vUv0;

void main(void) {
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		vUv0 = getImageEffectUV((vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw);
}
`;
function nn(a, e, t={}) {
    var s, i, n, r, o;
    a instanceof br && (a = arguments[1],
    e = arguments[2],
    t = {},
    arguments[3] !== void 0 && (t.specularPower = arguments[3]),
    arguments[4] !== void 0 && (t.numSamples = arguments[4]));
    const l = (s = t.seamPixels) != null ? s : 0
      , c = ((i = (n = t.rect) == null ? void 0 : n.z) != null ? i : e.width) - l * 2
      , d = ((r = (o = t.rect) == null ? void 0 : o.w) != null ? r : e.height) - l * 2;
    if (c < 1 || d < 1)
        return !1;
    const h = {
        none: "reproject",
        lambert: "prefilterSamplesUnweighted",
        phong: "prefilterSamplesUnweighted",
        ggx: "prefilterSamples"
    }
      , u = t.hasOwnProperty("specularPower") ? t.specularPower : 1
      , f = t.hasOwnProperty("face") ? t.face : null
      , p = t.hasOwnProperty("distribution") ? t.distribution : u === 1 ? "none" : "phong"
      , _ = h[p] || "reproject"
      , m = _.startsWith("prefilterSamples")
      , g = mi.decodeFunc(a.encoding)
      , v = mi.encodeFunc(e.encoding)
      , x = `sample${x0(a.projection)}`
      , S = `getDirection${x0(e.projection)}`
      , w = t.hasOwnProperty("numSamples") ? t.numSamples : 1024
      , T = `${_}_${g}_${v}_${x}_${S}_${w}`
      , b = a.device;
    let E = Cr(b).getCachedShader(T);
    if (!E) {
        const D = `#define PROCESS_FUNC ${_}
` + (m ? `#define USE_SAMPLES_TEX
` : "") + (a.cubemap ? `#define CUBEMAP_SOURCE
` : "") + `#define DECODE_FUNC ${g}
#define ENCODE_FUNC ${v}
#define SOURCE_FUNC ${x}
#define TARGET_FUNC ${S}
#define NUM_SAMPLES ${w}
#define NUM_SAMPLES_SQRT ${Math.round(Math.sqrt(w)).toFixed(1)}
`;
        E = Ys(b, UI, `${D}
${$.reprojectPS}`, T)
    }
    b.setBlendState(ft.NOBLEND),
    b.scope.resolve(a.cubemap ? "sourceCube" : "sourceTex").setValue(a);
    const R = b.scope.resolve("params")
      , F = b.scope.resolve("params2")
      , L = b.scope.resolve("uvMod");
    l > 0 ? L.setValue([(c + l * 2) / c, (d + l * 2) / d, -l / c, -l / d]) : L.setValue([1, 1, 0, 0]);
    const U = [0, u, a.fixCubemapSeams ? 1 / a.width : 0, e.fixCubemapSeams ? 1 / e.width : 0]
      , I = [e.width * e.height * (e.cubemap ? 6 : 1), a.width * a.height * (a.cubemap ? 6 : 1)];
    if (m) {
        const D = a.width * a.height * (a.cubemap ? 6 : 1)
          , A = p === "ggx" ? NI(b, w, u, D) : p === "lambert" ? BI(b, w, D) : kI(b, w, u);
        b.scope.resolve("samplesTex").setValue(A),
        b.scope.resolve("samplesTexInverseSize").setValue([1 / A.width, 1 / A.height])
    }
    for (let D = 0; D < (e.cubemap ? 6 : 1); D++)
        if (f === null || D === f) {
            var O;
            const A = new It({
                colorBuffer: e,
                face: D,
                depth: !1,
                flipY: b.isWebGPU
            });
            U[0] = D,
            R.setValue(U),
            F.setValue(I),
            ya(b, A, E, (O = t) == null ? void 0 : O.rect),
            A.destroy()
        }
    return !0
}
const zI = !0
  , pp = (a, e=0) => 1 + Math.floor(Math.log2(Math.max(a, e)))
  , VI = a => a.extTextureHalfFloat && a.textureHalfFloatRenderable
  , GI = a => a.extTextureFloat && a.textureFloatRenderable
  , HI = a => VI(a) ? Tt : GI(a) ? lt : ve
  , WI = a => ve
  , XI = (a, e, t, s) => new ge(a,{
    name: `lighting-${e}`,
    cubemap: !0,
    width: e,
    height: e,
    format: t,
    type: t === ve ? Bo : $s,
    addressU: oe,
    addressV: oe,
    fixCubemapSeams: zI,
    mipmaps: !!s
});
class yx {
    static generateSkyboxCubemap(e, t) {
        const s = e.device
          , i = XI(s, t || (e.cubemap ? e.width : e.width / 4), ve, !1);
        return nn(e, i, {
            numSamples: 1024
        }),
        i
    }
    static generateLightingSource(e, t) {
        const s = e.device
          , i = HI(s)
          , n = (t == null ? void 0 : t.target) || new ge(s,{
            name: "lighting-source",
            cubemap: !0,
            width: (t == null ? void 0 : t.size) || 128,
            height: (t == null ? void 0 : t.size) || 128,
            format: i,
            type: i === ve ? Bo : $s,
            addressU: oe,
            addressV: oe,
            fixCubemapSeams: !1,
            mipmaps: !0
        });
        return nn(e, n, {
            numSamples: e.mipmaps ? 1 : 1024
        }),
        n
    }
    static generateAtlas(e, t) {
        const s = e.device
          , i = WI()
          , n = (t == null ? void 0 : t.target) || new ge(s,{
            name: "envAtlas",
            width: (t == null ? void 0 : t.size) || 512,
            height: (t == null ? void 0 : t.size) || 512,
            format: i,
            type: Bo,
            projection: ly,
            addressU: oe,
            addressV: oe,
            mipmaps: !1
        })
          , r = n.width / 512
          , o = new M(0,0,512 * r,256 * r)
          , l = pp(256) - pp(4);
        for (let c = 0; c < l; ++c)
            nn(e, n, {
                numSamples: 1,
                rect: o,
                seamPixels: r
            }),
            o.x += o.w,
            o.y += o.w,
            o.z = Math.max(1, Math.floor(o.z * .5)),
            o.w = Math.max(1, Math.floor(o.w * .5));
        o.set(0, 256 * r, 256 * r, 128 * r);
        for (let c = 1; c < 7; ++c)
            nn(e, n, {
                numSamples: (t == null ? void 0 : t.numReflectionSamples) || 1024,
                distribution: (t == null ? void 0 : t.distribution) || "ggx",
                specularPower: Math.max(1, 2048 >> c * 2),
                rect: o,
                seamPixels: r
            }),
            o.y += o.w,
            o.z = Math.max(1, Math.floor(o.z * .5)),
            o.w = Math.max(1, Math.floor(o.w * .5));
        return o.set(128 * r, 384 * r, 64 * r, 32 * r),
        nn(e, n, {
            numSamples: (t == null ? void 0 : t.numAmbientSamples) || 2048,
            distribution: "lambert",
            rect: o,
            seamPixels: r
        }),
        n
    }
    static generatePrefilteredAtlas(e, t) {
        const s = e[0].device
          , i = e[0].format
          , n = e[0].type
          , r = (t == null ? void 0 : t.target) || new ge(s,{
            name: "envPrefilteredAtlas",
            width: (t == null ? void 0 : t.size) || 512,
            height: (t == null ? void 0 : t.size) || 512,
            format: i,
            type: n,
            projection: ly,
            addressU: oe,
            addressV: oe,
            mipmaps: !1
        })
          , o = r.width / 512
          , l = new M(0,0,512 * o,256 * o)
          , c = pp(512);
        for (let d = 0; d < c; ++d)
            nn(e[0], r, {
                numSamples: 1,
                rect: l,
                seamPixels: o
            }),
            l.x += l.w,
            l.y += l.w,
            l.z = Math.max(1, Math.floor(l.z * .5)),
            l.w = Math.max(1, Math.floor(l.w * .5));
        l.set(0, 256 * o, 256 * o, 128 * o);
        for (let d = 1; d < e.length; ++d)
            nn(e[d], r, {
                numSamples: 1,
                rect: l,
                seamPixels: o
            }),
            l.y += l.w,
            l.z = Math.max(1, Math.floor(l.z * .5)),
            l.w = Math.max(1, Math.floor(l.w * .5));
        return l.set(128 * o, 384 * o, 64 * o, 32 * o),
        t != null && t.legacyAmbient ? nn(e[5], r, {
            numSamples: 1,
            rect: l,
            seamPixels: o
        }) : nn(e[0], r, {
            numSamples: (t == null ? void 0 : t.numSamples) || 2048,
            distribution: "lambert",
            rect: l,
            seamPixels: o
        }),
        r
    }
}
class ou {
    constructor() {
        this.forceUv1 = !1,
        this.ambientTint = !1,
        this.diffuseTint = !1,
        this.specularTint = !1,
        this.metalnessTint = !1,
        this.glossTint = !1,
        this.emissiveTint = !1,
        this.opacityTint = !1,
        this.emissiveEncoding = "linear",
        this.lightMapEncoding = "linear",
        this.packedNormal = !1,
        this.glossInvert = !1,
        this.sheenGlossInvert = !1,
        this.clearCoatGlossInvert = !1,
        this.litOptions = new NR
    }
    get pass() {
        return this.litOptions.pass
    }
}
const Eo = []
  , mp = a => Object.keys(a).filter(e => e !== "litOptions").sort();
class jI extends Ue {
    constructor(...e) {
        super(...e),
        this.optionsContext = new ou,
        this.optionsContextMin = new ou
    }
    generateKey(e) {
        let t;
        return e === this.optionsContextMin ? (this.propsMin || (this.propsMin = mp(e)),
        t = this.propsMin) : e === this.optionsContext ? (this.props || (this.props = mp(e)),
        t = this.props) : t = mp(e),
        `standard:
` + t.map(i => i + e[i]).join(`
`) + Pm.generateKey(e.litOptions)
    }
    _getUvSourceExpression(e, t, s) {
        const i = s[e]
          , n = s[t]
          , r = s.litOptions.pass === pc || s.litOptions.pass === $i;
        let o;
        return r && s.litOptions.nineSlicedMode === xt || r && s.litOptions.nineSlicedMode === _t ? o = "nineSlicedUv" : (i === 0 ? o = "vUv" + n : o = "vUV" + n + "_" + i,
        s.heightMap && e !== "heightMapTransform" && (o += " + dUvOffset")),
        o
    }
    _addMapDef(e, t) {
        return t ? `#define ${e}
` : `#undef ${e}
`
    }
    _addMapDefs(e, t, s, i, n) {
        return this._addMapDef("MAPFLOAT", e) + this._addMapDef("MAPCOLOR", t) + this._addMapDef("MAPVERTEX", s) + this._addMapDef("MAPTEXTURE", i) + this._addMapDef("MAPINVERT", n)
    }
    _addMap(e, t, s, i, n, r=null) {
        const o = e + "Map"
          , l = o + "Uv"
          , c = o + "Identifier"
          , d = o + "Transform"
          , h = o + "Channel"
          , u = e + "VertexColorChannel"
          , f = e + "Tint"
          , p = e + "VertexColor"
          , _ = e + "Mode"
          , m = e + "Invert"
          , g = s[f]
          , v = s[p]
          , x = s[o]
          , S = s[c]
          , w = s[_];
        let T = i[t];
        if (x) {
            const R = this._getUvSourceExpression(d, l, s);
            if (T = T.replace(/\$UV/g, R).replace(/\$CH/g, s[h]),
            n && T.search(/\$SAMPLER/g) !== -1) {
                let F = "texture_" + o;
                const L = n[S];
                L ? F = L : n[S] = F,
                T = T.replace(/\$SAMPLER/g, F)
            }
            if (r && (s[h] === "aaa" ? T = T.replace(/\$DECODE/g, "passThrough") : T = T.replace(/\$DECODE/g, mi.decodeFunc(!s.litOptions.gamma && r === "srgb" ? "linear" : r)),
            T.indexOf("$texture2DSAMPLE"))) {
                const F = {
                    linear: "texture2D",
                    srgb: "texture2DSRGB",
                    rgbm: "texture2DRGBM",
                    rgbe: "texture2DRGBE"
                };
                T = T.replace(/\$texture2DSAMPLE/g, F[r] || "texture2D")
            }
        }
        v && (T = T.replace(/\$VC/g, s[u])),
        w && (T = T.replace(/\$DETAILMODE/g, w));
        const b = !!(g & 1)
          , E = !!(g & 2)
          , C = !!s[m];
        return T = this._addMapDefs(b, E, v, x, C) + T,
        T.replace(/\$/g, "")
    }
    _correctChannel(e, t, s) {
        if (s[e] > 0) {
            if (s[e] < t.length)
                return t.substring(0, s[e]);
            if (s[e] > t.length) {
                let i = t;
                const n = i.charAt(i.length - 1)
                  , r = s[e] - i.length;
                for (let o = 0; o < r; o++)
                    i += n;
                return i
            }
            return t
        }
    }
    createShaderDefinition(e, t) {
        const i = wi.get(e).getByIndex(t.litOptions.pass).isForward
          , n = new XR(e,t.litOptions)
          , r = []
          , o = []
          , l = []
          , c = 2
          , d = {};
        for (const m in Eo) {
            const g = m + "Map";
            if (t[m + "VertexColor"]) {
                const v = m + "VertexColorChannel";
                t[v] = this._correctChannel(m, t[v], Eo)
            }
            if (t[g]) {
                const v = g + "Channel"
                  , x = g + "Transform"
                  , S = g + "Uv";
                t[S] = Math.min(t[S], c - 1),
                t[v] = this._correctChannel(m, t[v], Eo);
                const w = t[S];
                r[w] = !0,
                o[w] = o[w] || t[g] && !t[x],
                t[x] && l.push({
                    name: m,
                    id: t[x],
                    uv: t[S]
                })
            }
        }
        t.forceUv1 && (r[1] = !0,
        o[1] = o[1] !== void 0 ? o[1] : !0),
        n.generateVertexShader(r, o, l),
        t.litOptions.shadingModel === ji ? (t.litOptions.fresnelModel = 0,
        t.litOptions.ambientSH = !1) : t.litOptions.fresnelModel = t.litOptions.fresnelModel === 0 ? W_ : t.litOptions.fresnelModel;
        const h = new rr
          , u = new rr
          , f = new rr
          , p = new rr;
        let _ = "";
        if (t.litOptions.nineSlicedMode === _t ? h.append("const float textureBias = -1000.0;") : h.append("uniform float textureBias;"),
        i) {
            if (t.heightMap && (h.append("vec2 dUvOffset;"),
            u.append(this._addMap("height", "parallaxPS", t, n.chunks, d)),
            f.append("getParallax();")),
            t.litOptions.blendType !== ls || t.litOptions.alphaTest || t.litOptions.alphaToCoverage || t.litOptions.opacityDither !== cs) {
                h.append("float dAlpha;"),
                u.append(this._addMap("opacity", "opacityPS", t, n.chunks, d)),
                f.append("getOpacity();"),
                p.append("litArgs_opacity = dAlpha;"),
                t.litOptions.alphaTest && (u.append(n.chunks.alphaTestPS),
                f.append("alphaTest(dAlpha);"));
                const m = t.litOptions.opacityDither;
                m !== cs && (m === Gy && h.append(n.chunks.bayerPS),
                h.append(`#define DITHER_${m.toUpperCase()}
`),
                h.append(n.chunks.opacityDitherPS),
                f.append("opacityDither(dAlpha, 0.0);"))
            } else
                h.append("float dAlpha = 1.0;");
            if (n.needsNormal) {
                if ((t.normalMap || t.clearCoatNormalMap) && (u.append(t.packedNormal ? n.chunks.normalXYPS : n.chunks.normalXYZPS),
                !t.litOptions.hasTangents)) {
                    const m = t.normalMap ? "normalMap" : "clearCoatNormalMap";
                    _ = this._getUvSourceExpression(`${m}Transform`, `${m}Uv`, t)
                }
                h.append("vec3 dNormalW;"),
                u.append(this._addMap("normalDetail", "normalDetailMapPS", t, n.chunks, d)),
                u.append(this._addMap("normal", "normalMapPS", t, n.chunks, d)),
                f.append("getNormal();"),
                p.append("litArgs_worldNormal = dNormalW;")
            }
            if (n.needsSceneColor && h.append("uniform sampler2D uSceneColorMap;"),
            n.needsScreenSize && h.append("uniform vec4 uScreenSize;"),
            n.needsTransforms && (h.append("uniform mat4 matrix_viewProjection;"),
            h.append("uniform mat4 matrix_model;")),
            (t.diffuseDetail || t.aoDetail) && u.append(n.chunks.detailModesPS),
            h.append("vec3 dAlbedo;"),
            t.diffuseDetail && u.append(this._addMap("diffuseDetail", "diffuseDetailMapPS", t, n.chunks, d, t.diffuseDetailEncoding)),
            u.append(this._addMap("diffuse", "diffusePS", t, n.chunks, d, t.diffuseEncoding)),
            f.append("getAlbedo();"),
            p.append("litArgs_albedo = dAlbedo;"),
            t.litOptions.useRefraction && (h.append("float dTransmission;"),
            u.append(this._addMap("refraction", "transmissionPS", t, n.chunks, d)),
            f.append("getRefraction();"),
            p.append("litArgs_transmission = dTransmission;"),
            h.append("float dThickness;"),
            u.append(this._addMap("thickness", "thicknessPS", t, n.chunks, d)),
            f.append("getThickness();"),
            p.append("litArgs_thickness = dThickness;")),
            t.litOptions.useIridescence && (h.append("float dIridescence;"),
            u.append(this._addMap("iridescence", "iridescencePS", t, n.chunks, d)),
            f.append("getIridescence();"),
            p.append("litArgs_iridescence_intensity = dIridescence;"),
            h.append("float dIridescenceThickness;"),
            u.append(this._addMap("iridescenceThickness", "iridescenceThicknessPS", t, n.chunks, d)),
            f.append("getIridescenceThickness();"),
            p.append("litArgs_iridescence_thickness = dIridescenceThickness;")),
            n.lighting && t.litOptions.useSpecular || n.reflections ? (h.append("vec3 dSpecularity;"),
            h.append("float dGlossiness;"),
            t.litOptions.useSheen && (h.append("vec3 sSpecularity;"),
            u.append(this._addMap("sheen", "sheenPS", t, n.chunks, d, t.sheenEncoding)),
            f.append("getSheen();"),
            p.append("litArgs_sheen_specularity = sSpecularity;"),
            h.append("float sGlossiness;"),
            u.append(this._addMap("sheenGloss", "sheenGlossPS", t, n.chunks, d)),
            f.append("getSheenGlossiness();"),
            p.append("litArgs_sheen_gloss = sGlossiness;")),
            t.litOptions.useMetalness && (h.append("float dMetalness;"),
            u.append(this._addMap("metalness", "metalnessPS", t, n.chunks, d)),
            f.append("getMetalness();"),
            p.append("litArgs_metalness = dMetalness;"),
            h.append("float dIor;"),
            u.append(this._addMap("ior", "iorPS", t, n.chunks, d)),
            f.append("getIor();"),
            p.append("litArgs_ior = dIor;")),
            t.litOptions.useSpecularityFactor && (h.append("float dSpecularityFactor;"),
            u.append(this._addMap("specularityFactor", "specularityFactorPS", t, n.chunks, d)),
            f.append("getSpecularityFactor();"),
            p.append("litArgs_specularityFactor = dSpecularityFactor;")),
            t.useSpecularColor ? u.append(this._addMap("specular", "specularPS", t, n.chunks, d, t.specularEncoding)) : u.append("void getSpecularity() { dSpecularity = vec3(1); }"),
            u.append(this._addMap("gloss", "glossPS", t, n.chunks, d)),
            f.append("getGlossiness();"),
            f.append("getSpecularity();"),
            p.append("litArgs_specularity = dSpecularity;"),
            p.append("litArgs_gloss = dGlossiness;")) : (h.append("vec3 dSpecularity = vec3(0.0);"),
            h.append("float dGlossiness = 0.0;")),
            t.aoDetail && u.append(this._addMap("aoDetail", "aoDetailMapPS", t, n.chunks, d)),
            (t.aoMap || t.aoVertexColor) && (h.append("float dAo;"),
            u.append(this._addMap("ao", "aoPS", t, n.chunks, d)),
            f.append("getAO();"),
            p.append("litArgs_ao = dAo;")),
            h.append("vec3 dEmission;"),
            u.append(this._addMap("emissive", "emissivePS", t, n.chunks, d, t.emissiveEncoding)),
            f.append("getEmission();"),
            p.append("litArgs_emission = dEmission;"),
            t.litOptions.useClearCoat && (h.append("float ccSpecularity;"),
            h.append("float ccGlossiness;"),
            h.append("vec3 ccNormalW;"),
            u.append(this._addMap("clearCoat", "clearCoatPS", t, n.chunks, d)),
            u.append(this._addMap("clearCoatGloss", "clearCoatGlossPS", t, n.chunks, d)),
            u.append(this._addMap("clearCoatNormal", "clearCoatNormalPS", t, n.chunks, d)),
            f.append("getClearCoat();"),
            f.append("getClearCoatGlossiness();"),
            f.append("getClearCoatNormal();"),
            p.append("litArgs_clearcoat_specularity = ccSpecularity;"),
            p.append("litArgs_clearcoat_gloss = ccGlossiness;"),
            p.append("litArgs_clearcoat_worldNormal = ccNormalW;")),
            t.lightMap || t.lightVertexColor) {
                const m = t.dirLightMap && t.litOptions.useSpecular
                  , g = m ? "lightmapDirPS" : "lightmapSinglePS";
                h.append("vec3 dLightmap;"),
                m && h.append("vec3 dLightmapDir;"),
                u.append(this._addMap("light", g, t, n.chunks, d, t.lightMapEncoding)),
                f.append("getLightMap();"),
                p.append("litArgs_lightmap = dLightmap;"),
                m && p.append("litArgs_lightmapDir = dLightmapDir;")
            }
            (u.code.indexOf("texture2DSRGB") !== -1 || u.code.indexOf("texture2DRGBM") !== -1 || u.code.indexOf("texture2DRGBE") !== -1) && u.prepend(n.chunks.textureSamplePS)
        } else {
            const m = t.litOptions.opacityShadowDither;
            (t.litOptions.alphaTest || m) && (h.append("float dAlpha;"),
            u.append(this._addMap("opacity", "opacityPS", t, n.chunks, d)),
            f.append("getOpacity();"),
            p.append("litArgs_opacity = dAlpha;"),
            t.litOptions.alphaTest && (u.append(n.chunks.alphaTestPS),
            f.append("alphaTest(dAlpha);")),
            m !== cs && (m === Gy && h.append(n.chunks.bayerPS),
            h.append(`#define DITHER_${m.toUpperCase()}
`),
            h.append(n.chunks.opacityDitherPS),
            f.append("opacityDither(dAlpha, 0.0);")))
        }
        h.append(n.chunks.litShaderArgsPS),
        u.append(`void evaluateFrontend() { 
${f.code}
${p.code}
 }
`),
        f.code = "evaluateFrontend();";
        for (const m in d)
            h.append(`uniform sampler2D ${d[m]};`);
        return f.code = `
${f.code.split(`
`).map(m => `    ${m}`).join(`
`)}

`,
        n.generateFragmentShader(h.code, u.code, f.code, _),
        n.getDefinition()
    }
}
const _p = new jI
  , w0 = (a, e) => {
    if (a.length !== e.length)
        return !1;
    for (let t = 0; t < a.length; ++t)
        if (a[t] !== e[t])
            return !1;
    return !0
}
  , Zc = a => a.r !== 1 || a.g !== 1 || a.b !== 1
  , $I = a => a.r !== 0 || a.g !== 0 || a.b !== 0;
class qI {
    constructor() {
        this._mapXForms = null
    }
    updateMinRef(e, t, s, i, n, r) {
        this._updateSharedOptions(e, t, s, i, n),
        this._updateMinOptions(e, s),
        this._updateUVOptions(e, s, i, !0)
    }
    updateRef(e, t, s, i, n, r) {
        this._updateSharedOptions(e, t, s, i, n),
        this._updateEnvOptions(e, s, t),
        this._updateMaterialOptions(e, s),
        n === $i && (e.litOptions.gamma && (e.litOptions.gamma = uc),
        e.litOptions.toneMap = fc),
        e.litOptions.hasTangents = i && (i & J_) !== 0,
        this._updateLightOptions(e, t, s, i, r),
        this._updateUVOptions(e, s, i, !1)
    }
    _updateSharedOptions(e, t, s, i, n) {
        e.forceUv1 = s.forceUv1,
        s.userAttributes && (e.litOptions.userAttributes = Object.fromEntries(s.userAttributes.entries())),
        e.litOptions.chunks = s.chunks || {},
        e.litOptions.pass = n,
        e.litOptions.alphaTest = s.alphaTest > 0,
        e.litOptions.blendType = s.blendType,
        e.litOptions.screenSpace = i && (i & Ah) !== 0,
        e.litOptions.skin = i && (i & Ch) !== 0,
        e.litOptions.useInstancing = i && (i & Eh) !== 0,
        e.litOptions.useMorphPosition = i && (i & Mh) !== 0,
        e.litOptions.useMorphNormal = i && (i & Ph) !== 0,
        e.litOptions.useMorphTextureBased = i && (i & Rh) !== 0,
        e.litOptions.nineSlicedMode = s.nineSlicedMode || 0,
        t.clusteredLightingEnabled && s.useLighting ? (e.litOptions.clusteredLightingEnabled = !0,
        e.litOptions.clusteredLightingCookiesEnabled = t.lighting.cookiesEnabled,
        e.litOptions.clusteredLightingShadowsEnabled = t.lighting.shadowsEnabled,
        e.litOptions.clusteredLightingShadowType = t.lighting.shadowType,
        e.litOptions.clusteredLightingAreaLightsEnabled = t.lighting.areaLightsEnabled) : (e.litOptions.clusteredLightingEnabled = !1,
        e.litOptions.clusteredLightingCookiesEnabled = !1,
        e.litOptions.clusteredLightingShadowsEnabled = !1,
        e.litOptions.clusteredLightingAreaLightsEnabled = !1)
    }
    _updateUVOptions(e, t, s, i) {
        let n = !1
          , r = !1
          , o = !1;
        s && (n = (s & ix) !== 0,
        r = (s & nx) !== 0,
        o = (s & rx) !== 0),
        e.litOptions.vertexColors = !1,
        this._mapXForms = [];
        const l = {};
        for (const c in Eo)
            this._updateTexOptions(e, t, c, n, r, o, i, l);
        this._mapXForms = null,
        e.litOptions.lightMapEnabled = e.lightMap,
        e.litOptions.dirLightMapEnabled = e.dirLightMap,
        e.litOptions.useHeights = e.heightMap,
        e.litOptions.useNormals = e.normalMap,
        e.litOptions.useClearCoatNormals = e.clearCoatNormalMap,
        e.litOptions.useAo = e.aoMap || e.aoVertexColor,
        e.litOptions.diffuseMapEnabled = e.diffuseMap
    }
    _updateTexOptions(e, t, s, i, n, r, o, l) {
        const c = s === "opacity";
        if (!o || c) {
            const d = s + "Map"
              , h = s + "VertexColor"
              , u = s + "VertexColorChannel"
              , f = d + "Channel"
              , p = d + "Transform"
              , _ = d + "Uv"
              , m = d + "Identifier";
            if (s !== "light" && (e[d] = !1,
            e[m] = void 0,
            e[f] = "",
            e[p] = 0,
            e[_] = 0),
            e[h] = !1,
            e[u] = "",
            c && t.blendType === ls && t.alphaTest === 0 && !t.alphaToCoverage && t.opacityDither === cs)
                return;
            if (s !== "height" && t[h] && r && (e[h] = t[h],
            e[u] = t[u],
            e.litOptions.vertexColors = !0),
            t[d]) {
                let g = !0;
                if (t[_] === 0 && !i && (g = !1),
                t[_] === 1 && !n && (g = !1),
                g) {
                    const v = t[d].id;
                    let x = l[v];
                    x === void 0 && (l[v] = s,
                    x = s),
                    e[d] = !!t[d],
                    e[m] = x,
                    e[p] = this._getMapTransformID(t.getUniform(p), t[_]),
                    e[f] = t[f],
                    e[_] = t[_]
                }
            }
        }
    }
    _updateMinOptions(e, t) {
        e.opacityTint = t.opacity !== 1 && (t.blendType !== ls || t.opacityShadowDither !== cs),
        e.litOptions.opacityShadowDither = t.opacityShadowDither,
        e.litOptions.lights = []
    }
    _updateMaterialOptions(e, t) {
        var s, i, n, r;
        const o = (t.diffuseTint || !t.diffuseMap && !t.diffuseVertexColor) && Zc(t.diffuse)
          , l = !!(t.useMetalness || t.specularMap || t.sphereMap || t.cubeMap || $I(t.specular) || t.specularityFactor > 0 && t.useMetalness || t.enableGGXSpecular || t.clearCoat > 0)
          , c = !t.useMetalness || t.useMetalnessSpecularColor
          , d = l && (t.specularTint || !t.specularMap && !t.specularVertexColor) && Zc(t.specular)
          , h = l && t.useMetalnessSpecularColor && (t.specularityFactorTint || t.specularityFactor < 1 && !t.specularityFactorMap)
          , u = !t.emissiveMap || Zc(t.emissive) && t.emissiveTint
          , f = t.emissiveIntensity !== 1
          , p = t.normalMap ? t.normalMap.format === Jo || t.normalMap.type === lf : !1;
        e.opacityTint = t.opacity !== 1 && (t.blendType !== ls || t.alphaTest > 0 || t.opacityDither !== cs) ? 1 : 0,
        e.ambientTint = t.ambientTint,
        e.diffuseTint = o ? 2 : 0,
        e.specularTint = d ? 2 : 0,
        e.specularityFactorTint = h ? 1 : 0,
        e.metalnessTint = t.useMetalness && t.metalness < 1 ? 1 : 0,
        e.glossTint = 1,
        e.emissiveTint = (u ? 2 : 0) + (f ? 1 : 0),
        e.diffuseEncoding = (s = t.diffuseMap) == null ? void 0 : s.encoding,
        e.diffuseDetailEncoding = (i = t.diffuseDetailMap) == null ? void 0 : i.encoding,
        e.emissiveEncoding = (n = t.emissiveMap) == null ? void 0 : n.encoding,
        e.lightMapEncoding = (r = t.lightMap) == null ? void 0 : r.encoding,
        e.packedNormal = p,
        e.refractionTint = t.refraction !== 1 ? 1 : 0,
        e.refractionIndexTint = t.refractionIndex !== 1 / 1.5 ? 1 : 0,
        e.thicknessTint = t.useDynamicRefraction && t.thickness !== 1 ? 1 : 0,
        e.specularEncoding = t.specularEncoding || "linear",
        e.sheenEncoding = t.sheenEncoding || "linear",
        e.aoMapUv = t.aoUvSet,
        e.aoDetail = !!t.aoMap,
        e.diffuseDetail = !!t.diffuseMap,
        e.normalDetail = !!t.normalMap,
        e.diffuseDetailMode = t.diffuseDetailMode,
        e.aoDetailMode = t.aoDetailMode,
        e.clearCoatTint = t.clearCoat !== 1 ? 1 : 0,
        e.clearCoatGloss = !!t.clearCoatGloss,
        e.clearCoatGlossTint = t.clearCoatGloss !== 1 ? 1 : 0,
        e.iorTint = t.refractionIndex !== 1 / 1.5 ? 1 : 0,
        e.iridescenceTint = t.iridescence !== 1 ? 1 : 0,
        e.sheenTint = t.useSheen && Zc(t.sheen) ? 2 : 0,
        e.sheenGlossTint = 1,
        e.glossInvert = t.glossInvert,
        e.sheenGlossInvert = t.sheenGlossInvert,
        e.clearCoatGlossInvert = t.clearCoatGlossInvert,
        e.useSpecularColor = c,
        e.litOptions.separateAmbient = !1,
        e.litOptions.useAmbientTint = t.ambientTint,
        e.litOptions.customFragmentShader = t.customFragmentShader,
        e.litOptions.pixelSnap = t.pixelSnap,
        e.litOptions.shadingModel = t.shadingModel,
        e.litOptions.ambientSH = !!t.ambientSH,
        e.litOptions.fastTbn = t.fastTbn,
        e.litOptions.twoSidedLighting = t.twoSidedLighting,
        e.litOptions.occludeSpecular = t.occludeSpecular,
        e.litOptions.occludeSpecularFloat = t.occludeSpecularIntensity !== 1,
        e.litOptions.useMsdf = !!t.msdfMap,
        e.litOptions.msdfTextAttribute = !!t.msdfTextAttribute,
        e.litOptions.alphaToCoverage = t.alphaToCoverage,
        e.litOptions.opacityFadesSpecular = t.opacityFadesSpecular,
        e.litOptions.opacityDither = t.opacityDither,
        e.litOptions.cubeMapProjection = t.cubeMapProjection,
        e.litOptions.occludeDirect = t.occludeDirect,
        e.litOptions.conserveEnergy = t.conserveEnergy && t.shadingModel !== ji,
        e.litOptions.useSpecular = l,
        e.litOptions.useSpecularityFactor = (h || !!t.specularityFactorMap) && t.useMetalnessSpecularColor,
        e.litOptions.enableGGXSpecular = t.enableGGXSpecular,
        e.litOptions.fresnelModel = t.fresnelModel,
        e.litOptions.useRefraction = (t.refraction || !!t.refractionMap) && (t.useDynamicRefraction || !!e.litOptions.reflectionSource),
        e.litOptions.useClearCoat = !!t.clearCoat,
        e.litOptions.useSheen = t.useSheen,
        e.litOptions.useIridescence = t.useIridescence && t.iridescence !== 0,
        e.litOptions.useMetalness = t.useMetalness,
        e.litOptions.useDynamicRefraction = t.useDynamicRefraction
    }
    _updateEnvOptions(e, t, s) {
        e.litOptions.fog = t.useFog ? s.fog : "none",
        e.litOptions.gamma = t.useGammaTonemap ? s.gammaCorrection : dc,
        e.litOptions.toneMap = t.useGammaTonemap ? s.toneMapping : -1,
        e.litOptions.fixSeams = t.cubeMap ? t.cubeMap.fixCubemapSeams : !1;
        const i = t.shadingModel === ji;
        let n = !1;
        if (t.envAtlas && t.cubeMap && !i ? (e.litOptions.reflectionSource = "envAtlasHQ",
        e.litOptions.reflectionEncoding = t.envAtlas.encoding,
        e.litOptions.reflectionCubemapEncoding = t.cubeMap.encoding) : t.envAtlas && !i ? (e.litOptions.reflectionSource = "envAtlas",
        e.litOptions.reflectionEncoding = t.envAtlas.encoding) : t.cubeMap ? (e.litOptions.reflectionSource = "cubeMap",
        e.litOptions.reflectionEncoding = t.cubeMap.encoding) : t.sphereMap ? (e.litOptions.reflectionSource = "sphereMap",
        e.litOptions.reflectionEncoding = t.sphereMap.encoding) : t.useSkybox && s.envAtlas && s.skybox && !i ? (e.litOptions.reflectionSource = "envAtlasHQ",
        e.litOptions.reflectionEncoding = s.envAtlas.encoding,
        e.litOptions.reflectionCubemapEncoding = s.skybox.encoding,
        n = !0) : t.useSkybox && s.envAtlas && !i ? (e.litOptions.reflectionSource = "envAtlas",
        e.litOptions.reflectionEncoding = s.envAtlas.encoding,
        n = !0) : t.useSkybox && s.skybox ? (e.litOptions.reflectionSource = "cubeMap",
        e.litOptions.reflectionEncoding = s.skybox.encoding,
        n = !0) : (e.litOptions.reflectionSource = null,
        e.litOptions.reflectionEncoding = null),
        t.ambientSH && !i)
            e.litOptions.ambientSource = "ambientSH",
            e.litOptions.ambientEncoding = null;
        else {
            const r = t.envAtlas || (t.useSkybox && s.envAtlas ? s.envAtlas : null);
            r && !i ? (e.litOptions.ambientSource = "envAtlas",
            e.litOptions.ambientEncoding = r.encoding) : (e.litOptions.ambientSource = "constant",
            e.litOptions.ambientEncoding = null)
        }
        e.litOptions.skyboxIntensity = n && (s.skyboxIntensity !== 1 || s.physicalUnits),
        e.litOptions.useCubeMapRotation = n && s._skyboxRotationShaderInclude
    }
    _updateLightOptions(e, t, s, i, n) {
        if (e.lightMap = !1,
        e.lightMapChannel = "",
        e.lightMapUv = 0,
        e.lightMapTransform = 0,
        e.litOptions.lightMapWithoutAmbient = !1,
        e.dirLightMap = !1,
        i && (e.litOptions.noShadow = (i & nu) !== 0,
        i & ru && (e.lightMapEncoding = t.lightmapPixelFormat === ve ? "rgbm" : "linear",
        e.lightMap = !0,
        e.lightMapChannel = "rgb",
        e.lightMapUv = 1,
        e.lightMapTransform = 0,
        e.litOptions.lightMapWithoutAmbient = !s.lightMap,
        i & Q_ && (e.dirLightMap = !0),
        i & eg && (e.litOptions.lightMapWithoutAmbient = !1))),
        s.useLighting) {
            const r = []
              , o = i ? i >> 16 : Rs;
            e.litOptions.lightMaskDynamic = !!(o & Rs),
            n && (ui.collectLights(pe, n[pe], r, o),
            ui.collectLights(Oe, n[Oe], r, o),
            ui.collectLights(He, n[He], r, o)),
            e.litOptions.lights = r
        } else
            e.litOptions.lights = [];
        e.litOptions.lights.length === 0 && (e.litOptions.noShadow = !0)
    }
    _getMapTransformID(e, t) {
        if (!e)
            return 0;
        let s = this._mapXForms[t];
        s || (s = [],
        this._mapXForms[t] = s);
        for (let i = 0; i < s.length; i++)
            if (w0(s[i][0].value, e[0].value) && w0(s[i][1].value, e[1].value))
                return i + 1;
        return s.push(e)
    }
}
function ht(a, e=!0, t=!0) {
    const s = {};
    return s[`${a}Map`] = "texture",
    s[`${a}MapTiling`] = "vec2",
    s[`${a}MapOffset`] = "vec2",
    s[`${a}MapRotation`] = "number",
    s[`${a}MapUv`] = "number",
    e && (s[`${a}MapChannel`] = "string",
    t && (s[`${a}VertexColor`] = "boolean",
    s[`${a}VertexColorChannel`] = "string")),
    s
}
const Yo = Bt({
    name: "string",
    chunks: "chunks",
    mappingFormat: "string",
    _engine: "boolean",
    ambient: "rgb",
    ambientTint: "boolean"
}, ht("ao"), ht("aoDetail", !0, !1), {
    aoDetailMode: "string",
    diffuse: "rgb",
    diffuseTint: "boolean"
}, ht("diffuse"), ht("diffuseDetail", !0, !1), {
    diffuseDetailMode: "string",
    specular: "rgb",
    specularTint: "boolean"
}, ht("specular"), {
    occludeSpecular: "enum:occludeSpecular",
    specularityFactor: "number",
    specularityFactorTint: "boolean"
}, ht("specularityFactor"), {
    useMetalness: "boolean",
    metalness: "number",
    enableGGXSpecular: "boolean",
    anisotropy: "number",
    metalnessTint: "boolean"
}, ht("metalness"), {
    useMetalnessSpecularColor: "boolean",
    conserveEnergy: "boolean",
    shininess: "number",
    gloss: "number",
    glossInvert: "boolean"
}, ht("gloss"), {
    clearCoat: "number"
}, ht("clearCoat"), {
    clearCoatGloss: "number",
    clearCoatGlossInvert: "boolean"
}, ht("clearCoatGloss"), {
    clearCoatBumpiness: "number"
}, ht("clearCoatNormal", !1), {
    useSheen: "boolean",
    sheen: "rgb",
    sheenTint: "boolean"
}, ht("sheen"), {
    sheenGloss: "number",
    sheenGlossTint: "boolean",
    sheenGlossInvert: "boolean"
}, ht("sheenGloss"), {
    fresnelModel: "number",
    emissive: "rgb",
    emissiveTint: "boolean"
}, ht("emissive"), {
    emissiveIntensity: "number"
}, ht("normal", !1), {
    bumpiness: "number"
}, ht("normalDetail", !1), {
    normalDetailMapBumpiness: "number"
}, ht("height", !0, !1), {
    heightMapFactor: "number",
    alphaToCoverage: "boolean",
    alphaTest: "number",
    alphaFade: "number",
    opacity: "number"
}, ht("opacity"), {
    opacityFadesSpecular: "boolean",
    opacityDither: "string",
    opacityShadowDither: "string",
    reflectivity: "number",
    refraction: "number",
    refractionTint: "boolean"
}, ht("refraction"), {
    refractionIndex: "number",
    thickness: "number",
    thicknessTint: "boolean"
}, ht("thickness"), {
    attenuation: "rgb",
    attenuationDistance: "number",
    useDynamicRefraction: "boolean",
    sphereMap: "texture",
    cubeMap: "cubemap",
    cubeMapProjection: "number",
    cubeMapProjectionBox: "boundingbox",
    useIridescence: "boolean",
    iridescence: "number",
    iridescenceTint: "boolean"
}, ht("iridescence"), {
    iridescenceThicknessTint: "boolean",
    iridescenceThicknessMin: "number",
    iridescenceThicknessMax: "number",
    iridescenceRefractionIndex: "number"
}, ht("iridescenceThickness"), ht("light"), {
    depthTest: "boolean",
    depthFunc: "enum:depthFunc",
    depthWrite: "boolean",
    depthBias: "number",
    slopeDepthBias: "number",
    cull: "enum:cull",
    blendType: "enum:blendType",
    shadingModel: "enum:shadingModel",
    useFog: "boolean",
    useLighting: "boolean",
    useSkybox: "boolean",
    useGammaTonemap: "boolean",
    envAtlas: "texture",
    twoSidedLighting: "boolean"
})
  , Af = [];
for (const a in Yo)
    Yo[a] === "texture" && Af.push(a);
const lg = [];
for (const a in Yo)
    Yo[a] === "cubemap" && lg.push(a);
const YI = {
    aoMapVertexColor: "boolean",
    diffuseMapTint: "boolean",
    diffuseMapVertexColor: "boolean",
    emissiveMapTint: "boolean",
    emissiveMapVertexColor: "boolean",
    glossMapVertexColor: "boolean",
    metalnessMapVertexColor: "boolean",
    opacityMapVertexColor: "boolean",
    specularAntialias: "boolean",
    specularMapTint: "boolean",
    specularMapVertexColor: "boolean"
}
  , Bd = {}
  , vx = {};
let wl = new Set;
class at extends Yi {
    constructor() {
        super(),
        this.userAttributes = new Map,
        this._dirtyShader = !0,
        this._assetReferences = {},
        this._activeParams = new Set,
        this._activeLightingParams = new Set,
        this.shaderOptBuilder = new qI,
        this.reset()
    }
    reset() {
        Object.keys(Bd).forEach(e => {
            this[`_${e}`] = Bd[e].value()
        }
        ),
        this._chunks = {},
        this._uniformCache = {}
    }
    set shader(e) {}
    get shader() {
        return null
    }
    set chunks(e) {
        this._dirtyShader = !0,
        this._chunks = e
    }
    get chunks() {
        return this._dirtyShader = !0,
        this._chunks
    }
    copy(e) {
        super.copy(e),
        Object.keys(Bd).forEach(t => {
            this[t] = e[t]
        }
        );
        for (const t in e._chunks)
            e._chunks.hasOwnProperty(t) && (this._chunks[t] = e._chunks[t]);
        return this
    }
    setAttribute(e, t) {
        this.userAttributes.set(t, e)
    }
    _setParameter(e, t) {
        wl.add(e),
        this.setParameter(e, t)
    }
    _setParameters(e) {
        e.forEach(t => {
            this._setParameter(t.name, t.value)
        }
        )
    }
    _processParameters(e) {
        const t = this[e];
        t.forEach(s => {
            wl.has(s) || delete this.parameters[s]
        }
        ),
        this[e] = wl,
        wl = t,
        wl.clear()
    }
    _updateMap(e) {
        const t = e + "Map"
          , s = this[t];
        if (s) {
            this._setParameter("texture_" + t, s);
            const i = t + "Transform"
              , n = this.getUniform(i);
            n && this._setParameters(n)
        }
    }
    _allocUniform(e, t) {
        let s = this._uniformCache[e];
        return s || (s = t(),
        this._uniformCache[e] = s),
        s
    }
    getUniform(e, t, s) {
        return vx[e](this, t, s)
    }
    updateUniforms(e, t) {
        const s = n => this.getUniform(n, e, t);
        this._setParameter("material_ambient", s("ambient")),
        (!this.diffuseMap || this.diffuseTint) && this._setParameter("material_diffuse", s("diffuse")),
        this.useMetalness ? ((!this.metalnessMap || this.metalness < 1) && this._setParameter("material_metalness", this.metalness),
        (!this.specularMap || this.specularTint) && this._setParameter("material_specular", s("specular")),
        (!this.specularityFactorMap || this.specularityFactorTint) && this._setParameter("material_specularityFactor", this.specularityFactor),
        (!this.sheenMap || this.sheenTint) && this._setParameter("material_sheen", s("sheen")),
        (!this.sheenGlossMap || this.sheenGlossTint) && this._setParameter("material_sheenGloss", this.sheenGloss),
        this._setParameter("material_refractionIndex", this.refractionIndex)) : (!this.specularMap || this.specularTint) && this._setParameter("material_specular", s("specular")),
        this.enableGGXSpecular && this._setParameter("material_anisotropy", this.anisotropy),
        this.clearCoat > 0 && (this._setParameter("material_clearCoat", this.clearCoat),
        this._setParameter("material_clearCoatGloss", this.clearCoatGloss),
        this._setParameter("material_clearCoatBumpiness", this.clearCoatBumpiness)),
        this._setParameter("material_gloss", s("gloss")),
        (!this.emissiveMap || this.emissiveTint) && this._setParameter("material_emissive", s("emissive")),
        this.emissiveIntensity !== 1 && this._setParameter("material_emissiveIntensity", this.emissiveIntensity),
        this.refraction > 0 && this._setParameter("material_refraction", this.refraction),
        this.useDynamicRefraction && (this._setParameter("material_thickness", this.thickness),
        this._setParameter("material_attenuation", s("attenuation")),
        this._setParameter("material_invAttenuationDistance", this.attenuationDistance === 0 ? 0 : 1 / this.attenuationDistance)),
        this.useIridescence && (this._setParameter("material_iridescence", this.iridescence),
        this._setParameter("material_iridescenceRefractionIndex", this.iridescenceRefractionIndex),
        this._setParameter("material_iridescenceThicknessMin", this.iridescenceThicknessMin),
        this._setParameter("material_iridescenceThicknessMax", this.iridescenceThicknessMax)),
        this._setParameter("material_opacity", this.opacity),
        this.opacityFadesSpecular === !1 && this._setParameter("material_alphaFade", this.alphaFade),
        this.occludeSpecular && this._setParameter("material_occludeSpecularIntensity", this.occludeSpecularIntensity),
        this.cubeMapProjection === rA && this._setParameter(s("cubeMapProjectionBox"));
        for (const n in Eo)
            this._updateMap(n);
        this.ambientSH && this._setParameter("ambientSH[0]", this.ambientSH),
        this.normalMap && this._setParameter("material_bumpiness", this.bumpiness),
        this.normalMap && this.normalDetailMap && this._setParameter("material_normalDetailMapBumpiness", this.normalDetailMapBumpiness),
        this.heightMap && this._setParameter("material_heightMapFactor", s("heightMapFactor"));
        const i = this.shadingModel === ji;
        this.envAtlas && this.cubeMap && !i ? (this._setParameter("texture_envAtlas", this.envAtlas),
        this._setParameter("texture_cubeMap", this.cubeMap)) : this.envAtlas && !i ? this._setParameter("texture_envAtlas", this.envAtlas) : this.cubeMap ? this._setParameter("texture_cubeMap", this.cubeMap) : this.sphereMap && this._setParameter("texture_sphereMap", this.sphereMap),
        this._setParameter("material_reflectivity", this.reflectivity),
        this._processParameters("_activeParams"),
        this._dirtyShader && this.clearVariants()
    }
    updateEnvUniforms(e, t) {
        const s = this.shadingModel === ji;
        !(this.envAtlas && !s || this.cubeMap || this.sphereMap) && this.useSkybox && (t.envAtlas && t.skybox && !s ? (this._setParameter("texture_envAtlas", t.envAtlas),
        this._setParameter("texture_cubeMap", t.skybox)) : t.envAtlas && !s ? this._setParameter("texture_envAtlas", t.envAtlas) : t.skybox && this._setParameter("texture_cubeMap", t.skybox)),
        this._processParameters("_activeLightingParams")
    }
    getShaderVariant(e, t, s, i, n, r, o, l, c) {
        this.updateEnvUniforms(e, t);
        const d = wi.get(e).getByIndex(n)
          , h = n === Vi || n === mc || d.isShadow;
        let u = h ? _p.optionsContextMin : _p.optionsContext;
        h ? this.shaderOptBuilder.updateMinRef(u, t, this, s, n, r) : this.shaderOptBuilder.updateRef(u, t, this, s, n, r),
        this.onUpdateShader && (u = this.onUpdateShader(u));
        const f = new Aa(o,l,c)
          , p = Cr(e);
        p.register("standard", _p);
        const _ = p.getProgram("standard", u, f, this.userId);
        return this._dirtyShader = !1,
        _
    }
    destroy() {
        for (const e in this._assetReferences)
            this._assetReferences[e]._unbind();
        this._assetReferences = null,
        super.destroy()
    }
}
at.TEXTURE_PARAMETERS = Af;
at.CUBEMAP_PARAMETERS = lg;
const Mf = (a, e) => {
    vx[a] = e
}
  , hg = (a, e, t, s) => {
    Object.defineProperty(at.prototype, a, {
        get: s || function() {
            return this[`_${a}`]
        }
        ,
        set: t
    }),
    Bd[a] = {
        value: e
    }
}
  , KI = a => {
    const e = `_${a.name}`
      , t = a.dirtyShaderFunc || ( () => !0)
      , s = function(n) {
        const r = this[e];
        r !== n && (this._dirtyShader = this._dirtyShader || t(r, n),
        this[e] = n)
    };
    hg(a.name, () => a.defaultValue, s, a.getterFunc)
}
  , ZI = a => {
    const e = `_${a.name}`
      , t = a.dirtyShaderFunc || ( () => !0)
      , s = function(n) {
        const r = this[e];
        r.equals(n) || (this._dirtyShader = this._dirtyShader || t(r, n),
        this[e] = r.copy(n))
    };
    hg(a.name, () => a.defaultValue.clone(), s, a.getterFunc)
}
  , Us = a => a.defaultValue && a.defaultValue.clone ? ZI(a) : KI(a);
function rt(a, e="rgb", t=!0, s=0) {
    Eo[a] = e.length || -1,
    Us({
        name: `${a}Map`,
        defaultValue: null,
        dirtyShaderFunc: (l, c) => !!l != !!c || l && (l.type !== c.type || l.fixCubemapSeams !== c.fixCubemapSeams || l.format !== c.format)
    }),
    Us({
        name: `${a}MapTiling`,
        defaultValue: new P(1,1)
    }),
    Us({
        name: `${a}MapOffset`,
        defaultValue: new P(0,0)
    }),
    Us({
        name: `${a}MapRotation`,
        defaultValue: 0
    }),
    Us({
        name: `${a}MapUv`,
        defaultValue: s
    }),
    e && (Us({
        name: `${a}MapChannel`,
        defaultValue: e
    }),
    t && (Us({
        name: `${a}VertexColor`,
        defaultValue: !1
    }),
    Us({
        name: `${a}VertexColorChannel`,
        defaultValue: e
    })));
    const i = `${a}MapTiling`
      , n = `${a}MapOffset`
      , r = `${a}MapRotation`
      , o = `${a}MapTransform`;
    Mf(o, (l, c, d) => {
        const h = l[i]
          , u = l[n]
          , f = l[r];
        if (h.x === 1 && h.y === 1 && u.x === 0 && u.y === 0 && f === 0)
            return null;
        const p = l._allocUniform(o, () => [{
            name: `texture_${o}0`,
            value: new Float32Array(3)
        }, {
            name: `texture_${o}1`,
            value: new Float32Array(3)
        }])
          , _ = Math.cos(f * W.DEG_TO_RAD)
          , m = Math.sin(f * W.DEG_TO_RAD)
          , g = p[0].value;
        g[0] = _ * h.x,
        g[1] = -m * h.y,
        g[2] = u.x;
        const v = p[1].value;
        return v[0] = m * h.x,
        v[1] = _ * h.y,
        v[2] = 1 - h.y - u.y,
        p
    }
    )
}
function Ga(a, e) {
    Us({
        name: a,
        defaultValue: e,
        getterFunc: function() {
            return this._dirtyShader = !0,
            this[`_${a}`]
        }
    }),
    Mf(a, (t, s, i) => {
        const n = t._allocUniform(a, () => new Float32Array(3))
          , r = t[a];
        return t.useGammaTonemap && i.gammaCorrection ? (n[0] = Math.pow(r.r, 2.2),
        n[1] = Math.pow(r.g, 2.2),
        n[2] = Math.pow(r.b, 2.2)) : (n[0] = r.r,
        n[1] = r.g,
        n[2] = r.b),
        n
    }
    )
}
function Ze(a, e, t) {
    Us({
        name: a,
        defaultValue: e,
        dirtyShaderFunc: (s, i) => (s === 0 || s === 1) != (i === 0 || i === 1)
    }),
    Mf(a, t)
}
function bl(a, e) {
    Us({
        name: a,
        defaultValue: null,
        dirtyShaderFunc: (t, s) => !!t == !!s
    }),
    Mf(a, e)
}
function Ee(a, e) {
    Us({
        name: a,
        defaultValue: e
    })
}
function QI() {
    Ga("ambient", new z(.7,.7,.7)),
    Ga("diffuse", new z(1,1,1)),
    Ga("specular", new z(0,0,0)),
    Ga("emissive", new z(0,0,0)),
    Ga("sheen", new z(1,1,1)),
    Ga("attenuation", new z(1,1,1)),
    Ze("emissiveIntensity", 1),
    Ze("specularityFactor", 1),
    Ze("sheenGloss", 0),
    Ze("gloss", .25, (s, i, n) => s.shadingModel === ji ? Math.pow(2, s.gloss * 11) : s.gloss),
    Ze("heightMapFactor", 1, (s, i, n) => s.heightMapFactor * .025),
    Ze("opacity", 1),
    Ze("alphaFade", 1),
    Ze("alphaTest", 0),
    Ze("bumpiness", 1),
    Ze("normalDetailMapBumpiness", 1),
    Ze("reflectivity", 1),
    Ze("occludeSpecularIntensity", 1),
    Ze("refraction", 0),
    Ze("refractionIndex", 1 / 1.5),
    Ze("thickness", 0),
    Ze("attenuationDistance", 0),
    Ze("metalness", 1),
    Ze("anisotropy", 0),
    Ze("clearCoat", 0),
    Ze("clearCoatGloss", 1),
    Ze("clearCoatBumpiness", 1),
    Ze("aoUvSet", 0, null),
    Ze("iridescence", 0),
    Ze("iridescenceRefractionIndex", 1 / 1.5),
    Ze("iridescenceThicknessMin", 0),
    Ze("iridescenceThicknessMax", 0),
    bl("ambientSH"),
    bl("cubeMapProjectionBox", (s, i, n) => {
        const r = s._allocUniform("cubeMapProjectionBox", () => [{
            name: "envBoxMin",
            value: new Float32Array(3)
        }, {
            name: "envBoxMax",
            value: new Float32Array(3)
        }])
          , o = s.cubeMapProjectionBox.getMin()
          , l = r[0].value;
        l[0] = o.x,
        l[1] = o.y,
        l[2] = o.z;
        const c = s.cubeMapProjectionBox.getMax()
          , d = r[1].value;
        return d[0] = c.x,
        d[1] = c.y,
        d[2] = c.z,
        r
    }
    ),
    Ee("ambientTint", !1),
    Ee("diffuseTint", !1),
    Ee("specularTint", !1),
    Ee("specularityFactorTint", !1),
    Ee("emissiveTint", !1),
    Ee("fastTbn", !1),
    Ee("useMetalness", !1),
    Ee("useMetalnessSpecularColor", !1),
    Ee("useSheen", !1),
    Ee("enableGGXSpecular", !1),
    Ee("occludeDirect", !1),
    Ee("normalizeNormalMap", !0),
    Ee("conserveEnergy", !0),
    Ee("opacityFadesSpecular", !0),
    Ee("occludeSpecular", Th),
    Ee("shadingModel", cc),
    Ee("fresnelModel", W_),
    Ee("useDynamicRefraction", !1),
    Ee("cubeMapProjection", sx),
    Ee("customFragmentShader", null),
    Ee("useFog", !0),
    Ee("useLighting", !0),
    Ee("useGammaTonemap", !0),
    Ee("useSkybox", !0),
    Ee("forceUv1", !1),
    Ee("pixelSnap", !1),
    Ee("twoSidedLighting", !1),
    Ee("nineSlicedMode", void 0),
    Ee("msdfTextAttribute", !1),
    Ee("useIridescence", !1),
    Ee("glossInvert", !1),
    Ee("sheenGlossInvert", !1),
    Ee("clearCoatGlossInvert", !1),
    Ee("opacityDither", cs),
    Ee("opacityShadowDither", cs),
    rt("diffuse"),
    rt("specular"),
    rt("emissive"),
    rt("thickness", "g"),
    rt("specularityFactor", "g"),
    rt("normal", ""),
    rt("metalness", "g"),
    rt("gloss", "g"),
    rt("opacity", "a"),
    rt("refraction", "g"),
    rt("height", "g", !1),
    rt("ao", "g"),
    rt("light", "rgb", !0, 1),
    rt("msdf", ""),
    rt("diffuseDetail", "rgb", !1),
    rt("normalDetail", ""),
    rt("aoDetail", "g", !1),
    rt("clearCoat", "g"),
    rt("clearCoatGloss", "g"),
    rt("clearCoatNormal", ""),
    rt("sheen", "rgb"),
    rt("sheenGloss", "g"),
    rt("iridescence", "g"),
    rt("iridescenceThickness", "g"),
    Ee("diffuseDetailMode", zy),
    Ee("aoDetailMode", zy),
    bl("cubeMap"),
    bl("sphereMap"),
    bl("envAtlas");
    const a = function() {
        return this._prefilteredCubemaps
    }
      , e = function(i) {
        const n = this._prefilteredCubemaps;
        i = i || [];
        let r = !1
          , o = !0;
        for (let l = 0; l < 6; ++l) {
            const c = i[l] || null;
            n[l] !== c && (n[l] = c,
            r = !0),
            o = o && !!n[l]
        }
        r && (o ? this.envAtlas = yx.generatePrefilteredAtlas(n, {
            target: this.envAtlas
        }) : this.envAtlas && (this.envAtlas.destroy(),
        this.envAtlas = null),
        this._dirtyShader = !0)
    }
      , t = [null, null, null, null, null, null];
    hg("prefilteredCubemaps", () => t.slice(), e, a)
}
QI();
class JI extends Js {
    constructor(e, t, s, i) {
        super(e),
        this.layerComposition = void 0,
        this.scene = void 0,
        this.renderer = void 0,
        this.renderActions = [],
        this.layerComposition = t,
        this.scene = s,
        this.renderer = i
    }
    addRenderAction(e) {
        this.renderActions.push(e)
    }
    addLayer(e, t, s, i=!0) {
        const n = new _x;
        if (n.renderTarget = this.renderTarget,
        n.camera = e,
        n.layer = t,
        n.transparent = s,
        i) {
            const r = this.renderActions.length === 0;
            n.setupClears(r ? e : void 0, t)
        }
        this.addRenderAction(n)
    }
    addLayers(e, t, s, i, n, r=!0) {
        const {layerList: o, subLayerEnabled: l, subLayerList: c} = e;
        let d = i
          , h = s;
        for (; h < o.length; ) {
            const u = o[h]
              , f = c[h]
              , p = u.enabled && l[h]
              , _ = t.camera.layersSet.has(u.id);
            if (p && _ && (this.addLayer(t, u, f, d),
            d = !1),
            h++,
            u.id === n && f === r)
                break
        }
        return h
    }
    updateDirectionalShadows() {
        const {renderer: e, renderActions: t} = this;
        for (let s = 0; s < t.length; s++) {
            const r = t[s].camera.camera
              , o = this.renderer.cameraDirShadowLights.get(r);
            if (o)
                for (let l = 0; l < o.length; l++) {
                    const c = o[l];
                    if (e.dirLightShadows.get(c) !== r) {
                        e.dirLightShadows.set(c, r);
                        const d = e._shadowRendererDirectional.getLightRenderPass(c, r);
                        d && this.beforePasses.push(d)
                    }
                }
        }
    }
    updateClears() {
        const e = this.renderActions[0];
        if (e) {
            const s = e.camera.camera
              , i = s.fullSizeClearRect;
            this.setClearColor(i && e.clearColor ? s.clearColor : void 0),
            this.setClearDepth(i && e.clearDepth ? s.clearDepth : void 0),
            this.setClearStencil(i && e.clearStencil ? s.clearStencil : void 0)
        }
    }
    frameUpdate() {
        super.frameUpdate(),
        this.updateDirectionalShadows(),
        this.updateClears()
    }
    before() {
        const {renderActions: e} = this;
        if (e.length) {
            const t = e[0];
            t.camera.onPreRender && t.firstCameraUse && t.camera.onPreRender()
        }
    }
    execute() {
        const {layerComposition: e, renderActions: t} = this;
        for (let s = 0; s < t.length; s++) {
            const i = t[s];
            e.isEnabled(i.layer, i.transparent) && this.renderRenderAction(i, s === 0)
        }
    }
    after() {
        const {renderActions: e} = this;
        if (e.length) {
            const t = e[e.length - 1];
            t.camera.onPostRender && t.lastCameraUse && t.camera.onPostRender()
        }
        this.beforePasses.length = 0
    }
    renderRenderAction(e, t) {
        const {scene: s, renderer: i, layerComposition: n} = this
          , r = s.clusteredLightingEnabled
          , o = i.device
          , {layer: l, transparent: c, camera: d} = e
          , h = n.camerasMap.get(d);
        if (!c && l.onPreRenderOpaque ? l.onPreRenderOpaque(h) : c && l.onPreRenderTransparent && l.onPreRenderTransparent(h),
        l._preRenderCalledForCameras & 1 << h || (l.onPreRender && l.onPreRender(h),
        l._preRenderCalledForCameras |= 1 << h),
        d) {
            var u, f, p;
            i.setupViewport(d.camera, e.renderTarget),
            (!t || !d.camera.fullSizeClearRect) && i.clear(d.camera, e.clearColor, e.clearDepth, e.clearStencil),
            l.sortVisible(d.camera, c);
            const _ = l.getCulledInstances(d.camera)
              , m = c ? _.transparent : _.opaque;
            s.immediate.onPreRenderLayer(l, m, c),
            l.requiresLightCube && (i.lightCube.update(s.ambientLight, l._lights),
            i.constantLightCube.setValue(i.lightCube.colors)),
            r && e.lightClusters && (e.lightClusters.activate(),
            !i.clustersDebugRendered && s.lighting.debugLayer === l.id && (i.clustersDebugRendered = !0)),
            s._activeCamera = d.camera;
            const g = i.setCameraUniforms(d.camera, e.renderTarget);
            o.supportsUniformBuffers && i.setupViewUniformBuffers(e.viewBindGroups, i.viewUniformFormat, i.viewBindGroupFormat, g);
            const v = !!(d.camera._flipFaces ^ (e == null || (u = e.renderTarget) == null ? void 0 : u.flipY))
              , x = (f = (p = d.camera.shaderPassInfo) == null ? void 0 : p.index) != null ? f : l.shaderPass
              , S = i._forwardDrawCalls;
            i.renderForward(d.camera, m, l.splitLights, x, l.onDrawCall, l, v),
            l._forwardDrawCalls += i._forwardDrawCalls - S,
            o.setBlendState(ft.NOBLEND),
            o.setStencilState(null, null),
            o.setAlphaToCoverage(!1)
        }
        !c && l.onPostRenderOpaque ? l.onPostRenderOpaque(h) : c && l.onPostRenderTransparent && l.onPostRenderTransparent(h),
        l.onPostRender && !(l._postRenderCalledForCameras & 1 << h) && (l._postRenderCounter &= ~(c ? 2 : 1),
        l._postRenderCounter === 0 && (l.onPostRender(h),
        l._postRenderCalledForCameras |= 1 << h,
        l._postRenderCounter = l._postRenderCounterMax))
    }
}
class eL extends Js {
    constructor(e, t, s) {
        super(e),
        this.renderer = t,
        this.renderAction = s,
        this.requiresCubemaps = !1
    }
    execute() {
        this.renderAction.camera.onPostprocessing()
    }
}
const Lr = {
    drawCalls: [],
    shaderInstances: [],
    isNewMaterial: [],
    lightMaskChanged: [],
    clear: function() {
        this.drawCalls.length = 0,
        this.shaderInstances.length = 0,
        this.isNewMaterial.length = 0,
        this.lightMaskChanged.length = 0
    }
};
function tL(a) {
    const e = [];
    for (let t = 0; t < a; ++t) {
        const s = Math.sqrt(t + .5) / Math.sqrt(a);
        e.push(s)
    }
    return e
}
function sL(a) {
    const e = [];
    for (let t = 0; t < a; t++) {
        const s = t / a
          , i = Math.sqrt(1 - s * s);
        e.push(i)
    }
    return e
}
class iL extends wI {
    constructor(e) {
        super(e);
        const t = this.device;
        this._forwardDrawCalls = 0,
        this._materialSwitches = 0,
        this._depthMapTime = 0,
        this._forwardTime = 0,
        this._sortTime = 0;
        const s = t.scope;
        this.fogColorId = s.resolve("fog_color"),
        this.fogStartId = s.resolve("fog_start"),
        this.fogEndId = s.resolve("fog_end"),
        this.fogDensityId = s.resolve("fog_density"),
        this.ambientId = s.resolve("light_globalAmbient"),
        this.skyboxIntensityId = s.resolve("skyboxIntensity"),
        this.cubeMapRotationMatrixId = s.resolve("cubeMapRotationMatrix"),
        this.pcssDiskSamplesId = s.resolve("pcssDiskSamples[0]"),
        this.pcssSphereSamplesId = s.resolve("pcssSphereSamples[0]"),
        this.lightColorId = [],
        this.lightDir = [],
        this.lightDirId = [],
        this.lightShadowMapId = [],
        this.lightShadowMatrixId = [],
        this.lightShadowParamsId = [],
        this.lightShadowIntensity = [],
        this.lightRadiusId = [],
        this.lightPos = [],
        this.lightPosId = [],
        this.lightWidth = [],
        this.lightWidthId = [],
        this.lightHeight = [],
        this.lightHeightId = [],
        this.lightInAngleId = [],
        this.lightOutAngleId = [],
        this.lightCookieId = [],
        this.lightCookieIntId = [],
        this.lightCookieMatrixId = [],
        this.lightCookieOffsetId = [],
        this.lightShadowSearchAreaId = [],
        this.lightCameraParamsId = [],
        this.shadowMatrixPaletteId = [],
        this.shadowCascadeDistancesId = [],
        this.shadowCascadeCountId = [],
        this.screenSizeId = s.resolve("uScreenSize"),
        this._screenSize = new Float32Array(4),
        this.fogColor = new Float32Array(3),
        this.ambientColor = new Float32Array(3),
        this.pcssDiskSamples = tL(16),
        this.pcssSphereSamples = sL(16)
    }
    destroy() {
        super.destroy()
    }
    dispatchGlobalLights(e) {
        if (this.ambientColor[0] = e.ambientLight.r,
        this.ambientColor[1] = e.ambientLight.g,
        this.ambientColor[2] = e.ambientLight.b,
        e.gammaCorrection)
            for (let t = 0; t < 3; t++)
                this.ambientColor[t] = Math.pow(this.ambientColor[t], 2.2);
        if (e.physicalUnits)
            for (let t = 0; t < 3; t++)
                this.ambientColor[t] *= e.ambientLuminance;
        this.ambientId.setValue(this.ambientColor),
        this.skyboxIntensityId.setValue(e.physicalUnits ? e.skyboxLuminance : e.skyboxIntensity),
        this.cubeMapRotationMatrixId.setValue(e._skyboxRotationMat3.data)
    }
    _resolveLight(e, t) {
        const s = "light" + t;
        this.lightColorId[t] = e.resolve(s + "_color"),
        this.lightDir[t] = new Float32Array(3),
        this.lightDirId[t] = e.resolve(s + "_direction"),
        this.lightShadowMapId[t] = e.resolve(s + "_shadowMap"),
        this.lightShadowMatrixId[t] = e.resolve(s + "_shadowMatrix"),
        this.lightShadowParamsId[t] = e.resolve(s + "_shadowParams"),
        this.lightShadowIntensity[t] = e.resolve(s + "_shadowIntensity"),
        this.lightShadowSearchAreaId[t] = e.resolve(s + "_shadowSearchArea"),
        this.lightRadiusId[t] = e.resolve(s + "_radius"),
        this.lightPos[t] = new Float32Array(3),
        this.lightPosId[t] = e.resolve(s + "_position"),
        this.lightWidth[t] = new Float32Array(3),
        this.lightWidthId[t] = e.resolve(s + "_halfWidth"),
        this.lightHeight[t] = new Float32Array(3),
        this.lightHeightId[t] = e.resolve(s + "_halfHeight"),
        this.lightInAngleId[t] = e.resolve(s + "_innerConeAngle"),
        this.lightOutAngleId[t] = e.resolve(s + "_outerConeAngle"),
        this.lightCookieId[t] = e.resolve(s + "_cookie"),
        this.lightCookieIntId[t] = e.resolve(s + "_cookieIntensity"),
        this.lightCookieMatrixId[t] = e.resolve(s + "_cookieMatrix"),
        this.lightCookieOffsetId[t] = e.resolve(s + "_cookieOffset"),
        this.lightCameraParamsId[t] = e.resolve(s + "_cameraParams"),
        this.shadowMatrixPaletteId[t] = e.resolve(s + "_shadowMatrixPalette[0]"),
        this.shadowCascadeDistancesId[t] = e.resolve(s + "_shadowCascadeDistances[0]"),
        this.shadowCascadeCountId[t] = e.resolve(s + "_shadowCascadeCount")
    }
    setLTCDirectionalLight(e, t, s, i, n) {
        this.lightPos[t][0] = i.x - s.x * n,
        this.lightPos[t][1] = i.y - s.y * n,
        this.lightPos[t][2] = i.z - s.z * n,
        this.lightPosId[t].setValue(this.lightPos[t]);
        const r = e.transformVector(new y(-.5,0,0));
        this.lightWidth[t][0] = r.x * n,
        this.lightWidth[t][1] = r.y * n,
        this.lightWidth[t][2] = r.z * n,
        this.lightWidthId[t].setValue(this.lightWidth[t]);
        const o = e.transformVector(new y(0,0,.5));
        this.lightHeight[t][0] = o.x * n,
        this.lightHeight[t][1] = o.y * n,
        this.lightHeight[t][2] = o.z * n,
        this.lightHeightId[t].setValue(this.lightHeight[t])
    }
    dispatchDirectLights(e, t, s, i) {
        let n = 0;
        const r = this.device.scope;
        for (let o = 0; o < e.length; o++) {
            if (!(e[o].mask & s))
                continue;
            const l = e[o]
              , c = l._node.getWorldTransform();
            if (this.lightColorId[n] || this._resolveLight(r, n),
            this.lightColorId[n].setValue(t.gammaCorrection ? l._linearFinalColor : l._finalColor),
            c.getY(l._direction).mulScalar(-1),
            l._direction.normalize(),
            this.lightDir[n][0] = l._direction.x,
            this.lightDir[n][1] = l._direction.y,
            this.lightDir[n][2] = l._direction.z,
            this.lightDirId[n].setValue(this.lightDir[n]),
            l.shape !== Nt && this.setLTCDirectionalLight(c, n, l._direction, i._node.getPosition(), i.farClip),
            l.castShadows) {
                const d = l.getRenderData(i, 0)
                  , h = l._getUniformBiasValues(d);
                this.lightShadowMapId[n].setValue(d.shadowBuffer),
                this.lightShadowMatrixId[n].setValue(d.shadowMatrix.data),
                this.shadowMatrixPaletteId[n].setValue(l._shadowMatrixPalette),
                this.shadowCascadeDistancesId[n].setValue(l._shadowCascadeDistances),
                this.shadowCascadeCountId[n].setValue(l.numCascades),
                this.lightShadowIntensity[n].setValue(l.shadowIntensity);
                const u = 50 / d.projectionCompensation
                  , f = l.penumbraSize / d.shadowCamera.renderTarget.width;
                this.lightShadowSearchAreaId[n].setValue(f * u);
                const p = l._shadowCameraParams;
                p.length = 4,
                p[0] = d.depthRangeCompensation,
                p[1] = d.shadowCamera._farClip,
                p[2] = d.shadowCamera._nearClip,
                p[3] = 1,
                this.lightCameraParamsId[n].setValue(p);
                const _ = l._shadowRenderParams;
                _.length = 4,
                _[0] = l._shadowResolution,
                _[1] = h.normalBias,
                _[2] = h.bias,
                _[3] = 0,
                this.lightShadowParamsId[n].setValue(_)
            }
            n++
        }
        return n
    }
    setLTCPositionalLight(e, t) {
        const s = e.transformVector(new y(-.5,0,0));
        this.lightWidth[t][0] = s.x,
        this.lightWidth[t][1] = s.y,
        this.lightWidth[t][2] = s.z,
        this.lightWidthId[t].setValue(this.lightWidth[t]);
        const i = e.transformVector(new y(0,0,.5));
        this.lightHeight[t][0] = i.x,
        this.lightHeight[t][1] = i.y,
        this.lightHeight[t][2] = i.z,
        this.lightHeightId[t].setValue(this.lightHeight[t])
    }
    dispatchOmniLight(e, t, s, i) {
        const n = s._node.getWorldTransform();
        if (this.lightColorId[i] || this._resolveLight(t, i),
        this.lightRadiusId[i].setValue(s.attenuationEnd),
        this.lightColorId[i].setValue(e.gammaCorrection ? s._linearFinalColor : s._finalColor),
        n.getTranslation(s._position),
        this.lightPos[i][0] = s._position.x,
        this.lightPos[i][1] = s._position.y,
        this.lightPos[i][2] = s._position.z,
        this.lightPosId[i].setValue(this.lightPos[i]),
        s.shape !== Nt && this.setLTCPositionalLight(n, i),
        s.castShadows) {
            const r = s.getRenderData(null, 0);
            this.lightShadowMapId[i].setValue(r.shadowBuffer);
            const o = s._getUniformBiasValues(r)
              , l = s._shadowRenderParams;
            l.length = 4,
            l[0] = s._shadowResolution,
            l[1] = o.normalBias,
            l[2] = o.bias,
            l[3] = 1 / s.attenuationEnd,
            this.lightShadowParamsId[i].setValue(l),
            this.lightShadowIntensity[i].setValue(s.shadowIntensity);
            const c = s.penumbraSize / r.shadowCamera.renderTarget.width;
            this.lightShadowSearchAreaId[i].setValue(c);
            const d = s._shadowCameraParams;
            d.length = 4,
            d[0] = r.depthRangeCompensation,
            d[1] = r.shadowCamera._farClip,
            d[2] = r.shadowCamera._nearClip,
            d[3] = 0,
            this.lightCameraParamsId[i].setValue(d)
        }
        s._cookie && (this.lightCookieId[i].setValue(s._cookie),
        this.lightShadowMatrixId[i].setValue(n.data),
        this.lightCookieIntId[i].setValue(s.cookieIntensity))
    }
    dispatchSpotLight(e, t, s, i) {
        const n = s._node.getWorldTransform();
        if (this.lightColorId[i] || this._resolveLight(t, i),
        this.lightInAngleId[i].setValue(s._innerConeAngleCos),
        this.lightOutAngleId[i].setValue(s._outerConeAngleCos),
        this.lightRadiusId[i].setValue(s.attenuationEnd),
        this.lightColorId[i].setValue(e.gammaCorrection ? s._linearFinalColor : s._finalColor),
        n.getTranslation(s._position),
        this.lightPos[i][0] = s._position.x,
        this.lightPos[i][1] = s._position.y,
        this.lightPos[i][2] = s._position.z,
        this.lightPosId[i].setValue(this.lightPos[i]),
        s.shape !== Nt && this.setLTCPositionalLight(n, i),
        n.getY(s._direction).mulScalar(-1),
        s._direction.normalize(),
        this.lightDir[i][0] = s._direction.x,
        this.lightDir[i][1] = s._direction.y,
        this.lightDir[i][2] = s._direction.z,
        this.lightDirId[i].setValue(this.lightDir[i]),
        s.castShadows) {
            const r = s.getRenderData(null, 0);
            this.lightShadowMapId[i].setValue(r.shadowBuffer),
            this.lightShadowMatrixId[i].setValue(r.shadowMatrix.data);
            const o = s._getUniformBiasValues(r)
              , l = s._shadowRenderParams;
            l.length = 4,
            l[0] = s._shadowResolution,
            l[1] = o.normalBias,
            l[2] = o.bias,
            l[3] = 1 / s.attenuationEnd,
            this.lightShadowParamsId[i].setValue(l),
            this.lightShadowIntensity[i].setValue(s.shadowIntensity);
            const c = s.penumbraSize / r.shadowCamera.renderTarget.width
              , d = r.shadowCamera._fov * Math.PI / 180
              , h = 1 / Math.tan(d / 2);
            this.lightShadowSearchAreaId[i].setValue(c * h);
            const u = s._shadowCameraParams;
            u.length = 4,
            u[0] = r.depthRangeCompensation,
            u[1] = r.shadowCamera._farClip,
            u[2] = r.shadowCamera._nearClip,
            u[3] = 0,
            this.lightCameraParamsId[i].setValue(u)
        }
        if (s._cookie) {
            if (!s.castShadows) {
                const r = vi.evalSpotCookieMatrix(s);
                this.lightShadowMatrixId[i].setValue(r.data)
            }
            this.lightCookieId[i].setValue(s._cookie),
            this.lightCookieIntId[i].setValue(s.cookieIntensity),
            s._cookieTransform && (s._cookieTransformUniform[0] = s._cookieTransform.x,
            s._cookieTransformUniform[1] = s._cookieTransform.y,
            s._cookieTransformUniform[2] = s._cookieTransform.z,
            s._cookieTransformUniform[3] = s._cookieTransform.w,
            this.lightCookieMatrixId[i].setValue(s._cookieTransformUniform),
            s._cookieOffsetUniform[0] = s._cookieOffset.x,
            s._cookieOffsetUniform[1] = s._cookieOffset.y,
            this.lightCookieOffsetId[i].setValue(s._cookieOffsetUniform))
        }
    }
    dispatchLocalLights(e, t, s, i) {
        let n = i;
        const r = this.device.scope
          , o = e[Oe]
          , l = o.length;
        for (let h = 0; h < l; h++) {
            const u = o[h];
            u.mask & s && (this.dispatchOmniLight(t, r, u, n),
            n++)
        }
        const c = e[He]
          , d = c.length;
        for (let h = 0; h < d; h++) {
            const u = c[h];
            u.mask & s && (this.dispatchSpotLight(t, r, u, n),
            n++)
        }
    }
    renderForwardPrepareMaterials(e, t, s, i, n) {
        var r;
        const o = (m, g, v, x) => {
            Lr.drawCalls.push(m),
            Lr.shaderInstances.push(g),
            Lr.isNewMaterial.push(v),
            Lr.lightMaskChanged.push(x)
        }
        ;
        Lr.clear();
        const l = this.device
          , c = this.scene
          , d = c.clusteredLightingEnabled
          , h = (r = i == null ? void 0 : i.getLightHash(d)) != null ? r : 0;
        let u = null, f, p;
        const _ = t.length;
        for (let m = 0; m < _; m++) {
            const g = t[m];
            g.ensureMaterial(l);
            const v = g.material
              , x = g._shaderDefs
              , S = g.mask;
            v && v === u && x !== f && (u = null),
            v !== u && (this._materialSwitches++,
            v._scene = c,
            v.dirty && (v.updateUniforms(l, c),
            v.dirty = !1));
            const w = g.getShaderInstance(n, h, c, this.viewUniformFormat, this.viewBindGroupFormat, s);
            o(g, w, v !== u, !u || S !== p),
            u = v,
            f = x,
            p = S
        }
        return l.endShaderBatch == null || l.endShaderBatch(),
        Lr
    }
    renderForwardInternal(e, t, s, i, n, r) {
        const o = this.device
          , l = this.scene
          , c = 1 << i
          , d = r ? -1 : 1
          , h = this.scene.clusteredLightingEnabled;
        let u = !1;
        const f = t.drawCalls.length;
        for (let m = 0; m < f; m++) {
            var p, _;
            const g = t.drawCalls[m]
              , v = t.isNewMaterial[m]
              , x = t.lightMaskChanged[m]
              , S = t.shaderInstances[m]
              , w = g.material;
            g._shaderDefs;
            const T = g.mask;
            if (v) {
                const F = S.shader;
                if (!F.failed && o.setShader(F),
                u = F.failed,
                u)
                    break;
                if (w.setParameters(o),
                x) {
                    const L = this.dispatchDirectLights(s[pe], l, T, e);
                    h || this.dispatchLocalLights(s, l, T, L)
                }
                this.alphaTestId.setValue(w.alphaTest),
                o.setBlendState(w.blendState),
                o.setDepthState(w.depthState),
                o.setAlphaToCoverage(w.alphaToCoverage)
            }
            this.setupCullMode(e._cullFaces, d, g);
            const b = (p = g.stencilFront) != null ? p : w.stencilFront
              , E = (_ = g.stencilBack) != null ? _ : w.stencilBack;
            o.setStencilState(b, E);
            const C = g.mesh;
            g.setParameters(o, c),
            this.setVertexBuffers(o, C),
            this.setMorphing(o, g.morphInstance),
            this.setSkinning(o, g),
            this.setupMeshUniformBuffers(S, g);
            const R = g.renderStyle;
            if (o.setIndexBuffer(C.indexBuffer[R]),
            n == null || n(g, m),
            e.xr && e.xr.session && e.xr.views.list.length) {
                const F = e.xr.views;
                for (let L = 0; L < F.list.length; L++) {
                    const U = F.list[L];
                    o.setViewport(U.viewport.x, U.viewport.y, U.viewport.z, U.viewport.w),
                    this.projId.setValue(U.projMat.data),
                    this.projSkyboxId.setValue(U.projMat.data),
                    this.viewId.setValue(U.viewOffMat.data),
                    this.viewInvId.setValue(U.viewInvOffMat.data),
                    this.viewId3.setValue(U.viewMat3.data),
                    this.viewProjId.setValue(U.projViewOffMat.data),
                    this.viewPosId.setValue(U.positionData),
                    this.viewIndexId.setValue(L),
                    L === 0 ? this.drawInstance(o, g, C, R, !0) : this.drawInstance2(o, g, C, R),
                    this._forwardDrawCalls++
                }
            } else
                this.drawInstance(o, g, C, R, !0),
                this._forwardDrawCalls++;
            m < f - 1 && !t.isNewMaterial[m + 1] && w.setParameters(o, g.parameters)
        }
    }
    renderForward(e, t, s, i, n, r, o) {
        const l = this.renderForwardPrepareMaterials(e, t, s, r, i);
        this.renderForwardInternal(e, l, s, i, n, o),
        Lr.clear()
    }
    setSceneConstants() {
        const e = this.scene;
        if (this.dispatchGlobalLights(e),
        e.fog !== Tf) {
            if (this.fogColor[0] = e.fogColor.r,
            this.fogColor[1] = e.fogColor.g,
            this.fogColor[2] = e.fogColor.b,
            e.gammaCorrection)
                for (let s = 0; s < 3; s++)
                    this.fogColor[s] = Math.pow(this.fogColor[s], 2.2);
            this.fogColorId.setValue(this.fogColor),
            e.fog === ZE ? (this.fogStartId.setValue(e.fogStart),
            this.fogEndId.setValue(e.fogEnd)) : this.fogDensityId.setValue(e.fogDensity)
        }
        const t = this.device;
        this._screenSize[0] = t.width,
        this._screenSize[1] = t.height,
        this._screenSize[2] = 1 / t.width,
        this._screenSize[3] = 1 / t.height,
        this.screenSizeId.setValue(this._screenSize),
        this.pcssDiskSamplesId.setValue(this.pcssDiskSamples),
        this.pcssSphereSamplesId.setValue(this.pcssSphereSamples)
    }
    buildFrameGraph(e, t) {
        const s = this.scene
          , i = this.device.isWebGL1;
        if (e.reset(),
        this.update(t),
        s.clusteredLightingEnabled) {
            const {shadowsEnabled: c, cookiesEnabled: d} = s.lighting;
            this._renderPassUpdateClustered.update(e, c, d, this.lights, this.localLights),
            e.addRenderPass(this._renderPassUpdateClustered)
        } else
            this._shadowRendererLocal.buildNonClusteredRenderPasses(e, this.localLights);
        let n = 0
          , r = !0
          , o = null;
        const l = t._renderActions;
        for (let c = n; c < l.length; c++) {
            const d = l[c]
              , {layer: h, camera: u} = d;
            if (d.useCameraPasses)
                u.camera.renderPasses.forEach(f => {
                    e.addRenderPass(f)
                }
                );
            else {
                const f = u.camera.renderPassDepthGrab;
                f && i && d.firstCameraUse && (f.update(this.scene),
                e.addRenderPass(f));
                const p = h.id === hs;
                if (i && p && !u.renderSceneColorMap)
                    continue;
                const _ = p && (u.renderSceneColorMap || u.renderSceneDepthMap);
                r && (r = !1,
                n = c,
                o = d.renderTarget);
                const m = l[c + 1]
                  , v = (m ? m.layer.id === hs : !1) && (u.renderSceneColorMap || u.renderSceneDepthMap) && !i
                  , x = m ? m.firstCameraUse && this.cameraDirShadowLights.has(m.camera.camera) : !1;
                if (!m || m.renderTarget !== o || x || v || _) {
                    if (p && n === c || this.addMainRenderPass(e, t, o, n, c),
                    p) {
                        if (u.renderSceneColorMap) {
                            const w = u.camera.renderPassColorGrab;
                            w.source = u.renderTarget,
                            e.addRenderPass(w)
                        }
                        u.renderSceneDepthMap && !i && e.addRenderPass(u.camera.renderPassDepthGrab)
                    }
                    if (d.triggerPostprocess && u != null && u.onPostprocessing) {
                        const w = new eL(this.device,this,d);
                        e.addRenderPass(w)
                    }
                    r = !0
                }
            }
        }
    }
    addMainRenderPass(e, t, s, i, n) {
        const r = new JI(this.device,t,this.scene,this);
        r.init(s);
        const o = t._renderActions;
        for (let l = i; l <= n; l++)
            r.addRenderAction(o[l]);
        e.addRenderPass(r)
    }
    update(e) {
        this.frameUpdate(),
        this.shadowRenderer.frameUpdate(),
        this.scene._updateSkyMesh(),
        this.updateLayerComposition(e),
        this.collectLights(e),
        this.beginFrame(e),
        this.setSceneConstants(),
        this.cullComposition(e),
        this.gpuUpdate(this.processingMeshInstances)
    }
}
function nL(a, e) {
    return a.drawOrder - e.drawOrder
}
function rL(a, e) {
    const t = a._key[Sn]
      , s = e._key[Sn];
    return t === s && a.mesh && e.mesh ? e.mesh.id - a.mesh.id : s - t
}
function aL(a, e) {
    return e.zdist - a.zdist
}
function oL(a, e) {
    return a.zdist - e.zdist
}
const lL = [null, nL, rL, aL, oL];
let gp = 0;
const Tl = []
  , Qc = new Set;
class hL {
    constructor() {
        this.opaque = [],
        this.transparent = []
    }
}
class Fi {
    constructor(e={}) {
        var t, s, i, n;
        this.meshInstances = [],
        this.meshInstancesSet = new Set,
        this.shadowCasters = [],
        this.shadowCastersSet = new Set,
        this._visibleInstances = new WeakMap,
        this._lights = [],
        this._lightsSet = new Set,
        this._clusteredLightsSet = new Set,
        this._splitLights = [[], [], []],
        this._splitLightsDirty = !0,
        this.requiresLightCube = !1,
        this.cameras = [],
        this.camerasSet = new Set,
        this._dirtyComposition = !1,
        e.id !== void 0 ? (this.id = e.id,
        gp = Math.max(this.id + 1, gp)) : this.id = gp++,
        this.name = e.name,
        this._enabled = (t = e.enabled) != null ? t : !0,
        this._refCounter = this._enabled ? 1 : 0,
        this.opaqueSortMode = (s = e.opaqueSortMode) != null ? s : fA,
        this.transparentSortMode = (i = e.transparentSortMode) != null ? i : Vy,
        e.renderTarget && (this.renderTarget = e.renderTarget),
        this.shaderPass = (n = e.shaderPass) != null ? n : pc,
        this._clearColorBuffer = !!e.clearColorBuffer,
        this._clearDepthBuffer = !!e.clearDepthBuffer,
        this._clearStencilBuffer = !!e.clearStencilBuffer,
        this.onPreCull = e.onPreCull,
        this.onPreRender = e.onPreRender,
        this.onPreRenderOpaque = e.onPreRenderOpaque,
        this.onPreRenderTransparent = e.onPreRenderTransparent,
        this.onPostCull = e.onPostCull,
        this.onPostRender = e.onPostRender,
        this.onPostRenderOpaque = e.onPostRenderOpaque,
        this.onPostRenderTransparent = e.onPostRenderTransparent,
        this.onDrawCall = e.onDrawCall,
        this.onEnable = e.onEnable,
        this.onDisable = e.onDisable,
        this._enabled && this.onEnable && this.onEnable(),
        this.layerReference = e.layerReference,
        this.customSortCallback = null,
        this.customCalculateSortValues = null,
        this._lightHash = 0,
        this._lightHashDirty = !1,
        this._lightIdHash = 0,
        this._lightIdHashDirty = !1,
        this._shaderVersion = -1
    }
    set enabled(e) {
        e !== this._enabled && (this._dirtyComposition = !0,
        this._enabled = e,
        e ? (this.incrementCounter(),
        this.onEnable && this.onEnable()) : (this.decrementCounter(),
        this.onDisable && this.onDisable()))
    }
    get enabled() {
        return this._enabled
    }
    set clearColorBuffer(e) {
        this._clearColorBuffer = e,
        this._dirtyComposition = !0
    }
    get clearColorBuffer() {
        return this._clearColorBuffer
    }
    set clearDepthBuffer(e) {
        this._clearDepthBuffer = e,
        this._dirtyComposition = !0
    }
    get clearDepthBuffer() {
        return this._clearDepthBuffer
    }
    set clearStencilBuffer(e) {
        this._clearStencilBuffer = e,
        this._dirtyComposition = !0
    }
    get clearStencilBuffer() {
        return this._clearStencilBuffer
    }
    get hasClusteredLights() {
        return this._clusteredLightsSet.size > 0
    }
    get clusteredLightsSet() {
        return this._clusteredLightsSet
    }
    incrementCounter() {
        this._refCounter === 0 && (this._enabled = !0,
        this.onEnable && this.onEnable()),
        this._refCounter++
    }
    decrementCounter() {
        if (this._refCounter === 1)
            this._enabled = !1,
            this.onDisable && this.onDisable();
        else if (this._refCounter === 0)
            return;
        this._refCounter--
    }
    addMeshInstances(e, t) {
        const s = this.meshInstances
          , i = this.meshInstancesSet;
        for (let n = 0; n < e.length; n++) {
            const r = e[n];
            i.has(r) || (s.push(r),
            i.add(r),
            Qc.add(r.material))
        }
        if (t || this.addShadowCasters(e),
        Qc.size > 0) {
            const n = this._shaderVersion;
            Qc.forEach(r => {
                n >= 0 && r._shaderVersion !== n && (r.getShaderVariant !== Yi.prototype.getShaderVariant && r.clearVariants(),
                r._shaderVersion = n)
            }
            ),
            Qc.clear()
        }
    }
    removeMeshInstances(e, t) {
        const s = this.meshInstances
          , i = this.meshInstancesSet;
        for (let n = 0; n < e.length; n++) {
            const r = e[n];
            if (i.has(r)) {
                i.delete(r);
                const o = s.indexOf(r);
                o >= 0 && s.splice(o, 1)
            }
        }
        t || this.removeShadowCasters(e)
    }
    addShadowCasters(e) {
        const t = this.shadowCasters
          , s = this.shadowCastersSet;
        for (let i = 0; i < e.length; i++) {
            const n = e[i];
            n.castShadow && !s.has(n) && (s.add(n),
            t.push(n))
        }
    }
    removeShadowCasters(e) {
        const t = this.shadowCasters
          , s = this.shadowCastersSet;
        for (let i = 0; i < e.length; i++) {
            const n = e[i];
            if (s.has(n)) {
                s.delete(n);
                const r = t.indexOf(n);
                r >= 0 && t.splice(r, 1)
            }
        }
    }
    clearMeshInstances(e=!1) {
        this.meshInstances.length = 0,
        this.meshInstancesSet.clear(),
        e || (this.shadowCasters.length = 0,
        this.shadowCastersSet.clear())
    }
    markLightsDirty() {
        this._lightHashDirty = !0,
        this._lightIdHashDirty = !0,
        this._splitLightsDirty = !0
    }
    addLight(e) {
        const t = e.light;
        this._lightsSet.has(t) || (this._lightsSet.add(t),
        this._lights.push(t),
        this.markLightsDirty()),
        t.type !== pe && this._clusteredLightsSet.add(t)
    }
    removeLight(e) {
        const t = e.light;
        this._lightsSet.has(t) && (this._lightsSet.delete(t),
        this._lights.splice(this._lights.indexOf(t), 1),
        this.markLightsDirty()),
        t.type !== pe && this._clusteredLightsSet.delete(t)
    }
    clearLights() {
        this._lightsSet.forEach(e => e.removeLayer(this)),
        this._lightsSet.clear(),
        this._clusteredLightsSet.clear(),
        this._lights.length = 0,
        this.markLightsDirty()
    }
    get splitLights() {
        if (this._splitLightsDirty) {
            this._splitLightsDirty = !1;
            const e = this._splitLights;
            for (let s = 0; s < e.length; s++)
                e[s].length = 0;
            const t = this._lights;
            for (let s = 0; s < t.length; s++) {
                const i = t[s];
                i.enabled && e[i._type].push(i)
            }
            for (let s = 0; s < e.length; s++)
                e[s].sort( (i, n) => i.key - n.key)
        }
        return this._splitLights
    }
    evaluateLightHash(e, t, s) {
        let i = 0;
        const n = this._lights;
        for (let r = 0; r < n.length; r++) {
            const o = n[r].type !== pe;
            (e && o || t && !o) && Tl.push(s ? n[r].id : n[r].key)
        }
        return Tl.length > 0 && (Tl.sort(),
        i = US(Tl),
        Tl.length = 0),
        i
    }
    getLightHash(e) {
        return this._lightHashDirty && (this._lightHashDirty = !1,
        this._lightHash = this.evaluateLightHash(!e, !0, !1)),
        this._lightHash
    }
    getLightIdHash() {
        return this._lightIdHashDirty && (this._lightIdHashDirty = !1,
        this._lightIdHash = this.evaluateLightHash(!0, !1, !0)),
        this._lightIdHash
    }
    addCamera(e) {
        this.camerasSet.has(e.camera) || (this.camerasSet.add(e.camera),
        this.cameras.push(e),
        this._dirtyComposition = !0)
    }
    removeCamera(e) {
        if (this.camerasSet.has(e.camera)) {
            this.camerasSet.delete(e.camera);
            const t = this.cameras.indexOf(e);
            this.cameras.splice(t, 1),
            this._dirtyComposition = !0
        }
    }
    clearCameras() {
        this.cameras.length = 0,
        this.camerasSet.clear(),
        this._dirtyComposition = !0
    }
    _calculateSortDistances(e, t, s, i) {
        for (let n = 0; n < t; n++) {
            const r = e[n];
            if (r.layer <= JE)
                continue;
            if (r.calculateSortDistance) {
                r.zdist = r.calculateSortDistance(r, s, i);
                continue
            }
            const o = r.aabb.center
              , l = o.x - s.x
              , c = o.y - s.y
              , d = o.z - s.z;
            r.zdist = l * i.x + c * i.y + d * i.z
        }
    }
    getCulledInstances(e) {
        let t = this._visibleInstances.get(e);
        return t || (t = new hL,
        this._visibleInstances.set(e, t)),
        t
    }
    sortVisible(e, t) {
        const s = t ? this.transparentSortMode : this.opaqueSortMode;
        if (s === Od)
            return;
        const i = this.getCulledInstances(e)
          , n = t ? i.transparent : i.opaque
          , r = e.node;
        if (s === mA) {
            const o = r.getPosition()
              , l = r.forward;
            this.customCalculateSortValues && this.customCalculateSortValues(n, n.length, o, l),
            this.customSortCallback && n.sort(this.customSortCallback)
        } else {
            if (s === Vy || s === pA) {
                const o = r.getPosition()
                  , l = r.forward;
                this._calculateSortDistances(n, n.length, o, l)
            }
            n.sort(lL[s])
        }
    }
}
const cL = (a, e) => a.priority - e.priority
  , Lh = a => a.sort(cL);
class b0 extends fe {
    constructor(e="Untitled") {
        super(),
        this.layerList = [],
        this.layerIdMap = new Map,
        this.layerNameMap = new Map,
        this.layerOpaqueIndexMap = new Map,
        this.layerTransparentIndexMap = new Map,
        this.subLayerList = [],
        this.subLayerEnabled = [],
        this.cameras = [],
        this.camerasMap = new Map,
        this._renderActions = [],
        this._dirty = !1,
        this.name = e,
        this._opaqueOrder = {},
        this._transparentOrder = {}
    }
    destroy() {
        this.destroyRenderActions()
    }
    destroyRenderActions() {
        this._renderActions.forEach(e => e.destroy()),
        this._renderActions.length = 0
    }
    _update() {
        const e = this.layerList.length;
        if (!this._dirty) {
            for (let t = 0; t < e; t++)
                if (this.layerList[t]._dirtyComposition) {
                    this._dirty = !0;
                    break
                }
        }
        if (this._dirty) {
            this._dirty = !1,
            this.cameras.length = 0;
            for (let s = 0; s < e; s++) {
                const i = this.layerList[s];
                i._dirtyComposition = !1;
                for (let n = 0; n < i.cameras.length; n++) {
                    const r = i.cameras[n];
                    this.cameras.indexOf(r) < 0 && this.cameras.push(r)
                }
            }
            this.cameras.length > 1 && Lh(this.cameras),
            this.camerasMap.clear();
            for (let s = 0; s < this.cameras.length; s++)
                this.camerasMap.set(this.cameras[s], s);
            let t = 0;
            this.destroyRenderActions();
            for (let s = 0; s < this.cameras.length; s++) {
                const i = this.cameras[s];
                if (i.camera.renderPasses.length > 0) {
                    this.addDummyRenderAction(t, i);
                    continue
                }
                let n = !0;
                const r = t;
                let o = null
                  , l = !1;
                for (let c = 0; c < e; c++) {
                    const d = this.layerList[c];
                    if (d.enabled && this.subLayerEnabled[c] && d.cameras.length > 0 && i.layers.indexOf(d.id) >= 0) {
                        !l && d.id === i.disablePostEffectsLayer && (l = !0,
                        o && (o.triggerPostprocess = !0));
                        const u = this.subLayerList[c];
                        o = this.addRenderAction(t, d, u, i, n, l),
                        t++,
                        n = !1
                    }
                }
                r < t && (o.lastCameraUse = !0),
                !l && o && (o.triggerPostprocess = !0),
                i.renderTarget && i.postEffectsEnabled && this.propagateRenderTarget(r - 1, i)
            }
            this._logRenderActions()
        }
    }
    getNextRenderAction(e) {
        const t = new _x;
        return this._renderActions.push(t),
        t
    }
    addDummyRenderAction(e, t) {
        const s = this.getNextRenderAction(e);
        s.camera = t,
        s.useCameraPasses = !0
    }
    addRenderAction(e, t, s, i, n, r) {
        let o = t.renderTarget;
        i && i.renderTarget && t.id !== hs && (o = i.renderTarget);
        let l = !1;
        const c = this._renderActions;
        for (let f = e - 1; f >= 0; f--)
            if (c[f].camera === i && c[f].renderTarget === o) {
                l = !0;
                break
            }
        r && i.postEffectsEnabled && (o = null);
        const d = this.getNextRenderAction(e);
        d.triggerPostprocess = !1,
        d.layer = t,
        d.transparent = s,
        d.camera = i,
        d.renderTarget = o,
        d.firstCameraUse = n,
        d.lastCameraUse = !1;
        const h = n || !l
          , u = t.clearColorBuffer || t.clearDepthBuffer || t.clearStencilBuffer;
        return (h || u) && d.setupClears(h ? i : void 0, t),
        d
    }
    propagateRenderTarget(e, t) {
        for (let s = e; s >= 0; s--) {
            const i = this._renderActions[s]
              , n = i.layer;
            if (i.renderTarget && n.id !== hs)
                break;
            if (n.id === hs)
                continue;
            if (i.useCameraPasses)
                break;
            const r = i == null ? void 0 : i.camera.camera;
            if (r && (!t.camera.rect.equals(r.rect) || !t.camera.scissorRect.equals(r.scissorRect)))
                break;
            i.renderTarget = t.renderTarget
        }
    }
    _logRenderActions() {}
    _isLayerAdded(e) {
        return this.layerIdMap.get(e.id) === e
    }
    _isSublayerAdded(e, t) {
        return (t ? this.layerTransparentIndexMap : this.layerOpaqueIndexMap).get(e) !== void 0
    }
    push(e) {
        this._isLayerAdded(e) || (this.layerList.push(e),
        this.layerList.push(e),
        this._opaqueOrder[e.id] = this.subLayerList.push(!1) - 1,
        this._transparentOrder[e.id] = this.subLayerList.push(!0) - 1,
        this.subLayerEnabled.push(!0),
        this.subLayerEnabled.push(!0),
        this._updateLayerMaps(),
        this._dirty = !0,
        this.fire("add", e))
    }
    insert(e, t) {
        if (this._isLayerAdded(e))
            return;
        this.layerList.splice(t, 0, e, e),
        this.subLayerList.splice(t, 0, !1, !0);
        const s = this.layerList.length;
        this._updateOpaqueOrder(t, s - 1),
        this._updateTransparentOrder(t, s - 1),
        this.subLayerEnabled.splice(t, 0, !0, !0),
        this._updateLayerMaps(),
        this._dirty = !0,
        this.fire("add", e)
    }
    remove(e) {
        let t = this.layerList.indexOf(e);
        for (delete this._opaqueOrder[t],
        delete this._transparentOrder[t]; t >= 0; )
            this.layerList.splice(t, 1),
            this.subLayerList.splice(t, 1),
            this.subLayerEnabled.splice(t, 1),
            t = this.layerList.indexOf(e),
            this._dirty = !0,
            this.fire("remove", e);
        const s = this.layerList.length;
        this._updateOpaqueOrder(0, s - 1),
        this._updateTransparentOrder(0, s - 1),
        this._updateLayerMaps()
    }
    pushOpaque(e) {
        this._isSublayerAdded(e, !1) || (this.layerList.push(e),
        this._opaqueOrder[e.id] = this.subLayerList.push(!1) - 1,
        this.subLayerEnabled.push(!0),
        this._updateLayerMaps(),
        this._dirty = !0,
        this.fire("add", e))
    }
    insertOpaque(e, t) {
        if (this._isSublayerAdded(e, !1))
            return;
        this.layerList.splice(t, 0, e),
        this.subLayerList.splice(t, 0, !1);
        const s = this.subLayerList.length;
        this._updateOpaqueOrder(t, s - 1),
        this.subLayerEnabled.splice(t, 0, !0),
        this._updateLayerMaps(),
        this._dirty = !0,
        this.fire("add", e)
    }
    removeOpaque(e) {
        for (let t = 0, s = this.layerList.length; t < s; t++)
            if (this.layerList[t] === e && !this.subLayerList[t]) {
                this.layerList.splice(t, 1),
                this.subLayerList.splice(t, 1),
                s--,
                this._updateOpaqueOrder(t, s - 1),
                this.subLayerEnabled.splice(t, 1),
                this._dirty = !0,
                this.layerList.indexOf(e) < 0 && this.fire("remove", e);
                break
            }
        this._updateLayerMaps()
    }
    pushTransparent(e) {
        this._isSublayerAdded(e, !0) || (this.layerList.push(e),
        this._transparentOrder[e.id] = this.subLayerList.push(!0) - 1,
        this.subLayerEnabled.push(!0),
        this._updateLayerMaps(),
        this._dirty = !0,
        this.fire("add", e))
    }
    insertTransparent(e, t) {
        if (this._isSublayerAdded(e, !0))
            return;
        this.layerList.splice(t, 0, e),
        this.subLayerList.splice(t, 0, !0);
        const s = this.subLayerList.length;
        this._updateTransparentOrder(t, s - 1),
        this.subLayerEnabled.splice(t, 0, !0),
        this._updateLayerMaps(),
        this._dirty = !0,
        this.fire("add", e)
    }
    removeTransparent(e) {
        for (let t = 0, s = this.layerList.length; t < s; t++)
            if (this.layerList[t] === e && this.subLayerList[t]) {
                this.layerList.splice(t, 1),
                this.subLayerList.splice(t, 1),
                s--,
                this._updateTransparentOrder(t, s - 1),
                this.subLayerEnabled.splice(t, 1),
                this._dirty = !0,
                this.layerList.indexOf(e) < 0 && this.fire("remove", e);
                break
            }
        this._updateLayerMaps()
    }
    getOpaqueIndex(e) {
        var t;
        return (t = this.layerOpaqueIndexMap.get(e)) != null ? t : -1
    }
    getTransparentIndex(e) {
        var t;
        return (t = this.layerTransparentIndexMap.get(e)) != null ? t : -1
    }
    isEnabled(e, t) {
        const s = t ? this.getTransparentIndex(e) : this.getOpaqueIndex(e);
        return this.subLayerEnabled[s]
    }
    _updateLayerMaps() {
        this.layerIdMap.clear(),
        this.layerNameMap.clear(),
        this.layerOpaqueIndexMap.clear(),
        this.layerTransparentIndexMap.clear();
        for (let e = 0; e < this.layerList.length; e++) {
            const t = this.layerList[e];
            this.layerIdMap.set(t.id, t),
            this.layerNameMap.set(t.name, t),
            (this.subLayerList[e] ? this.layerTransparentIndexMap : this.layerOpaqueIndexMap).set(t, e)
        }
    }
    getLayerById(e) {
        var t;
        return (t = this.layerIdMap.get(e)) != null ? t : null
    }
    getLayerByName(e) {
        var t;
        return (t = this.layerNameMap.get(e)) != null ? t : null
    }
    _updateOpaqueOrder(e, t) {
        for (let s = e; s <= t; s++)
            this.subLayerList[s] === !1 && (this._opaqueOrder[this.layerList[s].id] = s)
    }
    _updateTransparentOrder(e, t) {
        for (let s = e; s <= t; s++)
            this.subLayerList[s] === !0 && (this._transparentOrder[this.layerList[s].id] = s)
    }
    _sortLayersDescending(e, t, s) {
        let i = -1
          , n = -1;
        for (let r = 0, o = e.length; r < o; r++) {
            const l = e[r];
            s.hasOwnProperty(l) && (i = Math.max(i, s[l]))
        }
        for (let r = 0, o = t.length; r < o; r++) {
            const l = t[r];
            s.hasOwnProperty(l) && (n = Math.max(n, s[l]))
        }
        return i === -1 && n !== -1 ? 1 : n === -1 && i !== -1 ? -1 : n - i
    }
    sortTransparentLayers(e, t) {
        return this._sortLayersDescending(e, t, this._transparentOrder)
    }
    sortOpaqueLayers(e, t) {
        return this._sortLayersDescending(e, t, this._opaqueOrder)
    }
}
const Jc = new y
  , ii = {
    bias: 0,
    normalBias: 0
}
  , yp = {
    r: 0,
    g: 1,
    b: 2,
    a: 3
}
  , Im = {
    directional: pe,
    omni: Oe,
    point: Oe,
    spot: He
}
  , dL = [[new M(0,0,1,1)], [new M(0,0,.5,.5), new M(0,.5,.5,.5)], [new M(0,0,.5,.5), new M(0,.5,.5,.5), new M(.5,0,.5,.5)], [new M(0,0,.5,.5), new M(0,.5,.5,.5), new M(.5,0,.5,.5), new M(.5,.5,.5,.5)]];
let uL = 0;
class fL {
    constructor(e, t, s, i) {
        this.light = i,
        this.camera = t,
        this.shadowCamera = Ef.createShadowCamera(e, i._shadowType, i._type, s),
        this.shadowMatrix = new ee,
        this.shadowViewport = new M(0,0,1,1),
        this.shadowScissor = new M(0,0,1,1),
        this.depthRangeCompensation = 0,
        this.projectionCompensation = 0,
        this.face = s,
        this.visibleCasters = [],
        this.viewBindGroups = []
    }
    destroy() {
        this.viewBindGroups.forEach(e => {
            e.defaultUniformBuffer.destroy(),
            e.destroy()
        }
        ),
        this.viewBindGroups.length = 0
    }
    get shadowBuffer() {
        const e = this.shadowCamera.renderTarget;
        if (e) {
            const t = this.light;
            return t._type === Oe ? e.colorBuffer : t._isPcf && t.device.supportsDepthShadow ? e.depthBuffer : e.colorBuffer
        }
        return null
    }
}
let Sx = class Lm {
    constructor(e, t) {
        this.layers = new Set,
        this.clusteredLighting = void 0,
        this.shadowDepthState = $t.DEFAULT.clone(),
        this.device = e,
        this.clusteredLighting = t,
        this.id = uL++,
        this._type = pe,
        this._color = new z(.8,.8,.8),
        this._intensity = 1,
        this._affectSpecularity = !0,
        this._luminance = 0,
        this._castShadows = !1,
        this._enabled = !1,
        this._mask = Rs,
        this.isStatic = !1,
        this.key = 0,
        this.bakeDir = !0,
        this.bakeNumSamples = 1,
        this.bakeArea = 0,
        this.attenuationStart = 10,
        this.attenuationEnd = 10,
        this._falloffMode = q_,
        this._shadowType = St,
        this._vsmBlurSize = 11,
        this.vsmBlurMode = Y_,
        this.vsmBias = .01 * .25,
        this._cookie = null,
        this.cookieIntensity = 1,
        this._cookieFalloff = !0,
        this._cookieChannel = "rgb",
        this._cookieTransform = null,
        this._cookieTransformUniform = new Float32Array(4),
        this._cookieOffset = null,
        this._cookieOffsetUniform = new Float32Array(2),
        this._cookieTransformSet = !1,
        this._cookieOffsetSet = !1,
        this._innerConeAngle = 40,
        this._outerConeAngle = 45,
        this.cascades = null,
        this._shadowMatrixPalette = null,
        this._shadowCascadeDistances = null,
        this.numCascades = 1,
        this.cascadeDistribution = .5,
        this._shape = Nt,
        this._finalColor = new Float32Array([.8, .8, .8]);
        const s = Math.pow(this._finalColor[0], 2.2);
        this._linearFinalColor = new Float32Array([s, s, s]),
        this._position = new y(0,0,0),
        this._direction = new y(0,0,0),
        this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180),
        this._updateOuterAngle(this._outerConeAngle),
        this._usePhysicalUnits = void 0,
        this._shadowMap = null,
        this._shadowRenderParams = [],
        this._shadowCameraParams = [],
        this.shadowDistance = 40,
        this._shadowResolution = 1024,
        this._shadowBias = -5e-4,
        this.shadowIntensity = 1,
        this._normalOffsetBias = 0,
        this.shadowUpdateMode = tg,
        this.shadowUpdateOverrides = null,
        this._penumbraSize = 1,
        this._isVsm = !1,
        this._isPcf = !0,
        this._cookieMatrix = null,
        this._atlasViewport = null,
        this.atlasViewportAllocated = !1,
        this.atlasVersion = 0,
        this.atlasSlotIndex = 0,
        this.atlasSlotUpdated = !1,
        this._node = null,
        this._renderData = [],
        this.visibleThisFrame = !1,
        this.maxScreenSize = 0,
        this._updateShadowBias()
    }
    destroy() {
        this._destroyShadowMap(),
        this.releaseRenderData(),
        this._renderData = null
    }
    releaseRenderData() {
        if (this._renderData) {
            for (let e = 0; e < this._renderData.length; e++)
                this._renderData[e].destroy();
            this._renderData.length = 0
        }
    }
    addLayer(e) {
        this.layers.add(e)
    }
    removeLayer(e) {
        this.layers.delete(e)
    }
    set shadowBias(e) {
        this._shadowBias !== e && (this._shadowBias = e,
        this._updateShadowBias())
    }
    get shadowBias() {
        return this._shadowBias
    }
    set numCascades(e) {
        (!this.cascades || this.numCascades !== e) && (this.cascades = dL[e - 1],
        this._shadowMatrixPalette = new Float32Array(4 * 16),
        this._shadowCascadeDistances = new Float32Array(4),
        this._destroyShadowMap(),
        this.updateKey())
    }
    get numCascades() {
        return this.cascades.length
    }
    set shadowMap(e) {
        this._shadowMap !== e && (this._destroyShadowMap(),
        this._shadowMap = e)
    }
    get shadowMap() {
        return this._shadowMap
    }
    set mask(e) {
        this._mask !== e && (this._mask = e,
        this.updateKey())
    }
    get mask() {
        return this._mask
    }
    get numShadowFaces() {
        const e = this._type;
        return e === pe ? this.numCascades : e === Oe ? 6 : 1
    }
    set type(e) {
        if (this._type === e)
            return;
        this._type = e,
        this._destroyShadowMap(),
        this._updateShadowBias(),
        this.updateKey();
        const t = this._shadowType;
        this._shadowType = null,
        this.shadowUpdateOverrides = null,
        this.shadowType = t
    }
    get type() {
        return this._type
    }
    set shape(e) {
        if (this._shape === e)
            return;
        this._shape = e,
        this._destroyShadowMap(),
        this.updateKey();
        const t = this._shadowType;
        this._shadowType = null,
        this.shadowType = t
    }
    get shape() {
        return this._shape
    }
    set usePhysicalUnits(e) {
        this._usePhysicalUnits !== e && (this._usePhysicalUnits = e,
        this._updateFinalColor())
    }
    get usePhysicalUnits() {
        return this._usePhysicalUnits
    }
    set shadowType(e) {
        if (this._shadowType === e)
            return;
        const t = this.device;
        this._type === Oe && e !== St && e !== Kt && (e = St);
        const s = t.supportsDepthShadow;
        e === gi && !s && (e = St),
        e === Hs && (!t.textureFloatRenderable || !t.textureFloatFilterable) && (e = pi),
        e === pi && !t.textureHalfFloatRenderable && (e = zs),
        this._isVsm = e >= zs && e <= Hs,
        this._isPcf = e === Ni || e === St || e === gi,
        this._shadowType = e,
        this._destroyShadowMap(),
        this.updateKey()
    }
    get shadowType() {
        return this._shadowType
    }
    set enabled(e) {
        this._enabled !== e && (this._enabled = e,
        this.layersDirty())
    }
    get enabled() {
        return this._enabled
    }
    set castShadows(e) {
        this._castShadows !== e && (this._castShadows = e,
        this._destroyShadowMap(),
        this.layersDirty(),
        this.updateKey())
    }
    get castShadows() {
        return this._castShadows && this._mask !== zi && this._mask !== 0
    }
    set shadowResolution(e) {
        this._shadowResolution !== e && (this._type === Oe ? e = Math.min(e, this.device.maxCubeMapSize) : e = Math.min(e, this.device.maxTextureSize),
        this._shadowResolution = e,
        this._destroyShadowMap())
    }
    get shadowResolution() {
        return this._shadowResolution
    }
    set vsmBlurSize(e) {
        this._vsmBlurSize !== e && (e % 2 === 0 && e++,
        this._vsmBlurSize = e)
    }
    get vsmBlurSize() {
        return this._vsmBlurSize
    }
    set normalOffsetBias(e) {
        this._normalOffsetBias !== e && ((!this._normalOffsetBias && e || this._normalOffsetBias && !e) && this.updateKey(),
        this._normalOffsetBias = e)
    }
    get normalOffsetBias() {
        return this._normalOffsetBias
    }
    set falloffMode(e) {
        this._falloffMode !== e && (this._falloffMode = e,
        this.updateKey())
    }
    get falloffMode() {
        return this._falloffMode
    }
    set innerConeAngle(e) {
        this._innerConeAngle !== e && (this._innerConeAngle = e,
        this._innerConeAngleCos = Math.cos(e * Math.PI / 180),
        this._usePhysicalUnits && this._updateFinalColor())
    }
    get innerConeAngle() {
        return this._innerConeAngle
    }
    set outerConeAngle(e) {
        this._outerConeAngle !== e && (this._outerConeAngle = e,
        this._updateOuterAngle(e),
        this._usePhysicalUnits && this._updateFinalColor())
    }
    get outerConeAngle() {
        return this._outerConeAngle
    }
    set penumbraSize(e) {
        this._penumbraSize = e
    }
    get penumbraSize() {
        return this._penumbraSize
    }
    _updateOuterAngle(e) {
        const t = e * Math.PI / 180;
        this._outerConeAngleCos = Math.cos(t),
        this._outerConeAngleSin = Math.sin(t)
    }
    set intensity(e) {
        this._intensity !== e && (this._intensity = e,
        this._updateFinalColor())
    }
    get intensity() {
        return this._intensity
    }
    set affectSpecularity(e) {
        this._type === pe && (this._affectSpecularity = e,
        this.updateKey())
    }
    get affectSpecularity() {
        return this._affectSpecularity
    }
    set luminance(e) {
        this._luminance !== e && (this._luminance = e,
        this._updateFinalColor())
    }
    get luminance() {
        return this._luminance
    }
    get cookieMatrix() {
        return this._cookieMatrix || (this._cookieMatrix = new ee),
        this._cookieMatrix
    }
    get atlasViewport() {
        return this._atlasViewport || (this._atlasViewport = new M(0,0,1,1)),
        this._atlasViewport
    }
    set cookie(e) {
        this._cookie !== e && (this._cookie = e,
        this.updateKey())
    }
    get cookie() {
        return this._cookie
    }
    set cookieFalloff(e) {
        this._cookieFalloff !== e && (this._cookieFalloff = e,
        this.updateKey())
    }
    get cookieFalloff() {
        return this._cookieFalloff
    }
    set cookieChannel(e) {
        if (this._cookieChannel !== e) {
            if (e.length < 3) {
                const t = e.charAt(e.length - 1)
                  , s = 3 - e.length;
                for (let i = 0; i < s; i++)
                    e += t
            }
            this._cookieChannel = e,
            this.updateKey()
        }
    }
    get cookieChannel() {
        return this._cookieChannel
    }
    set cookieTransform(e) {
        this._cookieTransform !== e && (this._cookieTransform = e,
        this._cookieTransformSet = !!e,
        e && !this._cookieOffset && (this.cookieOffset = new P,
        this._cookieOffsetSet = !1),
        this.updateKey())
    }
    get cookieTransform() {
        return this._cookieTransform
    }
    set cookieOffset(e) {
        if (this._cookieOffset === e)
            return;
        !!(this._cookieTransformSet || e) && !e && this._cookieOffset ? this._cookieOffset.set(0, 0) : this._cookieOffset = e,
        this._cookieOffsetSet = !!e,
        e && !this._cookieTransform && (this.cookieTransform = new M(1,1,0,0),
        this._cookieTransformSet = !1),
        this.updateKey()
    }
    get cookieOffset() {
        return this._cookieOffset
    }
    beginFrame() {
        this.visibleThisFrame = this._type === pe && this._enabled,
        this.maxScreenSize = 0,
        this.atlasViewportAllocated = !1,
        this.atlasSlotUpdated = !1
    }
    _destroyShadowMap() {
        if (this.releaseRenderData(),
        this._shadowMap && (this._shadowMap.cached || this._shadowMap.destroy(),
        this._shadowMap = null),
        this.shadowUpdateMode === Si && (this.shadowUpdateMode = ga),
        this.shadowUpdateOverrides)
            for (let e = 0; e < this.shadowUpdateOverrides.length; e++)
                this.shadowUpdateOverrides[e] === Si && (this.shadowUpdateOverrides[e] = ga)
    }
    getRenderData(e, t) {
        for (let i = 0; i < this._renderData.length; i++) {
            const n = this._renderData[i];
            if (n.camera === e && n.face === t)
                return n
        }
        const s = new fL(this.device,e,t,this);
        return this._renderData.push(s),
        s
    }
    clone() {
        const e = new Lm(this.device,this.clusteredLighting);
        return e.type = this._type,
        e.setColor(this._color),
        e.intensity = this._intensity,
        e.affectSpecularity = this._affectSpecularity,
        e.luminance = this._luminance,
        e.castShadows = this.castShadows,
        e._enabled = this._enabled,
        e.attenuationStart = this.attenuationStart,
        e.attenuationEnd = this.attenuationEnd,
        e.falloffMode = this._falloffMode,
        e.shadowType = this._shadowType,
        e.vsmBlurSize = this._vsmBlurSize,
        e.vsmBlurMode = this.vsmBlurMode,
        e.vsmBias = this.vsmBias,
        e.penumbraSize = this.penumbraSize,
        e.shadowUpdateMode = this.shadowUpdateMode,
        e.mask = this.mask,
        this.shadowUpdateOverrides && (e.shadowUpdateOverrides = this.shadowUpdateOverrides.slice()),
        e.innerConeAngle = this._innerConeAngle,
        e.outerConeAngle = this._outerConeAngle,
        e.numCascades = this.numCascades,
        e.cascadeDistribution = this.cascadeDistribution,
        e.shape = this._shape,
        e.shadowDepthState.copy(this.shadowDepthState),
        e.shadowBias = this.shadowBias,
        e.normalOffsetBias = this._normalOffsetBias,
        e.shadowResolution = this._shadowResolution,
        e.shadowDistance = this.shadowDistance,
        e.shadowIntensity = this.shadowIntensity,
        e
    }
    static getLightUnitConversion(e, t=Math.PI / 4, s=0) {
        switch (e) {
        case He:
            {
                const i = Math.cos(t)
                  , n = Math.cos(s);
                return 2 * Math.PI * (1 - n + (n - i) / 2)
            }
        case Oe:
            return 4 * Math.PI;
        case pe:
            return 1
        }
    }
    _getUniformBiasValues(e) {
        const t = e.shadowCamera._farClip;
        switch (this._type) {
        case Oe:
            ii.bias = this.shadowBias,
            ii.normalBias = this._normalOffsetBias;
            break;
        case He:
            this._isVsm ? ii.bias = -1e-5 * 20 : (ii.bias = this.shadowBias * 20,
            this.device.isWebGL1 && this.device.extStandardDerivatives && (ii.bias *= -100)),
            ii.normalBias = this._isVsm ? this.vsmBias / (this.attenuationEnd / 7) : this._normalOffsetBias;
            break;
        case pe:
            this._isVsm ? ii.bias = -1e-5 * 20 : (ii.bias = this.shadowBias / t * 100,
            this.device.isWebGL1 && this.device.extStandardDerivatives && (ii.bias *= -100)),
            ii.normalBias = this._isVsm ? this.vsmBias / (t / 7) : this._normalOffsetBias;
            break
        }
        return ii
    }
    getColor() {
        return this._color
    }
    getBoundingSphere(e) {
        if (this._type === He) {
            const t = this.attenuationEnd
              , s = this._outerConeAngle
              , i = this._outerConeAngleCos
              , n = this._node;
            Jc.copy(n.up),
            s > 45 ? (e.radius = t * this._outerConeAngleSin,
            Jc.mulScalar(-t * i)) : (e.radius = t / (2 * i),
            Jc.mulScalar(-e.radius)),
            e.center.add2(n.getPosition(), Jc)
        } else
            this._type === Oe && (e.center = this._node.getPosition(),
            e.radius = this.attenuationEnd)
    }
    getBoundingBox(e) {
        if (this._type === He) {
            const t = this.attenuationEnd
              , s = this._outerConeAngle
              , i = this._node
              , n = Math.abs(Math.sin(s * W.DEG_TO_RAD) * t);
            e.center.set(0, -t * .5, 0),
            e.halfExtents.set(n, t * .5, n),
            e.setFromTransformedAabb(e, i.getWorldTransform(), !0)
        } else
            this._type === Oe && (e.center.copy(this._node.getPosition()),
            e.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd))
    }
    _updateShadowBias() {
        const e = this.device;
        if (e.isWebGL2 || e.isWebGPU)
            if (this._type === Oe && !this.clusteredLighting)
                this.shadowDepthState.depthBias = 0,
                this.shadowDepthState.depthBiasSlope = 0;
            else {
                const t = this.shadowBias * -1e3;
                this.shadowDepthState.depthBias = t,
                this.shadowDepthState.depthBiasSlope = t
            }
    }
    _updateFinalColor() {
        const e = this._color
          , t = e.r
          , s = e.g
          , i = e.b;
        let n = this._intensity;
        this._usePhysicalUnits && (n = this._luminance / Lm.getLightUnitConversion(this._type, this._outerConeAngle * W.DEG_TO_RAD, this._innerConeAngle * W.DEG_TO_RAD));
        const r = this._finalColor
          , o = this._linearFinalColor;
        r[0] = t * n,
        r[1] = s * n,
        r[2] = i * n,
        n >= 1 ? (o[0] = Math.pow(t, 2.2) * n,
        o[1] = Math.pow(s, 2.2) * n,
        o[2] = Math.pow(i, 2.2) * n) : (o[0] = Math.pow(r[0], 2.2),
        o[1] = Math.pow(r[1], 2.2),
        o[2] = Math.pow(r[2], 2.2))
    }
    setColor() {
        arguments.length === 1 ? this._color.set(arguments[0].r, arguments[0].g, arguments[0].b) : arguments.length === 3 && this._color.set(arguments[0], arguments[1], arguments[2]),
        this._updateFinalColor()
    }
    layersDirty() {
        this.layers.forEach(e => {
            e.markLightsDirty()
        }
        )
    }
    updateKey() {
        let e = this._type << 29 | (this._castShadows ? 1 : 0) << 28 | this._shadowType << 25 | this._falloffMode << 23 | (this._normalOffsetBias !== 0 ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | yp[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12 | this._shape << 10 | this.numCascades - 1 << 8 | (this.affectSpecularity ? 1 : 0) << 7 | this.mask << 6;
        this._cookieChannel.length === 3 && (e |= yp[this._cookieChannel.charAt(1)] << 16,
        e |= yp[this._cookieChannel.charAt(2)] << 14),
        e !== this.key && this.layersDirty(),
        this.key = e
    }
}
;
class xx {
    constructor(e, t, s) {
        this._areaLightsEnabled = !1,
        this._cells = new y(10,3,10),
        this._maxLightsPerCell = 255,
        this._shadowsEnabled = !0,
        this._shadowType = St,
        this._shadowAtlasResolution = 2048,
        this._cookiesEnabled = !1,
        this._cookieAtlasResolution = 2048,
        this.debugLayer = void 0,
        this.atlasSplit = null,
        this._supportsAreaLights = e,
        this._maxTextureSize = t,
        this._dirtyLightsFnc = s
    }
    applySettings(e) {
        var t, s, i, n, r, o, l;
        this.shadowsEnabled = (t = e.lightingShadowsEnabled) != null ? t : this.shadowsEnabled,
        this.cookiesEnabled = (s = e.lightingCookiesEnabled) != null ? s : this.cookiesEnabled,
        this.areaLightsEnabled = (i = e.lightingAreaLightsEnabled) != null ? i : this.areaLightsEnabled,
        this.shadowAtlasResolution = (n = e.lightingShadowAtlasResolution) != null ? n : this.shadowAtlasResolution,
        this.cookieAtlasResolution = (r = e.lightingCookieAtlasResolution) != null ? r : this.cookieAtlasResolution,
        this.maxLightsPerCell = (o = e.lightingMaxLightsPerCell) != null ? o : this.maxLightsPerCell,
        this.shadowType = (l = e.lightingShadowType) != null ? l : this.shadowType,
        e.lightingCells && (this.cell = new y(e.lightingCells))
    }
    set cells(e) {
        this._cells.copy(e)
    }
    get cells() {
        return this._cells
    }
    set maxLightsPerCell(e) {
        this._maxLightsPerCell = W.clamp(e, 1, 255)
    }
    get maxLightsPerCell() {
        return this._maxLightsPerCell
    }
    set cookieAtlasResolution(e) {
        this._cookieAtlasResolution = W.clamp(e, 32, this._maxTextureSize)
    }
    get cookieAtlasResolution() {
        return this._cookieAtlasResolution
    }
    set shadowAtlasResolution(e) {
        this._shadowAtlasResolution = W.clamp(e, 32, this._maxTextureSize)
    }
    get shadowAtlasResolution() {
        return this._shadowAtlasResolution
    }
    set shadowType(e) {
        this._shadowType !== e && (this._shadowType = e,
        this._dirtyLightsFnc())
    }
    get shadowType() {
        return this._shadowType
    }
    set cookiesEnabled(e) {
        this._cookiesEnabled !== e && (this._cookiesEnabled = e,
        this._dirtyLightsFnc())
    }
    get cookiesEnabled() {
        return this._cookiesEnabled
    }
    set areaLightsEnabled(e) {
        this._supportsAreaLights && this._areaLightsEnabled !== e && (this._areaLightsEnabled = e,
        this._dirtyLightsFnc())
    }
    get areaLightsEnabled() {
        return this._areaLightsEnabled
    }
    set shadowsEnabled(e) {
        this._shadowsEnabled !== e && (this._shadowsEnabled = e,
        this._dirtyLightsFnc())
    }
    get shadowsEnabled() {
        return this._shadowsEnabled
    }
}
const pL = `
	attribute vec2 vertex_position;
	varying vec2 uv0;
	void main(void) {
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		uv0 = vertex_position.xy * 0.5 + 0.5;
	}
	`
  , mL = new ft(!0,Qs,Ut,Ut);
class Sa {
    constructor(e) {
        this.morph = e,
        e.incRefCount(),
        this.device = e.device,
        this._weights = [],
        this._weightMap = new Map;
        for (let t = 0; t < e._targets.length; t++) {
            const s = e._targets[t];
            s.name && this._weightMap.set(s.name, t),
            this.setWeight(t, s.defaultWeight)
        }
        if (this._activeTargets = [],
        e.useTextureMorph) {
            this.shaderCache = {},
            this.maxSubmitCount = this.device.maxTextures,
            this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);
            const t = (s, i) => (this[i] = e._createTexture(s, e._renderTextureFormat),
            new It({
                colorBuffer: this[i],
                depth: !1
            }));
            e.morphPositions && (this.rtPositions = t("MorphRTPos", "texturePositions")),
            e.morphNormals && (this.rtNormals = t("MorphRTNrm", "textureNormals")),
            this._textureParams = new Float32Array([e.morphTextureWidth, e.morphTextureHeight, 1 / e.morphTextureWidth, 1 / e.morphTextureHeight]);
            for (let s = 0; s < this.maxSubmitCount; s++)
                this["morphBlendTex" + s] = this.device.scope.resolve("morphBlendTex" + s);
            this.morphFactor = this.device.scope.resolve("morphFactor[0]"),
            this.zeroTextures = !1
        } else
            this.maxSubmitCount = 8,
            this._shaderMorphWeights = new Float32Array(this.maxSubmitCount),
            this._shaderMorphWeightsA = new Float32Array(this._shaderMorphWeights.buffer,0,4),
            this._shaderMorphWeightsB = new Float32Array(this._shaderMorphWeights.buffer,4 * 4,4),
            this._activeVertexBuffers = new Array(this.maxSubmitCount)
    }
    destroy() {
        this.shader = null;
        const e = this.morph;
        e && (this.morph = null,
        e.decRefCount(),
        e.refCount < 1 && e.destroy()),
        this.rtPositions && (this.rtPositions.destroy(),
        this.rtPositions = null),
        this.texturePositions && (this.texturePositions.destroy(),
        this.texturePositions = null),
        this.rtNormals && (this.rtNormals.destroy(),
        this.rtNormals = null),
        this.textureNormals && (this.textureNormals.destroy(),
        this.textureNormals = null)
    }
    clone() {
        return new Sa(this.morph)
    }
    _getWeightIndex(e) {
        return typeof e == "string" ? this._weightMap.get(e) : e
    }
    getWeight(e) {
        const t = this._getWeightIndex(e);
        return this._weights[t]
    }
    setWeight(e, t) {
        const s = this._getWeightIndex(e);
        this._weights[s] = t,
        this._dirty = !0
    }
    _getFragmentShader(e) {
        let t = "";
        e > 0 && (t += `varying vec2 uv0;
uniform highp float morphFactor[` + e + `];
`);
        for (let s = 0; s < e; s++)
            t += "uniform highp sampler2D morphBlendTex" + s + `;
`;
        t += `void main (void) {
    highp vec4 color = vec4(0, 0, 0, 1);
`;
        for (let s = 0; s < e; s++)
            t += "    color.xyz += morphFactor[" + s + "] * texture2D(morphBlendTex" + s + `, uv0).xyz;
`;
        return t += `    gl_FragColor = color;
}
`,
        t
    }
    _getShader(e) {
        let t = this.shaderCache[e];
        if (!t) {
            const s = this._getFragmentShader(e);
            t = Ys(this.device, pL, s, "textureMorph" + e),
            this.shaderCache[e] = t
        }
        return t
    }
    _updateTextureRenderTarget(e, t) {
        const s = this.device
          , i = (l, c) => {
            this.morphFactor.setValue(this._shaderMorphWeights),
            s.setBlendState(c ? mL : ft.NOBLEND);
            const d = this._getShader(l);
            ya(s, e, d)
        }
        ;
        let n = 0
          , r = !1;
        const o = this._activeTargets.length;
        for (let l = 0; l < o; l++) {
            const c = this._activeTargets[l]
              , d = c.target[t];
            d && (this["morphBlendTex" + n].setValue(d),
            this._shaderMorphWeights[n] = c.weight,
            n++,
            n >= this.maxSubmitCount && (i(n, r),
            n = 0,
            r = !0))
        }
        (n > 0 || o === 0 && !this.zeroTextures) && i(n, r)
    }
    _updateTextureMorph() {
        this.device,
        (this._activeTargets.length > 0 || !this.zeroTextures) && (this.rtPositions && this._updateTextureRenderTarget(this.rtPositions, "texturePositions"),
        this.rtNormals && this._updateTextureRenderTarget(this.rtNormals, "textureNormals"),
        this.zeroTextures = this._activeTargets.length === 0)
    }
    _updateVertexMorph() {
        const e = this.maxSubmitCount;
        for (let i = 0; i < e; i++)
            this._shaderMorphWeights[i] = 0,
            this._activeVertexBuffers[i] = null;
        let t = 0
          , s = this.morph.morphPositions ? 4 : 0;
        for (let i = 0; i < this._activeTargets.length; i++) {
            const n = this._activeTargets[i].target;
            n._vertexBufferPositions && (this._activeVertexBuffers[t] = n._vertexBufferPositions,
            this._shaderMorphWeights[t] = this._activeTargets[i].weight,
            t++),
            n._vertexBufferNormals && (this._activeVertexBuffers[s] = n._vertexBufferNormals,
            this._shaderMorphWeights[s] = this._activeTargets[i].weight,
            s++)
        }
    }
    update() {
        this._dirty = !1;
        const e = this.morph._targets;
        let t = 0;
        const s = 1e-5;
        for (let n = 0; n < e.length; n++) {
            const r = Math.abs(this.getWeight(n));
            if (r > s) {
                this._activeTargets.length <= t && (this._activeTargets[t] = {});
                const o = this._activeTargets[t++];
                o.absWeight = r,
                o.weight = this.getWeight(n),
                o.target = e[n]
            }
        }
        this._activeTargets.length = t;
        const i = this.morph.maxActiveTargets;
        this._activeTargets.length > i && (this._activeTargets.sort(function(n, r) {
            return n.absWeight < r.absWeight ? 1 : r.absWeight < n.absWeight ? -1 : 0
        }),
        this._activeTargets.length = i),
        this.morph.useTextureMorph ? this._updateTextureMorph() : this._updateVertexMorph()
    }
}
class kn {
    constructor() {
        this.graph = null,
        this.meshInstances = [],
        this.skinInstances = [],
        this.morphInstances = [],
        this.cameras = [],
        this.lights = [],
        this._shadersVersion = 0,
        this._immutable = !1
    }
    getGraph() {
        return this.graph
    }
    setGraph(e) {
        this.graph = e
    }
    getCameras() {
        return this.cameras
    }
    setCameras(e) {
        this.cameras = e
    }
    getLights() {
        return this.lights
    }
    setLights(e) {
        this.lights = e
    }
    getMaterials() {
        const e = [];
        for (let t = 0; t < this.meshInstances.length; t++) {
            const s = this.meshInstances[t];
            e.indexOf(s.material) === -1 && e.push(s.material)
        }
        return e
    }
    clone() {
        const e = []
          , t = []
          , i = function c(d) {
            const h = d.clone();
            e.push(d),
            t.push(h);
            for (let u = 0; u < d._children.length; u++)
                h.addChild(c(d._children[u]));
            return h
        }(this.graph)
          , n = []
          , r = []
          , o = [];
        for (let c = 0; c < this.skinInstances.length; c++) {
            const d = this.skinInstances[c].skin
              , h = new gc(d)
              , u = [];
            for (let f = 0; f < d.boneNames.length; f++) {
                const p = d.boneNames[f]
                  , _ = i.findByName(p);
                u.push(_)
            }
            h.bones = u,
            r.push(h)
        }
        for (let c = 0; c < this.morphInstances.length; c++) {
            const d = this.morphInstances[c].morph
              , h = new Sa(d);
            o.push(h)
        }
        for (let c = 0; c < this.meshInstances.length; c++) {
            const d = this.meshInstances[c]
              , h = e.indexOf(d.node)
              , u = new Fe(d.mesh,d.material,t[h]);
            if (d.skinInstance) {
                const f = this.skinInstances.indexOf(d.skinInstance);
                u.skinInstance = r[f]
            }
            if (d.morphInstance) {
                const f = this.morphInstances.indexOf(d.morphInstance);
                u.morphInstance = o[f]
            }
            n.push(u)
        }
        const l = new kn;
        return l.graph = i,
        l.meshInstances = n,
        l.skinInstances = r,
        l.morphInstances = o,
        l.getGraph().syncHierarchy(),
        l
    }
    destroy() {
        const e = this.meshInstances;
        for (let t = 0; t < e.length; t++)
            e[t].destroy();
        this.meshInstances.length = 0
    }
    generateWireframe() {
        Fe._prepareRenderStyleForArray(this.meshInstances, Wr)
    }
}
class wx extends ig {
    constructor(e, t, {preferHighPrecision: s=!1}={}) {
        super(),
        this._aabb = void 0,
        this.preferHighPrecision = void 0,
        this.device = t,
        this.preferHighPrecision = s,
        this._targets = e.slice();
        const i = this.device;
        if (i.supportsMorphTargetTexturesCore) {
            const n = i.extTextureHalfFloat && i.textureHalfFloatRenderable ? Tt : void 0
              , r = i.extTextureFloat && i.textureFloatRenderable ? lt : void 0;
            this._renderTextureFormat = this.preferHighPrecision ? r ?? n : n ?? r;
            const o = i.extTextureHalfFloat && i.textureHalfFloatUpdatable ? Tt : void 0
              , l = i.extTextureFloat ? Ta : void 0;
            this._textureFormat = this.preferHighPrecision ? l ?? o : o ?? l,
            this._renderTextureFormat !== void 0 && this._textureFormat !== void 0 && (this._useTextureMorph = !0)
        }
        this._init(),
        this._updateMorphFlags()
    }
    get aabb() {
        if (!this._aabb) {
            const e = new y
              , t = new y;
            for (let s = 0; s < this._targets.length; s++) {
                const i = this._targets[s].aabb;
                e.min(i.getMin()),
                t.max(i.getMax())
            }
            this._aabb = new Pe,
            this._aabb.setMinMax(e, t)
        }
        return this._aabb
    }
    get morphPositions() {
        return this._morphPositions
    }
    get morphNormals() {
        return this._morphNormals
    }
    get maxActiveTargets() {
        return this._useTextureMorph ? this._targets.length : this._morphPositions && this._morphNormals ? 4 : 8
    }
    get useTextureMorph() {
        return this._useTextureMorph
    }
    _init() {
        if (this._useTextureMorph && (this._useTextureMorph = this._initTextureBased()),
        !this._useTextureMorph)
            for (let e = 0; e < this._targets.length; e++)
                this._targets[e]._initVertexBuffers(this.device);
        for (let e = 0; e < this._targets.length; e++)
            this._targets[e]._postInit()
    }
    _findSparseSet(e, t, s, i) {
        let n = 1;
        const r = e[0].length;
        for (let o = 0; o < r; o += 3) {
            let l = !1;
            for (let c = 0; c < e.length; c++) {
                const d = e[c];
                if (d[o] !== 0 || d[o + 1] !== 0 || d[o + 2] !== 0) {
                    l = !0;
                    break
                }
            }
            l ? (t.push(n + i),
            s.push(o / 3),
            n++) : t.push(0 + i)
        }
        return n
    }
    _initTextureBased() {
        const e = this.device.isWebGPU
          , t = e ? 0 : .2
          , s = []
          , i = [];
        for (let m = 0; m < this._targets.length; m++) {
            const g = this._targets[m];
            g.options.deltaPositions && (s.push(g.options.deltaPositions),
            i.push({
                target: g,
                name: "texturePositions"
            })),
            g.options.deltaNormals && (s.push(g.options.deltaNormals),
            i.push({
                target: g,
                name: "textureNormals"
            }))
        }
        const n = []
          , r = []
          , o = this._findSparseSet(s, n, r, t)
          , l = Math.min(this.device.maxTextureSize, 4096);
        let c = Math.ceil(Math.sqrt(o));
        c = Math.min(c, l);
        const d = Math.ceil(o / c);
        if (d > l)
            return !1;
        this.morphTextureWidth = c,
        this.morphTextureHeight = d;
        let h = !1
          , u = 3;
        const f = Ge.float2Half;
        this._textureFormat === Tt && (h = !0,
        u = 4);
        const p = [];
        for (let m = 0; m < s.length; m++)
            p.push(this._createTexture("MorphTarget", this._textureFormat));
        for (let m = 0; m < s.length; m++) {
            const g = s[m]
              , v = p[m]
              , x = v.lock();
            if (h)
                for (let w = 0; w < r.length; w++) {
                    const T = r[w] * 3
                      , b = w * u + u;
                    x[b] = f(g[T]),
                    x[b + 1] = f(g[T + 1]),
                    x[b + 2] = f(g[T + 2])
                }
            else
                for (let w = 0; w < r.length; w++) {
                    const T = r[w] * 3
                      , b = w * u + u;
                    x[b] = g[T],
                    x[b + 1] = g[T + 1],
                    x[b + 2] = g[T + 2]
                }
            v.unlock(),
            i[m].target._setTexture(i[m].name, v)
        }
        const _ = [{
            semantic: $r,
            components: 1,
            type: e ? il : Me
        }];
        return this.vertexBufferIds = new xi(this.device,new fs(this.device,_,n.length),n.length,es,e ? new Uint32Array(n) : new Float32Array(n)),
        !0
    }
    destroy() {
        var e;
        (e = this.vertexBufferIds) == null || e.destroy(),
        this.vertexBufferIds = null;
        for (let t = 0; t < this._targets.length; t++)
            this._targets[t].destroy();
        this._targets.length = 0
    }
    get targets() {
        return this._targets
    }
    _updateMorphFlags() {
        this._morphPositions = !1,
        this._morphNormals = !1;
        for (let e = 0; e < this._targets.length; e++) {
            const t = this._targets[e];
            t.morphPositions && (this._morphPositions = !0),
            t.morphNormals && (this._morphNormals = !0)
        }
    }
    _createTexture(e, t) {
        return new ge(this.device,{
            width: this.morphTextureWidth,
            height: this.morphTextureHeight,
            format: t,
            cubemap: !1,
            mipmaps: !1,
            minFilter: be,
            magFilter: be,
            addressU: oe,
            addressV: oe,
            name: e
        })
    }
}
class Pf {
    constructor(e) {
        this.used = !1,
        arguments.length === 2 && (e = arguments[1]),
        this.options = e,
        this._name = e.name,
        this._defaultWeight = e.defaultWeight || 0,
        this._aabb = e.aabb,
        this.deltaPositions = e.deltaPositions
    }
    destroy() {
        var e, t, s, i;
        (e = this._vertexBufferPositions) == null || e.destroy(),
        this._vertexBufferPositions = null,
        (t = this._vertexBufferNormals) == null || t.destroy(),
        this._vertexBufferNormals = null,
        (s = this.texturePositions) == null || s.destroy(),
        this.texturePositions = null,
        (i = this.textureNormals) == null || i.destroy(),
        this.textureNormals = null
    }
    get name() {
        return this._name
    }
    get defaultWeight() {
        return this._defaultWeight
    }
    get aabb() {
        return this._aabb || (this._aabb = new Pe,
        this.deltaPositions && this._aabb.compute(this.deltaPositions)),
        this._aabb
    }
    get morphPositions() {
        return !!this._vertexBufferPositions || !!this.texturePositions
    }
    get morphNormals() {
        return !!this._vertexBufferNormals || !!this.textureNormals
    }
    clone() {
        return new Pf(this.options)
    }
    _postInit() {
        this.options.preserveData || (this.options = null),
        this.used = !0
    }
    _initVertexBuffers(e) {
        const t = this.options;
        this._vertexBufferPositions = this._createVertexBuffer(e, t.deltaPositions, t.deltaPositionsType),
        this._vertexBufferNormals = this._createVertexBuffer(e, t.deltaNormals, t.deltaNormalsType),
        this._vertexBufferPositions && (this.deltaPositions = this._vertexBufferPositions.lock())
    }
    _createVertexBuffer(e, t, s=Me) {
        if (t) {
            const i = [{
                semantic: Kd,
                components: 3,
                type: s
            }];
            return new xi(e,new fs(e,i),t.length / 3,es,t)
        }
        return null
    }
    _setTexture(e, t) {
        this[e] = t
    }
}
class _L extends Ue {
    generateKey(e) {
        let t = "particle";
        for (const s in e)
            e.hasOwnProperty(s) && (t += e[s]);
        return t
    }
    _animTex(e) {
        let t = "";
        return t += e.animTexLoop ? $.particleAnimFrameLoopVS : $.particleAnimFrameClampVS,
        t += $.particleAnimTexVS,
        t
    }
    createShaderDefinition(e, t) {
        const s = `#define PARTICLE_${t.useCpu ? "CPU" : "GPU"}
`;
        let i = `#define PARTICLE
` + s
          , n = `#define VERTEXSHADER
` + s;
        t.mesh && (n += `#define USE_MESH
`),
        t.localSpace && (n += `#define LOCAL_SPACE
`),
        t.screenSpace && (n += `#define SCREEN_SPACE
`),
        t.animTex && (n += `
uniform vec2 animTexTilesParams;
`),
        t.animTex && (n += `
uniform vec4 animTexParams;
`),
        t.animTex && (n += `
uniform vec2 animTexIndexParams;
`),
        t.normal === 2 && (n += `
varying mat3 ParticleMat;
`),
        t.normal === 1 && (n += `
varying vec3 Normal;
`),
        t.soft && (n += `
varying float vDepth;
`);
        const r = t.customFace ? $.particle_customFaceVS : $.particle_billboardVS;
        return t.useCpu ? (t.soft > 0 && (n += $.screenDepthPS),
        n += $.particle_cpuVS,
        t.localSpace && (n += $.particle_localShiftVS),
        t.animTex && (n += this._animTex(t)),
        t.alignToMotion && (n += $.particle_pointAlongVS),
        n += t.mesh ? $.particle_meshVS : r,
        t.normal === 1 && (n += $.particle_normalVS),
        t.normal === 2 && (n += $.particle_TBNVS),
        t.stretch > 0 && (n += $.particle_stretchVS),
        n += $.particle_cpu_endVS,
        t.soft > 0 && (n += $.particle_softVS)) : (n += $.particle_initVS,
        n += t.pack8 ? $.particleInputRgba8PS : $.particleInputFloatPS,
        t.soft > 0 && (n += $.screenDepthPS),
        n += $.particleVS,
        t.localSpace && (n += $.particle_localShiftVS),
        t.animTex && (n += this._animTex(t)),
        t.wrap && (n += $.particle_wrapVS),
        t.alignToMotion && (n += $.particle_pointAlongVS),
        n += t.mesh ? $.particle_meshVS : r,
        t.normal === 1 && (n += $.particle_normalVS),
        t.normal === 2 && (n += $.particle_TBNVS),
        t.stretch > 0 && (n += $.particle_stretchVS),
        n += $.particle_endVS,
        t.soft > 0 && (n += $.particle_softVS)),
        n += `}
`,
        t.normal > 0 && (t.normal === 1 ? i += `
varying vec3 Normal;
` : t.normal === 2 && (i += `
varying mat3 ParticleMat;
`),
        i += `
uniform vec3 lightCube[6];
`),
        t.soft && (i += `
varying float vDepth;
`),
        t.normal === 0 && t.fog === "none" && (t.srgb = !1),
        i += $.decodePS,
        i += Ue.gammaCode(t.gamma),
        i += Ue.tonemapCode(t.toneMap),
        t.fog === "linear" ? i += $.fogLinearPS : t.fog === "exp" ? i += $.fogExpPS : t.fog === "exp2" ? i += $.fogExp2PS : i += $.fogNonePS,
        t.normal === 2 && (i += `
uniform sampler2D normalMap;
`),
        t.soft > 0 && (i += $.screenDepthPS),
        i += $.particlePS,
        t.soft > 0 && (i += $.particle_softPS),
        t.normal === 1 && (i += `
vec3 normal = Normal;
`),
        t.normal === 2 && (i += $.particle_normalMapPS),
        t.normal > 0 && (i += t.halflambert ? $.particle_halflambertPS : $.particle_lambertPS),
        t.normal > 0 && (i += $.particle_lightingPS),
        t.blend === ps ? i += $.particle_blendNormalPS : t.blend === hc ? i += $.particle_blendAddPS : t.blend === H_ && (i += $.particle_blendMultiplyPS),
        i += $.particle_endPS,
        Pt.createDefinition(e, {
            name: "ParticleShader",
            vertexCode: n,
            fragmentCode: i
        })
    }
}
const gL = new _L;
let rn, T0 = 1;
const ce = 4
  , vp = new ee
  , Sp = new ee
  , Ri = new y
  , Je = new y
  , ni = new y
  , Ha = new y
  , vs = new y
  , pt = new y
  , Wa = new y
  , Xa = new y
  , Cl = new y
  , C0 = new y
  , Gt = new y
  , ed = new y
  , Dr = new y;
function go(a) {
    return a - Math.floor(a)
}
function yL(a) {
    return Math.max(Math.min(a, 1), 0)
}
function xp(a, e) {
    return a - e * Math.floor(a / e)
}
function vL(a) {
    let e = go(a)
      , t = go(255 * a)
      , s = go(65025 * a)
      , i = go(160581375 * a);
    return e -= t / 255,
    t -= s / 255,
    s -= i / 255,
    i -= i / 255,
    [e, t, s, i]
}
function td(a) {
    let e = go(a)
      , t = go(255 * a);
    return e -= t / 255,
    t -= t / 255,
    [e, t]
}
class SL {
    constructor(e) {
        this._emitter = e
    }
    calcSpawnPosition(e, t, s, i, n) {
        const r = this._emitter
          , o = Math.random()
          , l = Math.random()
          , c = Math.random()
          , d = Math.random();
        if (r.useCpu && (e[n * ce + 0 + r.numParticlesPot * 2 * ce] = o,
        e[n * ce + 1 + r.numParticlesPot * 2 * ce] = l,
        e[n * ce + 2 + r.numParticlesPot * 2 * ce] = c),
        Je.x = o - .5,
        Je.y = l - .5,
        Je.z = c - .5,
        r.emitterShape === di) {
            const f = Math.max(Math.abs(Je.x), Math.max(Math.abs(Je.y), Math.abs(Je.z)))
              , p = f + (.5 - f) * s[0]
              , _ = f + (.5 - f) * s[1]
              , m = f + (.5 - f) * s[2];
            Je.x = p * (f === Math.abs(Je.x) ? Math.sign(Je.x) : 2 * Je.x),
            Je.y = _ * (f === Math.abs(Je.y) ? Math.sign(Je.y) : 2 * Je.y),
            Je.z = m * (f === Math.abs(Je.z) ? Math.sign(Je.z) : 2 * Je.z),
            r.localSpace ? Ri.copy(t.transformPoint(Je)) : Ri.copy(i).add(t.transformPoint(Je))
        } else {
            Je.normalize();
            const f = r.emitterRadius === 0 ? 0 : r.emitterRadiusInner / r.emitterRadius
              , p = d * (1 - f) + f;
            r.localSpace ? Ri.copy(Je.mulScalar(p * r.emitterRadius)) : Ri.copy(i).add(Je.mulScalar(p * r.emitterRadius))
        }
        let u = -W.lerp(r.rate, r.rate2, o) * n;
        if (r.pack8) {
            const f = (Ri.x - r.worldBounds.center.x) / r.worldBoundsSize.x + .5
              , p = (Ri.y - r.worldBounds.center.y) / r.worldBoundsSize.y + .5
              , _ = (Ri.z - r.worldBounds.center.z) / r.worldBoundsSize.z + .5;
            let m = W.lerp(r.startAngle * W.DEG_TO_RAD, r.startAngle2 * W.DEG_TO_RAD, o);
            m = m % (Math.PI * 2) / (Math.PI * 2);
            const g = td(f);
            e[n * ce] = g[0],
            e[n * ce + 1] = g[1];
            const v = td(p);
            e[n * ce + 2] = v[0],
            e[n * ce + 3] = v[1];
            const x = td(_);
            e[n * ce + 0 + r.numParticlesPot * ce] = x[0],
            e[n * ce + 1 + r.numParticlesPot * ce] = x[1];
            const S = td(m);
            e[n * ce + 2 + r.numParticlesPot * ce] = S[0],
            e[n * ce + 3 + r.numParticlesPot * ce] = S[1];
            const w = 1;
            e[n * ce + 3 + r.numParticlesPot * ce * 2] = w;
            const T = Math.max(r.lifetime, (r.numParticles - 1) * Math.max(r.rate, r.rate2))
              , b = r.lifetime + 1;
            u = (u + T) / (T + b);
            const E = vL(u);
            e[n * ce + 0 + r.numParticlesPot * ce * 3] = E[0],
            e[n * ce + 1 + r.numParticlesPot * ce * 3] = E[1],
            e[n * ce + 2 + r.numParticlesPot * ce * 3] = E[2],
            e[n * ce + 3 + r.numParticlesPot * ce * 3] = E[3]
        } else
            e[n * ce] = Ri.x,
            e[n * ce + 1] = Ri.y,
            e[n * ce + 2] = Ri.z,
            e[n * ce + 3] = W.lerp(r.startAngle * W.DEG_TO_RAD, r.startAngle2 * W.DEG_TO_RAD, o),
            e[n * ce + 3 + r.numParticlesPot * ce] = u
    }
    update(e, t, s, i, n, r, o, l) {
        let c, d, h;
        const u = this._emitter;
        if (u.meshInstance.node) {
            const C = u.meshInstance.node.worldTransform;
            for (let R = 0; R < 12; R++)
                vp.data[R] = C.data[R];
            Sp.copy(vp),
            Sp.invert(),
            rn = u.meshInstance.node.localScale,
            T0 = Math.max(Math.max(rn.x, rn.y), rn.z)
        }
        r = u.meshInstance.node === null || u.localSpace ? y.ZERO : u.meshInstance.node.getPosition();
        const f = u.camera ? u.camera._node.getPosition() : y.ZERO
          , p = u.useMesh ? 17 : 15;
        let _, m, g, v, x, S, w, T, b;
        const E = u.precision - 1;
        for (let C = 0; C < u.numParticles; C++) {
            const R = Math.floor(u.vbCPU[C * u.numParticleVerts * (u.useMesh ? 6 : 4) + 3])
              , F = s[R * ce + 0 + u.numParticlesPot * 2 * ce];
            ni.x = F,
            ni.y = s[R * ce + 1 + u.numParticlesPot * 2 * ce],
            ni.z = s[R * ce + 2 + u.numParticlesPot * 2 * ce];
            const L = u.rate + (u.rate2 - u.rate) * F
              , U = u.lifetime;
            let I = s[R * ce + 3 + u.numParticlesPot * ce] + o;
            const O = yL(I / U);
            let D = 0
              , A = 0;
            const k = 0;
            (I - o <= 0 || I >= U) && this.calcSpawnPosition(s, i, n, r, R);
            let H = I > 0 && I < U;
            H && (h = O * E,
            _ = Math.floor(h),
            m = Math.ceil(h),
            h %= 1,
            c = u.qRotSpeed[_],
            d = u.qRotSpeed[m],
            g = c + (d - c) * h,
            c = u.qRotSpeed2[_],
            d = u.qRotSpeed2[m],
            v = c + (d - c) * h,
            c = u.qScale[_],
            d = u.qScale[m],
            D = c + (d - c) * h,
            c = u.qScale2[_],
            d = u.qScale2[m],
            x = c + (d - c) * h,
            c = u.qAlpha[_],
            d = u.qAlpha[m],
            S = c + (d - c) * h,
            c = u.qAlpha2[_],
            d = u.qAlpha2[m],
            w = c + (d - c) * h,
            c = u.qRadialSpeed[_],
            d = u.qRadialSpeed[m],
            T = c + (d - c) * h,
            c = u.qRadialSpeed2[_],
            d = u.qRadialSpeed2[m],
            b = c + (d - c) * h,
            T += (b - T) * (F * 100 % 1),
            Ha.x = s[R * ce],
            Ha.y = s[R * ce + 1],
            Ha.z = s[R * ce + 2],
            u.localSpace ? Cl.copy(Ha) : Cl.copy(Ha).sub(r),
            Cl.normalize().mulScalar(T),
            _ *= 3,
            m *= 3,
            c = u.qLocalVelocity[_],
            d = u.qLocalVelocity[m],
            pt.x = c + (d - c) * h,
            c = u.qLocalVelocity[_ + 1],
            d = u.qLocalVelocity[m + 1],
            pt.y = c + (d - c) * h,
            c = u.qLocalVelocity[_ + 2],
            d = u.qLocalVelocity[m + 2],
            pt.z = c + (d - c) * h,
            c = u.qLocalVelocity2[_],
            d = u.qLocalVelocity2[m],
            Xa.x = c + (d - c) * h,
            c = u.qLocalVelocity2[_ + 1],
            d = u.qLocalVelocity2[m + 1],
            Xa.y = c + (d - c) * h,
            c = u.qLocalVelocity2[_ + 2],
            d = u.qLocalVelocity2[m + 2],
            Xa.z = c + (d - c) * h,
            c = u.qVelocity[_],
            d = u.qVelocity[m],
            vs.x = c + (d - c) * h,
            c = u.qVelocity[_ + 1],
            d = u.qVelocity[m + 1],
            vs.y = c + (d - c) * h,
            c = u.qVelocity[_ + 2],
            d = u.qVelocity[m + 2],
            vs.z = c + (d - c) * h,
            c = u.qVelocity2[_],
            d = u.qVelocity2[m],
            Wa.x = c + (d - c) * h,
            c = u.qVelocity2[_ + 1],
            d = u.qVelocity2[m + 1],
            Wa.y = c + (d - c) * h,
            c = u.qVelocity2[_ + 2],
            d = u.qVelocity2[m + 2],
            Wa.z = c + (d - c) * h,
            pt.x += (Xa.x - pt.x) * ni.x,
            pt.y += (Xa.y - pt.y) * ni.y,
            pt.z += (Xa.z - pt.z) * ni.z,
            u.initialVelocity > 0 && (u.emitterShape === K_ ? (Je.copy(ni).mulScalar(2).sub(y.ONE).normalize(),
            pt.add(Je.mulScalar(u.initialVelocity))) : pt.add(y.FORWARD.mulScalar(u.initialVelocity))),
            vs.x += (Wa.x - vs.x) * ni.x,
            vs.y += (Wa.y - vs.y) * ni.y,
            vs.z += (Wa.z - vs.z) * ni.z,
            g += (v - g) * ni.y,
            D = (D + (x - D) * (F * 1e4 % 1)) * T0,
            A = (w - S) * (F * 1e3 % 1),
            u.meshInstance.node && (u.localSpace ? (pt.x /= rn.x,
            pt.y /= rn.y,
            pt.z /= rn.z) : vp.transformPoint(pt, pt)),
            u.localSpace ? (Sp.transformPoint(vs, vs),
            pt.add(vs).add(Cl)) : (pt.add(vs.mul(rn)),
            pt.add(Cl.mul(rn))),
            ed.copy(pt),
            C0.copy(Ha).add(pt.mulScalar(o)),
            Gt.copy(C0),
            s[R * ce] = Gt.x,
            s[R * ce + 1] = Gt.y,
            s[R * ce + 2] = Gt.z,
            s[R * ce + 3] += g * o,
            u.wrap && u.wrapBounds && (u.localSpace || Gt.sub(r),
            Gt.x = xp(Gt.x, u.wrapBounds.x) - u.wrapBounds.x * .5,
            Gt.y = xp(Gt.y, u.wrapBounds.y) - u.wrapBounds.y * .5,
            Gt.z = xp(Gt.z, u.wrapBounds.z) - u.wrapBounds.z * .5,
            u.localSpace || Gt.add(r)),
            u.sort > 0 && (u.sort === 1 ? (Dr.copy(Gt).sub(f),
            u.particleDistance[R] = -(Dr.x * Dr.x + Dr.y * Dr.y + Dr.z * Dr.z)) : u.sort === 2 ? u.particleDistance[R] = I : u.sort === 3 && (u.particleDistance[R] = -I))),
            l ? I < 0 && (s[R * ce + 3 + u.numParticlesPot * 2 * ce] = -1) : (I >= U && (I -= Math.max(U, (u.numParticles - 1) * L),
            s[R * ce + 3 + u.numParticlesPot * 2 * ce] = u.loop ? 1 : -1),
            I < 0 && u.loop && (s[R * ce + 3 + u.numParticlesPot * 2 * ce] = 1)),
            s[R * ce + 3 + u.numParticlesPot * 2 * ce] < 0 && (H = !1),
            s[R * ce + 3 + u.numParticlesPot * ce] = I;
            for (let K = 0; K < u.numParticleVerts; K++) {
                const q = (C * u.numParticleVerts + K) * (u.useMesh ? 6 : 4);
                let se = u.vbCPU[q]
                  , ie = u.vbCPU[q + 1]
                  , ae = u.vbCPU[q + 2];
                H || (se = ie = ae = 0);
                const he = C * u.numParticleVerts * p + K * p;
                e[he] = Gt.x,
                e[he + 1] = Gt.y,
                e[he + 2] = Gt.z,
                e[he + 3] = O,
                e[he + 4] = u.alignToMotion ? k : s[R * ce + 3],
                e[he + 5] = D,
                e[he + 6] = A,
                e[he + 7] = ed.x,
                e[he + 8] = se,
                e[he + 9] = ie,
                e[he + 10] = ae,
                e[he + 11] = ed.y,
                e[he + 12] = R,
                e[he + 13] = ed.z,
                e[he + 14] = u.vbCPU[q + 3],
                u.useMesh && (e[he + 15] = u.vbCPU[q + 4],
                e[he + 16] = u.vbCPU[q + 5])
            }
        }
        if (u.sort > Tm && u.camera) {
            const C = u.useMesh ? 6 : 4
              , R = u.particleDistance;
            for (let F = 0; F < u.numParticles; F++)
                t[F][0] = F,
                t[F][1] = R[Math.floor(u.vbCPU[F * u.numParticleVerts * C + 3])];
            u.vbOld.set(u.vbCPU),
            t.sort(function(F, L) {
                return F[1] - L[1]
            });
            for (let F = 0; F < u.numParticles; F++) {
                const L = t[F][0] * u.numParticleVerts * C
                  , U = F * u.numParticleVerts * C;
                for (let I = 0; I < u.numParticleVerts * C; I++)
                    u.vbCPU[U + I] = u.vbOld[L + I]
            }
        }
    }
}
const E0 = new Ci
  , A0 = new Ci
  , M0 = new Ci;
class xL {
    constructor(e, t) {
        this._emitter = e,
        this.frameRandomUniform = new Float32Array(3),
        this.emitterPosUniform = new Float32Array(3),
        this.emitterScaleUniform = new Float32Array([1, 1, 1]),
        this.worldBoundsMulUniform = new Float32Array(3),
        this.worldBoundsAddUniform = new Float32Array(3),
        this.inBoundsSizeUniform = new Float32Array(3),
        this.inBoundsCenterUniform = new Float32Array(3),
        this.constantParticleTexIN = t.scope.resolve("particleTexIN"),
        this.constantParticleTexOUT = t.scope.resolve("particleTexOUT"),
        this.constantEmitterPos = t.scope.resolve("emitterPos"),
        this.constantEmitterScale = t.scope.resolve("emitterScale"),
        this.constantSpawnBounds = t.scope.resolve("spawnBounds"),
        this.constantSpawnPosInnerRatio = t.scope.resolve("spawnPosInnerRatio"),
        this.constantSpawnBoundsSphere = t.scope.resolve("spawnBoundsSphere"),
        this.constantSpawnBoundsSphereInnerRatio = t.scope.resolve("spawnBoundsSphereInnerRatio"),
        this.constantInitialVelocity = t.scope.resolve("initialVelocity"),
        this.constantFrameRandom = t.scope.resolve("frameRandom"),
        this.constantDelta = t.scope.resolve("delta"),
        this.constantRate = t.scope.resolve("rate"),
        this.constantRateDiv = t.scope.resolve("rateDiv"),
        this.constantLifetime = t.scope.resolve("lifetime"),
        this.constantGraphSampleSize = t.scope.resolve("graphSampleSize"),
        this.constantGraphNumSamples = t.scope.resolve("graphNumSamples"),
        this.constantInternalTex0 = t.scope.resolve("internalTex0"),
        this.constantInternalTex1 = t.scope.resolve("internalTex1"),
        this.constantInternalTex2 = t.scope.resolve("internalTex2"),
        this.constantInternalTex3 = t.scope.resolve("internalTex3"),
        this.constantEmitterMatrix = t.scope.resolve("emitterMatrix"),
        this.constantEmitterMatrixInv = t.scope.resolve("emitterMatrixInv"),
        this.constantNumParticles = t.scope.resolve("numParticles"),
        this.constantNumParticlesPot = t.scope.resolve("numParticlesPot"),
        this.constantLocalVelocityDivMult = t.scope.resolve("localVelocityDivMult"),
        this.constantVelocityDivMult = t.scope.resolve("velocityDivMult"),
        this.constantRotSpeedDivMult = t.scope.resolve("rotSpeedDivMult"),
        this.constantSeed = t.scope.resolve("seed"),
        this.constantStartAngle = t.scope.resolve("startAngle"),
        this.constantStartAngle2 = t.scope.resolve("startAngle2"),
        this.constantOutBoundsMul = t.scope.resolve("outBoundsMul"),
        this.constantOutBoundsAdd = t.scope.resolve("outBoundsAdd"),
        this.constantInBoundsSize = t.scope.resolve("inBoundsSize"),
        this.constantInBoundsCenter = t.scope.resolve("inBoundsCenter"),
        this.constantMaxVel = t.scope.resolve("maxVel"),
        this.constantFaceTangent = t.scope.resolve("faceTangent"),
        this.constantFaceBinorm = t.scope.resolve("faceBinorm")
    }
    _setInputBounds() {
        this.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x,
        this.inBoundsSizeUniform[1] = this._emitter.prevWorldBoundsSize.y,
        this.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z,
        this.constantInBoundsSize.setValue(this.inBoundsSizeUniform),
        this.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x,
        this.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y,
        this.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z,
        this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform)
    }
    randomize() {
        this.frameRandomUniform[0] = Math.random(),
        this.frameRandomUniform[1] = Math.random(),
        this.frameRandomUniform[2] = Math.random()
    }
    update(e, t, s, i, n) {
        const r = this._emitter;
        e.setBlendState(ft.NOBLEND),
        e.setDepthState($t.NODEPTH),
        e.setCullMode(bt),
        this.randomize(),
        this.constantGraphSampleSize.setValue(1 / r.precision),
        this.constantGraphNumSamples.setValue(r.precision),
        this.constantNumParticles.setValue(r.numParticles),
        this.constantNumParticlesPot.setValue(r.numParticlesPot),
        this.constantInternalTex0.setValue(r.internalTex0),
        this.constantInternalTex1.setValue(r.internalTex1),
        this.constantInternalTex2.setValue(r.internalTex2),
        this.constantInternalTex3.setValue(r.internalTex3);
        const o = r.meshInstance.node
          , l = o === null ? y.ONE : o.localScale;
        if (r.pack8) {
            this.worldBoundsMulUniform[0] = r.worldBoundsMul.x,
            this.worldBoundsMulUniform[1] = r.worldBoundsMul.y,
            this.worldBoundsMulUniform[2] = r.worldBoundsMul.z,
            this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform),
            this.worldBoundsAddUniform[0] = r.worldBoundsAdd.x,
            this.worldBoundsAddUniform[1] = r.worldBoundsAdd.y,
            this.worldBoundsAddUniform[2] = r.worldBoundsAdd.z,
            this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform),
            this._setInputBounds();
            let f = r.maxVel * Math.max(Math.max(l.x, l.y), l.z);
            f = Math.max(f, 1),
            this.constantMaxVel.setValue(f)
        }
        const c = o === null || r.localSpace ? y.ZERO : o.getPosition()
          , d = o === null ? ee.IDENTITY : o.getWorldTransform();
        r.emitterShape === di ? (E0.setFromMat4(t),
        this.constantSpawnBounds.setValue(E0.data),
        this.constantSpawnPosInnerRatio.setValue(s)) : (this.constantSpawnBoundsSphere.setValue(r.emitterRadius),
        this.constantSpawnBoundsSphereInnerRatio.setValue(r.emitterRadius === 0 ? 0 : r.emitterRadiusInner / r.emitterRadius)),
        this.constantInitialVelocity.setValue(r.initialVelocity),
        A0.setFromMat4(d),
        M0.invertMat4(d),
        this.emitterPosUniform[0] = c.x,
        this.emitterPosUniform[1] = c.y,
        this.emitterPosUniform[2] = c.z,
        this.constantEmitterPos.setValue(this.emitterPosUniform),
        this.constantFrameRandom.setValue(this.frameRandomUniform),
        this.constantDelta.setValue(i),
        this.constantRate.setValue(r.rate),
        this.constantRateDiv.setValue(r.rate2 - r.rate),
        this.constantStartAngle.setValue(r.startAngle * W.DEG_TO_RAD),
        this.constantStartAngle2.setValue(r.startAngle2 * W.DEG_TO_RAD),
        this.constantSeed.setValue(r.seed),
        this.constantLifetime.setValue(r.lifetime),
        this.emitterScaleUniform[0] = l.x,
        this.emitterScaleUniform[1] = l.y,
        this.emitterScaleUniform[2] = l.z,
        this.constantEmitterScale.setValue(this.emitterScaleUniform),
        this.constantEmitterMatrix.setValue(A0.data),
        this.constantEmitterMatrixInv.setValue(M0.data),
        this.constantLocalVelocityDivMult.setValue(r.localVelocityUMax),
        this.constantVelocityDivMult.setValue(r.velocityUMax),
        this.constantRotSpeedDivMult.setValue(r.rotSpeedUMax[0]);
        let h = r.swapTex ? r.particleTexOUT : r.particleTexIN;
        h = r.beenReset ? r.particleTexStart : h;
        const u = r.swapTex ? r.particleTexIN : r.particleTexOUT;
        this.constantParticleTexIN.setValue(h),
        ya(e, r.swapTex ? r.rtParticleTexIN : r.rtParticleTexOUT, n ? r.shaderParticleUpdateOnStop : r.loop ? r.shaderParticleUpdateRespawn : r.shaderParticleUpdateNoRespawn),
        r.material.setParameter("particleTexOUT", h),
        r.material.setParameter("particleTexIN", u),
        r.beenReset = !1,
        r.swapTex = !r.swapTex,
        r.prevWorldBoundsSize.copy(r.worldBoundsSize),
        r.prevWorldBoundsCenter.copy(r.worldBounds.center),
        r.pack8 && this._setInputBounds()
    }
}
const P0 = [[-1, -1], [1, -1], [1, 1], [-1, 1]];
function Fs(a, e, t, s, i=lt, n, r) {
    let o = be;
    r && i === ve && (o = ot);
    const l = new ge(a,{
        width: e,
        height: t,
        format: i,
        cubemap: !1,
        mipmaps: !1,
        minFilter: o,
        magFilter: o,
        addressU: oe,
        addressV: oe,
        name: "ParticleSystemTexture"
    })
      , c = l.lock();
    if (i === ve) {
        const d = new Uint8Array(s.length);
        for (let h = 0; h < s.length; h++)
            d[h] = s[h] * n * 255;
        s = d
    }
    return c.set(s),
    l.unlock(),
    l
}
function R0(a) {
    return Math.max(Math.min(a, 1), 0)
}
const I0 = new Ot([0, 0, 1, 0])
  , L0 = new Ot([0, 1, 1, 1])
  , D0 = new Qt([0, 0, 1, 0],[0, 0, 1, 0],[0, 0, 1, 0])
  , wL = new Qt([0, 1, 1, 1],[0, 1, 1, 1],[0, 1, 1, 1]);
let an = 2;
const sd = 4
  , on = new Float32Array(3)
  , Or = new ee
  , O0 = new y
  , id = new y
  , nd = new y;
let Dm, kd;
function de(a, e) {
    kd[a] !== void 0 && kd[a] !== null ? Dm[a] = kd[a] : Dm[a] = e
}
function bx(a, e, t) {
    return (a * 255 << 16 | e * 255 << 8 | t * 255) / (1 << 24)
}
function F0(a, e) {
    const t = a.length / 3
      , s = new Array(t * 4);
    for (let i = 0; i < t; i++)
        s[i * 4] = a[i * 3],
        s[i * 4 + 1] = a[i * 3 + 1],
        s[i * 4 + 2] = a[i * 3 + 2],
        s[i * 4 + 3] = bx(e[i * 3], e[i * 3 + 1], e[i * 3 + 2]);
    return s
}
function bL(a, e) {
    const t = new Array(e.length * 4);
    for (let s = 0; s < e.length; s++)
        t[s * 4] = a[s * 3],
        t[s * 4 + 1] = a[s * 3 + 1],
        t[s * 4 + 2] = a[s * 3 + 2],
        t[s * 4 + 3] = e[s];
    return t
}
function TL(a, e, t, s, i) {
    const n = new Array(a.length * 4);
    for (let r = 0; r < a.length; r++)
        n[r * 4] = a[r],
        n[r * 4 + 1] = e[r],
        n[r * 4 + 2] = 0,
        n[r * 4 + 3] = bx(t[r], s[r], i[r]);
    return n
}
function CL(a, e) {
    const t = new Array(a.length * 4);
    for (let s = 0; s < a.length; s++)
        t[s * 4] = a[s],
        t[s * 4 + 1] = e[s],
        t[s * 4 + 2] = 0,
        t[s * 4 + 3] = 0;
    return t
}
function EL(a) {
    const e = Math.max(a.rate, a.rate2) * a.numParticles + a.lifetime;
    return Date.now() + e * 1e3
}
function AL(a, e) {
    const t = new Float32Array(a.length);
    for (let s = 0; s < a.length; s++)
        t[s] = a[s] - e[s];
    return t
}
function Xr(a, e) {
    const t = e.length
      , s = a.length / t;
    for (let i = 0; i < s; i++)
        for (let n = 0; n < t; n++) {
            const r = Math.abs(a[i * t + n]);
            e[n] = Math.max(e[n], r)
        }
}
function ML(a, e) {
    const t = e.length
      , s = a.length / t;
    for (let i = 0; i < s; i++)
        for (let n = 0; n < t; n++)
            a[i * t + n] /= e[n] === 0 ? 1 : e[n],
            a[i * t + n] *= .5,
            a[i * t + n] += .5
}
function Fr(a, e, t) {
    const s = AL(e, a);
    return Xr(s, t),
    ML(s, t),
    s
}
const PL = new Os;
class RL {
    constructor(e, t) {
        this.graphicsDevice = e;
        const s = e
          , i = 32;
        this.precision = i,
        this._addTimeTime = 0,
        Dm = this,
        kd = t,
        de("numParticles", 1),
        this.numParticles > e.maxTextureSize && (this.numParticles = e.maxTextureSize),
        de("rate", 1),
        de("rate2", this.rate),
        de("lifetime", 50),
        de("emitterExtents", new y(0,0,0)),
        de("emitterExtentsInner", new y(0,0,0)),
        de("emitterRadius", 0),
        de("emitterRadiusInner", 0),
        de("emitterShape", di),
        de("initialVelocity", 1),
        de("wrap", !1),
        de("localSpace", !1),
        de("screenSpace", !1),
        de("wrapBounds", null),
        de("colorMap", this.defaultParamTexture),
        de("normalMap", null),
        de("loop", !0),
        de("preWarm", !1),
        de("sort", Tm),
        de("mode", tx),
        de("scene", null),
        de("lighting", !1),
        de("halfLambert", !1),
        de("intensity", 1),
        de("stretch", 0),
        de("alignToMotion", !1),
        de("depthSoftening", 0),
        de("mesh", null),
        de("particleNormal", new y(0,1,0)),
        de("orientation", ih),
        de("depthWrite", !1),
        de("noFog", !1),
        de("blendType", ps),
        de("node", null),
        de("startAngle", 0),
        de("startAngle2", this.startAngle),
        de("animTilesX", 1),
        de("animTilesY", 1),
        de("animStartFrame", 0),
        de("animNumFrames", 1),
        de("animNumAnimations", 1),
        de("animIndex", 0),
        de("randomizeAnimIndex", !1),
        de("animSpeed", 1),
        de("animLoop", !0),
        this._gpuUpdater = new xL(this,s),
        this._cpuUpdater = new SL(this),
        this.emitterPosUniform = new Float32Array(3),
        this.wrapBoundsUniform = new Float32Array(3),
        this.emitterScaleUniform = new Float32Array([1, 1, 1]),
        de("colorGraph", wL),
        de("colorGraph2", this.colorGraph),
        de("scaleGraph", L0),
        de("scaleGraph2", this.scaleGraph),
        de("alphaGraph", L0),
        de("alphaGraph2", this.alphaGraph),
        de("localVelocityGraph", D0),
        de("localVelocityGraph2", this.localVelocityGraph),
        de("velocityGraph", D0),
        de("velocityGraph2", this.velocityGraph),
        de("rotationSpeedGraph", I0),
        de("rotationSpeedGraph2", this.rotationSpeedGraph),
        de("radialSpeedGraph", I0),
        de("radialSpeedGraph2", this.radialSpeedGraph),
        this.animTilesParams = new Float32Array(2),
        this.animParams = new Float32Array(4),
        this.animIndexParams = new Float32Array(2),
        this.internalTex0 = null,
        this.internalTex1 = null,
        this.internalTex2 = null,
        this.colorParam = null,
        this.vbToSort = null,
        this.vbOld = null,
        this.particleDistance = null,
        this.camera = null,
        this.swapTex = !1,
        this.useMesh = !0,
        this.useCpu = !e.supportsGpuParticles,
        this.pack8 = !0,
        this.localBounds = new Pe,
        this.worldBoundsNoTrail = new Pe,
        this.worldBoundsTrail = [new Pe, new Pe],
        this.worldBounds = new Pe,
        this.worldBoundsSize = new y,
        this.prevWorldBoundsSize = new y,
        this.prevWorldBoundsCenter = new y,
        this.prevEmitterExtents = this.emitterExtents,
        this.prevEmitterRadius = this.emitterRadius,
        this.worldBoundsMul = new y,
        this.worldBoundsAdd = new y,
        this.timeToSwitchBounds = 0,
        this.shaderParticleUpdateRespawn = null,
        this.shaderParticleUpdateNoRespawn = null,
        this.shaderParticleUpdateOnStop = null,
        this.numParticleVerts = 0,
        this.numParticleIndices = 0,
        this.material = null,
        this.meshInstance = null,
        this.drawOrder = 0,
        this.seed = Math.random(),
        this.fixedTimeStep = 1 / 60,
        this.maxSubSteps = 10,
        this.simTime = 0,
        this.simTimeTotal = 0,
        this.beenReset = !1,
        this._layer = null,
        this.rebuild()
    }
    get defaultParamTexture() {
        return PL.get(this.graphicsDevice, () => {
            const s = new Float32Array(1024);
            for (let n = 0; n < 16; n++)
                for (let r = 0; r < 16; r++) {
                    const o = r + 1 - 8.5
                      , l = n + 1 - 8.5
                      , c = R0(1 - R0(Math.sqrt(o * o + l * l) / 16) - .5)
                      , d = n * 16 + r;
                    s[d * 4] = 1,
                    s[d * 4 + 1] = 1,
                    s[d * 4 + 2] = 1,
                    s[d * 4 + 3] = c
                }
            const i = Fs(this.graphicsDevice, 16, 16, s, ve, 1, !0);
            return i.minFilter = ot,
            i.magFilter = ot,
            i
        }
        )
    }
    onChangeCamera() {
        this.regenShader(),
        this.resetMaterial()
    }
    calculateBoundsMad() {
        this.worldBoundsMul.x = 1 / this.worldBoundsSize.x,
        this.worldBoundsMul.y = 1 / this.worldBoundsSize.y,
        this.worldBoundsMul.z = 1 / this.worldBoundsSize.z,
        this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).mulScalar(-1),
        this.worldBoundsAdd.x += .5,
        this.worldBoundsAdd.y += .5,
        this.worldBoundsAdd.z += .5
    }
    calculateWorldBounds() {
        if (!this.node)
            return;
        if (this.prevWorldBoundsSize.copy(this.worldBoundsSize),
        this.prevWorldBoundsCenter.copy(this.worldBounds.center),
        !this.useCpu) {
            let s = !1;
            this.emitterShape === di ? s = !this.emitterExtents.equals(this.prevEmitterExtents) : s = this.emitterRadius !== this.prevEmitterRadius,
            s && this.calculateLocalBounds()
        }
        const e = this.node.getWorldTransform();
        this.localSpace ? this.worldBoundsNoTrail.copy(this.localBounds) : this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, e),
        this.worldBoundsTrail[0].add(this.worldBoundsNoTrail),
        this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);
        const t = this.simTimeTotal;
        t >= this.timeToSwitchBounds && (this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]),
        this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail),
        this.timeToSwitchBounds = t + this.lifetime),
        this.worldBounds.copy(this.worldBoundsTrail[0]),
        this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2),
        this.localSpace ? (this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, e),
        this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, e)) : (this.meshInstance.aabb.copy(this.worldBounds),
        this.meshInstance.mesh.aabb.copy(this.worldBounds)),
        this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer,
        this.pack8 && this.calculateBoundsMad()
    }
    resetWorldBounds() {
        this.node && (this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.localSpace ? ee.IDENTITY : this.node.getWorldTransform()),
        this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail),
        this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail),
        this.worldBounds.copy(this.worldBoundsTrail[0]),
        this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2),
        this.prevWorldBoundsSize.copy(this.worldBoundsSize),
        this.prevWorldBoundsCenter.copy(this.worldBounds.center),
        this.simTimeTotal = 0,
        this.timeToSwitchBounds = 0)
    }
    calculateLocalBounds() {
        let e = Number.MAX_VALUE
          , t = Number.MAX_VALUE
          , s = Number.MAX_VALUE
          , i = -Number.MAX_VALUE
          , n = -Number.MAX_VALUE
          , r = -Number.MAX_VALUE
          , o = 0
          , l = 0;
        const c = this.lifetime / this.precision
          , d = [this.qVelocity, this.qVelocity2]
          , h = [this.qLocalVelocity, this.qLocalVelocity2]
          , u = [0, 0]
          , f = [0, 0]
          , p = [0, 0]
          , _ = [0, 0]
          , m = [0, 0];
        let g, v, x;
        for (let w = 0; w < this.precision + 1; w++) {
            const T = Math.min(w, this.precision - 1);
            for (let b = 0; b < 2; b++)
                g = h[b][T * 3 + 0] * c + u[b],
                v = h[b][T * 3 + 1] * c + f[b],
                x = h[b][T * 3 + 2] * c + p[b],
                e = Math.min(g, e),
                t = Math.min(v, t),
                s = Math.min(x, s),
                i = Math.max(g, i),
                n = Math.max(v, n),
                r = Math.max(x, r),
                u[b] = g,
                f[b] = v,
                p[b] = x;
            for (let b = 0; b < 2; b++)
                m[b] += c * Math.sqrt(d[b][T * 3 + 0] * d[b][T * 3 + 0] + d[b][T * 3 + 1] * d[b][T * 3 + 1] + d[b][T * 3 + 2] * d[b][T * 3 + 2]);
            _[0] += this.qRadialSpeed[T] * c,
            _[1] += this.qRadialSpeed2[T] * c,
            o = Math.max(o, Math.max(Math.abs(_[0]), Math.abs(_[1]))),
            l = Math.max(l, this.qScale[T])
        }
        this.emitterShape === di ? (g = this.emitterExtents.x * .5,
        v = this.emitterExtents.y * .5,
        x = this.emitterExtents.z * .5) : (g = this.emitterRadius,
        v = this.emitterRadius,
        x = this.emitterRadius);
        const S = Math.max(m[0], m[1]);
        id.x = e - l - g - o - S,
        id.y = t - l - v - o - S,
        id.z = s - l - x - o - S,
        nd.x = i + l + g + o + S,
        nd.y = n + l + v + o + S,
        nd.z = r + l + x + o + S,
        this.localBounds.setMinMax(id, nd)
    }
    rebuild() {
        const e = this.graphicsDevice;
        this.colorMap === null && (this.colorMap = this.defaultParamTexture),
        this.spawnBounds = this.emitterShape === di ? this.emitterExtents : this.emitterRadius,
        this.useCpu = this.useCpu || this.sort > Tm || e.maxVertexTextures <= 1 || e.fragmentUniformsCount < 64 || e.forceCpuParticles || !e.extTextureFloat,
        this._destroyResources(),
        this.pack8 = (this.pack8 || !e.textureFloatRenderable) && !this.useCpu,
        an = this.useCpu || this.pack8 ? 4 : 2,
        this.useMesh = !1,
        this.mesh && (this.numParticles * this.mesh.vertexBuffer.numVertices > 65535 || (this.useMesh = !0)),
        this.numParticlesPot = W.nextPowerOfTwo(this.numParticles),
        this.rebuildGraphs(),
        this.calculateLocalBounds(),
        this.resetWorldBounds(),
        this.node && (this.worldBounds.setFromTransformedAabb(this.localBounds, this.localSpace ? ee.IDENTITY : this.node.getWorldTransform()),
        this.worldBoundsTrail[0].copy(this.worldBounds),
        this.worldBoundsTrail[1].copy(this.worldBounds),
        this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2),
        this.prevWorldBoundsSize.copy(this.worldBoundsSize),
        this.prevWorldBoundsCenter.copy(this.worldBounds.center),
        this.pack8 && this.calculateBoundsMad()),
        this.vbToSort = new Array(this.numParticles);
        for (let d = 0; d < this.numParticles; d++)
            this.vbToSort[d] = [0, 0];
        this.particleDistance = new Float32Array(this.numParticles),
        this._gpuUpdater.randomize(),
        this.particleTex = new Float32Array(this.numParticlesPot * an * sd);
        const t = this.node === null || this.localSpace ? y.ZERO : this.node.getPosition();
        this.emitterShape === di && (this.node === null || this.localSpace ? Or.setTRS(y.ZERO, ne.IDENTITY, this.spawnBounds) : Or.setTRS(y.ZERO, this.node.getRotation(), O0.copy(this.spawnBounds).mul(this.node.localScale)),
        on[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0,
        on[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0,
        on[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0);
        for (let d = 0; d < this.numParticles; d++)
            this._cpuUpdater.calcSpawnPosition(this.particleTex, Or, on, t, d),
            this.useCpu && (this.particleTex[d * sd + 3 + this.numParticlesPot * 2 * sd] = 1);
        this.particleTexStart = new Float32Array(this.numParticlesPot * an * sd);
        for (let d = 0; d < this.particleTexStart.length; d++)
            this.particleTexStart[d] = this.particleTex[d];
        this.useCpu || (this.pack8 ? (this.particleTexIN = Fs(e, this.numParticlesPot, an, this.particleTex, ve, 1, !1),
        this.particleTexOUT = Fs(e, this.numParticlesPot, an, this.particleTex, ve, 1, !1),
        this.particleTexStart = Fs(e, this.numParticlesPot, an, this.particleTexStart, ve, 1, !1)) : (this.particleTexIN = Fs(e, this.numParticlesPot, an, this.particleTex),
        this.particleTexOUT = Fs(e, this.numParticlesPot, an, this.particleTex),
        this.particleTexStart = Fs(e, this.numParticlesPot, an, this.particleTexStart)),
        this.rtParticleTexIN = new It({
            colorBuffer: this.particleTexIN,
            depth: !1
        }),
        this.rtParticleTexOUT = new It({
            colorBuffer: this.particleTexOUT,
            depth: !1
        }),
        this.swapTex = !1);
        const s = (this.localSpace ? `#define LOCAL_SPACE
` : "") + $.particleUpdaterInitPS + (this.pack8 ? $.particleInputRgba8PS + $.particleOutputRgba8PS : $.particleInputFloatPS + $.particleOutputFloatPS) + (this.emitterShape === di ? $.particleUpdaterAABBPS : $.particleUpdaterSpherePS) + $.particleUpdaterStartPS
          , i = s + $.particleUpdaterRespawnPS + $.particleUpdaterEndPS
          , n = s + $.particleUpdaterNoRespawnPS + $.particleUpdaterEndPS
          , r = s + $.particleUpdaterOnStopPS + $.particleUpdaterEndPS
          , o = this.emitterShape + "" + this.pack8 + this.localSpace;
        this.shaderParticleUpdateRespawn = Ys(e, $.fullscreenQuadVS, i, "fsQuad0" + o),
        this.shaderParticleUpdateNoRespawn = Ys(e, $.fullscreenQuadVS, n, "fsQuad1" + o),
        this.shaderParticleUpdateOnStop = Ys(e, $.fullscreenQuadVS, r, "fsQuad2" + o),
        this.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4,
        this.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6,
        this._allocate(this.numParticles);
        const l = new ms(e);
        l.vertexBuffer = this.vertexBuffer,
        l.indexBuffer[0] = this.indexBuffer,
        l.primitive[0].type = xn,
        l.primitive[0].base = 0,
        l.primitive[0].count = this.numParticles * this.numParticleIndices,
        l.primitive[0].indexed = !0,
        this.material = new Yi,
        this.material.name = this.node.name,
        this.material.cull = bt,
        this.material.alphaWrite = !1,
        this.material.blendType = this.blendType,
        this.material.depthWrite = this.depthWrite,
        this.material.emitter = this,
        this.regenShader(),
        this.resetMaterial();
        const c = this.meshInstance ? this.meshInstance.visible : !0;
        this.meshInstance = new Fe(l,this.material,this.node),
        this.meshInstance.pick = !1,
        this.meshInstance.updateKey(),
        this.meshInstance.cull = !0,
        this.meshInstance._noDepthDrawGl1 = !0,
        this.localSpace ? this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform()) : this.meshInstance.aabb.copy(this.worldBounds),
        this.meshInstance._updateAabb = !1,
        this.meshInstance.visible = c,
        this._initializeTextures(),
        this.resetTime(),
        this.addTime(0, !1),
        this.preWarm && this.prewarm(this.lifetime)
    }
    _isAnimated() {
        return this.animNumFrames >= 1 && (this.animTilesX > 1 || this.animTilesY > 1) && (this.colorMap && this.colorMap !== this.defaultParamTexture || this.normalMap)
    }
    rebuildGraphs() {
        const e = this.precision
          , t = this.graphicsDevice;
        this.qLocalVelocity = this.localVelocityGraph.quantize(e),
        this.qVelocity = this.velocityGraph.quantize(e),
        this.qColor = this.colorGraph.quantizeClamped(e, 0, 1),
        this.qRotSpeed = this.rotationSpeedGraph.quantize(e),
        this.qScale = this.scaleGraph.quantize(e),
        this.qAlpha = this.alphaGraph.quantize(e),
        this.qRadialSpeed = this.radialSpeedGraph.quantize(e),
        this.qLocalVelocity2 = this.localVelocityGraph2.quantize(e),
        this.qVelocity2 = this.velocityGraph2.quantize(e),
        this.qColor2 = this.colorGraph2.quantizeClamped(e, 0, 1),
        this.qRotSpeed2 = this.rotationSpeedGraph2.quantize(e),
        this.qScale2 = this.scaleGraph2.quantize(e),
        this.qAlpha2 = this.alphaGraph2.quantize(e),
        this.qRadialSpeed2 = this.radialSpeedGraph2.quantize(e);
        for (let s = 0; s < e; s++)
            this.qRotSpeed[s] *= W.DEG_TO_RAD,
            this.qRotSpeed2[s] *= W.DEG_TO_RAD;
        if (this.localVelocityUMax = new Float32Array(3),
        this.velocityUMax = new Float32Array(3),
        this.colorUMax = new Float32Array(3),
        this.rotSpeedUMax = [0],
        this.scaleUMax = [0],
        this.alphaUMax = [0],
        this.radialSpeedUMax = [0],
        this.qLocalVelocityDiv = Fr(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax),
        this.qVelocityDiv = Fr(this.qVelocity, this.qVelocity2, this.velocityUMax),
        this.qColorDiv = Fr(this.qColor, this.qColor2, this.colorUMax),
        this.qRotSpeedDiv = Fr(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax),
        this.qScaleDiv = Fr(this.qScale, this.qScale2, this.scaleUMax),
        this.qAlphaDiv = Fr(this.qAlpha, this.qAlpha2, this.alphaUMax),
        this.qRadialSpeedDiv = Fr(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax),
        this.pack8) {
            const s = [0, 0, 0];
            Xr(this.qVelocity, s);
            const i = [0, 0, 0];
            Xr(this.qVelocity2, i);
            const n = [0, 0, 0];
            Xr(this.qLocalVelocity, n);
            const r = [0, 0, 0];
            Xr(this.qLocalVelocity2, r);
            const o = [0];
            Xr(this.qRadialSpeed, o);
            const l = [0];
            Xr(this.qRadialSpeed2, l);
            let c = Math.max(s[0], i[0]);
            c = Math.max(c, s[1]),
            c = Math.max(c, i[1]),
            c = Math.max(c, s[2]),
            c = Math.max(c, i[2]);
            let d = Math.max(n[0], r[0]);
            d = Math.max(d, n[1]),
            d = Math.max(d, r[1]),
            d = Math.max(d, n[2]),
            d = Math.max(d, r[2]);
            const h = Math.max(o[0], l[0]);
            this.maxVel = c + d + h
        }
        this.useCpu || (this.internalTex0 = Fs(t, e, 1, F0(this.qLocalVelocity, this.qLocalVelocityDiv)),
        this.internalTex1 = Fs(t, e, 1, F0(this.qVelocity, this.qVelocityDiv)),
        this.internalTex2 = Fs(t, e, 1, TL(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv)),
        this.internalTex3 = Fs(t, e, 1, CL(this.qRadialSpeed, this.qRadialSpeedDiv))),
        this.colorParam = Fs(t, e, 1, bL(this.qColor, this.qAlpha), ve, 1, !0)
    }
    _initializeTextures() {
        this.colorMap && (this.material.setParameter("colorMap", this.colorMap),
        this.lighting && this.normalMap && this.material.setParameter("normalMap", this.normalMap))
    }
    regenShader() {
        const e = Cr(this.graphicsDevice);
        e.register("particle", gL);
        const t = this.normalMap !== null;
        this.normalOption = 0,
        this.lighting && (this.normalOption = t ? 2 : 1),
        this.material.getShaderVariant = function(s, i, n, r, o, l, c, d) {
            this.emitter.scene && this.emitter.camera !== this.emitter.scene._activeCamera && (this.emitter.camera = this.emitter.scene._activeCamera,
            this.emitter.onChangeCamera());
            const h = this.emitter.inTools
              , u = new Aa(c,d);
            return e.getProgram("particle", {
                pass: pc,
                useCpu: this.emitter.useCpu,
                normal: this.emitter.normalOption,
                halflambert: this.emitter.halfLambert,
                stretch: this.emitter.stretch,
                alignToMotion: this.emitter.alignToMotion,
                soft: this.emitter.depthSoftening,
                mesh: this.emitter.useMesh,
                gamma: this.emitter.scene ? this.emitter.scene.gammaCorrection : 0,
                toneMap: this.emitter.scene ? this.emitter.scene.toneMapping : 0,
                fog: this.emitter.scene && !this.emitter.noFog ? this.emitter.scene.fog : "none",
                wrap: this.emitter.wrap && this.emitter.wrapBounds,
                localSpace: this.emitter.localSpace,
                screenSpace: h ? !1 : this.emitter.screenSpace,
                blend: this.blendType,
                animTex: this.emitter._isAnimated(),
                animTexLoop: this.emitter.animLoop,
                pack8: this.emitter.pack8,
                customFace: this.emitter.orientation !== ih
            }, u)
        }
        ,
        this.material.shader = this.material.getShaderVariant()
    }
    resetMaterial() {
        const e = this.material;
        e.setParameter("stretch", this.stretch),
        this._isAnimated() && (e.setParameter("animTexTilesParams", this.animTilesParams),
        e.setParameter("animTexParams", this.animParams),
        e.setParameter("animTexIndexParams", this.animIndexParams)),
        e.setParameter("colorMult", this.intensity),
        this.useCpu || (e.setParameter("internalTex0", this.internalTex0),
        e.setParameter("internalTex1", this.internalTex1),
        e.setParameter("internalTex2", this.internalTex2),
        e.setParameter("internalTex3", this.internalTex3)),
        e.setParameter("colorParam", this.colorParam),
        e.setParameter("numParticles", this.numParticles),
        e.setParameter("numParticlesPot", this.numParticlesPot),
        e.setParameter("lifetime", this.lifetime),
        e.setParameter("rate", this.rate),
        e.setParameter("rateDiv", this.rate2 - this.rate),
        e.setParameter("seed", this.seed),
        e.setParameter("scaleDivMult", this.scaleUMax[0]),
        e.setParameter("alphaDivMult", this.alphaUMax[0]),
        e.setParameter("radialSpeedDivMult", this.radialSpeedUMax[0]),
        e.setParameter("graphNumSamples", this.precision),
        e.setParameter("graphSampleSize", 1 / this.precision),
        e.setParameter("emitterScale", new Float32Array([1, 1, 1])),
        this.pack8 && (this._gpuUpdater._setInputBounds(),
        e.setParameter("inBoundsSize", this._gpuUpdater.inBoundsSizeUniform),
        e.setParameter("inBoundsCenter", this._gpuUpdater.inBoundsCenterUniform),
        e.setParameter("maxVel", this.maxVel)),
        this.wrap && this.wrapBounds && (this.wrapBoundsUniform[0] = this.wrapBounds.x,
        this.wrapBoundsUniform[1] = this.wrapBounds.y,
        this.wrapBoundsUniform[2] = this.wrapBounds.z,
        e.setParameter("wrapBounds", this.wrapBoundsUniform)),
        this.colorMap && e.setParameter("colorMap", this.colorMap),
        this.lighting && this.normalMap && e.setParameter("normalMap", this.normalMap),
        this.depthSoftening > 0 && e.setParameter("softening", 1 / (this.depthSoftening * this.depthSoftening * 100)),
        this.stretch > 0 && (e.cull = bt),
        this._compParticleFaceParams()
    }
    _compParticleFaceParams() {
        let e, t;
        if (this.orientation === ih)
            e = new Float32Array([1, 0, 0]),
            t = new Float32Array([0, 0, 1]);
        else {
            let s;
            this.orientation === nA ? s = this.particleNormal.normalize() : s = (this.node === null ? ee.IDENTITY : this.node.getWorldTransform()).transformVector(this.particleNormal).normalize();
            const i = new y(1,0,0);
            Math.abs(i.dot(s)) === 1 && i.set(0, 0, 1);
            const n = new y().cross(s, i).normalize();
            i.cross(n, s).normalize(),
            e = new Float32Array([i.x, i.y, i.z]),
            t = new Float32Array([n.x, n.y, n.z])
        }
        this.material.setParameter("faceTangent", e),
        this.material.setParameter("faceBinorm", t)
    }
    _allocate(e) {
        const t = e * this.numParticleVerts
          , s = e * this.numParticleIndices;
        if (this.vertexBuffer === void 0 || this.vertexBuffer.getNumVertices() !== t) {
            if (this.useCpu) {
                const d = [{
                    semantic: Kd,
                    components: 4,
                    type: Me
                }, {
                    semantic: fm,
                    components: 4,
                    type: Me
                }, {
                    semantic: LS,
                    components: 4,
                    type: Me
                }, {
                    semantic: DS,
                    components: 1,
                    type: Me
                }, {
                    semantic: OS,
                    components: this.useMesh ? 4 : 2,
                    type: Me
                }]
                  , h = new fs(this.graphicsDevice,d);
                this.vertexBuffer = new xi(this.graphicsDevice,h,t,Do),
                this.indexBuffer = new _r(this.graphicsDevice,js,s)
            } else {
                const d = [{
                    semantic: Kd,
                    components: 4,
                    type: Me
                }];
                this.useMesh && d.push({
                    semantic: fm,
                    components: 2,
                    type: Me
                });
                const h = new fs(this.graphicsDevice,d);
                this.vertexBuffer = new xi(this.graphicsDevice,h,t,Do),
                this.indexBuffer = new _r(this.graphicsDevice,js,s)
            }
            const i = new Float32Array(this.vertexBuffer.lock());
            let n, r, o;
            if (this.useMesh) {
                n = new Float32Array(this.mesh.vertexBuffer.lock()),
                r = n.length / this.mesh.vertexBuffer.numVertices;
                for (let d = 0; d < this.mesh.vertexBuffer.format.elements.length; d++)
                    if (this.mesh.vertexBuffer.format.elements[d].name === Ls) {
                        o = this.mesh.vertexBuffer.format.elements[d].offset / 4;
                        break
                    }
            }
            for (let d = 0; d < t; d++) {
                const h = Math.floor(d / this.numParticleVerts);
                if (this.useMesh) {
                    const u = d % this.numParticleVerts;
                    i[d * 6] = n[u * r],
                    i[d * 6 + 1] = n[u * r + 1],
                    i[d * 6 + 2] = n[u * r + 2],
                    i[d * 6 + 3] = h,
                    i[d * 6 + 4] = n[u * r + o + 0],
                    i[d * 6 + 5] = 1 - n[u * r + o + 1]
                } else {
                    const u = d % 4;
                    i[d * 4] = P0[u][0],
                    i[d * 4 + 1] = P0[u][1],
                    i[d * 4 + 2] = 0,
                    i[d * 4 + 3] = h
                }
            }
            this.useCpu && (this.vbCPU = new Float32Array(i),
            this.vbOld = new Float32Array(this.vbCPU.length)),
            this.vertexBuffer.unlock(),
            this.useMesh && this.mesh.vertexBuffer.unlock();
            let l = 0;
            const c = new Uint16Array(this.indexBuffer.lock());
            this.useMesh && (n = new Uint16Array(this.mesh.indexBuffer[0].lock()));
            for (let d = 0; d < e; d++)
                if (this.useMesh)
                    for (let h = 0; h < this.numParticleIndices; h++)
                        c[d * this.numParticleIndices + h] = n[h] + d * this.numParticleVerts;
                else {
                    const h = d * 4;
                    c[l++] = h,
                    c[l++] = h + 1,
                    c[l++] = h + 2,
                    c[l++] = h,
                    c[l++] = h + 2,
                    c[l++] = h + 3
                }
            this.indexBuffer.unlock(),
            this.useMesh && this.mesh.indexBuffer[0].unlock()
        }
    }
    reset() {
        if (this.beenReset = !0,
        this.seed = Math.random(),
        this.material.setParameter("seed", this.seed),
        this.useCpu)
            for (let t = 0; t < this.particleTexStart.length; t++)
                this.particleTex[t] = this.particleTexStart[t];
        else
            this._initializeTextures();
        this.resetWorldBounds(),
        this.resetTime();
        const e = this.loop;
        this.loop = !0,
        this.addTime(0, !1),
        this.loop = e,
        this.preWarm && this.prewarm(this.lifetime)
    }
    prewarm(e) {
        const t = e / this.lifetime
          , s = Math.min(Math.floor(t * this.precision), this.precision)
          , i = e / s;
        for (let n = 0; n < s; n++)
            this.addTime(i, !1)
    }
    resetTime() {
        this.endTime = EL(this)
    }
    finishFrame() {
        this.useCpu && this.vertexBuffer.unlock()
    }
    addTime(e, t) {
        const s = this.graphicsDevice;
        if (this.simTimeTotal += e,
        this.calculateWorldBounds(),
        this._isAnimated()) {
            const r = this.animTilesParams;
            r[0] = 1 / this.animTilesX,
            r[1] = 1 / this.animTilesY;
            const o = this.animParams;
            o[0] = this.animStartFrame,
            o[1] = this.animNumFrames * this.animSpeed,
            o[2] = this.animNumFrames - 1,
            o[3] = this.animNumAnimations - 1;
            const l = this.animIndexParams;
            l[0] = this.animIndex,
            l[1] = this.randomizeAnimIndex
        }
        this.scene && this.camera !== this.scene._activeCamera && (this.camera = this.scene._activeCamera,
        this.onChangeCamera()),
        this.emitterShape === di && (on[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0,
        on[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0,
        on[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0,
        this.meshInstance.node === null ? Or.setTRS(y.ZERO, ne.IDENTITY, this.emitterExtents) : Or.setTRS(y.ZERO, this.meshInstance.node.getRotation(), O0.copy(this.emitterExtents).mul(this.meshInstance.node.localScale)));
        let i;
        const n = this.meshInstance.node === null ? y.ONE : this.meshInstance.node.localScale;
        if (this.emitterScaleUniform[0] = n.x,
        this.emitterScaleUniform[1] = n.y,
        this.emitterScaleUniform[2] = n.z,
        this.material.setParameter("emitterScale", this.emitterScaleUniform),
        this.localSpace && this.meshInstance.node && (i = this.meshInstance.node.getPosition(),
        this.emitterPosUniform[0] = i.x,
        this.emitterPosUniform[1] = i.y,
        this.emitterPosUniform[2] = i.z,
        this.material.setParameter("emitterPos", this.emitterPosUniform)),
        this._compParticleFaceParams(),
        !this.useCpu)
            this._gpuUpdater.update(s, Or, on, e, t);
        else {
            const r = new Float32Array(this.vertexBuffer.lock());
            this._cpuUpdater.update(r, this.vbToSort, this.particleTex, Or, on, i, e, t)
        }
        this.loop || Date.now() > this.endTime && (this.onFinished && this.onFinished(),
        this.meshInstance.visible = !1),
        this.meshInstance && (this.meshInstance.drawOrder = this.drawOrder)
    }
    _destroyResources() {
        this.particleTexIN && (this.particleTexIN.destroy(),
        this.particleTexIN = null),
        this.particleTexOUT && (this.particleTexOUT.destroy(),
        this.particleTexOUT = null),
        this.particleTexStart && this.particleTexStart.destroy && (this.particleTexStart.destroy(),
        this.particleTexStart = null),
        this.rtParticleTexIN && (this.rtParticleTexIN.destroy(),
        this.rtParticleTexIN = null),
        this.rtParticleTexOUT && (this.rtParticleTexOUT.destroy(),
        this.rtParticleTexOUT = null),
        this.internalTex0 && (this.internalTex0.destroy(),
        this.internalTex0 = null),
        this.internalTex1 && (this.internalTex1.destroy(),
        this.internalTex1 = null),
        this.internalTex2 && (this.internalTex2.destroy(),
        this.internalTex2 = null),
        this.internalTex3 && (this.internalTex3.destroy(),
        this.internalTex3 = null),
        this.colorParam && (this.colorParam.destroy(),
        this.colorParam = null),
        this.vertexBuffer && (this.vertexBuffer.destroy(),
        this.vertexBuffer = void 0),
        this.indexBuffer && (this.indexBuffer.destroy(),
        this.indexBuffer = void 0),
        this.material && (this.material.destroy(),
        this.material = null)
    }
    destroy() {
        this.camera = null,
        this._destroyResources()
    }
}
class IL extends Ue {
    generateKey(e) {
        return `skybox-${e.type}-${e.encoding}-${e.useIntensity}-${e.gamma}-${e.toneMapping}-${e.skymesh}` + (e.type === "cubemap" ? `-${e.fixSeams}-${e.mip}` : "")
    }
    createShaderDefinition(e, t) {
        const s = t.skymesh === Fd ? "" : `#define SKYMESH
`
          , i = s + $.skyboxVS;
        let n = s;
        if (t.type === "cubemap") {
            const r = [128, 64, 16, 8, 4, 2];
            n += t.mip ? $.fixCubemapSeamsStretchPS : $.fixCubemapSeamsNonePS,
            n += t.useIntensity ? $.envMultiplyPS : $.envConstPS,
            n += $.decodePS,
            n += Ue.gammaCode(t.gamma),
            n += Ue.tonemapCode(t.toneMapping),
            n += $.skyboxHDRPS.replace(/\$DECODE/g, mi.decodeFunc(t.encoding)).replace(/\$FIXCONST/g, 1 - 1 / r[t.mip] + "")
        } else
            n += t.useIntensity ? $.envMultiplyPS : $.envConstPS,
            n += $.decodePS,
            n += Ue.gammaCode(t.gamma),
            n += Ue.tonemapCode(t.toneMapping),
            n += $.sphericalPS,
            n += $.envAtlasPS,
            n += $.skyboxEnvPS.replace(/\$DECODE/g, mi.decodeFunc(t.encoding));
        return Pt.createDefinition(e, {
            name: "SkyboxShader",
            attributes: {
                aPosition: ut
            },
            vertexCode: i,
            fragmentCode: n
        })
    }
}
const LL = new IL;
class rh {
    static create(e, t) {
        switch (t) {
        case _A:
            return rh.box(e);
        case gA:
            return rh.dome(e)
        }
        return rh.infinite(e)
    }
    static infinite(e) {
        return au(e)
    }
    static box(e) {
        return au(e, {
            yOffset: .5
        })
    }
    static dome(e) {
        const l = []
          , c = [];
        for (let d = 0; d <= 50; d++) {
            const h = d * Math.PI / 50
              , u = Math.sin(h)
              , f = Math.cos(h);
            for (let p = 0; p <= 50; p++) {
                const _ = p * 2 * Math.PI / 50 - Math.PI / 2
                  , m = Math.sin(_)
                  , v = Math.cos(_) * u;
                let x = f;
                const S = m * u;
                x < 0 && (x *= .3,
                v * v + S * S < .9025 && (x = -.1)),
                x += .1,
                l.push(v * .5, x * .5, S * .5)
            }
        }
        for (let d = 0; d < 50; ++d)
            for (let h = 0; h < 50; ++h) {
                const u = d * 51 + h
                  , f = u + 50 + 1;
                c.push(u + 1, f, u),
                c.push(u + 1, f + 1, f)
            }
        return qi(e, l, {
            indices: c
        })
    }
}
class DL {
    constructor(e, t, s, i, n) {
        this.meshInstance = null;
        const r = new Yi;
        r.getShaderVariant = function(l, c, d, h, u, f, p, _) {
            const m = {
                pass: u,
                encoding: i.encoding,
                useIntensity: t.skyboxIntensity !== 1 || t.physicalUnits,
                gamma: u === $i ? t.gammaCorrection ? uc : dc : t.gammaCorrection,
                toneMapping: u === $i ? fc : t.toneMapping,
                skymesh: n
            };
            i.cubemap ? (m.type = "cubemap",
            m.mip = i.fixCubemapSeams ? t.skyboxMip : 0,
            m.fixSeams = i.fixCubemapSeams) : m.type = "envAtlas";
            const g = new Aa(p,_)
              , v = Cr(e);
            return v.register("skybox", LL),
            v.getProgram("skybox", m, g)
        }
        ,
        i.cubemap ? r.setParameter("texture_cubeMap", i) : (r.setParameter("texture_envAtlas", i),
        r.setParameter("mipLevel", t._skyboxMip)),
        r.cull = Zl,
        r.depthWrite = !1;
        const o = t.layers.getLayerById(j_);
        if (o) {
            const l = rh.create(e, n)
              , c = new Fe(l,r,s);
            this.meshInstance = c,
            c.cull = !1,
            c._noDepthDrawGl1 = !0,
            c.pick = !1,
            o.addMeshInstances([c]),
            this.skyLayer = o
        }
    }
    destroy() {
        this.meshInstance && (this.skyLayer && this.skyLayer.removeMeshInstances([this.meshInstance]),
        this.meshInstance.destroy(),
        this.meshInstance = null)
    }
}
class OL {
    constructor(e) {
        this._type = Fd,
        this._center = new y(0,1,0),
        this.skyMesh = null,
        this.node = new yt("SkyMeshNode"),
        this.device = e.device,
        this.scene = e,
        this.center = new y(0,1,0),
        this.centerArray = new Float32Array(3),
        this.projectedSkydomeCenterId = this.device.scope.resolve("projectedSkydomeCenter")
    }
    applySettings(e) {
        var t, s, i, n;
        this.type = (t = e.skyType) != null ? t : Fd,
        this.node.setLocalPosition(new y((s = e.skyMeshPosition) != null ? s : [0, 0, 0])),
        this.node.setLocalEulerAngles(new y((i = e.skyMeshRotation) != null ? i : [0, 0, 0])),
        this.node.setLocalScale(new y((n = e.skyMeshScale) != null ? n : [1, 1, 1])),
        e.skyCenter && (this._center = new y(e.skyCenter))
    }
    set type(e) {
        this._type !== e && (this._type = e,
        this.scene.updateShaders = !0,
        this.updateSkyMesh())
    }
    get type() {
        return this._type
    }
    set center(e) {
        this._center.copy(e)
    }
    get center() {
        return this._center
    }
    updateSkyMesh() {
        const e = this.scene._getSkyboxTex();
        e && (this.resetSkyMesh(),
        this.skyMesh = new DL(this.device,this.scene,this.node,e,this.type),
        this.scene.fire("set:skybox", e))
    }
    resetSkyMesh() {
        var e;
        (e = this.skyMesh) == null || e.destroy(),
        this.skyMesh = null
    }
    update() {
        if (this.type !== Fd) {
            const {center: e, centerArray: t} = this
              , s = new y;
            this.node.getWorldTransform().transformPoint(e, s),
            t[0] = s.x,
            t[1] = s.y,
            t[2] = s.z,
            this.projectedSkydomeCenterId.setValue(t)
        }
    }
}
const lu = new yt;
lu.worldTransform = ee.IDENTITY;
lu._dirtyWorld = lu._dirtyNormal = !1;
class FL {
    constructor(e, t, s) {
        this.material = t,
        this.layer = s,
        this.positions = [],
        this.colors = [],
        this.mesh = new ms(e),
        this.meshInstance = null
    }
    addLines(e, t) {
        const s = this.positions
          , i = e.length;
        for (let r = 0; r < i; r++) {
            const o = e[r];
            s.push(o.x, o.y, o.z)
        }
        const n = this.colors;
        if (t.length)
            for (let r = 0; r < i; r++) {
                const o = t[r];
                n.push(o.r, o.g, o.b, o.a)
            }
        else
            for (let r = 0; r < i; r++)
                n.push(t.r, t.g, t.b, t.a)
    }
    addLinesArrays(e, t) {
        const s = this.positions;
        for (let n = 0; n < e.length; n += 3)
            s.push(e[n], e[n + 1], e[n + 2]);
        const i = this.colors;
        if (t.length)
            for (let n = 0; n < t.length; n += 4)
                i.push(t[n], t[n + 1], t[n + 2], t[n + 3]);
        else {
            const n = e.length / 3;
            for (let r = 0; r < n; r++)
                i.push(t.r, t.g, t.b, t.a)
        }
    }
    onPreRender(e, t) {
        this.positions.length > 0 && this.material.transparent === t && (this.mesh.setPositions(this.positions),
        this.mesh.setColors(this.colors),
        this.mesh.update(of, !1),
        this.meshInstance || (this.meshInstance = new Fe(this.mesh,this.material,lu)),
        this.positions.length = 0,
        this.colors.length = 0,
        e.push(this.meshInstance))
    }
}
class BL {
    constructor(e) {
        this.device = e,
        this.map = new Map
    }
    getBatch(e, t) {
        let s = this.map.get(e);
        return s || (s = new FL(this.device,e,t),
        this.map.set(e, s)),
        s
    }
    onPreRender(e, t) {
        this.map.forEach(s => {
            s.onPreRender(e, t)
        }
        )
    }
}
const ri = [];
class kL {
    constructor(e) {
        this.device = e,
        this.quadMesh = null,
        this.textureShader = null,
        this.depthTextureShader = null,
        this.cubeLocalPos = null,
        this.cubeWorldPos = null,
        this.batchesMap = new Map,
        this.allBatches = new Set,
        this.updatedLayers = new Set,
        this._materialDepth = null,
        this._materialNoDepth = null,
        this.layerMeshInstances = new Map
    }
    createMaterial(e) {
        const t = new vR;
        return t.vertexColors = !0,
        t.blendType = ps,
        t.depthTest = e,
        t.update(),
        t
    }
    get materialDepth() {
        return this._materialDepth || (this._materialDepth = this.createMaterial(!0)),
        this._materialDepth
    }
    get materialNoDepth() {
        return this._materialNoDepth || (this._materialNoDepth = this.createMaterial(!1)),
        this._materialNoDepth
    }
    getBatch(e, t) {
        let s = this.batchesMap.get(e);
        s || (s = new BL(this.device),
        this.batchesMap.set(e, s)),
        this.allBatches.add(s);
        const i = t ? this.materialDepth : this.materialNoDepth;
        return s.getBatch(i, e)
    }
    getShader(e, t) {
        if (!this[e]) {
            const s = `
				attribute vec2 vertex_position;
				uniform mat4 matrix_model;
				varying vec2 uv0;
				void main(void) {
					gl_Position = matrix_model * vec4(vertex_position, 0, 1);
					uv0 = vertex_position.xy + 0.5;
				}
			`;
            this[e] = Ys(this.device, s, t, `DebugShader:${e}`)
        }
        return this[e]
    }
    getTextureShader() {
        return this.getShader("textureShader", `
			varying vec2 uv0;
			uniform sampler2D colorMap;
			void main (void) {
				gl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);
			}
		`)
    }
    getUnfilterableTextureShader() {
        return this.getShader("textureShaderUnfilterable", `
			varying vec2 uv0;
			uniform highp sampler2D colorMap;
			void main (void) {
				ivec2 uv = ivec2(uv0 * textureSize(colorMap, 0));
				gl_FragColor = vec4(texelFetch(colorMap, uv, 0).xyz, 1);
			}
		`)
    }
    getDepthTextureShader() {
        return this.getShader("depthTextureShader", `
			${$.screenDepthPS}
			varying vec2 uv0;
			void main() {
				float depth = getLinearScreenDepth(getImageEffectUV(uv0)) * camera_params.x;
				gl_FragColor = vec4(vec3(depth), 1.0);
			}
		`)
    }
    getQuadMesh() {
        return this.quadMesh || (this.quadMesh = new ms(this.device),
        this.quadMesh.setPositions([-.5, -.5, 0, .5, -.5, 0, -.5, .5, 0, .5, .5, 0]),
        this.quadMesh.update(Ks)),
        this.quadMesh
    }
    drawMesh(e, t, s, i, n) {
        if (!i) {
            const o = this.getGraphNode(t);
            i = new Fe(s,e,o)
        }
        let r = this.layerMeshInstances.get(n);
        r || (r = [],
        this.layerMeshInstances.set(n, r)),
        r.push(i)
    }
    drawWireAlignedBox(e, t, s, i, n) {
        ri.push(e.x, e.y, e.z, e.x, t.y, e.z, e.x, t.y, e.z, t.x, t.y, e.z, t.x, t.y, e.z, t.x, e.y, e.z, t.x, e.y, e.z, e.x, e.y, e.z, e.x, e.y, t.z, e.x, t.y, t.z, e.x, t.y, t.z, t.x, t.y, t.z, t.x, t.y, t.z, t.x, e.y, t.z, t.x, e.y, t.z, e.x, e.y, t.z, e.x, e.y, e.z, e.x, e.y, t.z, e.x, t.y, e.z, e.x, t.y, t.z, t.x, t.y, e.z, t.x, t.y, t.z, t.x, e.y, e.z, t.x, e.y, t.z),
        this.getBatch(n, i).addLinesArrays(ri, s),
        ri.length = 0
    }
    drawWireSphere(e, t, s, i, n, r) {
        const o = 2 * Math.PI / i;
        let l = 0;
        for (let d = 0; d < i; d++) {
            const h = Math.sin(l)
              , u = Math.cos(l);
            l += o;
            const f = Math.sin(l)
              , p = Math.cos(l);
            ri.push(e.x + t * h, e.y, e.z + t * u),
            ri.push(e.x + t * f, e.y, e.z + t * p),
            ri.push(e.x + t * h, e.y + t * u, e.z),
            ri.push(e.x + t * f, e.y + t * p, e.z),
            ri.push(e.x, e.y + t * h, e.z + t * u),
            ri.push(e.x, e.y + t * f, e.z + t * p)
        }
        this.getBatch(r, n).addLinesArrays(ri, s),
        ri.length = 0
    }
    getGraphNode(e) {
        const t = new yt("ImmediateDebug");
        return t.worldTransform = e,
        t._dirtyWorld = t._dirtyNormal = !1,
        t
    }
    onPreRenderLayer(e, t, s) {
        if (this.batchesMap.forEach( (i, n) => {
            n === e && i.onPreRender(t, s)
        }
        ),
        !this.updatedLayers.has(e)) {
            this.updatedLayers.add(e);
            const i = this.layerMeshInstances.get(e);
            if (i) {
                for (let n = 0; n < i.length; n++)
                    t.push(i[n]);
                i.length = 0
            }
        }
    }
    onPostRender() {
        this.allBatches.clear(),
        this.updatedLayers.clear()
    }
}
let cg = class extends fe {
    constructor(e) {
        super(),
        this.ambientBake = !1,
        this.ambientBakeOcclusionBrightness = 0,
        this.ambientBakeOcclusionContrast = 0,
        this.ambientLight = new z(0,0,0),
        this.ambientLuminance = 0,
        this.exposure = 1,
        this.fogColor = new z(0,0,0),
        this.fogDensity = 0,
        this.fogEnd = 1e3,
        this.fogStart = 1,
        this.lightmapSizeMultiplier = 1,
        this.lightmapMaxResolution = 2048,
        this.lightmapMode = Dd,
        this.lightmapFilterEnabled = !1,
        this.lightmapHDR = !1,
        this.root = null,
        this.physicalUnits = !1,
        this._envAtlas = null,
        this._skyboxCubeMap = null,
        this.device = e,
        this._gravity = new y(0,-9.8,0),
        this._layers = null,
        this._fog = Tf,
        this._gammaCorrection = Z_,
        this._toneMapping = 0,
        this._prefilteredCubemaps = [],
        this._internalEnvAtlas = null,
        this._skyboxIntensity = 1,
        this._skyboxLuminance = 0,
        this._skyboxMip = 0,
        this._skyboxRotationShaderInclude = !1,
        this._skyboxRotation = new ne,
        this._skyboxRotationMat3 = new Ci,
        this._skyboxRotationMat4 = new ee,
        this._ambientBakeNumSamples = 1,
        this._ambientBakeSpherePart = .4,
        this._lightmapFilterRange = 10,
        this._lightmapFilterSmoothness = .2,
        this._clusteredLightingEnabled = !0,
        this._lightingParams = new xx(this.device.supportsAreaLights,this.device.maxTextureSize, () => {
            this.updateShaders = !0
        }
        ),
        this._sky = new OL(this),
        this._stats = {
            meshInstances: 0,
            lights: 0,
            dynamicLights: 0,
            bakedLights: 0,
            updateShadersTime: 0
        },
        this.updateShaders = !0,
        this._shaderVersion = 0,
        this.immediate = new kL(this.device)
    }
    get defaultDrawLayer() {
        return this.layers.getLayerById($_)
    }
    set ambientBakeNumSamples(e) {
        this._ambientBakeNumSamples = W.clamp(Math.floor(e), 1, 255)
    }
    get ambientBakeNumSamples() {
        return this._ambientBakeNumSamples
    }
    set ambientBakeSpherePart(e) {
        this._ambientBakeSpherePart = W.clamp(e, .001, 1)
    }
    get ambientBakeSpherePart() {
        return this._ambientBakeSpherePart
    }
    set clusteredLightingEnabled(e) {
        if (!(this.device.isWebGPU && !e)) {
            if (!this._clusteredLightingEnabled && e) {
                console.error("Turning on disabled clustered lighting is not currently supported");
                return
            }
            this._clusteredLightingEnabled = e
        }
    }
    get clusteredLightingEnabled() {
        return this._clusteredLightingEnabled
    }
    set envAtlas(e) {
        e !== this._envAtlas && (this._envAtlas = e,
        e && (e.addressU = oe,
        e.addressV = oe,
        e.minFilter = ot,
        e.magFilter = ot,
        e.mipmaps = !1),
        this._prefilteredCubemaps = [],
        this._internalEnvAtlas && (this._internalEnvAtlas.destroy(),
        this._internalEnvAtlas = null),
        this._resetSkyMesh())
    }
    get envAtlas() {
        return this._envAtlas
    }
    set fog(e) {
        e !== this._fog && (this._fog = e,
        this.updateShaders = !0)
    }
    get fog() {
        return this._fog
    }
    set gammaCorrection(e) {
        e !== this._gammaCorrection && (this._gammaCorrection = e,
        this.updateShaders = !0)
    }
    get gammaCorrection() {
        return this._gammaCorrection
    }
    set layers(e) {
        const t = this._layers;
        this._layers = e,
        this.fire("set:layers", t, e)
    }
    get layers() {
        return this._layers
    }
    get sky() {
        return this._sky
    }
    get lighting() {
        return this._lightingParams
    }
    set lightmapFilterRange(e) {
        this._lightmapFilterRange = Math.max(e, .001)
    }
    get lightmapFilterRange() {
        return this._lightmapFilterRange
    }
    set lightmapFilterSmoothness(e) {
        this._lightmapFilterSmoothness = Math.max(e, .001)
    }
    get lightmapFilterSmoothness() {
        return this._lightmapFilterSmoothness
    }
    set prefilteredCubemaps(e) {
        e = e || [];
        const t = this._prefilteredCubemaps;
        (t.length !== e.length || t.some( (i, n) => i !== e[n])) && (e.length === 6 && e.every(n => !!n) ? (this._internalEnvAtlas = yx.generatePrefilteredAtlas(e, {
            target: this._internalEnvAtlas
        }),
        this._envAtlas = this._internalEnvAtlas) : (this._internalEnvAtlas && (this._internalEnvAtlas.destroy(),
        this._internalEnvAtlas = null),
        this._envAtlas = null),
        this._prefilteredCubemaps = e.slice(),
        this._resetSkyMesh())
    }
    get prefilteredCubemaps() {
        return this._prefilteredCubemaps
    }
    set skybox(e) {
        e !== this._skyboxCubeMap && (this._skyboxCubeMap = e,
        this._resetSkyMesh())
    }
    get skybox() {
        return this._skyboxCubeMap
    }
    set skyboxIntensity(e) {
        e !== this._skyboxIntensity && (this._skyboxIntensity = e,
        this._resetSkyMesh())
    }
    get skyboxIntensity() {
        return this._skyboxIntensity
    }
    set skyboxLuminance(e) {
        e !== this._skyboxLuminance && (this._skyboxLuminance = e,
        this._resetSkyMesh())
    }
    get skyboxLuminance() {
        return this._skyboxLuminance
    }
    set skyboxMip(e) {
        e !== this._skyboxMip && (this._skyboxMip = e,
        this._resetSkyMesh())
    }
    get skyboxMip() {
        return this._skyboxMip
    }
    set skyboxRotation(e) {
        if (!this._skyboxRotation.equals(e)) {
            const t = e.equals(ne.IDENTITY);
            this._skyboxRotation.copy(e),
            t ? this._skyboxRotationMat3.setIdentity() : (this._skyboxRotationMat4.setTRS(y.ZERO, e, y.ONE),
            this._skyboxRotationMat3.invertMat4(this._skyboxRotationMat4)),
            !this._skyboxRotationShaderInclude && !t && (this._skyboxRotationShaderInclude = !0,
            this._resetSkyMesh())
        }
    }
    get skyboxRotation() {
        return this._skyboxRotation
    }
    set toneMapping(e) {
        e !== this._toneMapping && (this._toneMapping = e,
        this.updateShaders = !0)
    }
    get toneMapping() {
        return this._toneMapping
    }
    destroy() {
        this._resetSkyMesh(),
        this.root = null,
        this.off()
    }
    drawLine(e, t, s=z.WHITE, i=!0, n=this.defaultDrawLayer) {
        this.immediate.getBatch(n, i).addLines([e, t], [s, s])
    }
    drawLines(e, t, s=!0, i=this.defaultDrawLayer) {
        this.immediate.getBatch(i, s).addLines(e, t)
    }
    drawLineArrays(e, t, s=!0, i=this.defaultDrawLayer) {
        this.immediate.getBatch(i, s).addLinesArrays(e, t)
    }
    applySettings(e) {
        var t, s, i, n;
        const r = e.physics
          , o = e.render;
        this._gravity.set(r.gravity[0], r.gravity[1], r.gravity[2]),
        this.ambientLight.set(o.global_ambient[0], o.global_ambient[1], o.global_ambient[2]),
        this.ambientLuminance = o.ambientLuminance,
        this._fog = o.fog,
        this.fogColor.set(o.fog_color[0], o.fog_color[1], o.fog_color[2]),
        this.fogStart = o.fog_start,
        this.fogEnd = o.fog_end,
        this.fogDensity = o.fog_density,
        this._gammaCorrection = o.gamma_correction,
        this._toneMapping = o.tonemapping,
        this.lightmapSizeMultiplier = o.lightmapSizeMultiplier,
        this.lightmapMaxResolution = o.lightmapMaxResolution,
        this.lightmapMode = o.lightmapMode,
        this.exposure = o.exposure,
        this._skyboxIntensity = (t = o.skyboxIntensity) != null ? t : 1,
        this._skyboxLuminance = (s = o.skyboxLuminance) != null ? s : 2e4,
        this._skyboxMip = (i = o.skyboxMip) != null ? i : 0,
        o.skyboxRotation && (this.skyboxRotation = new ne().setFromEulerAngles(o.skyboxRotation[0], o.skyboxRotation[1], o.skyboxRotation[2])),
        this.sky.applySettings(o),
        this.clusteredLightingEnabled = (n = o.clusteredLightingEnabled) != null ? n : !1,
        this.lighting.applySettings(o),
        ["lightmapFilterEnabled", "lightmapFilterRange", "lightmapFilterSmoothness", "ambientBake", "ambientBakeNumSamples", "ambientBakeSpherePart", "ambientBakeOcclusionBrightness", "ambientBakeOcclusionContrast"].forEach(l => {
            o.hasOwnProperty(l) && (this[l] = o[l])
        }
        ),
        this._resetSkyMesh()
    }
    _getSkyboxTex() {
        const e = this._prefilteredCubemaps;
        return this._skyboxMip ? e[[0, 1, 3, 4, 5, 6][this._skyboxMip]] || this._envAtlas || e[0] || this._skyboxCubeMap : this._skyboxCubeMap || e[0] || this._envAtlas
    }
    _updateSkyMesh() {
        this.sky.skyMesh || this.sky.updateSkyMesh(),
        this.sky.update()
    }
    _resetSkyMesh() {
        this.sky.resetSkyMesh(),
        this.updateShaders = !0
    }
    setSkybox(e) {
        e ? (this.skybox = e[0] || null,
        e[1] && !e[1].cubemap ? this.envAtlas = e[1] : this.prefilteredCubemaps = e.slice(1)) : (this.skybox = null,
        this.envAtlas = null)
    }
    get lightmapPixelFormat() {
        return this.lightmapHDR && this.device.getRenderableHdrFormat() || ve
    }
}
;
cg.EVENT_SETLAYERS = "set:layers";
cg.EVENT_SETSKYBOX = "set:skybox";
class Tx {
    constructor(e, t, s) {
        this.device = e,
        this.inverseBindPose = t,
        this.boneNames = s
    }
}
const NL = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]
  , UL = [0, 1, 3, 2, 3, 1];
class Cx extends fe {
    constructor(e, t) {
        super(),
        this._device = e,
        this._pixelsPerUnit = t && t.pixelsPerUnit !== void 0 ? t.pixelsPerUnit : 1,
        this._renderMode = t && t.renderMode !== void 0 ? t.renderMode : gn,
        this._atlas = t && t.atlas !== void 0 ? t.atlas : null,
        this._frameKeys = t && t.frameKeys !== void 0 ? t.frameKeys : null,
        this._meshes = [],
        this._updatingProperties = !1,
        this._meshesDirty = !1,
        this._atlas && this._frameKeys && this._createMeshes()
    }
    set frameKeys(e) {
        this._frameKeys = e,
        this._atlas && this._frameKeys && (this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes()),
        this.fire("set:frameKeys", e)
    }
    get frameKeys() {
        return this._frameKeys
    }
    set atlas(e) {
        e !== this._atlas && (this._atlas && (this._atlas.off("set:frames", this._onSetFrames, this),
        this._atlas.off("set:frame", this._onFrameChanged, this),
        this._atlas.off("remove:frame", this._onFrameRemoved, this)),
        this._atlas = e,
        this._atlas && this._frameKeys && (this._atlas.on("set:frames", this._onSetFrames, this),
        this._atlas.on("set:frame", this._onFrameChanged, this),
        this._atlas.on("remove:frame", this._onFrameRemoved, this),
        this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes()),
        this.fire("set:atlas", e))
    }
    get atlas() {
        return this._atlas
    }
    set pixelsPerUnit(e) {
        this._pixelsPerUnit !== e && (this._pixelsPerUnit = e,
        this.fire("set:pixelsPerUnit", e),
        this._atlas && this._frameKeys && this.renderMode === gn && (this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes()))
    }
    get pixelsPerUnit() {
        return this._pixelsPerUnit
    }
    set renderMode(e) {
        if (this._renderMode === e)
            return;
        const t = this._renderMode;
        this._renderMode = e,
        this.fire("set:renderMode", e),
        (t === gn || e === gn) && this._atlas && this._frameKeys && (this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes())
    }
    get renderMode() {
        return this._renderMode
    }
    get meshes() {
        return this._meshes
    }
    _createMeshes() {
        const e = this._meshes.length;
        for (let i = 0; i < e; i++) {
            const n = this._meshes[i];
            n && n.destroy()
        }
        const t = this._frameKeys.length;
        this._meshes = new Array(t);
        const s = this.renderMode === xt || this._renderMode === _t ? this._create9SliceMesh : this._createSimpleMesh;
        for (let i = 0; i < t; i++) {
            const n = this._atlas.frames[this._frameKeys[i]];
            this._meshes[i] = n ? s.call(this, n) : null
        }
        this.fire("set:meshes")
    }
    _createSimpleMesh(e) {
        const t = e.rect
          , s = this._atlas.texture.width
          , i = this._atlas.texture.height
          , n = t.z / this._pixelsPerUnit
          , r = t.w / this._pixelsPerUnit
          , o = e.pivot.x
          , l = e.pivot.y
          , c = [-o * n, -l * r, 0, (1 - o) * n, -l * r, 0, (1 - o) * n, (1 - l) * r, 0, -o * n, (1 - l) * r, 0]
          , d = t.x / s
          , h = 1 - t.y / i
          , u = (t.x + t.z) / s
          , f = 1 - (t.y + t.w) / i
          , p = [d, h, u, h, u, f, d, f];
        return qi(this._device, c, {
            uvs: p,
            normals: NL,
            indices: UL
        })
    }
    _create9SliceMesh() {
        const e = P.ONE
          , t = 3
          , s = 3
          , i = []
          , n = []
          , r = []
          , o = [];
        let l = 0;
        for (let d = 0; d <= t; d++) {
            const h = d === 0 || d === t ? 0 : 1;
            for (let u = 0; u <= s; u++) {
                const f = -e.x + 2 * e.x * (d <= 1 ? 0 : 3) / t
                  , p = 0
                  , _ = -(-e.y + 2 * e.y * (u <= 1 ? 0 : 3) / s)
                  , m = u === 0 || u === s ? 0 : 1;
                i.push(-f, p, _),
                n.push(0, 1, 0),
                r.push(h, m),
                d < t && u < s && (o.push(l + s + 1, l + 1, l),
                o.push(l + s + 1, l + s + 2, l + 1)),
                l++
            }
        }
        const c = {
            normals: n,
            uvs: r,
            indices: o
        };
        return qi(this._device, i, c)
    }
    _onSetFrames(e) {
        this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes()
    }
    _onFrameChanged(e, t) {
        const s = this._frameKeys.indexOf(e);
        s < 0 || (t ? this.renderMode === gn && (this._meshes[s] = this._createSimpleMesh(t)) : this._meshes[s] = null,
        this.fire("set:meshes"))
    }
    _onFrameRemoved(e) {
        const t = this._frameKeys.indexOf(e);
        t < 0 || (this._meshes[t] = null,
        this.fire("set:meshes"))
    }
    startUpdate() {
        this._updatingProperties = !0,
        this._meshesDirty = !1
    }
    endUpdate() {
        this._updatingProperties = !1,
        this._meshesDirty && this._atlas && this._frameKeys && this._createMeshes(),
        this._meshesDirty = !1
    }
    destroy() {
        for (const e of this._meshes)
            e && e.destroy();
        this._meshes.length = 0
    }
}
class Ex extends fe {
    constructor() {
        super(),
        this._texture = null,
        this._frames = null
    }
    set texture(e) {
        this._texture = e,
        this.fire("set:texture", e)
    }
    get texture() {
        return this._texture
    }
    set frames(e) {
        this._frames = e,
        this.fire("set:frames", e)
    }
    get frames() {
        return this._frames
    }
    setFrame(e, t) {
        let s = this._frames[e];
        s ? (s.rect.copy(t.rect),
        s.pivot.copy(t.pivot),
        s.border.copy(t.border)) : (s = {
            rect: t.rect.clone(),
            pivot: t.pivot.clone(),
            border: t.border.clone()
        },
        this._frames[e] = s),
        this.fire("set:frame", e.toString(), s)
    }
    removeFrame(e) {
        const t = this._frames[e];
        t && (delete this._frames[e],
        this.fire("remove:frame", e.toString(), t))
    }
    destroy() {
        this._texture && this._texture.destroy()
    }
}
class B0 {
    constructor(e, t, s, i) {
        this.time = e,
        this.position = t,
        this.rotation = s,
        this.scale = i
    }
}
class k0 {
    constructor() {
        this._name = "",
        this._keys = []
    }
}
class N0 {
    constructor() {
        this.name = "",
        this.duration = 0,
        this._nodes = [],
        this._nodeDict = {}
    }
    getNode(e) {
        return this._nodeDict[e]
    }
    addNode(e) {
        this._nodes.push(e),
        this._nodeDict[e._name] = e
    }
    get nodes() {
        return this._nodes
    }
}
class zL {
    constructor() {
        this._written = !1,
        this._name = "",
        this._keyFrames = [],
        this._quat = new ne,
        this._pos = new y,
        this._scale = new y,
        this._targetNode = null
    }
    getTarget() {
        return this._targetNode
    }
    setTarget(e) {
        this._targetNode = e
    }
}
class wp {
    constructor(e) {
        this.looping = !0,
        this._animation = null,
        this._time = 0,
        this._interpolatedKeys = [],
        this._interpolatedKeyDict = {},
        this._currKeyIndices = {},
        this.graph = null;
        const t = s => {
            const i = new zL;
            i._name = s.name,
            this._interpolatedKeys.push(i),
            this._interpolatedKeyDict[s.name] = i,
            this._currKeyIndices[s.name] = 0;
            for (let n = 0; n < s._children.length; n++)
                t(s._children[n])
        }
        ;
        t(e)
    }
    set animation(e) {
        this._animation = e,
        this.currentTime = 0
    }
    get animation() {
        return this._animation
    }
    set currentTime(e) {
        this._time = e;
        const t = this._interpolatedKeys.length;
        for (let s = 0; s < t; s++) {
            const n = this._interpolatedKeys[s]._name;
            this._currKeyIndices[n] = 0
        }
        this.addTime(0),
        this.updateGraph()
    }
    get currentTime() {
        return this._time
    }
    get numNodes() {
        return this._interpolatedKeys.length
    }
    addTime(e) {
        if (this._animation !== null) {
            const t = this._animation._nodes
              , s = this._animation.duration;
            if (this._time === s && !this.looping)
                return;
            if (this._time += e,
            this._time > s) {
                this._time = this.looping ? 0 : s;
                for (let n = 0; n < t.length; n++) {
                    const o = t[n]._name;
                    this._currKeyIndices[o] = 0
                }
            } else if (this._time < 0) {
                this._time = this.looping ? s : 0;
                for (let n = 0; n < t.length; n++) {
                    const r = t[n]
                      , o = r._name;
                    this._currKeyIndices[o] = r._keys.length - 2
                }
            }
            const i = e >= 0 ? 1 : -1;
            for (let n = 0; n < t.length; n++) {
                const r = t[n]
                  , o = r._name
                  , l = r._keys
                  , c = this._interpolatedKeyDict[o];
                if (c === void 0)
                    continue;
                let d = !1;
                if (l.length !== 1)
                    for (let h = this._currKeyIndices[o]; h < l.length - 1 && h >= 0; h += i) {
                        const u = l[h]
                          , f = l[h + 1];
                        if (u.time <= this._time && f.time >= this._time) {
                            const p = (this._time - u.time) / (f.time - u.time);
                            c._pos.lerp(u.position, f.position, p),
                            c._quat.slerp(u.rotation, f.rotation, p),
                            c._scale.lerp(u.scale, f.scale, p),
                            c._written = !0,
                            this._currKeyIndices[o] = h,
                            d = !0;
                            break
                        }
                    }
                (l.length === 1 || !d && this._time === 0 && this.looping) && (c._pos.copy(l[0].position),
                c._quat.copy(l[0].rotation),
                c._scale.copy(l[0].scale),
                c._written = !0)
            }
        }
    }
    blend(e, t, s) {
        const i = this._interpolatedKeys.length;
        for (let n = 0; n < i; n++) {
            const r = e._interpolatedKeys[n]
              , o = t._interpolatedKeys[n]
              , l = this._interpolatedKeys[n];
            r._written && o._written ? (l._quat.slerp(r._quat, t._interpolatedKeys[n]._quat, s),
            l._pos.lerp(r._pos, t._interpolatedKeys[n]._pos, s),
            l._scale.lerp(r._scale, o._scale, s),
            l._written = !0) : r._written ? (l._quat.copy(r._quat),
            l._pos.copy(r._pos),
            l._scale.copy(r._scale),
            l._written = !0) : o._written && (l._quat.copy(o._quat),
            l._pos.copy(o._pos),
            l._scale.copy(o._scale),
            l._written = !0)
        }
    }
    setGraph(e) {
        if (this.graph = e,
        e)
            for (let t = 0; t < this._interpolatedKeys.length; t++) {
                const s = this._interpolatedKeys[t]
                  , i = e.findByName(s._name);
                this._interpolatedKeys[t].setTarget(i)
            }
        else
            for (let t = 0; t < this._interpolatedKeys.length; t++)
                this._interpolatedKeys[t].setTarget(null)
    }
    updateGraph() {
        if (this.graph)
            for (let e = 0; e < this._interpolatedKeys.length; e++) {
                const t = this._interpolatedKeys[e];
                if (t._written) {
                    const s = t.getTarget();
                    s.localPosition.copy(t._pos),
                    s.localRotation.copy(t._quat),
                    s.localScale.copy(t._scale),
                    s._dirtyLocal || s._dirtifyLocal(),
                    t._written = !1
                }
            }
    }
}
class VL {
    constructor(e, t) {
        this.processedCache = new Map,
        this.definitionsCache = new Map,
        this._generators = new Map,
        this._device = e,
        this._isClearingCache = !1,
        this._precached = !1,
        this._programsCollection = [],
        this._defaultStdMatOption = new ou,
        this._defaultStdMatOptionMin = new ou,
        t.shaderOptBuilder.updateRef(this._defaultStdMatOption, {}, t, null, [], pc, null),
        t.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, {}, t, null, ax, null),
        e.on("destroy:shader", s => {
            this.removeFromCache(s)
        }
        )
    }
    destroy() {
        this.clearCache()
    }
    register(e, t) {
        this._generators.has(e) || this._generators.set(e, t)
    }
    unregister(e) {
        this._generators.has(e) && this._generators.delete(e)
    }
    isRegistered(e) {
        return this._generators.has(e)
    }
    generateShaderDefinition(e, t, s, i) {
        let n = this.definitionsCache.get(s);
        if (!n) {
            var r, o, l;
            let c;
            (r = i.litOptions) != null && r.lights && (c = i.litOptions.lights,
            i.litOptions.lights = c.map(function(h) {
                const u = h.clone ? h.clone() : h;
                return u.key = h.key,
                u
            })),
            this.storeNewProgram(t, i),
            (o = i.litOptions) != null && o.lights && (i.litOptions.lights = c),
            this._precached;
            const d = this._device;
            n = e.createShaderDefinition(d, i),
            n.name = (l = n.name) != null ? l : i.pass ? `${t}-pass:${i.pass}` : t,
            this.definitionsCache.set(s, n)
        }
        return n
    }
    getCachedShader(e) {
        return this.processedCache.get(e)
    }
    setCachedShader(e, t) {
        this.processedCache.set(e, t)
    }
    getProgram(e, t, s, i) {
        const n = this._generators.get(e);
        if (!n)
            return null;
        const r = n.generateKey(t)
          , o = Sh(r)
          , l = s.generateKey(this._device)
          , c = Sh(l)
          , d = `${o}#${c}`;
        let h = this.getCachedShader(d);
        if (!h) {
            const u = this.generateShaderDefinition(n, e, o, t);
            let f = "", p;
            t.pass !== void 0 && (p = wi.get(this._device).getByIndex(t.pass),
            f = `-${p.name}`),
            this._device.fire("shader:generate", {
                userMaterialId: i,
                shaderPassInfo: p,
                definition: u
            });
            const _ = {
                name: `${u.name}${f}-proc`,
                attributes: u.attributes,
                vshader: u.vshader,
                fshader: u.fshader,
                processingOptions: s
            };
            h = new Xi(this._device,_),
            this.setCachedShader(d, h)
        }
        return h
    }
    storeNewProgram(e, t) {
        let s = {};
        if (e === "standard") {
            const i = this._getDefaultStdMatOptions(t.pass);
            for (const n in t)
                (t.hasOwnProperty(n) && i[n] !== t[n] || n === "pass") && (s[n] = t[n]);
            for (const n in t.litOptions)
                s[n] = t.litOptions[n]
        } else
            s = t;
        this._programsCollection.push(JSON.stringify({
            name: e,
            options: s
        }))
    }
    dumpPrograms() {
        let e = `let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;
`;
        e += "let shaders = [",
        this._programsCollection[0] && (e += `
	` + this._programsCollection[0]);
        for (let s = 1; s < this._programsCollection.length; ++s)
            e += `,
	` + this._programsCollection[s];
        e += `
];
`,
        e += `device.getProgramLibrary().precompile(shaders);
`,
        e += 'if (pc.version != "' + Mb + '" || pc.revision != "' + Pb + `")
`,
        e += '	console.warn("precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine");';
        const t = document.createElement("a");
        t.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(e)),
        t.setAttribute("download", "precompile-shaders.js"),
        t.style.display = "none",
        document.body.appendChild(t),
        t.click(),
        document.body.removeChild(t)
    }
    clearCache() {
        this._isClearingCache = !0,
        this.processedCache.forEach(e => {
            e.destroy()
        }
        ),
        this.processedCache.clear(),
        this._isClearingCache = !1
    }
    removeFromCache(e) {
        this._isClearingCache || this.processedCache.forEach( (t, s) => {
            e === t && this.processedCache.delete(s)
        }
        )
    }
    _getDefaultStdMatOptions(e) {
        const t = wi.get(this._device).getByIndex(e);
        return e === Vi || e === mc || t.isShadow ? this._defaultStdMatOptionMin : this._defaultStdMatOption
    }
    precompile(e) {
        if (e) {
            const t = new Array(e.length);
            for (let s = 0; s < e.length; s++) {
                if (e[s].name === "standard") {
                    const i = e[s].options
                      , n = this._getDefaultStdMatOptions(i.pass);
                    for (const r in n)
                        n.hasOwnProperty(r) && i[r] === void 0 && (i[r] = n[r])
                }
                t[s] = this.getProgram(e[s].name, e[s].options)
            }
        }
        this._precached = !0
    }
}
var GL = `
	vec4 dirLm = texture2D(texture_dirLightMap, vUv1);
	if (bakeDir > 0.5) {
		if (dAtten > 0.00001) {
			dirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);
			dAtten = saturate(dAtten);
			gl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);
			gl_FragColor.a = dirLm.w + dAtten;
			gl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);
		} else {
			gl_FragColor = dirLm;
		}
	} else {
		gl_FragColor.rgb = dirLm.xyz;
		gl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);
	}
`
  , HL = `
#ifdef LIGHTMAP_RGBM
	gl_FragColor.rgb = dDiffuseLight;
	gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));
	gl_FragColor.rgb /= 8.0;
	gl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );
	gl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;
	gl_FragColor.rgb /= gl_FragColor.a;
#else
	gl_FragColor = vec4(dDiffuseLight, 1.0);
#endif
`
  , WL = `
varying vec2 vUv0;
uniform sampler2D source;
uniform vec2 pixelOffset;
void main(void) {
	vec4 c = texture2DLodEXT(source, vUv0, 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 - pixelOffset, 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(0, -pixelOffset.y), 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y), 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(-pixelOffset.x, 0), 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(pixelOffset.x, 0), 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y), 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(0, pixelOffset.y), 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + pixelOffset, 0.0);
	gl_FragColor = c;
}
`
  , XL = `
float normpdf3(in vec3 v, in float sigma) {
	return 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;
}
vec3 decodeRGBM(vec4 rgbm) {
	vec3 color = (8.0 * rgbm.a) * rgbm.rgb;
	return color * color;
}
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
vec4 encodeRGBM(vec3 color) {
	vec4 encoded;
	encoded.rgb = pow(color.rgb, vec3(0.5));
	encoded.rgb *= 1.0 / 8.0;
	encoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );
	encoded.a = ceil(encoded.a * 255.0) / 255.0;
	encoded.rgb /= encoded.a;
	return encoded;
}
#define MSIZE 15
varying vec2 vUv0;
uniform sampler2D source;
uniform vec2 pixelOffset;
uniform vec2 sigmas;
uniform float bZnorm;
uniform float kernel[MSIZE];
void main(void) {
	
	vec4 pixelRgbm = texture2DLodEXT(source, vUv0, 0.0);
	if (pixelRgbm.a <= 0.0) {
		gl_FragColor = pixelRgbm;
		return ;
	}
	float sigma = sigmas.x;
	float bSigma = sigmas.y;
	vec3 pixelHdr = decodeRGBM(pixelRgbm);
	vec3 accumulatedHdr = vec3(0.0);
	float accumulatedFactor = 0.0;
	const int kSize = (MSIZE-1)/2;
	for (int i = -kSize; i <= kSize; ++i) {
		for (int j = -kSize; j <= kSize; ++j) {
			
			vec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;
			vec4 rgbm = texture2DLodEXT(source, coord, 0.0);
			if (rgbm.a > 0.0) {
				vec3 hdr = decodeRGBM(rgbm);
				float factor = kernel[kSize + j] * kernel[kSize + i];
				factor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;
				accumulatedHdr += factor * hdr;
				accumulatedFactor += factor;
			}
		}
	}
	gl_FragColor = encodeRGBM(accumulatedHdr / accumulatedFactor);
}
`;
const hu = {
    bakeDirLmEndPS: GL,
    bakeLmEndPS: HL,
    dilatePS: WL,
    bilateralDeNoisePS: XL
}
  , $n = new y
  , qn = new ee
  , ja = new ne
  , U0 = new ne
  , bp = new Pe
  , z0 = new Pe
  , et = [new y, new y, new y, new y, new y, new y, new y, new y]
  , jL = [et[0], et[1], et[1], et[3], et[3], et[2], et[2], et[0], et[4], et[5], et[5], et[7], et[7], et[6], et[6], et[4], et[0], et[4], et[1], et[5], et[2], et[6], et[3], et[7]]
  , $L = new z(1,1,0,.4)
  , V0 = (a, e) => {
    const t = e.x
      , s = e.y
      , i = e.z
      , n = Math.sqrt(e.rx * e.rx + e.ry * e.ry + e.rz * e.rz + e.rw * e.rw)
      , r = e.rx / n
      , o = e.ry / n
      , l = e.rz / n
      , c = e.rw / n;
    a.data.set([1 - 2 * (l * l + c * c), 2 * (o * l + r * c), 2 * (o * c - r * l), 0, 2 * (o * l - r * c), 1 - 2 * (o * o + c * c), 2 * (l * c + r * o), 0, 2 * (o * c + r * l), 2 * (l * c - r * o), 1 - 2 * (o * o + l * l), 0, t, s, i, 1])
}
;
class ah {
    constructor(e, t=!0) {
        this.elements = void 0,
        this.vertexElement = void 0,
        this.elements = e,
        this.vertexElement = e.find(s => s.name === "vertex"),
        !this.isCompressed && t && (qn.setScale(-1, -1, 1),
        this.transform(qn))
    }
    get numSplats() {
        return this.vertexElement.count
    }
    static calcSplatAabb(e, t) {
        V0(qn, t),
        bp.center.set(0, 0, 0),
        bp.halfExtents.set(t.sx * 2, t.sy * 2, t.sz * 2),
        e.setFromTransformedAabb(bp, qn)
    }
    transform(e) {
        const t = this.getProp("x")
          , s = this.getProp("y")
          , i = this.getProp("z")
          , n = this.getProp("rot_0")
          , r = this.getProp("rot_1")
          , o = this.getProp("rot_2")
          , l = this.getProp("rot_3");
        U0.setFromMat4(e);
        for (let c = 0; c < this.numSplats; ++c)
            $n.set(t[c], s[c], i[c]),
            e.transformPoint($n, $n),
            t[c] = $n.x,
            s[c] = $n.y,
            i[c] = $n.z,
            ja.set(r[c], o[c], l[c], n[c]).mul2(U0, ja),
            n[c] = ja.w,
            r[c] = ja.x,
            o[c] = ja.y,
            l[c] = ja.z
    }
    getProp(e) {
        var t;
        return (t = this.vertexElement.properties.find(s => s.name === e && s.storage)) == null ? void 0 : t.storage
    }
    addProp(e, t) {
        this.vertexElement.properties.push({
            type: "float",
            name: e,
            storage: t,
            byteSize: 4
        })
    }
    calcAabb(e, t) {
        const s = this.getProp("x")
          , i = this.getProp("y")
          , n = this.getProp("z")
          , r = this.getProp("rot_0")
          , o = this.getProp("rot_1")
          , l = this.getProp("rot_2")
          , c = this.getProp("rot_3")
          , d = this.getProp("scale_0")
          , h = this.getProp("scale_1")
          , u = this.getProp("scale_2")
          , f = {
            x: 0,
            y: 0,
            z: 0,
            rx: 0,
            ry: 0,
            rz: 0,
            rw: 0,
            sx: 0,
            sy: 0,
            sz: 0
        };
        let p = !0;
        for (let _ = 0; _ < this.numSplats; ++_)
            t && !t(_) || (f.x = s[_],
            f.y = i[_],
            f.z = n[_],
            f.rx = r[_],
            f.ry = o[_],
            f.rz = l[_],
            f.rw = c[_],
            f.sx = Math.exp(d[_]),
            f.sy = Math.exp(h[_]),
            f.sz = Math.exp(u[_]),
            p ? (p = !1,
            ah.calcSplatAabb(e, f)) : (ah.calcSplatAabb(z0, f),
            e.add(z0)));
        return !p
    }
    calcFocalPoint(e, t) {
        const s = this.getProp("x")
          , i = this.getProp("y")
          , n = this.getProp("z")
          , r = this.getProp("scale_0")
          , o = this.getProp("scale_1")
          , l = this.getProp("scale_2");
        e.x = 0,
        e.y = 0,
        e.z = 0;
        let c = 0;
        for (let d = 0; d < this.numSplats; ++d) {
            if (t && !t(d))
                continue;
            const h = 1 / (1 + Math.exp(Math.max(r[d], o[d], l[d])));
            e.x += s[d] * h,
            e.y += i[d] * h,
            e.z += n[d] * h,
            c += h
        }
        e.mulScalar(1 / c)
    }
    renderWireframeBounds(e, t) {
        const s = this.getProp("x")
          , i = this.getProp("y")
          , n = this.getProp("z")
          , r = this.getProp("rot_0")
          , o = this.getProp("rot_1")
          , l = this.getProp("rot_2")
          , c = this.getProp("rot_3")
          , d = this.getProp("scale_0")
          , h = this.getProp("scale_1")
          , u = this.getProp("scale_2")
          , f = {
            x: 0,
            y: 0,
            z: 0,
            rx: 0,
            ry: 0,
            rz: 0,
            rw: 0,
            sx: 0,
            sy: 0,
            sz: 0
        };
        for (let p = 0; p < this.numSplats; ++p) {
            f.x = s[p],
            f.y = i[p],
            f.z = n[p],
            f.rx = r[p],
            f.ry = o[p],
            f.rz = l[p],
            f.rw = c[p],
            f.sx = Math.exp(d[p]),
            f.sy = Math.exp(h[p]),
            f.sz = Math.exp(u[p]),
            V0(qn, f),
            qn.mul2(t, qn);
            for (let _ = 0; _ < 8; ++_)
                $n.set(f.sx * 2 * (_ & 1 ? 1 : -1), f.sy * 2 * (_ & 2 ? 1 : -1), f.sz * 2 * (_ & 4 ? 1 : -1)),
                qn.transformPoint($n, et[_]);
            e.drawLineArrays(jL, $L)
        }
    }
    get isCompressed() {
        return this.elements.some(e => e.name === "chunk") && ["packed_position", "packed_rotation", "packed_scale", "packed_color"].every(e => this.getProp(e))
    }
    decompress() {
        const e = ["x", "y", "z", "f_dc_0", "f_dc_1", "f_dc_2", "opacity", "rot_0", "rot_1", "rot_2", "rot_3", "scale_0", "scale_1", "scale_2"]
          , t = this.elements.find(O => O.name === "chunk")
          , s = this.vertexElement
          , i = {};
        e.forEach(O => {
            i[O] = new Float32Array(s.count)
        }
        );
        const n = O => {
            var D;
            return (D = t.properties.find(A => A.name === O && A.storage)) == null ? void 0 : D.storage
        }
          , r = n("min_x")
          , o = n("min_y")
          , l = n("min_z")
          , c = n("max_x")
          , d = n("max_y")
          , h = n("max_z")
          , u = n("min_scale_x")
          , f = n("min_scale_y")
          , p = n("min_scale_z")
          , _ = n("max_scale_x")
          , m = n("max_scale_y")
          , g = n("max_scale_z")
          , v = this.getProp("packed_position")
          , x = this.getProp("packed_rotation")
          , S = this.getProp("packed_scale")
          , w = this.getProp("packed_color")
          , T = (O, D) => {
            const A = (1 << D) - 1;
            return (O & A) / A
        }
          , b = (O, D) => {
            O.x = T(D >>> 21, 11),
            O.y = T(D >>> 11, 10),
            O.z = T(D, 11)
        }
          , E = (O, D) => {
            O.x = T(D >>> 24, 8),
            O.y = T(D >>> 16, 8),
            O.z = T(D >>> 8, 8),
            O.w = T(D, 8)
        }
          , C = (O, D) => {
            const A = 1 / (Math.sqrt(2) * .5)
              , k = (T(D >>> 20, 10) - .5) * A
              , N = (T(D >>> 10, 10) - .5) * A
              , H = (T(D, 10) - .5) * A
              , K = Math.sqrt(1 - (k * k + N * N + H * H));
            switch (D >>> 30) {
            case 0:
                O.set(K, k, N, H);
                break;
            case 1:
                O.set(k, K, N, H);
                break;
            case 2:
                O.set(k, N, K, H);
                break;
            case 3:
                O.set(k, N, H, K);
                break
            }
        }
          , R = (O, D, A) => O * (1 - A) + D * A
          , F = new y
          , L = new ne
          , U = new y
          , I = new M;
        for (let O = 0; O < s.count; ++O) {
            const D = Math.floor(O / 256);
            b(F, v[O]),
            C(L, x[O]),
            b(U, S[O]),
            E(I, w[O]),
            i.x[O] = R(r[D], c[D], F.x),
            i.y[O] = R(o[D], d[D], F.y),
            i.z[O] = R(l[D], h[D], F.z),
            i.rot_0[O] = L.x,
            i.rot_1[O] = L.y,
            i.rot_2[O] = L.z,
            i.rot_3[O] = L.w,
            i.scale_0[O] = R(u[D], _[D], U.x),
            i.scale_1[O] = R(f[D], m[D], U.y),
            i.scale_2[O] = R(p[D], g[D], U.z);
            const A = .28209479177387814;
            i.f_dc_0[O] = (I.x - .5) / A,
            i.f_dc_1[O] = (I.y - .5) / A,
            i.f_dc_2[O] = (I.z - .5) / A,
            i.opacity[O] = -Math.log(1 / I.w - 1)
        }
        return new ah([{
            name: "vertex",
            count: s.count,
            properties: e.map(O => ({
                name: O,
                type: "float",
                byteSize: 4,
                storage: i[O]
            }))
        }],!1)
    }
}
class qL {
    constructor(e, t, s) {
        this.device = void 0,
        this.numSplats = void 0,
        this.vertexFormat = void 0,
        this.format = void 0,
        this.colorTexture = void 0,
        this.scaleTexture = void 0,
        this.rotationTexture = void 0,
        this.centerTexture = void 0,
        this.centers = void 0,
        this.aabb = void 0,
        this.device = e,
        this.numSplats = t,
        this.aabb = s,
        this.vertexFormat = new fs(e,[{
            semantic: ea,
            components: 1,
            type: e.isWebGL1 ? Me : il,
            asInt: !e.isWebGL1
        }]);
        const i = this.evalTextureSize(t);
        this.format = this.getTextureFormat(e, !1),
        this.colorTexture = this.createTexture(e, "splatColor", ve, i),
        this.scaleTexture = this.createTexture(e, "splatScale", this.format.format, i),
        this.rotationTexture = this.createTexture(e, "splatRotation", this.format.format, i),
        this.centerTexture = this.createTexture(e, "splatCenter", this.format.format, i)
    }
    destroy() {
        this.colorTexture.destroy(),
        this.scaleTexture.destroy(),
        this.rotationTexture.destroy(),
        this.centerTexture.destroy()
    }
    setupMaterial(e) {
        e.setParameter("splatColor", this.colorTexture),
        e.setParameter("splatScale", this.scaleTexture),
        e.setParameter("splatRotation", this.rotationTexture),
        e.setParameter("splatCenter", this.centerTexture);
        const {width: t, height: s} = this.colorTexture;
        e.setParameter("tex_params", new Float32Array([t, s, 1 / t, 1 / s]))
    }
    evalTextureSize(e) {
        const t = Math.ceil(Math.sqrt(e))
          , s = Math.ceil(e / t);
        return new P(t,s)
    }
    createTexture(e, t, s, i) {
        return new ge(e,{
            name: t,
            width: i.x,
            height: i.y,
            format: s,
            cubemap: !1,
            mipmaps: !1,
            minFilter: be,
            magFilter: be,
            addressU: oe,
            addressV: oe
        })
    }
    getTextureFormat(e, t) {
        const s = e.extTextureHalfFloat && e.textureHalfFloatUpdatable ? Tt : void 0
          , i = s ? {
            format: s,
            numComponents: 4,
            isHalf: !0
        } : void 0
          , n = e.isWebGPU ? lt : e.extTextureFloat ? Ta : void 0
          , r = n ? {
            format: n,
            numComponents: n === lt ? 4 : 3,
            isHalf: !1
        } : void 0;
        return t ? r ?? i : i ?? r
    }
    updateColorData(e, t, s, i) {
        const n = .28209479177387814
          , r = this.colorTexture
          , o = r.lock()
          , l = c => {
            if (c > 0)
                return 1 / (1 + Math.exp(-c));
            const d = Math.exp(c);
            return d / (1 + d)
        }
        ;
        for (let c = 0; c < this.numSplats; ++c)
            e && t && s && (o[c * 4 + 0] = W.clamp((.5 + n * e[c]) * 255, 0, 255),
            o[c * 4 + 1] = W.clamp((.5 + n * t[c]) * 255, 0, 255),
            o[c * 4 + 2] = W.clamp((.5 + n * s[c]) * 255, 0, 255)),
            o[c * 4 + 3] = i ? W.clamp(l(i[c]) * 255, 0, 255) : 255;
        r.unlock()
    }
    updateScaleData(e, t, s) {
        const {numComponents: i, isHalf: n} = this.format
          , r = this.scaleTexture
          , o = r.lock()
          , l = Ge.float2Half;
        for (let c = 0; c < this.numSplats; c++) {
            const d = Math.exp(e[c])
              , h = Math.exp(t[c])
              , u = Math.exp(s[c]);
            n ? (o[c * i + 0] = l(d),
            o[c * i + 1] = l(h),
            o[c * i + 2] = l(u)) : (o[c * i + 0] = d,
            o[c * i + 1] = h,
            o[c * i + 2] = u)
        }
        r.unlock()
    }
    updateRotationData(e, t, s, i) {
        const {numComponents: n, isHalf: r} = this.format
          , o = new ne
          , l = this.rotationTexture
          , c = l.lock()
          , d = Ge.float2Half;
        for (let h = 0; h < this.numSplats; h++)
            o.set(e[h], t[h], s[h], i[h]).normalize(),
            o.w < 0 && o.conjugate(),
            r ? (c[h * n + 0] = d(o.x),
            c[h * n + 1] = d(o.y),
            c[h * n + 2] = d(o.z)) : (c[h * n + 0] = o.x,
            c[h * n + 1] = o.y,
            c[h * n + 2] = o.z);
        l.unlock()
    }
    updateCenterData(e, t, s) {
        const {numComponents: i, isHalf: n} = this.format
          , r = this.centerTexture
          , o = r.lock()
          , l = Ge.float2Half;
        for (let c = 0; c < this.numSplats; c++)
            n ? (o[c * i + 0] = l(e[c]),
            o[c * i + 1] = l(t[c]),
            o[c * i + 2] = l(s[c])) : (o[c * i + 0] = e[c],
            o[c * i + 1] = t[c],
            o[c * i + 2] = s[c]);
        r.unlock()
    }
}
const YL = `
		attribute vec3 vertex_position;

		uniform mat4 matrix_model;
		uniform mat4 matrix_view;
		uniform mat4 matrix_projection;
		uniform mat4 matrix_viewProjection;

		uniform vec2 viewport;

		varying vec2 texCoord;
		varying vec4 color;
		varying float id;

		mat3 quatToMat3(vec3 R)
		{
				float x = R.x;
				float y = R.y;
				float z = R.z;
				float w = sqrt(1.0 - dot(R, R));

				return mat3(
						1.0 - 2.0 * (z * z + w * w),
								2.0 * (y * z + x * w),
								2.0 * (y * w - x * z),

								2.0 * (y * z - x * w),
						1.0 - 2.0 * (y * y + w * w),
								2.0 * (z * w + x * y),

								2.0 * (y * w + x * z),
								2.0 * (z * w - x * y),
						1.0 - 2.0 * (y * y + z * z)
				);
		}

		uniform vec4 tex_params;
		uniform sampler2D splatColor;
		uniform highp sampler2D splatScale;
		uniform highp sampler2D splatRotation;
		uniform highp sampler2D splatCenter;

		#ifdef INT_INDICES

				attribute uint vertex_id;
				ivec2 dataUV;
				void evalDataUV() {

						// turn vertex_id into int grid coordinates
						ivec2 textureSize = ivec2(tex_params.xy);
						vec2 invTextureSize = tex_params.zw;

						int gridV = int(float(vertex_id) * invTextureSize.x);
						int gridU = int(vertex_id) - gridV * textureSize.x;
						dataUV = ivec2(gridU, gridV);
				}

				vec4 getColor() {
						return texelFetch(splatColor, dataUV, 0);
				}

				vec3 getScale() {
						return texelFetch(splatScale, dataUV, 0).xyz;
				}

				vec3 getRotation() {
						return texelFetch(splatRotation, dataUV, 0).xyz;
				}

				vec3 getCenter() {
						return texelFetch(splatCenter, dataUV, 0).xyz;
				}

		#else

				// TODO: use texture2DLodEXT on WebGL

				attribute float vertex_id;
				vec2 dataUV;
				void evalDataUV() {
						vec2 textureSize = tex_params.xy;
						vec2 invTextureSize = tex_params.zw;

						// turn vertex_id into int grid coordinates
						float gridV = floor(vertex_id * invTextureSize.x);
						float gridU = vertex_id - (gridV * textureSize.x);

						// convert grid coordinates to uv coordinates with half pixel offset
						dataUV = vec2(gridU, gridV) * invTextureSize + (0.5 * invTextureSize);
				}

				vec4 getColor() {
						return texture2D(splatColor, dataUV);
				}

				vec3 getScale() {
						return texture2D(splatScale, dataUV).xyz;
				}

				vec3 getRotation() {
						return texture2D(splatRotation, dataUV).xyz;
				}

				vec3 getCenter() {
						return texture2D(splatCenter, dataUV).xyz;
				}

		#endif

		void computeCov3d(in mat3 rot, in vec3 scale, out vec3 covA, out vec3 covB)
		{
				// M = S * R
				float M0 = scale.x * rot[0][0];
				float M1 = scale.x * rot[0][1];
				float M2 = scale.x * rot[0][2];
				float M3 = scale.y * rot[1][0];
				float M4 = scale.y * rot[1][1];
				float M5 = scale.y * rot[1][2];
				float M6 = scale.z * rot[2][0];
				float M7 = scale.z * rot[2][1];
				float M8 = scale.z * rot[2][2];

				covA = vec3(
						M0 * M0 + M3 * M3 + M6 * M6,
						M0 * M1 + M3 * M4 + M6 * M7,
						M0 * M2 + M3 * M5 + M6 * M8
				);

				covB = vec3(
						M1 * M1 + M4 * M4 + M7 * M7,
						M1 * M2 + M4 * M5 + M7 * M8,
						M2 * M2 + M5 * M5 + M8 * M8
				);
		}

		vec3 evalCenter() {
				evalDataUV();
				return getCenter();
		}

		#ifndef GL2
		#ifndef WEBGPU
		mat3 transpose(in mat3 m) {
				return mat3(
						m[0].x, m[1].x, m[2].x,
						m[0].y, m[1].y, m[2].y,
						m[0].z, m[1].z, m[2].z
				);
		}
		#endif
		#endif

		vec4 evalSplat(vec4 centerWorld)
		{
				vec4 splat_cam = matrix_view * centerWorld;
				vec4 splat_proj = matrix_projection * splat_cam;

				// cull behind camera
				if (splat_proj.z < -splat_proj.w) {
						return vec4(0.0, 0.0, 2.0, 1.0);
				}

				vec3 scale = getScale();
				vec3 rotation = getRotation();

				color = getColor();

				#ifdef DEBUG_RENDER
						vec3 local = quatToMat3(rotation) * (vertex_position * scale * 2.0) + center;
						return matrix_viewProjection * matrix_model * vec4(local, 1.0);
				#else
						vec3 splat_cova;
						vec3 splat_covb;
						computeCov3d(mat3(matrix_model) * quatToMat3(rotation), scale, splat_cova, splat_covb);

						mat3 Vrk = mat3(
								splat_cova.x, splat_cova.y, splat_cova.z, 
								splat_cova.y, splat_covb.x, splat_covb.y,
								splat_cova.z, splat_covb.y, splat_covb.z
						);

						float focal = viewport.x * matrix_projection[0][0];

						mat3 J = mat3(
								focal / splat_cam.z, 0., -(focal * splat_cam.x) / (splat_cam.z * splat_cam.z), 
								0., focal / splat_cam.z, -(focal * splat_cam.y) / (splat_cam.z * splat_cam.z), 
								0., 0., 0.
						);

						mat3 W = transpose(mat3(matrix_view));
						mat3 T = W * J;
						mat3 cov = transpose(T) * Vrk * T;

						float diagonal1 = cov[0][0] + 0.3;
						float offDiagonal = cov[0][1];
						float diagonal2 = cov[1][1] + 0.3;

						float mid = 0.5 * (diagonal1 + diagonal2);
						float radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));
						float lambda1 = mid + radius;
						float lambda2 = max(mid - radius, 0.1);
						vec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));
						vec2 v1 = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;
						vec2 v2 = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);

						// early out tiny splats
						// TODO: figure out length units and expose as uniform parameter
						// TODO: perhaps make this a shader compile-time option
						if (dot(v1, v1) < 4.0 && dot(v2, v2) < 4.0) {
								return vec4(0.0, 0.0, 2.0, 1.0);
						}

						texCoord = vertex_position.xy * 2.0;

						return splat_proj +
								vec4((vertex_position.x * v1 + vertex_position.y * v2) / viewport * 2.0,
										0.0, 0.0) * splat_proj.w;
				#endif

				id = float(vertex_id);
		}
`
  , KL = `
		varying vec2 texCoord;
		varying vec4 color;
		varying float id;

		#ifdef PICK_PASS
				uniform vec4 uColor;
		#endif

		vec4 evalSplat() {

				#ifdef DEBUG_RENDER

						if (color.a < 0.2) discard;
						return color;

				#else

						float A = -dot(texCoord, texCoord);
						if (A < -4.0) discard;
						float B = exp(A) * color.a;

						#ifdef PICK_PASS
								if (B < 0.3) discard;
								return(uColor);
						#endif

						#ifndef DITHER_NONE
								opacityDither(B, id * 0.013);
						#endif

						// the color here is in gamma space, so bring it to linear
						vec3 diffuse = decodeGamma(color.rgb);

						// apply tone-mapping and gamma correction as needed
						diffuse = toneMap(diffuse);
						diffuse = gammaCorrectOutput(diffuse);

						return vec4(diffuse, B);

				#endif
		}
`;
class ZL {
    generateKey(e) {
        const t = Sh(e.vertex)
          , s = Sh(e.fragment);
        return `splat-${e.pass}-${e.gamma}-${e.toneMapping}-${t}-${s}-${e.debugRender}-${e.dither}}`
    }
    createShaderDefinition(e, t) {
        const n = wi.get(e).getByIndex(t.pass).shaderDefines + (t.debugRender ? `#define DEBUG_RENDER
` : "") + (e.isWebGL1 ? "" : `#define INT_INDICES
`) + `#define DITHER_${t.dither.toUpperCase()}
`
          , r = n + YL + t.vertex
          , o = n + $.decodePS + (t.dither === cs ? "" : $.bayerPS + $.opacityDitherPS) + Ue.tonemapCode(t.toneMapping) + Ue.gammaCode(t.gamma) + KL + t.fragment;
        return Pt.createDefinition(e, {
            name: "SplatShader",
            attributes: {
                vertex_position: ut,
                vertex_id: ea
            },
            vertexCode: r,
            fragmentCode: o
        })
    }
}
const QL = new ZL
  , JL = `
		void main(void)
		{
				vec3 centerLocal = evalCenter();
				vec4 centerWorld = matrix_model * vec4(centerLocal, 1.0);

				gl_Position = evalSplat(centerWorld);
		}
`
  , eD = `
		void main(void)
		{
				gl_FragColor = evalSplat();
		}
`
  , tD = (a={}) => {
    var e;
    const {debugRender: t} = a
      , s = (e = a.dither) != null ? e : cs
      , i = s !== cs
      , n = new Yi;
    return n.name = "splatMaterial",
    n.cull = t ? dr : bt,
    n.blendType = i ? ls : ps,
    n.depthWrite = i,
    n.getShaderVariant = function(r, o, l, c, d, h, u, f) {
        var p, _;
        const m = {
            pass: d,
            gamma: d === $i ? o.gammaCorrection ? uc : dc : o.gammaCorrection,
            toneMapping: d === $i ? fc : o.toneMapping,
            vertex: (p = a.vertex) != null ? p : JL,
            fragment: (_ = a.fragment) != null ? _ : eD,
            debugRender: t,
            dither: s
        }
          , g = new Aa(u,f)
          , v = Cr(r);
        return v.register("splat", QL),
        v.getProgram("splat", m, g)
    }
    ,
    n.update(),
    n
}
;
function sD() {
    let t, s, i, n, r;
    const o = {
        x: 0,
        y: 0,
        z: 0
    }
      , l = {
        x: 0,
        y: 0,
        z: 0
    }
      , c = {
        x: 0,
        y: 0,
        z: 0
    }
      , d = {
        x: 0,
        y: 0,
        z: 0
    };
    let h, u, f, p;
    const _ = () => {
        var m;
        if (!s || !t || !i || !n)
            return;
        const g = i.x
          , v = i.y
          , x = i.z
          , S = n.x
          , w = n.y
          , T = n.z
          , b = .001;
        if (Math.abs(g - o.x) < b && Math.abs(v - o.y) < b && Math.abs(x - o.z) < b && Math.abs(S - l.x) < b && Math.abs(w - l.y) < b && Math.abs(T - l.z) < b)
            return;
        o.x = g,
        o.y = v,
        o.z = x,
        l.x = S,
        l.y = w,
        l.z = T;
        const E = s.length / 3;
        ((m = h) == null ? void 0 : m.length) !== E && (h = new Uint32Array(E),
        u = new Uint32Array(E),
        f = new Float32Array(E));
        let C, R;
        for (let D = 0; D < 8; ++D) {
            const A = D & 1 ? c.x : d.x
              , k = D & 2 ? c.y : d.y
              , N = D & 4 ? c.z : d.z
              , H = (A - g) * S + (k - v) * w + (N - x) * T;
            D === 0 ? C = R = H : (C = Math.min(C, H),
            R = Math.max(R, H))
        }
        p || (p = new Uint32Array(65537));
        for (let D = 0; D < 65537; D++)
            p[D] = 0;
        const L = 1 / (R - C) * 2 ** 16;
        for (let D = 0; D < E; ++D) {
            const A = D * 3
              , k = (s[A + 0] - g) * S + (s[A + 1] - v) * w + (s[A + 2] - x) * T
              , N = Math.floor((k - C) * L);
            h[D] = N,
            u[D] = D,
            p[N]++
        }
        for (let D = 1; D < 65537; D++)
            p[D] += p[D - 1];
        const U = r ? new Uint32Array(f.buffer) : f
          , I = r ? 0 : .2;
        for (let D = E - 1; D >= 0; D--) {
            const A = h[D]
              , k = u[D];
            U[p[A] - 1] = k + I,
            p[A]--
        }
        const O = t;
        t = f,
        f = O,
        self.postMessage({
            data: t.buffer
        }, [t.buffer]),
        t = null
    }
    ;
    self.onmessage = m => {
        if (m.data.data && (t = new Float32Array(m.data.data)),
        m.data.centers) {
            s = new Float32Array(m.data.centers),
            c.x = d.x = s[0],
            c.y = d.y = s[1],
            c.z = d.z = s[2];
            const g = s.length / 3;
            for (let v = 1; v < g; ++v) {
                const x = s[v * 3 + 0]
                  , S = s[v * 3 + 1]
                  , w = s[v * 3 + 2];
                c.x = Math.min(c.x, x),
                c.y = Math.min(c.y, S),
                c.z = Math.min(c.z, w),
                d.x = Math.max(d.x, x),
                d.y = Math.max(d.y, S),
                d.z = Math.max(d.z, w)
            }
        }
        m.data.intIndices && (r = m.data.intIndices),
        m.data.cameraPosition && (i = m.data.cameraPosition),
        m.data.cameraDirection && (n = m.data.cameraDirection),
        _()
    }
}
class iD extends fe {
    constructor() {
        super(),
        this.worker = void 0,
        this.vertexBuffer = void 0,
        this.worker = new Worker(URL.createObjectURL(new Blob([`(${sD.toString()})()`],{
            type: "application/javascript"
        }))),
        this.worker.onmessage = e => {
            const t = e.data.data
              , s = this.vertexBuffer.storage;
            this.worker.postMessage({
                data: s
            }, [s]),
            setTimeout( () => {
                this.vertexBuffer.setData(t),
                this.fire("updated")
            }
            )
        }
    }
    destroy() {
        this.worker.terminate(),
        this.worker = null
    }
    init(e, t, s) {
        this.vertexBuffer = e;
        const i = e.storage.slice(0);
        this.worker.postMessage({
            data: i,
            centers: t.buffer,
            intIndices: s
        }, [i, t.buffer])
    }
    setCamera(e, t) {
        this.worker.postMessage({
            cameraPosition: {
                x: e.x,
                y: e.y,
                z: e.z
            },
            cameraDirection: {
                x: t.x,
                y: t.y,
                z: t.z
            }
        })
    }
}
const nD = new ee
  , $a = new y
  , qa = new y
  , Tp = [0, 0];
class dg {
    constructor(e, t) {
        this.splat = void 0,
        this.mesh = void 0,
        this.meshInstance = void 0,
        this.material = void 0,
        this.vb = void 0,
        this.options = {},
        this.sorter = null,
        this.lastCameraPosition = new y,
        this.lastCameraDirection = new y,
        this.cameras = [],
        this.splat = e,
        t = Object.assign(this.options, t);
        const s = t.debugRender;
        this.createMaterial(t);
        const i = e.device;
        s ? this.mesh = au(i, {
            halfExtents: new y(1,1,1)
        }) : (this.mesh = new ms(i),
        this.mesh.setPositions(new Float32Array([-1, -1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1]), 2),
        this.mesh.update()),
        this.mesh.aabb.copy(e.aabb);
        const n = e.numSplats;
        let r;
        if (i.isWebGL1) {
            r = new Float32Array(n);
            for (let l = 0; l < n; ++l)
                r[l] = l + .2
        } else {
            r = new Uint32Array(n);
            for (let l = 0; l < n; ++l)
                r[l] = l
        }
        const o = new xi(i,e.vertexFormat,n,Do,r.buffer);
        this.vb = o,
        this.meshInstance = new Fe(this.mesh,this.material),
        this.meshInstance.setInstancing(o, !0),
        this.meshInstance.gsplatInstance = this,
        this.centers = new Float32Array(e.centers),
        (!t.dither || t.dither === cs) && (this.sorter = new iD,
        this.sorter.init(this.vb, this.centers, !this.splat.device.isWebGL1))
    }
    destroy() {
        var e;
        this.material.destroy(),
        this.vb.destroy(),
        this.meshInstance.destroy(),
        (e = this.sorter) == null || e.destroy()
    }
    clone() {
        return new dg(this.splat,this.options)
    }
    createMaterial(e) {
        this.material = tD(e),
        this.splat.setupMaterial(this.material),
        this.meshInstance && (this.meshInstance.material = this.material)
    }
    updateViewport() {
        const e = this.splat.device;
        Tp[0] = e.width,
        Tp[1] = e.height,
        this.material.setParameter("viewport", Tp)
    }
    sort(e) {
        if (this.sorter) {
            const t = e.getWorldTransform();
            t.getTranslation($a),
            t.getZ(qa);
            const s = this.meshInstance.node.getWorldTransform()
              , i = nD.invert(s);
            i.transformPoint($a, $a),
            i.transformVector(qa, qa),
            (!$a.equalsApprox(this.lastCameraPosition) || !qa.equalsApprox(this.lastCameraDirection)) && (this.lastCameraPosition.copy($a),
            this.lastCameraDirection.copy(qa),
            this.sorter.setCamera($a, qa))
        }
        this.updateViewport()
    }
    update() {
        if (this.cameras.length > 0) {
            const e = this.cameras[0];
            this.sort(e._node),
            this.cameras.length = 0
        }
    }
}
const rD = "NONE"
  , aD = "FILL_WINDOW"
  , G0 = "KEEP_ASPECT"
  , Om = "AUTO"
  , oD = "FIXED";
let Ax;
function Tn() {
    return Ax
}
function Fm(a) {
    Ax = a
}
class Ws {
    static push(e, t) {
        t && Ws._types.length > 0 ? console.assert("Script Ordering Error. Contact support@playcanvas.com") : Ws._types.push(e)
    }
}
Ws._types = [];
let cu = !1
  , H0 = !1;
const Xt = {
    app: null,
    create(a, e) {
        if (!cu)
            return;
        const t = e(Xt.app);
        t._pcScriptName = a,
        Ws.push(t, cu),
        this.fire("created", a, e)
    },
    attribute(a, e, t, s) {},
    createLoadingScreen(a) {
        if (H0)
            return;
        H0 = !0;
        const e = Tn();
        a(e)
    }
};
Object.defineProperty(Xt, "legacy", {
    get: function() {
        return cu
    },
    set: function(a) {
        cu = a
    }
});
y_.attach(Xt);
class lD {
    constructor() {
        this.renderPasses = [],
        this.renderTargetMap = new Map
    }
    addRenderPass(e) {
        e.frameUpdate();
        const t = e.beforePasses;
        for (let i = 0; i < t.length; i++) {
            const n = t[i];
            n.enabled && this.addRenderPass(n)
        }
        e.enabled && this.renderPasses.push(e);
        const s = e.afterPasses;
        for (let i = 0; i < s.length; i++) {
            const n = s[i];
            n.enabled && this.addRenderPass(n)
        }
    }
    reset() {
        this.renderPasses.length = 0
    }
    compile() {
        const e = this.renderTargetMap
          , t = this.renderPasses;
        for (let n = 0; n < t.length; n++) {
            const r = t[n]
              , o = r.renderTarget;
            if (o !== void 0) {
                const l = e.get(o);
                if (l) {
                    const c = r.colorArrayOps.length;
                    for (let d = 0; d < c; d++)
                        r.colorArrayOps[d].clear || (l.colorArrayOps[d].store = !0);
                    r.depthStencilOps.clearDepth || (l.depthStencilOps.storeDepth = !0),
                    r.depthStencilOps.clearStencil || (l.depthStencilOps.storeStencil = !0)
                }
                e.set(o, r)
            }
        }
        let s = null
          , i = null;
        for (let n = 0; n < t.length; n++) {
            const r = t[n]
              , o = r.renderTarget
              , l = o == null ? void 0 : o.colorBuffer;
            if (l != null && l.cubemap) {
                if (s === l) {
                    const c = i.colorArrayOps.length;
                    for (let d = 0; d < c; d++)
                        i.colorArrayOps[d].mipmaps = !1
                }
                s = o.colorBuffer,
                i = r
            } else
                r.requiresCubemaps && (s = null,
                i = null)
        }
        e.clear()
    }
    render(e) {
        this.compile();
        const t = this.renderPasses;
        for (let s = 0; s < t.length; s++)
            t[s].render()
    }
}
class hD {
    constructor(e, t) {
        this.texture0 = e,
        this.texture1 = t
    }
    destroy() {
        var e, t;
        (e = this.texture0) == null || e.destroy(),
        (t = this.texture1) == null || t.destroy()
    }
}
const W0 = new Os;
class qr {
    static createTexture(e, t, s, i="") {
        return new ge(e,{
            name: `AreaLightLUT${i}`,
            width: s,
            height: s,
            format: t,
            addressU: oe,
            addressV: oe,
            type: $s,
            magFilter: ot,
            minFilter: be,
            anisotropy: 1,
            mipmaps: !1
        })
    }
    static applyTextures(e, t, s) {
        W0.remove(e),
        W0.get(e, () => new hD(t,t === s ? null : s)),
        e.scope.resolve("areaLightsLutTex1").setValue(t),
        e.scope.resolve("areaLightsLutTex2").setValue(s)
    }
    static createPlaceholder(e) {
        const t = qr.createTexture(e, e.areaLightLutFormat, 2, "placeholder");
        t.lock().fill(0),
        t.unlock(),
        qr.applyTextures(e, t, t)
    }
    static set(e, t, s) {
        function i(_, m, g) {
            const v = qr.createTexture(_, g, 64);
            return v.lock().set(m),
            v.unlock(),
            v
        }
        function n(_, m, g) {
            const v = _.length
              , x = new Float32Array(v);
            for (let S = 0; S < v; S++) {
                const w = S % 4;
                x[S] = (_[S] + m[w]) * g[w]
            }
            return x
        }
        function r(_) {
            const m = _.length
              , g = new Uint16Array(m)
              , v = Ge.float2Half;
            for (let x = 0; x < m; x++)
                g[x] = v(_[x]);
            return g
        }
        function o(_) {
            const m = _.length
              , g = new Uint8ClampedArray(m);
            for (let v = 0; v < m; v++)
                g[v] = _[v] * 255;
            return g
        }
        const l = t
          , c = s;
        let d, h;
        const u = e.areaLightLutFormat;
        if (u === lt)
            d = l,
            h = c;
        else if (u === Tt)
            d = r(l),
            h = r(c);
        else {
            const _ = [0, .2976, .01381, 0]
              , m = [.999, 3.08737, 1.6546, .603249]
              , g = [-.306897, 0, 0, 0]
              , v = [1.442787, 1, 1, 1];
            d = o(n(l, _, m)),
            h = o(n(c, g, v))
        }
        const f = i(e, d, u)
          , p = i(e, h, u);
        qr.applyTextures(e, f, p)
    }
}
const du = "en-US"
  , uu = {
    en: "en-US",
    es: "en-ES",
    zh: "zh-CN",
    "zh-HK": "zh-TW",
    "zh-TW": "zh-HK",
    "zh-MO": "zh-HK",
    fr: "fr-FR",
    de: "de-DE",
    it: "it-IT",
    ru: "ru-RU",
    ja: "ja-JP"
}
  , ug = {};
function Er(a, e) {
    for (let t = 0, s = a.length; t < s; t++)
        ug[a[t]] = e
}
function un(a) {
    const e = a.indexOf("-");
    return e !== -1 ? a.substring(0, e) : a
}
function cD(a, e) {
    const t = a.indexOf("-");
    return t !== -1 ? e + a.substring(t) : e
}
function Mx(a, e) {
    if (e[a])
        return a;
    let t = uu[a];
    if (t && e[t])
        return t;
    const s = un(a);
    return t = uu[s],
    e[t] ? t : e[s] ? s : du
}
Er(["ja", "ko", "th", "vi", "zh", "id"], function(a) {
    return 0
});
Er(["fa", "hi"], function(a) {
    return a >= 0 && a <= 1 ? 0 : 1
});
Er(["fr", "pt"], function(a) {
    return a >= 0 && a < 2 ? 0 : 1
});
Er(["da"], function(a) {
    return a === 1 || !Number.isInteger(a) && a >= 0 && a <= 1 ? 0 : 1
});
Er(["de", "en", "it", "el", "es", "tr", "fi", "sv", "nb", "no", "ur"], function(a) {
    return a === 1 ? 0 : 1
});
Er(["ru", "uk"], function(a) {
    if (Number.isInteger(a)) {
        const e = a % 10
          , t = a % 100;
        if (e === 1 && t !== 11)
            return 0;
        if (e >= 2 && e <= 4 && (t < 12 || t > 14))
            return 1;
        if (e === 0 || e >= 5 && e <= 9 || t >= 11 && t <= 14)
            return 2
    }
    return 3
});
Er(["pl"], function(a) {
    if (Number.isInteger(a)) {
        if (a === 1)
            return 0;
        const e = a % 10
          , t = a % 100;
        if (e >= 2 && e <= 4 && (t < 12 || t > 14))
            return 1;
        if (e >= 0 && e <= 1 || e >= 5 && e <= 9 || t >= 12 && t <= 14)
            return 2
    }
    return 3
});
Er(["ar"], function(a) {
    if (a === 0)
        return 0;
    if (a === 1)
        return 1;
    if (a === 2)
        return 2;
    if (Number.isInteger(a)) {
        const e = a % 100;
        if (e >= 3 && e <= 10)
            return 3;
        if (e >= 11 && e <= 99)
            return 4
    }
    return 5
});
const dD = ug[un(du)];
function Cp(a) {
    return ug[a] || dD
}
const Ko = new RegExp("^\\s*(?:(?:[a-z]+[a-z0-9\\-\\+\\.]*:)?//|data:|blob:)","i");
class uD {
    constructor(e="", t="", s=null, i=null, n=null, r=null) {
        this.url = e,
        this.filename = t,
        this.hash = s,
        this.size = i,
        this.opt = n,
        this.contents = r
    }
    equals(e) {
        return this.url === e.url && this.filename === e.filename && this.hash === e.hash && this.size === e.size && this.opt === e.opt && this.contents === e.contents
    }
}
let fD = -1;
const pD = {
    pvr: "extCompressedTexturePVRTC",
    dxt: "extCompressedTextureS3TC",
    etc2: "extCompressedTextureETC",
    etc1: "extCompressedTextureETC1",
    basis: "canvas"
}
  , X0 = ["pvr", "dxt", "etc2", "etc1", "basis"];
class le extends fe {
    constructor(e, t, s, i, n) {
        super(),
        this._id = fD--,
        this._name = e || "",
        this.type = t,
        this.tags = new zh(this),
        this._preload = !1,
        this._file = null,
        this._data = i || {},
        this.options = n || {},
        this._resources = [],
        this._i18n = {},
        this.loaded = !1,
        this.loading = !1,
        this.registry = null,
        s && (this.file = s)
    }
    set id(e) {
        this._id = e
    }
    get id() {
        return this._id
    }
    set name(e) {
        if (this._name === e)
            return;
        const t = this._name;
        this._name = e,
        this.fire("name", this, this._name, t)
    }
    get name() {
        return this._name
    }
    set file(e) {
        if (e && e.variants && ["texture", "textureatlas", "bundle"].indexOf(this.type) !== -1) {
            var t;
            const n = ((t = this.registry) == null || (t = t._loader) == null ? void 0 : t._app) || Tn()
              , r = n == null ? void 0 : n.graphicsDevice;
            if (r)
                for (let o = 0, l = X0.length; o < l; o++) {
                    const c = X0[o];
                    if (e.variants[c] && r[pD[c]]) {
                        e = e.variants[c];
                        break
                    }
                    if (n.enableBundles) {
                        const d = n.bundles.listBundlesForAsset(this);
                        if (d && d.find(h => {
                            var u;
                            return h == null || (u = h.file) == null ? void 0 : u.variants[c]
                        }
                        ))
                            break
                    }
                }
        }
        const s = this._file
          , i = e ? new uD(e.url,e.filename,e.hash,e.size,e.opt,e.contents) : null;
        (!!i != !!s || i && !i.equals(s)) && (this._file = i,
        this.fire("change", this, "file", i, s),
        this.reload())
    }
    get file() {
        return this._file
    }
    set data(e) {
        const t = this._data;
        this._data = e,
        e !== t && (this.fire("change", this, "data", e, t),
        this.loaded && this.registry._loader.patch(this, this.registry))
    }
    get data() {
        return this._data
    }
    set resource(e) {
        const t = this._resources[0];
        this._resources[0] = e,
        this.fire("change", this, "resource", e, t)
    }
    get resource() {
        return this._resources[0]
    }
    set resources(e) {
        const t = this._resources;
        this._resources = e,
        this.fire("change", this, "resources", e, t)
    }
    get resources() {
        return this._resources
    }
    set preload(e) {
        e = !!e,
        this._preload !== e && (this._preload = e,
        this._preload && !this.loaded && !this.loading && this.registry && this.registry.load(this))
    }
    get preload() {
        return this._preload
    }
    set loadFaces(e) {
        e = !!e,
        (!this.hasOwnProperty("_loadFaces") || e !== this._loadFaces) && (this._loadFaces = e,
        this.loaded && this.registry._loader.patch(this, this.registry))
    }
    get loadFaces() {
        return this._loadFaces
    }
    getFileUrl() {
        const e = this.file;
        if (!e || !e.url)
            return null;
        let t = e.url;
        if (this.registry && this.registry.prefix && !Ko.test(t) && (t = this.registry.prefix + t),
        this.type !== "script" && e.hash) {
            const s = t.indexOf("?") !== -1 ? "&" : "?";
            t += s + "t=" + e.hash
        }
        return t
    }
    getAbsoluteUrl(e) {
        if (e.startsWith("blob:") || e.startsWith("data:"))
            return e;
        const t = ye.getDirectory(this.file.url);
        return ye.join(t, e)
    }
    getLocalizedAssetId(e) {
        return e = Mx(e, this._i18n),
        this._i18n[e] || null
    }
    addLocalizedAssetId(e, t) {
        this._i18n[e] = t,
        this.fire("add:localized", e, t)
    }
    removeLocalizedAssetId(e) {
        const t = this._i18n[e];
        t && (delete this._i18n[e],
        this.fire("remove:localized", e, t))
    }
    ready(e, t) {
        t = t || this,
        this.loaded ? e.call(t, this) : this.once("load", function(s) {
            e.call(t, s)
        })
    }
    reload() {
        this.loaded && (this.loaded = !1,
        this.registry.load(this))
    }
    unload() {
        if (!this.loaded && this._resources.length === 0)
            return;
        this.fire("unload", this),
        this.registry.fire("unload:" + this.id, this);
        const e = this._resources;
        this.resources = [],
        this.loaded = !1,
        this.file && this.registry._loader.clearCache(this.getFileUrl(), this.type);
        for (let t = 0; t < e.length; ++t) {
            const s = e[t];
            s && s.destroy && s.destroy()
        }
    }
    static fetchArrayBuffer(e, t, s, i=0) {
        var n;
        s != null && (n = s.file) != null && n.contents ? setTimeout( () => {
            t(null, s.file.contents)
        }
        ) : st.get(e, {
            cache: !0,
            responseType: "arraybuffer",
            retry: i > 0,
            maxRetries: i
        }, t)
    }
}
le.EVENT_LOAD = "load";
le.EVENT_UNLOAD = "unload";
le.EVENT_REMOVE = "remove";
le.EVENT_ERROR = "error";
le.EVENT_CHANGE = "change";
le.EVENT_ADDLOCALIZED = "add:localized";
le.EVENT_REMOVELOCALIZED = "remove:localized";
class mD {
    constructor(e=null) {
        this._index = {},
        this._key = void 0,
        this._key = e
    }
    addItem(e) {
        const t = e.tags._list;
        for (const s of t)
            this.add(s, e)
    }
    removeItem(e) {
        const t = e.tags._list;
        for (const s of t)
            this.remove(s, e)
    }
    add(e, t) {
        this._index[e] && this._index[e].list.indexOf(t) !== -1 || (this._index[e] || (this._index[e] = {
            list: []
        },
        this._key && (this._index[e].keys = {})),
        this._index[e].list.push(t),
        this._key && (this._index[e].keys[t[this._key]] = t))
    }
    remove(e, t) {
        if (!this._index[e] || this._key && !this._index[e].keys[t[this._key]])
            return;
        const s = this._index[e].list.indexOf(t);
        s !== -1 && (this._index[e].list.splice(s, 1),
        this._key && delete this._index[e].keys[t[this._key]],
        this._index[e].list.length === 0 && delete this._index[e])
    }
    find(e) {
        const t = {}
          , s = [];
        let i, n, r, o, l;
        const c = (d, h) => this._index[d].list.length - this._index[h].list.length;
        for (let d = 0; d < e.length; d++) {
            if (n = e[d],
            n instanceof Array) {
                if (n.length === 0)
                    continue;
                if (n.length === 1)
                    n = n[0];
                else {
                    l = !1;
                    for (let h = 0; h < n.length; h++)
                        if (!this._index[n[h]]) {
                            l = !0;
                            break
                        }
                    if (l)
                        continue;
                    r = n.slice(0).sort(c),
                    o = r.slice(1),
                    o.length === 1 && (o = o[0]);
                    for (let h = 0; h < this._index[r[0]].list.length; h++)
                        i = this._index[r[0]].list[h],
                        (this._key ? !t[i[this._key]] : s.indexOf(i) === -1) && i.tags.has(o) && (this._key && (t[i[this._key]] = !0),
                        s.push(i));
                    continue
                }
            }
            if (n && typeof n == "string" && this._index[n])
                for (let h = 0; h < this._index[n].list.length; h++)
                    i = this._index[n].list[h],
                    this._key ? t[i[this._key]] || (t[i[this._key]] = !0,
                    s.push(i)) : s.indexOf(i) === -1 && s.push(i)
        }
        return s
    }
}
class Ar extends fe {
    constructor(e) {
        super(),
        this._assets = new Set,
        this._idToAsset = new Map,
        this._urlToAsset = new Map,
        this._nameToAsset = new Map,
        this._tags = new mD("_id"),
        this.prefix = null,
        this._loader = e
    }
    list(e={}) {
        const t = Array.from(this._assets);
        return e.preload !== void 0 ? t.filter(s => s.preload === e.preload) : t
    }
    add(e) {
        var t, s;
        this._assets.has(e) || (this._assets.add(e),
        this._idToAsset.set(e.id, e),
        (t = e.file) != null && t.url && this._urlToAsset.set(e.file.url, e),
        this._nameToAsset.has(e.name) || this._nameToAsset.set(e.name, new Set),
        this._nameToAsset.get(e.name).add(e),
        e.on("name", this._onNameChange, this),
        e.registry = this,
        this._tags.addItem(e),
        e.tags.on("add", this._onTagAdd, this),
        e.tags.on("remove", this._onTagRemove, this),
        this.fire("add", e),
        this.fire("add:" + e.id, e),
        (s = e.file) != null && s.url && this.fire("add:url:" + e.file.url, e),
        e.preload && this.load(e))
    }
    remove(e) {
        var t, s;
        if (!this._assets.has(e))
            return !1;
        if (this._assets.delete(e),
        this._idToAsset.delete(e.id),
        (t = e.file) != null && t.url && this._urlToAsset.delete(e.file.url),
        e.off("name", this._onNameChange, this),
        this._nameToAsset.has(e.name)) {
            const i = this._nameToAsset.get(e.name);
            i.delete(e),
            i.size === 0 && this._nameToAsset.delete(e.name)
        }
        return this._tags.removeItem(e),
        e.tags.off("add", this._onTagAdd, this),
        e.tags.off("remove", this._onTagRemove, this),
        e.fire("remove", e),
        this.fire("remove", e),
        this.fire("remove:" + e.id, e),
        (s = e.file) != null && s.url && this.fire("remove:url:" + e.file.url, e),
        !0
    }
    get(e) {
        return this._idToAsset.get(Number(e))
    }
    getByUrl(e) {
        return this._urlToAsset.get(e)
    }
    load(e) {
        if (e.loading || e.loaded)
            return;
        const t = e.file
          , s = n => {
            n instanceof Array ? e.resources = n : e.resource = n,
            this._loader.patch(e, this),
            this.fire("load", e),
            this.fire("load:" + e.id, e),
            t && t.url && this.fire("load:url:" + t.url, e),
            e.fire("load", e)
        }
          , i = (n, r, o) => {
            if (e.loaded = !0,
            e.loading = !1,
            n)
                this.fire("error", n, e),
                this.fire("error:" + e.id, n, e),
                e.fire("error", n, e);
            else {
                if (!Xt.legacy && e.type === "script") {
                    const l = this._loader.getHandler("script");
                    l._cache[e.id] && l._cache[e.id].parentNode === document.head && document.head.removeChild(l._cache[e.id]),
                    l._cache[e.id] = o
                }
                s(r)
            }
        }
        ;
        if (t || e.type === "cubemap")
            this.fire("load:start", e),
            this.fire("load:" + e.id + ":start", e),
            e.loading = !0,
            this._loader.load(e.getFileUrl(), e.type, i, e);
        else {
            const n = this._loader.open(e.type, e.data);
            e.loaded = !0,
            s(n)
        }
    }
    loadFromUrl(e, t, s) {
        this.loadFromUrlAndFilename(e, null, t, s)
    }
    loadFromUrlAndFilename(e, t, s, i) {
        const n = ye.getBasename(t || e)
          , r = {
            filename: t || n,
            url: e
        };
        let o = this.getByUrl(e);
        if (!o)
            o = new le(n,s,r),
            this.add(o);
        else if (o.loaded) {
            i(o.loadFromUrlError || null, o);
            return
        }
        const l = c => {
            c.once("load", d => {
                s === "material" ? this._loadTextures(d, (h, u) => {
                    i(h, d)
                }
                ) : i(null, d)
            }
            ),
            c.once("error", d => {
                d && (this.loadFromUrlError = d),
                i(d, c)
            }
            ),
            this.load(c)
        }
        ;
        o.resource ? i(null, o) : s === "model" ? this._loadModel(o, l) : l(o)
    }
    _loadModel(e, t) {
        const s = e.getFileUrl()
          , i = ye.getExtension(s);
        if (i === ".json" || i === ".glb") {
            const n = ye.getDirectory(s)
              , r = ye.getBasename(s)
              , o = ye.join(n, r.replace(i, ".mapping.json"));
            this._loader.load(o, "json", (l, c) => {
                l ? (e.data = {
                    mapping: []
                },
                t(e)) : this._loadMaterials(e, c, (d, h) => {
                    e.data = c,
                    t(e)
                }
                )
            }
            )
        } else
            t(e)
    }
    _loadMaterials(e, t, s) {
        const i = [];
        let n = 0;
        const r = (o, l) => {
            this._loadTextures(l, (c, d) => {
                i.push(l),
                i.length === n && s(null, i)
            }
            )
        }
        ;
        for (let o = 0; o < t.mapping.length; o++) {
            const l = t.mapping[o].path;
            if (l) {
                n++;
                const c = e.getAbsoluteUrl(l);
                this.loadFromUrl(c, "material", r)
            }
        }
        n === 0 && s(null, i)
    }
    _loadTextures(e, t) {
        const s = [];
        let i = 0;
        const n = e.data;
        if (n.mappingFormat !== "path") {
            t(null, s);
            return
        }
        const r = (l, c) => {
            l && console.error(l),
            s.push(c),
            s.length === i && t(null, s)
        }
          , o = Af;
        for (let l = 0; l < o.length; l++) {
            const c = n[o[l]];
            if (c && typeof c == "string") {
                i++;
                const d = e.getAbsoluteUrl(c);
                this.loadFromUrl(d, "texture", r)
            }
        }
        i === 0 && t(null, s)
    }
    _onTagAdd(e, t) {
        this._tags.add(e, t)
    }
    _onTagRemove(e, t) {
        this._tags.remove(e, t)
    }
    _onNameChange(e, t, s) {
        if (this._nameToAsset.has(s)) {
            const i = this._nameToAsset.get(s);
            i.delete(e),
            i.size === 0 && this._nameToAsset.delete(s)
        }
        this._nameToAsset.has(e.name) || this._nameToAsset.set(e.name, new Set),
        this._nameToAsset.get(e.name).add(e)
    }
    findByTag() {
        return this._tags.find(arguments)
    }
    filter(e) {
        return Array.from(this._assets).filter(t => e(t))
    }
    find(e, t) {
        const s = this._nameToAsset.get(e);
        if (!s)
            return null;
        for (const i of s)
            if (!t || i.type === t)
                return i;
        return null
    }
    findAll(e, t) {
        const s = this._nameToAsset.get(e);
        if (!s)
            return [];
        const i = Array.from(s);
        return t ? i.filter(n => n.type === t) : i
    }
}
Ar.EVENT_LOAD = "load";
Ar.EVENT_ADD = "add";
Ar.EVENT_REMOVE = "remove";
Ar.EVENT_ERROR = "error";
class _D {
    constructor(e) {
        this._assets = e,
        this._bundleAssets = {},
        this._assetsInBundles = {},
        this._urlsInBundles = {},
        this._fileRequests = {},
        this._assets.on("add", this._onAssetAdded, this),
        this._assets.on("remove", this._onAssetRemoved, this)
    }
    _onAssetAdded(e) {
        if (e.type === "bundle") {
            this._bundleAssets[e.id] = e,
            this._registerBundleEventListeners(e.id);
            for (let t = 0, s = e.data.assets.length; t < s; t++)
                this._indexAssetInBundle(e.data.assets[t], e)
        } else
            this._assetsInBundles[e.id] && this._indexAssetFileUrls(e)
    }
    _registerBundleEventListeners(e) {
        this._assets.on("load:" + e, this._onBundleLoaded, this),
        this._assets.on("error:" + e, this._onBundleError, this)
    }
    _unregisterBundleEventListeners(e) {
        this._assets.off("load:" + e, this._onBundleLoaded, this),
        this._assets.off("error:" + e, this._onBundleError, this)
    }
    _indexAssetInBundle(e, t) {
        if (!this._assetsInBundles[e])
            this._assetsInBundles[e] = [t];
        else {
            const i = this._assetsInBundles[e];
            i.indexOf(t) === -1 && i.push(t)
        }
        const s = this._assets.get(e);
        s && this._indexAssetFileUrls(s)
    }
    _indexAssetFileUrls(e) {
        const t = this._getAssetFileUrls(e);
        if (t)
            for (let s = 0, i = t.length; s < i; s++) {
                const n = t[s];
                this._urlsInBundles[n] = this._assetsInBundles[e.id]
            }
    }
    _getAssetFileUrls(e) {
        let t = e.getFileUrl();
        if (!t)
            return null;
        t = this._normalizeUrl(t);
        const s = [t];
        if (e.type === "font") {
            const i = e.data.info.maps.length;
            for (let n = 1; n < i; n++)
                s.push(t.replace(".png", n + ".png"))
        }
        return s
    }
    _normalizeUrl(e) {
        return e && e.split("?")[0]
    }
    _onAssetRemoved(e) {
        if (e.type === "bundle") {
            delete this._bundleAssets[e.id],
            this._unregisterBundleEventListeners(e.id);
            for (const t in this._assetsInBundles) {
                const s = this._assetsInBundles[t]
                  , i = s.indexOf(e);
                if (i !== -1 && (s.splice(i, 1),
                !s.length)) {
                    delete this._assetsInBundles[t];
                    for (const n in this._urlsInBundles)
                        this._urlsInBundles[n] === s && delete this._urlsInBundles[n]
                }
            }
            this._onBundleError(`Bundle ${e.id} was removed`, e)
        } else if (this._assetsInBundles[e.id]) {
            delete this._assetsInBundles[e.id];
            const t = this._getAssetFileUrls(e);
            for (let s = 0, i = t.length; s < i; s++)
                delete this._urlsInBundles[t[s]]
        }
    }
    _onBundleLoaded(e) {
        if (!e.resource) {
            this._onBundleError(`Bundle ${e.id} failed to load`, e);
            return
        }
        requestAnimationFrame( () => {
            if (this._fileRequests)
                for (const t in this._fileRequests) {
                    const s = this._urlsInBundles[t];
                    if (!s || s.indexOf(e) === -1)
                        continue;
                    const i = decodeURIComponent(t);
                    let n = null;
                    e.resource.hasBlobUrl(i) || (n = `Bundle ${e.id} does not contain URL ${t}`);
                    const r = this._fileRequests[t];
                    for (let o = 0, l = r.length; o < l; o++)
                        n ? r[o](n) : r[o](null, e.resource.getBlobUrl(i));
                    delete this._fileRequests[t]
                }
        }
        )
    }
    _onBundleError(e, t) {
        for (const s in this._fileRequests)
            if (!this._findLoadedOrLoadingBundleForUrl(s)) {
                const n = this._fileRequests[s];
                for (let r = 0, o = n.length; r < o; r++)
                    n[r](e);
                delete this._fileRequests[s]
            }
    }
    _findLoadedOrLoadingBundleForUrl(e) {
        const t = this._urlsInBundles[e];
        if (!t)
            return null;
        const s = t.length;
        for (let i = 0; i < s; i++)
            if (t[i].loaded && t[i].resource)
                return t[i];
        for (let i = 0; i < s; i++)
            if (t[i].loading)
                return t[i];
        return null
    }
    listBundlesForAsset(e) {
        return this._assetsInBundles[e.id] || null
    }
    list() {
        const e = [];
        for (const t in this._bundleAssets)
            e.push(this._bundleAssets[t]);
        return e
    }
    hasUrl(e) {
        return !!this._urlsInBundles[e]
    }
    canLoadUrl(e) {
        return !!this._findLoadedOrLoadingBundleForUrl(e)
    }
    loadUrl(e, t) {
        const s = this._findLoadedOrLoadingBundleForUrl(e);
        if (!s) {
            t(`URL ${e} not found in any bundles`);
            return
        }
        if (s.loaded) {
            const i = decodeURIComponent(e);
            if (!s.resource.hasBlobUrl(i)) {
                t(`Bundle ${s.id} does not contain URL ${e}`);
                return
            }
            t(null, s.resource.getBlobUrl(i))
        } else
            this._fileRequests.hasOwnProperty(e) ? this._fileRequests[e].push(t) : this._fileRequests[e] = [t]
    }
    destroy() {
        this._assets.off("add", this._onAssetAdded, this),
        this._assets.off("remove", this._onAssetRemoved, this);
        for (const e in this._bundleAssets)
            this._unregisterBundleEventListeners(e);
        this._assets = null,
        this._bundleAssets = null,
        this._assetsInBundles = null,
        this._urlsInBundles = null,
        this._fileRequests = null
    }
}
class gD extends fe {
    constructor() {
        super(),
        this.anim = void 0,
        this.animation = void 0,
        this.audiolistener = void 0,
        this.audiosource = void 0,
        this.button = void 0,
        this.camera = void 0,
        this.collision = void 0,
        this.element = void 0,
        this.joint = void 0,
        this.layoutchild = void 0,
        this.layoutgroup = void 0,
        this.light = void 0,
        this.model = void 0,
        this.particlesystem = void 0,
        this.render = void 0,
        this.rigidbody = void 0,
        this.screen = void 0,
        this.script = void 0,
        this.scrollbar = void 0,
        this.scrollview = void 0,
        this.sound = void 0,
        this.sprite = void 0,
        this.zone = void 0,
        this.list = []
    }
    add(e) {
        const t = e.id;
        if (this[t])
            throw new Error(`ComponentSystem name '${t}' already registered or not allowed`);
        this[t] = e,
        this.list.push(e)
    }
    remove(e) {
        const t = e.id;
        if (!this[t])
            throw new Error(`No ComponentSystem named '${t}' registered`);
        delete this[t];
        const s = this.list.indexOf(this[t]);
        s !== -1 && this.list.splice(s, 1)
    }
    destroy() {
        this.off();
        for (let e = 0; e < this.list.length; e++)
            this.list[e].destroy()
    }
}
class yD {
    constructor(e) {
        this._blobUrls = {};
        for (let t = 0, s = e.length; t < s; t++)
            e[t].url && (this._blobUrls[e[t].name] = e[t].url)
    }
    hasBlobUrl(e) {
        return !!this._blobUrls[e]
    }
    getBlobUrl(e) {
        return this._blobUrls[e]
    }
    destroy() {
        for (const e in this._blobUrls)
            URL.revokeObjectURL(this._blobUrls[e]);
        this._blobUrls = null
    }
}
let Px;
function Rx(a) {
    let e, t;
    if (typeof TextDecoder < "u")
        try {
            e = new TextDecoder("utf-8"),
            t = new TextDecoder("windows-1252")
        } catch {
            console.warn("TextDecoder not supported - pc.Untar module will not work")
        }
    else
        console.warn("TextDecoder not supported - pc.Untar module will not work");
    function s(n) {
        this._fields = n
    }
    s.parse = function(n, r, o) {
        const l = new Uint8Array(n,r,o);
        let c = 0;
        const d = [];
        for (; c < o; ) {
            let h;
            for (h = c; h < o && l[h] !== 32; h++)
                ;
            if (h >= o)
                throw new Error("Invalid PAX header data format.");
            const u = parseInt(e.decode(new Uint8Array(n,r + c,h - c)), 10)
              , p = e.decode(new Uint8Array(n,r + h + 1,u - (h - c) - 2)).split("=");
            if (p.length !== 2)
                throw new Error("Invalid PAX header data format.");
            p[1].length === 0 && (p[1] = null),
            d.push({
                name: p[0],
                value: p[1]
            }),
            c += u
        }
        return new s(d)
    }
    ,
    s.prototype.applyHeader = function(n) {
        for (let r = 0; r < this._fields.length; r++) {
            let o = this._fields[r].name;
            const l = this._fields[r].value;
            o === "path" && (o = "name"),
            l === null ? delete n[o] : n[o] = l
        }
    }
    ;
    function i(n) {
        this._arrayBuffer = n || new ArrayBuffer(0),
        this._bufferView = new DataView(this._arrayBuffer),
        this._globalPaxHeader = null,
        this._paxHeader = null,
        this._bytesRead = 0
    }
    a || (Px = i),
    i.prototype._hasNext = function() {
        return this._bytesRead + 4 < this._arrayBuffer.byteLength && this._bufferView.getUint32(this._bytesRead) !== 0
    }
    ,
    i.prototype._readNextFile = function() {
        const n = new DataView(this._arrayBuffer,this._bytesRead,512)
          , r = t.decode(n);
        this._bytesRead += 512;
        let o = r.substring(0, 100).replace(/\0/g, "");
        const l = r.substring(257, 263)
          , c = parseInt(r.substring(124, 136), 8)
          , d = r.substring(156, 157)
          , h = this._bytesRead;
        let u = null
          , f = !1;
        switch (d) {
        case "0":
        case "":
            if (f = !0,
            !a) {
                const m = new Blob([this._arrayBuffer.slice(this._bytesRead, this._bytesRead + c)]);
                u = URL.createObjectURL(m)
            }
            break;
        case "g":
            this._globalPaxHeader = s.parse(this._arrayBuffer, this._bytesRead, c);
            break;
        case "x":
            this._paxHeader = s.parse(this._arrayBuffer, this._bytesRead, c);
            break
        }
        this._bytesRead += c;
        const p = c % 512;
        if (p !== 0 && (this._bytesRead += 512 - p),
        !f)
            return null;
        if (l.indexOf("ustar") !== -1) {
            const m = r.substring(345, 500).replace(/\0/g, "");
            m.length > 0 && (o = m.trim() + o.trim())
        }
        const _ = {
            name: o,
            start: h,
            size: c,
            url: u
        };
        return this._globalPaxHeader && this._globalPaxHeader.applyHeader(_),
        this._paxHeader && (this._paxHeader.applyHeader(_),
        this._paxHeader = null),
        _
    }
    ,
    i.prototype.untar = function(n) {
        if (!e)
            return console.error("Cannot untar because TextDecoder interface is not available for this platform."),
            [];
        const r = [];
        for (; this._hasNext(); ) {
            const o = this._readNextFile();
            o && (n && o.name && (o.name = n + o.name),
            r.push(o))
        }
        return r
    }
    ,
    a && (self.onmessage = function(n) {
        const r = n.data.id;
        try {
            const l = new i(n.data.arrayBuffer).untar(n.data.prefix);
            postMessage({
                id: r,
                files: l,
                arrayBuffer: n.data.arrayBuffer
            }, [n.data.arrayBuffer])
        } catch (o) {
            postMessage({
                id: r,
                error: o.toString()
            })
        }
    }
    )
}
let Ep = null;
function vD() {
    if (!Ep) {
        const a = "(" + Rx.toString() + `)(true)

`
          , e = new Blob([a],{
            type: "application/javascript"
        });
        Ep = URL.createObjectURL(e)
    }
    return Ep
}
class SD {
    constructor(e) {
        this._requestId = 0,
        this._pendingRequests = {},
        this._filenamePrefix = e,
        this._worker = new Worker(vD()),
        this._worker.addEventListener("message", this._onMessage.bind(this))
    }
    _onMessage(e) {
        const t = e.data.id;
        if (!this._pendingRequests[t])
            return;
        const s = this._pendingRequests[t];
        if (delete this._pendingRequests[t],
        e.data.error)
            s(e.data.error);
        else {
            const i = e.data.arrayBuffer;
            for (let n = 0, r = e.data.files.length; n < r; n++) {
                const o = e.data.files[n]
                  , l = new Blob([i.slice(o.start, o.start + o.size)]);
                o.url = URL.createObjectURL(l)
            }
            s(null, e.data.files)
        }
    }
    untar(e, t) {
        const s = this._requestId++;
        this._pendingRequests[s] = t,
        this._worker.postMessage({
            id: s,
            prefix: this._filenamePrefix,
            arrayBuffer: e
        }, [e])
    }
    hasPendingRequests() {
        return Object.keys(this._pendingRequests).length > 0
    }
    destroy() {
        this._worker && (this._worker.terminate(),
        this._worker = null,
        this._pendingRequests = null)
    }
}
Rx();
class xD {
    constructor(e) {
        this.handlerType = "bundle",
        this._assets = e.assets,
        this._worker = null,
        this.maxRetries = 0
    }
    load(e, t) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        });
        const s = this;
        st.get(e.load, {
            responseType: we.ResponseType.ARRAY_BUFFER,
            retry: this.maxRetries > 0,
            maxRetries: this.maxRetries
        }, function(i, n) {
            if (i)
                t("Error loading bundle resource " + e.original + ": " + i);
            else
                try {
                    s._untar(n, t)
                } catch (r) {
                    t("Error loading bundle resource " + e.original + ": " + r)
                }
        })
    }
    _untar(e, t) {
        const s = this;
        if (Le.workers)
            s._worker || (s._worker = new SD(s._assets.prefix)),
            s._worker.untar(e, function(i, n) {
                t(i, n),
                s._worker.hasPendingRequests() || (s._worker.destroy(),
                s._worker = null)
            });
        else {
            const n = new Px(e).untar(s._assets.prefix);
            t(null, n)
        }
    }
    open(e, t) {
        return new yD(t)
    }
    patch(e, t) {}
}
class Ao {
    constructor(e) {
        this._handlers = {},
        this._requests = {},
        this._cache = {},
        this._app = e
    }
    addHandler(e, t) {
        this._handlers[e] = t,
        t._loader = this
    }
    removeHandler(e) {
        delete this._handlers[e]
    }
    getHandler(e) {
        return this._handlers[e]
    }
    static makeKey(e, t) {
        return `${e}-${t}`
    }
    load(e, t, s, i) {
        const n = this._handlers[t];
        if (!n) {
            const o = `No resource handler for asset type: '${t}' when loading [${e}]`;
            s(o);
            return
        }
        if (!e) {
            this._loadNull(n, s, i);
            return
        }
        const r = Ao.makeKey(e, t);
        if (this._cache[r] !== void 0)
            s(null, this._cache[r]);
        else if (this._requests[r])
            this._requests[r].push(s);
        else {
            this._requests[r] = [s];
            const o = this
              , l = function(h, u) {
                if (h) {
                    o._onFailure(r, h);
                    return
                }
                n.load(u, function(f, p, _) {
                    if (o._requests[r]) {
                        if (f) {
                            o._onFailure(r, f);
                            return
                        }
                        try {
                            o._onSuccess(r, n.open(u.original, p, i), _)
                        } catch (m) {
                            o._onFailure(r, m)
                        }
                    }
                }, i)
            }
              , c = e.split("?")[0];
            if (this._app.enableBundles && this._app.bundles.hasUrl(c)) {
                if (!this._app.bundles.canLoadUrl(c)) {
                    l(`Bundle for ${e} not loaded yet`);
                    return
                }
                this._app.bundles.loadUrl(c, function(d, h) {
                    l(d, {
                        load: h,
                        original: c
                    })
                })
            } else
                l(null, {
                    load: e,
                    original: i && i.file.filename || e
                })
        }
    }
    _loadNull(e, t, s) {
        const i = function(r, o, l) {
            if (r)
                t(r);
            else
                try {
                    t(null, e.open(null, o, s), l)
                } catch (c) {
                    t(c)
                }
        };
        e.load(null, i, s)
    }
    _onSuccess(e, t, s) {
        t !== null ? this._cache[e] = t : delete this._cache[e];
        for (let i = 0; i < this._requests[e].length; i++)
            this._requests[e][i](null, t, s);
        delete this._requests[e]
    }
    _onFailure(e, t) {
        if (console.error(t),
        this._requests[e]) {
            for (let s = 0; s < this._requests[e].length; s++)
                this._requests[e][s](t);
            delete this._requests[e]
        }
    }
    open(e, t) {
        const s = this._handlers[e];
        return s ? s.open(null, t) : (console.warn("No resource handler found for: " + e),
        t)
    }
    patch(e, t) {
        const s = this._handlers[e.type];
        if (!s) {
            console.warn("No resource handler found for: " + e.type);
            return
        }
        s.patch && s.patch(e, t)
    }
    clearCache(e, t) {
        const s = Ao.makeKey(e, t);
        delete this._cache[s]
    }
    getFromCache(e, t) {
        const s = Ao.makeKey(e, t);
        if (this._cache[s])
            return this._cache[s]
    }
    enableRetry(e=5) {
        e = Math.max(0, e) || 0;
        for (const t in this._handlers)
            this._handlers[t].maxRetries = e
    }
    disableRetry() {
        for (const e in this._handlers)
            this._handlers[e].maxRetries = 0
    }
    destroy() {
        this._handlers = {},
        this._requests = {},
        this._cache = {}
    }
}
class wD {
    _validate(e) {
        if (!e.header)
            throw new Error('pc.I18n#addData: Missing "header" field');
        if (!e.header.version)
            throw new Error('pc.I18n#addData: Missing "header.version" field');
        if (e.header.version !== 1)
            throw new Error('pc.I18n#addData: Invalid "header.version" field');
        if (e.data) {
            if (!Array.isArray(e.data))
                throw new Error('pc.I18n#addData: "data" field must be an array')
        } else
            throw new Error('pc.I18n#addData: Missing "data" field');
        for (let t = 0, s = e.data.length; t < s; t++) {
            const i = e.data[t];
            if (!i.info)
                throw new Error(`pc.I18n#addData: missing "data[${t}].info" field`);
            if (!i.info.locale)
                throw new Error(`pc.I18n#addData: missing "data[${t}].info.locale" field`);
            if (typeof i.info.locale != "string")
                throw new Error(`pc.I18n#addData: "data[${t}].info.locale" must be a string`);
            if (!i.messages)
                throw new Error(`pc.I18n#addData: missing "data[${t}].messages" field`)
        }
    }
    parse(e) {
        return e.data
    }
}
class bD extends fe {
    constructor(e) {
        super(),
        this.locale = du,
        this._translations = {},
        this._availableLangs = {},
        this._app = e,
        this._assets = [],
        this._parser = new wD
    }
    set assets(e) {
        const t = {};
        for (let i = 0, n = e.length; i < n; i++) {
            const r = e[i]instanceof le ? e[i].id : e[i];
            t[r] = !0
        }
        let s = this._assets.length;
        for (; s--; ) {
            const i = this._assets[s];
            if (!t[i]) {
                this._app.assets.off("add:" + i, this._onAssetAdd, this);
                const n = this._app.assets.get(i);
                n && this._onAssetRemove(n),
                this._assets.splice(s, 1)
            }
        }
        for (const i in t) {
            const n = parseInt(i, 10);
            if (this._assets.indexOf(n) !== -1)
                continue;
            this._assets.push(n);
            const r = this._app.assets.get(n);
            r ? this._onAssetAdd(r) : this._app.assets.once("add:" + n, this._onAssetAdd, this)
        }
    }
    get assets() {
        return this._assets
    }
    set locale(e) {
        if (this._locale === e)
            return;
        let t = un(e);
        if (t === "in" && (t = "id",
        e = cD(e, t),
        this._locale === e))
            return;
        const s = this._locale;
        this._locale = e,
        this._lang = t,
        this._pluralFn = Cp(this._lang),
        this.fire("set:locale", e, s)
    }
    get locale() {
        return this._locale
    }
    static findAvailableLocale(e, t) {
        return Mx(e, t)
    }
    findAvailableLocale(e) {
        if (this._translations[e])
            return e;
        const t = un(e);
        return this._findFallbackLocale(e, t)
    }
    getText(e, t) {
        let s = e, i;
        t || (t = this._locale,
        i = this._lang);
        let n = this._translations[t];
        return n || (i || (i = un(t)),
        t = this._findFallbackLocale(t, i),
        n = this._translations[t]),
        n && n.hasOwnProperty(e) && (s = n[e],
        Array.isArray(s) && (s = s[0]),
        s == null && (s = e)),
        s
    }
    getPluralText(e, t, s) {
        let i = e, n, r;
        s ? (n = un(s),
        r = Cp(n)) : (s = this._locale,
        n = this._lang,
        r = this._pluralFn);
        let o = this._translations[s];
        if (o || (s = this._findFallbackLocale(s, n),
        n = un(s),
        r = Cp(n),
        o = this._translations[s]),
        o && o[e] && r) {
            const l = r(t);
            i = o[e][l],
            i == null && (i = e)
        }
        return i
    }
    addData(e) {
        let t;
        try {
            t = this._parser.parse(e)
        } catch (s) {
            console.error(s);
            return
        }
        for (let s = 0, i = t.length; s < i; s++) {
            const n = t[s]
              , r = n.info.locale
              , o = n.messages;
            if (!this._translations[r]) {
                this._translations[r] = {};
                const l = un(r);
                this._availableLangs[l] || (this._availableLangs[l] = r)
            }
            Object.assign(this._translations[r], o),
            this.fire("data:add", r, o)
        }
    }
    removeData(e) {
        let t;
        try {
            t = this._parser.parse(e)
        } catch (s) {
            console.error(s);
            return
        }
        for (let s = 0, i = t.length; s < i; s++) {
            const n = t[s]
              , r = n.info.locale
              , o = this._translations[r];
            if (!o)
                continue;
            const l = n.messages;
            for (const c in l)
                delete o[c];
            Object.keys(o).length === 0 && (delete this._translations[r],
            delete this._availableLangs[un(r)]),
            this.fire("data:remove", r, l)
        }
    }
    destroy() {
        this._translations = null,
        this._availableLangs = null,
        this._assets = null,
        this._parser = null,
        this.off()
    }
    _findFallbackLocale(e, t) {
        let s = uu[e];
        return s && this._translations[s] || (s = uu[t],
        s && this._translations[s]) || (s = this._availableLangs[t],
        s && this._translations[s]) ? s : du
    }
    _onAssetAdd(e) {
        e.on("load", this._onAssetLoad, this),
        e.on("change", this._onAssetChange, this),
        e.on("remove", this._onAssetRemove, this),
        e.on("unload", this._onAssetUnload, this),
        e.resource && this._onAssetLoad(e)
    }
    _onAssetLoad(e) {
        this.addData(e.resource)
    }
    _onAssetChange(e) {
        e.resource && this.addData(e.resource)
    }
    _onAssetRemove(e) {
        e.off("load", this._onAssetLoad, this),
        e.off("change", this._onAssetChange, this),
        e.off("remove", this._onAssetRemove, this),
        e.off("unload", this._onAssetUnload, this),
        e.resource && this.removeData(e.resource),
        this._app.assets.once("add:" + e.id, this._onAssetAdd, this)
    }
    _onAssetUnload(e) {
        e.resource && this.removeData(e.resource)
    }
}
class TD extends fe {
    constructor(e) {
        super(),
        this.app = e,
        this._scripts = {},
        this._list = []
    }
    destroy() {
        this.app = null,
        this.off()
    }
    add(e) {
        const t = e.__name;
        return this._scripts.hasOwnProperty(t) ? (setTimeout( () => {
            if (e.prototype.swap) {
                const s = this._scripts[t]
                  , i = this._list.indexOf(s);
                this._list[i] = e,
                this._scripts[t] = e,
                this.fire("swap", t, e),
                this.fire("swap:" + t, e)
            } else
                console.warn(`script registry already has '${t}' script, define 'swap' method for new script type to enable code hot swapping`)
        }
        ),
        !1) : (this._scripts[t] = e,
        this._list.push(e),
        this.fire("add", t, e),
        this.fire("add:" + t, e),
        setTimeout( () => {
            if (!this._scripts.hasOwnProperty(t) || !this.app || !this.app.systems || !this.app.systems.script)
                return;
            const s = this.app.systems.script._components;
            let i;
            const n = []
              , r = [];
            for (s.loopIndex = 0; s.loopIndex < s.length; s.loopIndex++) {
                const o = s.items[s.loopIndex];
                if (o._scriptsIndex[t] && o._scriptsIndex[t].awaiting) {
                    o._scriptsData && o._scriptsData[t] && (i = o._scriptsData[t].attributes);
                    const l = o.create(t, {
                        preloading: !0,
                        ind: o._scriptsIndex[t].ind,
                        attributes: i
                    });
                    l && n.push(l)
                }
            }
            for (let o = 0; o < n.length; o++)
                n[o].__initializeAttributes();
            for (let o = 0; o < n.length; o++)
                n[o].enabled && (n[o]._initialized = !0,
                r.push(n[o]),
                n[o].initialize && n[o].initialize());
            for (let o = 0; o < r.length; o++)
                !r[o].enabled || r[o]._postInitialized || (r[o]._postInitialized = !0,
                r[o].postInitialize && r[o].postInitialize())
        }
        ),
        !0)
    }
    remove(e) {
        let t = e
          , s = e;
        if (typeof s != "string" ? s = t.__name : t = this.get(s),
        this.get(s) !== t)
            return !1;
        delete this._scripts[s];
        const i = this._list.indexOf(t);
        return this._list.splice(i, 1),
        this.fire("remove", s, t),
        this.fire("remove:" + s, t),
        !0
    }
    get(e) {
        return this._scripts[e] || null
    }
    has(e) {
        if (typeof e == "string")
            return this._scripts.hasOwnProperty(e);
        if (!e)
            return !1;
        const t = e.__name;
        return this._scripts[t] === e
    }
    list() {
        return this._list
    }
}
const El = [];
class V extends yt {
    constructor(e, t=Tn()) {
        super(e),
        this.anim = void 0,
        this.animation = void 0,
        this.audiolistener = void 0,
        this.button = void 0,
        this.camera = void 0,
        this.collision = void 0,
        this.element = void 0,
        this.gsplat = void 0,
        this.layoutchild = void 0,
        this.layoutgroup = void 0,
        this.light = void 0,
        this.model = void 0,
        this.particlesystem = void 0,
        this.render = void 0,
        this.rigidbody = void 0,
        this.screen = void 0,
        this.script = void 0,
        this.scrollbar = void 0,
        this.scrollview = void 0,
        this.sound = void 0,
        this.sprite = void 0,
        this.c = {},
        this._app = void 0,
        this._destroying = !1,
        this._guid = null,
        this._template = !1,
        this._app = t
    }
    addComponent(e, t) {
        const s = this._app.systems[e];
        return !s || this.c[e] ? null : s.addComponent(this, t)
    }
    removeComponent(e) {
        const t = this._app.systems[e];
        t && this.c[e] && t.removeComponent(this)
    }
    findComponent(e) {
        const t = this.findOne(function(s) {
            return s.c && s.c[e]
        });
        return t && t.c[e]
    }
    findComponents(e) {
        return this.find(function(s) {
            return s.c && s.c[e]
        }).map(function(s) {
            return s.c[e]
        })
    }
    findScript(e) {
        const t = this.findOne(s => {
            var i;
            return (i = s.c) == null || (i = i.script) == null ? void 0 : i.has(e)
        }
        );
        return t == null ? void 0 : t.c.script.get(e)
    }
    findScripts(e) {
        return this.find(s => {
            var i;
            return (i = s.c) == null || (i = i.script) == null ? void 0 : i.has(e)
        }
        ).map(s => s.c.script.get(e))
    }
    getGuid() {
        return this._guid || this.setGuid(Db.create()),
        this._guid
    }
    setGuid(e) {
        const t = this._app._entityIndex;
        this._guid && delete t[this._guid],
        this._guid = e,
        t[this._guid] = this
    }
    _notifyHierarchyStateChanged(e, t) {
        let s = !1;
        e === this && El.length === 0 && (s = !0),
        e._beingEnabled = !0,
        e._onHierarchyStateChanged(t),
        e._onHierarchyStatePostChanged && El.push(e);
        const i = e._children;
        for (let n = 0, r = i.length; n < r; n++)
            i[n]._enabled && this._notifyHierarchyStateChanged(i[n], t);
        if (e._beingEnabled = !1,
        s) {
            for (let n = 0; n < El.length; n++)
                El[n]._onHierarchyStatePostChanged();
            El.length = 0
        }
    }
    _onHierarchyStateChanged(e) {
        super._onHierarchyStateChanged(e);
        const t = this.c;
        for (const s in t)
            if (t.hasOwnProperty(s)) {
                const i = t[s];
                i.enabled && (e ? i.onEnable() : i.onDisable())
            }
    }
    _onHierarchyStatePostChanged() {
        const e = this.c;
        for (const t in e)
            e.hasOwnProperty(t) && e[t].onPostStateChange()
    }
    findByGuid(e) {
        if (this._guid === e)
            return this;
        const t = this._app._entityIndex[e];
        return t && (t === this || t.isDescendantOf(this)) ? t : null
    }
    destroy() {
        this._destroying = !0;
        for (const e in this.c)
            this.c[e].enabled = !1;
        for (const e in this.c)
            this.c[e].system.removeComponent(this);
        super.destroy(),
        this._guid && delete this._app._entityIndex[this._guid],
        this._destroying = !1
    }
    clone() {
        const e = {}
          , t = this._cloneRecursively(e);
        return e[this.getGuid()] = t,
        Ix(this, this, t, e),
        t
    }
    _cloneRecursively(e) {
        const t = new this.constructor(void 0,this._app);
        super._cloneInternal(t);
        for (const s in this.c)
            this.c[s].system.cloneComponent(this, t);
        for (let s = 0; s < this._children.length; s++) {
            const i = this._children[s];
            if (i instanceof V) {
                const n = i._cloneRecursively(e);
                t.addChild(n),
                e[i.getGuid()] = n
            }
        }
        return t
    }
}
V.EVENT_DESTROY = "destroy";
function Ix(a, e, t, s) {
    if (e instanceof V) {
        const i = e.c;
        for (const o in i) {
            const l = i[o]
              , c = l.system.getPropertiesOfType("entity");
            for (let d = 0, h = c.length; d < h; d++) {
                const f = c[d].name
                  , p = l[f];
                if (!!a.findByGuid(p)) {
                    const m = s[p].getGuid();
                    m && (t.c[o][f] = m)
                }
            }
        }
        i.script && !t._app.useLegacyScriptAttributeCloning && t.script.resolveDuplicatedEntityReferenceProperties(i.script, s),
        i.render && t.render.resolveDuplicatedEntityReferenceProperties(i.render, s),
        i.anim && t.anim.resolveDuplicatedEntityReferenceProperties(i.anim, s);
        const n = e.children.filter(function(o) {
            return o instanceof V
        })
          , r = t.children.filter(function(o) {
            return o instanceof V
        });
        for (let o = 0, l = n.length; o < l; o++)
            Ix(a, n[o], r[o], s)
    }
}
class j0 {
    constructor(e, t) {
        this.name = void 0,
        this.url = void 0,
        this.data = null,
        this._loading = !1,
        this._onLoadedCallbacks = [],
        this.name = e,
        this.url = t
    }
    get loaded() {
        return !!this.data
    }
    get loading() {
        return this._loading
    }
}
class CD {
    constructor(e) {
        this._app = void 0,
        this._list = [],
        this._index = {},
        this._urlIndex = {},
        this._app = e
    }
    destroy() {
        this._app = null
    }
    list() {
        return this._list
    }
    add(e, t) {
        if (this._index.hasOwnProperty(e))
            return !1;
        const s = new j0(e,t)
          , i = this._list.push(s);
        return this._index[s.name] = i - 1,
        this._urlIndex[s.url] = i - 1,
        !0
    }
    find(e) {
        return this._index.hasOwnProperty(e) ? this._list[this._index[e]] : null
    }
    findByUrl(e) {
        return this._urlIndex.hasOwnProperty(e) ? this._list[this._urlIndex[e]] : null
    }
    remove(e) {
        if (this._index.hasOwnProperty(e)) {
            const t = this._index[e];
            let s = this._list[t];
            delete this._urlIndex[s.url],
            delete this._index[e],
            this._list.splice(t, 1);
            for (let i = 0; i < this._list.length; i++)
                s = this._list[i],
                this._index[s.name] = i,
                this._urlIndex[s.url] = i
        }
    }
    _loadSceneData(e, t, s) {
        const i = this._app;
        let n = e;
        if (typeof e == "string" && (e = this.findByUrl(n) || this.find(n) || new j0("Untitled",n)),
        n = e.url,
        !n) {
            s("Cannot find scene to load");
            return
        }
        if (e.loaded) {
            s(null, e);
            return
        }
        i.assets && i.assets.prefix && !Ko.test(n) && (n = ye.join(i.assets.prefix, n)),
        e._onLoadedCallbacks.push(s),
        e._loading || i.loader.getHandler("hierarchy").load(n, (o, l) => {
            e.data = l,
            e._loading = !1;
            for (let c = 0; c < e._onLoadedCallbacks.length; c++)
                e._onLoadedCallbacks[c](o, e);
            t || (e.data = null),
            e._onLoadedCallbacks.length = 0
        }
        ),
        e._loading = !0
    }
    loadSceneData(e, t) {
        this._loadSceneData(e, !0, t)
    }
    unloadSceneData(e) {
        typeof e == "string" && (e = this.findByUrl(e)),
        e && (e.data = null)
    }
    _loadSceneHierarchy(e, t, s) {
        this._loadSceneData(e, !1, (i, n) => {
            if (i) {
                s && s(i);
                return
            }
            t && t(n);
            const r = this._app
              , o = () => {
                const l = r.loader.getHandler("hierarchy");
                r.systems.script.preloading = !0;
                const c = l.open(n.url, n.data);
                r.systems.script.preloading = !1,
                r.loader.clearCache(n.url, "hierarchy"),
                r.root.addChild(c),
                r.systems.fire("initialize", c),
                r.systems.fire("postInitialize", c),
                r.systems.fire("postPostInitialize", c),
                s && s(null, c)
            }
            ;
            r._preloadScripts(n.data, o)
        }
        )
    }
    loadSceneHierarchy(e, t) {
        this._loadSceneHierarchy(e, null, t)
    }
    loadSceneSettings(e, t) {
        this._loadSceneData(e, !1, (s, i) => {
            s ? t && t(s) : (this._app.applySceneSettings(i.data.settings),
            t && t(null))
        }
        )
    }
    changeScene(e, t) {
        const s = this._app
          , i = n => {
            const {children: r} = s.root;
            for (; r.length; )
                r[0].destroy();
            s.applySceneSettings(n.data.settings)
        }
        ;
        this._loadSceneHierarchy(e, i, t)
    }
    loadScene(e, t) {
        const s = this._app
          , i = s.loader.getHandler("scene");
        s.assets && s.assets.prefix && !Ko.test(e) && (e = ye.join(s.assets.prefix, e)),
        i.load(e, (n, r) => {
            if (n)
                t && t(n);
            else {
                const o = () => {
                    s.systems.script.preloading = !0;
                    const l = i.open(e, r)
                      , c = this.findByUrl(e);
                    c && !c.loaded && (c.data = r),
                    s.systems.script.preloading = !1,
                    s.loader.clearCache(e, "scene"),
                    s.loader.patch({
                        resource: l,
                        type: "scene"
                    }, s.assets),
                    s.root.addChild(l.root),
                    s.systems.rigidbody && typeof Ammo < "u" && s.systems.rigidbody.gravity.set(l._gravity.x, l._gravity.y, l._gravity.z),
                    t && t(null, l)
                }
                ;
                s._preloadScripts(r, o)
            }
        }
        )
    }
}
class ED {
    constructor(e) {
        this.frame = {
            fps: 0,
            ms: 0,
            dt: 0,
            updateStart: 0,
            updateTime: 0,
            renderStart: 0,
            renderTime: 0,
            physicsStart: 0,
            physicsTime: 0,
            cullTime: 0,
            sortTime: 0,
            skinTime: 0,
            morphTime: 0,
            instancingTime: 0,
            triangles: 0,
            otherPrimitives: 0,
            shaders: 0,
            materials: 0,
            cameras: 0,
            shadowMapUpdates: 0,
            shadowMapTime: 0,
            depthMapTime: 0,
            forwardTime: 0,
            lightClustersTime: 0,
            lightClusters: 0,
            _timeToCountFrames: 0,
            _fpsAccum: 0
        },
        this.drawCalls = {
            forward: 0,
            depth: 0,
            shadow: 0,
            immediate: 0,
            misc: 0,
            total: 0,
            skinned: 0,
            instanced: 0,
            removedByInstancing: 0
        },
        this.misc = {
            renderTargetCreationTime: 0
        },
        this.particles = {
            updatesPerFrame: 0,
            _updatesPerFrame: 0,
            frameTime: 0,
            _frameTime: 0
        },
        this.shaders = e._shaderStats,
        this.vram = e._vram,
        Object.defineProperty(this.vram, "totalUsed", {
            get: function() {
                return this.tex + this.vb + this.ib
            }
        }),
        Object.defineProperty(this.vram, "geom", {
            get: function() {
                return this.vb + this.ib
            }
        })
    }
    get scene() {
        return Tn().scene._stats
    }
    get lightmapper() {
        var e;
        return (e = Tn().lightmapper) == null ? void 0 : e.stats
    }
    get batcher() {
        const e = Tn()._batcher;
        return e ? e._stats : null
    }
}
let $0 = class {
    constructor(e) {
        this.length = e,
        this.count = 0
    }
    inc() {
        this.count++
    }
    done() {
        return this.count === this.length
    }
}
  , Bi = null;
class ar extends fe {
    constructor(e) {
        super(),
        this.frameRequestId = void 0,
        ar._applications[e.id] = this,
        Fm(this),
        Bi = this,
        this._destroyRequested = !1,
        this._inFrameUpdate = !1,
        this._time = 0,
        this.timeScale = 1,
        this.maxDeltaTime = .1,
        this.frame = 0,
        this.autoRender = !0,
        this.renderNextFrame = !1,
        this.useLegacyScriptAttributeCloning = Xt.legacy,
        this._librariesLoaded = !1,
        this._fillMode = G0,
        this._resolutionMode = oD,
        this._allowResize = !0,
        this.context = this
    }
    init(e) {
        const t = e.graphicsDevice;
        this.graphicsDevice = t,
        this._initDefaultMaterial(),
        this._initProgramLibrary(),
        this.stats = new ED(t),
        this._soundManager = e.soundManager,
        this.loader = new Ao(this),
        this._entityIndex = {},
        this.scene = new cg(t),
        this._registerSceneImmediate(this.scene),
        this.root = new V,
        this.root._enabledInHierarchy = !0,
        this.assets = new Ar(this.loader),
        e.assetPrefix && (this.assets.prefix = e.assetPrefix),
        this.bundles = new _D(this.assets),
        this.enableBundles = typeof TextDecoder < "u",
        this.scriptsOrder = e.scriptsOrder || [],
        this.scripts = new TD(this),
        this.i18n = new bD(this),
        this.scenes = new CD(this),
        this.defaultLayerWorld = new Fi({
            name: "World",
            id: Bn
        }),
        this.defaultLayerDepth = new Fi({
            name: "Depth",
            id: hs,
            enabled: !1,
            opaqueSortMode: Od
        }),
        this.defaultLayerSkybox = new Fi({
            name: "Skybox",
            id: j_,
            opaqueSortMode: Od
        }),
        this.defaultLayerUi = new Fi({
            name: "UI",
            id: Cf,
            transparentSortMode: uA
        }),
        this.defaultLayerImmediate = new Fi({
            name: "Immediate",
            id: $_,
            opaqueSortMode: Od
        });
        const s = new b0("default");
        s.pushOpaque(this.defaultLayerWorld),
        s.pushOpaque(this.defaultLayerDepth),
        s.pushOpaque(this.defaultLayerSkybox),
        s.pushTransparent(this.defaultLayerWorld),
        s.pushOpaque(this.defaultLayerImmediate),
        s.pushTransparent(this.defaultLayerImmediate),
        s.pushTransparent(this.defaultLayerUi),
        this.scene.layers = s,
        qr.createPlaceholder(t),
        this.renderer = new iL(t),
        this.renderer.scene = this.scene,
        this.frameGraph = new lD,
        this.lightmapper = null,
        e.lightmapper && (this.lightmapper = new e.lightmapper(t,this.root,this.scene,this.renderer,this.assets),
        this.once("prerender", this._firstBake, this)),
        this._batcher = null,
        e.batchManager && (this._batcher = new e.batchManager(t,this.root,this.scene),
        this.once("prerender", this._firstBatch, this)),
        this.keyboard = e.keyboard || null,
        this.mouse = e.mouse || null,
        this.touch = e.touch || null,
        this.gamepads = e.gamepads || null,
        this.elementInput = e.elementInput || null,
        this.elementInput && (this.elementInput.app = this),
        this.xr = e.xr ? new e.xr(this) : null,
        this.elementInput && this.elementInput.attachSelectEvents(),
        this._inTools = !1,
        this._skyboxAsset = null,
        this._scriptPrefix = e.scriptPrefix || "",
        this.enableBundles && this.loader.addHandler("bundle", new xD(this)),
        e.resourceHandlers.forEach(i => {
            const n = new i(this);
            this.loader.addHandler(n.handlerType, n)
        }
        ),
        this.systems = new gD,
        e.componentSystems.forEach(i => {
            this.systems.add(new i(this))
        }
        ),
        this._visibilityChangeHandler = this.onVisibilityChange.bind(this),
        typeof document < "u" && (document.hidden !== void 0 ? (this._hiddenAttr = "hidden",
        document.addEventListener("visibilitychange", this._visibilityChangeHandler, !1)) : document.mozHidden !== void 0 ? (this._hiddenAttr = "mozHidden",
        document.addEventListener("mozvisibilitychange", this._visibilityChangeHandler, !1)) : document.msHidden !== void 0 ? (this._hiddenAttr = "msHidden",
        document.addEventListener("msvisibilitychange", this._visibilityChangeHandler, !1)) : document.webkitHidden !== void 0 && (this._hiddenAttr = "webkitHidden",
        document.addEventListener("webkitvisibilitychange", this._visibilityChangeHandler, !1))),
        this.tick = AD(this)
    }
    static getApplication(e) {
        return e ? ar._applications[e] : Tn()
    }
    _initDefaultMaterial() {
        const e = new at;
        e.name = "Default Material",
        e.shadingModel = cc,
        gR(this.graphicsDevice, e)
    }
    _initProgramLibrary() {
        const e = new VL(this.graphicsDevice,new at);
        oR(this.graphicsDevice, e)
    }
    get soundManager() {
        return this._soundManager
    }
    get batcher() {
        return this._batcher
    }
    get fillMode() {
        return this._fillMode
    }
    get resolutionMode() {
        return this._resolutionMode
    }
    configure(e, t) {
        st.get(e, (s, i) => {
            if (s) {
                t(s);
                return
            }
            const n = i.application_properties
              , r = i.scenes
              , o = i.assets;
            this._parseApplicationProperties(n, l => {
                this._parseScenes(r),
                this._parseAssets(o),
                t(l || null)
            }
            )
        }
        )
    }
    preload(e) {
        this.fire("preload:start");
        const t = this.assets.list({
            preload: !0
        })
          , s = new $0(t.length);
        let i = !1;
        const n = () => {
            this.graphicsDevice && !i && s.done() && (i = !0,
            this.fire("preload:end"),
            e())
        }
          , r = t.length;
        if (s.length) {
            const o = c => {
                s.inc(),
                this.fire("preload:progress", s.count / r),
                s.done() && n()
            }
              , l = (c, d) => {
                s.inc(),
                this.fire("preload:progress", s.count / r),
                s.done() && n()
            }
            ;
            for (let c = 0; c < t.length; c++)
                t[c].loaded ? (s.inc(),
                this.fire("preload:progress", s.count / r),
                s.done() && n()) : (t[c].once("load", o),
                t[c].once("error", l),
                this.assets.load(t[c]))
        } else
            n()
    }
    _preloadScripts(e, t) {
        if (!Xt.legacy) {
            t();
            return
        }
        this.systems.script.preloading = !0;
        const s = this._getScriptReferences(e)
          , i = s.length
          , n = new $0(i)
          , r = /^http(s)?:\/\//;
        if (i) {
            const o = (l, c) => {
                l && console.error(l),
                n.inc(),
                n.done() && (this.systems.script.preloading = !1,
                t())
            }
            ;
            for (let l = 0; l < i; l++) {
                let c = s[l];
                !r.test(c.toLowerCase()) && this._scriptPrefix && (c = ye.join(this._scriptPrefix, s[l])),
                this.loader.load(c, "script", o)
            }
        } else
            this.systems.script.preloading = !1,
            t()
    }
    _parseApplicationProperties(e, t) {
        if (typeof e.maxAssetRetries == "number" && e.maxAssetRetries > 0 && this.loader.enableRetry(e.maxAssetRetries),
        e.useDevicePixelRatio || (e.useDevicePixelRatio = e.use_device_pixel_ratio),
        e.resolutionMode || (e.resolutionMode = e.resolution_mode),
        e.fillMode || (e.fillMode = e.fill_mode),
        this._width = e.width,
        this._height = e.height,
        e.useDevicePixelRatio && (this.graphicsDevice.maxPixelRatio = window.devicePixelRatio),
        this.setCanvasResolution(e.resolutionMode, this._width, this._height),
        this.setCanvasFillMode(e.fillMode, this._width, this._height),
        e.layers && e.layerOrder) {
            const s = new b0("application")
              , i = {};
            for (const n in e.layers) {
                const r = e.layers[n];
                r.id = parseInt(n, 10),
                r.enabled = r.id !== hs,
                i[n] = new Fi(r)
            }
            for (let n = 0, r = e.layerOrder.length; n < r; n++) {
                const o = e.layerOrder[n]
                  , l = i[o.layer];
                l && (o.transparent ? s.pushTransparent(l) : s.pushOpaque(l),
                s.subLayerEnabled[n] = o.enabled)
            }
            this.scene.layers = s
        }
        if (e.batchGroups) {
            const s = this.batcher;
            if (s)
                for (let i = 0, n = e.batchGroups.length; i < n; i++) {
                    const r = e.batchGroups[i];
                    s.addGroup(r.name, r.dynamic, r.maxAabbSize, r.id, r.layers)
                }
        }
        e.i18nAssets && (this.i18n.assets = e.i18nAssets),
        this._loadLibraries(e.libraries, t)
    }
    _loadLibraries(e, t) {
        const s = e.length;
        let i = s;
        const n = /^http(s)?:\/\//;
        if (s) {
            const r = (o, l) => {
                i--,
                o ? t(o) : i === 0 && (this.onLibrariesLoaded(),
                t(null))
            }
            ;
            for (let o = 0; o < s; ++o) {
                let l = e[o];
                !n.test(l.toLowerCase()) && this._scriptPrefix && (l = ye.join(this._scriptPrefix, l)),
                this.loader.load(l, "script", r)
            }
        } else
            this.onLibrariesLoaded(),
            t(null)
    }
    _parseScenes(e) {
        if (e)
            for (let t = 0; t < e.length; t++)
                this.scenes.add(e[t].name, e[t].url)
    }
    _parseAssets(e) {
        const t = []
          , s = {}
          , i = {};
        if (Xt.legacy) {
            if (this.enableBundles)
                for (const n in e)
                    e[n].type === "bundle" && (i[n] = !0,
                    t.push(e[n]));
            for (const n in e)
                i[n] || t.push(e[n])
        } else {
            for (let n = 0; n < this.scriptsOrder.length; n++) {
                const r = this.scriptsOrder[n];
                e[r] && (s[r] = !0,
                t.push(e[r]))
            }
            if (this.enableBundles)
                for (const n in e)
                    e[n].type === "bundle" && (i[n] = !0,
                    t.push(e[n]));
            for (const n in e)
                s[n] || i[n] || t.push(e[n])
        }
        for (let n = 0; n < t.length; n++) {
            const r = t[n]
              , o = new le(r.name,r.type,r.file,r.data);
            if (o.id = parseInt(r.id, 10),
            o.preload = r.preload ? r.preload : !1,
            o.loaded = r.type === "script" && r.data && r.data.loadingType > 0,
            o.tags.add(r.tags),
            r.i18n)
                for (const l in r.i18n)
                    o.addLocalizedAssetId(l, r.i18n[l]);
            this.assets.add(o)
        }
    }
    _getScriptReferences(e) {
        let t = [];
        e.settings.priority_scripts && (t = e.settings.priority_scripts);
        const s = []
          , i = {};
        for (let r = 0; r < t.length; r++)
            s.push(t[r]),
            i[t[r]] = !0;
        const n = e.entities;
        for (const r in n) {
            if (!n[r].components.script)
                continue;
            const o = n[r].components.script.scripts;
            for (let l = 0; l < o.length; l++)
                i[o[l].url] || (s.push(o[l].url),
                i[o[l].url] = !0)
        }
        return s
    }
    start() {
        this.frame = 0,
        this.fire("start", {
            timestamp: Hi(),
            target: this
        }),
        this._librariesLoaded || this.onLibrariesLoaded(),
        this.systems.fire("initialize", this.root),
        this.fire("initialize"),
        this.systems.fire("postInitialize", this.root),
        this.systems.fire("postPostInitialize", this.root),
        this.fire("postinitialize"),
        this.tick()
    }
    inputUpdate(e) {
        this.controller && this.controller.update(e),
        this.mouse && this.mouse.update(),
        this.keyboard && this.keyboard.update(),
        this.gamepads && this.gamepads.update()
    }
    update(e) {
        this.frame++,
        this.graphicsDevice.updateClientRect(),
        Xt.legacy && this.systems.fire("fixedUpdate", 1 / 60),
        this.systems.fire(this._inTools ? "toolsUpdate" : "update", e),
        this.systems.fire("animationUpdate", e),
        this.systems.fire("postUpdate", e),
        this.fire("update", e),
        this.inputUpdate(e)
    }
    frameStart() {
        this.graphicsDevice.frameStart()
    }
    frameEnd() {
        this.graphicsDevice.frameEnd()
    }
    render() {
        this.fire("prerender"),
        this.root.syncHierarchy(),
        this._batcher && this._batcher.updateAll(),
        this.renderComposition(this.scene.layers),
        this.fire("postrender")
    }
    renderComposition(e) {
        this.renderer.buildFrameGraph(this.frameGraph, e),
        this.frameGraph.render(this.graphicsDevice)
    }
    _fillFrameStatsBasic(e, t, s) {
        const i = this.stats.frame;
        i.dt = t,
        i.ms = s,
        e > i._timeToCountFrames ? (i.fps = i._fpsAccum,
        i._fpsAccum = 0,
        i._timeToCountFrames = e + 1e3) : i._fpsAccum++,
        this.stats.drawCalls.total = this.graphicsDevice._drawCallsPerFrame,
        this.graphicsDevice._drawCallsPerFrame = 0
    }
    _fillFrameStats() {
        let e = this.stats.frame;
        e.cameras = this.renderer._camerasRendered,
        e.materials = this.renderer._materialSwitches,
        e.shaders = this.graphicsDevice._shaderSwitchesPerFrame,
        e.shadowMapUpdates = this.renderer._shadowMapUpdates,
        e.shadowMapTime = this.renderer._shadowMapTime,
        e.depthMapTime = this.renderer._depthMapTime,
        e.forwardTime = this.renderer._forwardTime;
        const t = this.graphicsDevice._primsPerFrame;
        e.triangles = t[xn] / 3 + Math.max(t[Ks] - 2, 0) + Math.max(t[Zr] - 2, 0),
        e.cullTime = this.renderer._cullTime,
        e.sortTime = this.renderer._sortTime,
        e.skinTime = this.renderer._skinTime,
        e.morphTime = this.renderer._morphTime,
        e.lightClusters = this.renderer._lightClusters,
        e.lightClustersTime = this.renderer._lightClustersTime,
        e.otherPrimitives = 0;
        for (let s = 0; s < t.length; s++)
            s < xn && (e.otherPrimitives += t[s]),
            t[s] = 0;
        this.renderer._camerasRendered = 0,
        this.renderer._materialSwitches = 0,
        this.renderer._shadowMapUpdates = 0,
        this.graphicsDevice._shaderSwitchesPerFrame = 0,
        this.renderer._cullTime = 0,
        this.renderer._layerCompositionUpdateTime = 0,
        this.renderer._lightClustersTime = 0,
        this.renderer._sortTime = 0,
        this.renderer._skinTime = 0,
        this.renderer._morphTime = 0,
        this.renderer._shadowMapTime = 0,
        this.renderer._depthMapTime = 0,
        this.renderer._forwardTime = 0,
        e = this.stats.drawCalls,
        e.forward = this.renderer._forwardDrawCalls,
        e.culled = this.renderer._numDrawCallsCulled,
        e.depth = 0,
        e.shadow = this.renderer._shadowDrawCalls,
        e.skinned = this.renderer._skinDrawCalls,
        e.immediate = 0,
        e.instanced = 0,
        e.removedByInstancing = 0,
        e.misc = e.total - (e.forward + e.shadow),
        this.renderer._depthDrawCalls = 0,
        this.renderer._shadowDrawCalls = 0,
        this.renderer._forwardDrawCalls = 0,
        this.renderer._numDrawCallsCulled = 0,
        this.renderer._skinDrawCalls = 0,
        this.renderer._immediateRendered = 0,
        this.renderer._instancedDrawCalls = 0,
        this.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime,
        e = this.stats.particles,
        e.updatesPerFrame = e._updatesPerFrame,
        e.frameTime = e._frameTime,
        e._updatesPerFrame = 0,
        e._frameTime = 0
    }
    setCanvasFillMode(e, t, s) {
        this._fillMode = e,
        this.resizeCanvas(t, s)
    }
    setCanvasResolution(e, t, s) {
        this._resolutionMode = e,
        e === Om && t === void 0 && (t = this.graphicsDevice.canvas.clientWidth,
        s = this.graphicsDevice.canvas.clientHeight),
        this.graphicsDevice.resizeCanvas(t, s)
    }
    isHidden() {
        return document[this._hiddenAttr]
    }
    onVisibilityChange() {
        this.isHidden() ? this._soundManager && this._soundManager.suspend() : this._soundManager && this._soundManager.resume()
    }
    resizeCanvas(e, t) {
        if (!this._allowResize || this.xr && this.xr.session)
            return;
        const s = window.innerWidth
          , i = window.innerHeight;
        if (this._fillMode === G0) {
            const n = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height
              , r = s / i;
            n > r ? (e = s,
            t = e / n) : (t = i,
            e = t * n)
        } else
            this._fillMode === aD && (e = s,
            t = i);
        return this.graphicsDevice.canvas.style.width = e + "px",
        this.graphicsDevice.canvas.style.height = t + "px",
        this.updateCanvasSize(),
        {
            width: e,
            height: t
        }
    }
    updateCanvasSize() {
        var e;
        if (!(!this._allowResize || (e = this.xr) != null && e.active) && this._resolutionMode === Om) {
            const t = this.graphicsDevice.canvas;
            this.graphicsDevice.resizeCanvas(t.clientWidth, t.clientHeight)
        }
    }
    onLibrariesLoaded() {
        this._librariesLoaded = !0,
        this.systems.rigidbody && this.systems.rigidbody.onLibraryLoaded()
    }
    applySceneSettings(e) {
        let t;
        if (this.systems.rigidbody && typeof Ammo < "u") {
            const s = e.physics.gravity;
            this.systems.rigidbody.gravity.set(s[0], s[1], s[2])
        }
        this.scene.applySettings(e),
        e.render.hasOwnProperty("skybox") && (e.render.skybox ? (t = this.assets.get(e.render.skybox),
        t ? this.setSkybox(t) : this.assets.once("add:" + e.render.skybox, this.setSkybox, this)) : this.setSkybox(null))
    }
    setAreaLightLuts(e, t) {
        e && t && qr.set(this.graphicsDevice, e, t)
    }
    setSkybox(e) {
        if (e !== this._skyboxAsset) {
            const t = () => {
                this.setSkybox(null)
            }
              , s = () => {
                this.scene.setSkybox(this._skyboxAsset ? this._skyboxAsset.resources : null)
            }
            ;
            this._skyboxAsset && (this.assets.off("load:" + this._skyboxAsset.id, s, this),
            this.assets.off("remove:" + this._skyboxAsset.id, t, this),
            this._skyboxAsset.off("change", s, this)),
            this._skyboxAsset = e,
            this._skyboxAsset && (this.assets.on("load:" + this._skyboxAsset.id, s, this),
            this.assets.once("remove:" + this._skyboxAsset.id, t, this),
            this._skyboxAsset.on("change", s, this),
            this.scene.skyboxMip === 0 && !this._skyboxAsset.loadFaces && (this._skyboxAsset.loadFaces = !0),
            this.assets.load(this._skyboxAsset)),
            s()
        }
    }
    _firstBake() {
        var e;
        (e = this.lightmapper) == null || e.bake(null, this.scene.lightmapMode)
    }
    _firstBatch() {
        var e;
        (e = this.batcher) == null || e.generate()
    }
    _processTimestamp(e) {
        return e
    }
    drawLine(e, t, s, i, n) {
        this.scene.drawLine(e, t, s, i, n)
    }
    drawLines(e, t, s=!0, i=this.scene.defaultDrawLayer) {
        this.scene.drawLines(e, t, s, i)
    }
    drawLineArrays(e, t, s=!0, i=this.scene.defaultDrawLayer) {
        this.scene.drawLineArrays(e, t, s, i)
    }
    drawWireSphere(e, t, s=z.WHITE, i=20, n=!0, r=this.scene.defaultDrawLayer) {
        this.scene.immediate.drawWireSphere(e, t, s, i, n, r)
    }
    drawWireAlignedBox(e, t, s=z.WHITE, i=!0, n=this.scene.defaultDrawLayer) {
        this.scene.immediate.drawWireAlignedBox(e, t, s, i, n)
    }
    drawMeshInstance(e, t=this.scene.defaultDrawLayer) {
        this.scene.immediate.drawMesh(null, null, null, e, t)
    }
    drawMesh(e, t, s, i=this.scene.defaultDrawLayer) {
        this.scene.immediate.drawMesh(t, s, e, null, i)
    }
    drawQuad(e, t, s=this.scene.defaultDrawLayer) {
        this.scene.immediate.drawMesh(t, e, this.scene.immediate.getQuadMesh(), null, s)
    }
    drawTexture(e, t, s, i, n, r, o=this.scene.defaultDrawLayer, l=!0) {
        if (l === !1 && !this.graphicsDevice.isWebGPU)
            return;
        const c = new ee;
        c.setTRS(new y(e,t,0), ne.IDENTITY, new y(s,-i,0)),
        r || (r = new Yi,
        r.cull = bt,
        r.setParameter("colorMap", n),
        r.shader = l ? this.scene.immediate.getTextureShader() : this.scene.immediate.getUnfilterableTextureShader(),
        r.update()),
        this.drawQuad(c, r, o)
    }
    drawDepthTexture(e, t, s, i, n=this.scene.defaultDrawLayer) {
        const r = new Yi;
        r.cull = bt,
        r.shader = this.scene.immediate.getDepthTextureShader(),
        r.update(),
        this.drawTexture(e, t, s, i, null, r, n)
    }
    destroy() {
        var e, t, s, i;
        if (this._inFrameUpdate) {
            this._destroyRequested = !0;
            return
        }
        const n = this.graphicsDevice.canvas.id;
        this.fire("destroy", this),
        this.off("librariesloaded"),
        typeof document < "u" && (document.removeEventListener("visibilitychange", this._visibilityChangeHandler, !1),
        document.removeEventListener("mozvisibilitychange", this._visibilityChangeHandler, !1),
        document.removeEventListener("msvisibilitychange", this._visibilityChangeHandler, !1),
        document.removeEventListener("webkitvisibilitychange", this._visibilityChangeHandler, !1)),
        this._visibilityChangeHandler = null,
        this.root.destroy(),
        this.root = null,
        this.mouse && (this.mouse.off(),
        this.mouse.detach(),
        this.mouse = null),
        this.keyboard && (this.keyboard.off(),
        this.keyboard.detach(),
        this.keyboard = null),
        this.touch && (this.touch.off(),
        this.touch.detach(),
        this.touch = null),
        this.elementInput && (this.elementInput.detach(),
        this.elementInput = null),
        this.gamepads && (this.gamepads.destroy(),
        this.gamepads = null),
        this.controller && (this.controller = null),
        this.systems.destroy(),
        this.scene.layers && this.scene.layers.destroy();
        const r = this.assets.list();
        for (let l = 0; l < r.length; l++)
            r[l].unload(),
            r[l].off();
        this.assets.off(),
        this.bundles.destroy(),
        this.bundles = null,
        this.i18n.destroy(),
        this.i18n = null;
        const o = this.loader.getHandler("script");
        o == null || o.clearCache(),
        this.loader.destroy(),
        this.loader = null,
        this.scene.destroy(),
        this.scene = null,
        this.systems = null,
        this.context = null,
        this.scripts.destroy(),
        this.scripts = null,
        this.scenes.destroy(),
        this.scenes = null,
        (e = this.lightmapper) == null || e.destroy(),
        this.lightmapper = null,
        this._batcher && (this._batcher.destroy(),
        this._batcher = null),
        this._entityIndex = {},
        this.defaultLayerDepth.onPreRenderOpaque = null,
        this.defaultLayerDepth.onPostRenderOpaque = null,
        this.defaultLayerDepth.onDisable = null,
        this.defaultLayerDepth.onEnable = null,
        this.defaultLayerDepth = null,
        this.defaultLayerWorld = null,
        (t = this.xr) == null || t.end(),
        (s = this.xr) == null || s.destroy(),
        this.renderer.destroy(),
        this.renderer = null,
        this.graphicsDevice.destroy(),
        this.graphicsDevice = null,
        this.tick = null,
        this.off(),
        (i = this._soundManager) == null || i.destroy(),
        this._soundManager = null,
        Xt.app = null,
        ar._applications[n] = null,
        Tn() === this && Fm(null),
        ar.cancelTick(this)
    }
    static cancelTick(e) {
        e.frameRequestId && (window.cancelAnimationFrame(e.frameRequestId),
        e.frameRequestId = void 0)
    }
    getEntityFromIndex(e) {
        return this._entityIndex[e]
    }
    _registerSceneImmediate(e) {
        this.on("postrender", e.immediate.onPostRender, e.immediate)
    }
}
ar._applications = {};
const Ap = {}
  , AD = function(e) {
    const t = e;
    return function(s, i) {
        var n;
        if (!t.graphicsDevice)
            return;
        t.frameRequestId = null,
        t._inFrameUpdate = !0,
        Fm(t),
        Bi = t;
        const r = t._processTimestamp(s) || Hi()
          , o = r - (t._time || r);
        let l = o / 1e3;
        if (l = W.clamp(l, 0, t.maxDeltaTime),
        l *= t.timeScale,
        t._time = r,
        (n = t.xr) != null && n.session ? t.frameRequestId = t.xr.session.requestAnimationFrame(t.tick) : t.frameRequestId = Le.browser ? window.requestAnimationFrame(t.tick) : null,
        t.graphicsDevice.contextLost)
            return;
        t._fillFrameStatsBasic(r, l, o),
        t.fire("frameupdate", o);
        let c = !0;
        if (i) {
            var d;
            c = (d = t.xr) == null ? void 0 : d.update(i),
            t.graphicsDevice.defaultFramebuffer = i.session.renderState.baseLayer.framebuffer
        } else
            t.graphicsDevice.defaultFramebuffer = null;
        c && (t.update(l),
        t.fire("framerender"),
        (t.autoRender || t.renderNextFrame) && (t.updateCanvasSize(),
        t.frameStart(),
        t.render(),
        t.frameEnd(),
        t.renderNextFrame = !1),
        Ap.timestamp = Hi(),
        Ap.target = t,
        t.fire("frameend", Ap)),
        t._inFrameUpdate = !1,
        t._destroyRequested && t.destroy()
    }
};
class MD {
    constructor() {
        this.elementInput = void 0,
        this.keyboard = void 0,
        this.mouse = void 0,
        this.touch = void 0,
        this.gamepads = void 0,
        this.scriptPrefix = void 0,
        this.assetPrefix = void 0,
        this.scriptsOrder = void 0,
        this.soundManager = void 0,
        this.graphicsDevice = void 0,
        this.lightmapper = void 0,
        this.batchManager = void 0,
        this.xr = void 0,
        this.componentSystems = [],
        this.resourceHandlers = []
    }
}
const Al = new b_;
class Lx {
    constructor(e, t) {
        this.scene = e,
        this.light = t,
        this.store(),
        t.numCascades = 1,
        t.type !== pe && (t._node.getWorldTransform(),
        t.getBoundingSphere(Al),
        this.lightBounds = new Pe,
        this.lightBounds.center.copy(Al.center),
        this.lightBounds.halfExtents.set(Al.radius, Al.radius, Al.radius))
    }
    store() {
        this.mask = this.light.mask,
        this.shadowUpdateMode = this.light.shadowUpdateMode,
        this.enabled = this.light.enabled,
        this.intensity = this.light.intensity,
        this.rotation = this.light._node.getLocalRotation().clone(),
        this.numCascades = this.light.numCascades
    }
    restore() {
        const e = this.light;
        e.mask = this.mask,
        e.shadowUpdateMode = this.shadowUpdateMode,
        e.enabled = this.enabled,
        e.intensity = this.intensity,
        e._node.setLocalRotation(this.rotation),
        e.numCascades = this.numCascades
    }
    startBake() {
        this.light.enabled = !0,
        this.light._destroyShadowMap(),
        this.light.beginFrame()
    }
    endBake(e) {
        const t = this.light;
        t.enabled = !1,
        t.shadowMap && (t.shadowMap.cached && e.add(t, t.shadowMap),
        t.shadowMap = null)
    }
}
const rd = new P;
class PD extends Lx {
    get numVirtualLights() {
        return this.light.type === pe ? this.light.bakeNumSamples : 1
    }
    prepareVirtualLight(e, t) {
        const s = this.light;
        if (s._node.setLocalRotation(this.rotation),
        e > 0) {
            const r = s.bakeArea;
            yc.circlePointDeterministic(rd, e, t),
            rd.mulScalar(r * .5),
            s._node.rotateLocal(rd.x, 0, rd.y)
        }
        s._node.getWorldTransform();
        const i = this.scene.gammaCorrection ? 2.2 : 1
          , n = Math.pow(this.intensity, i);
        s.intensity = Math.pow(n / t, 1 / i)
    }
}
const q0 = new y;
class Y0 extends Lx {
    constructor(e) {
        const t = new V("AmbientLight");
        t.addComponent("light", {
            type: "directional",
            affectDynamic: !0,
            affectLightmapped: !1,
            bake: !0,
            bakeNumSamples: e.ambientBakeNumSamples,
            castShadows: !0,
            normalOffsetBias: .05,
            shadowBias: .2,
            shadowDistance: 1,
            shadowResolution: 2048,
            shadowType: St,
            color: z.WHITE,
            intensity: 1,
            bakeDir: !1
        }),
        super(e, t.light.light)
    }
    get numVirtualLights() {
        return this.light.bakeNumSamples
    }
    prepareVirtualLight(e, t) {
        yc.spherePointDeterministic(q0, e, t, 0, this.scene.ambientBakeSpherePart),
        this.light._node.lookAt(q0.mulScalar(-1)),
        this.light._node.rotateLocal(90, 0, 0);
        const s = this.scene.gammaCorrection ? 2.2 : 1
          , i = 2 * Math.PI * this.scene.ambientBakeSpherePart
          , n = Math.pow(i, s);
        this.light.intensity = Math.pow(n / t, 1 / s)
    }
}
class ad {
    constructor(e, t=null) {
        this.node = e,
        this.component = e.render || e.model,
        t = t || this.component.meshInstances,
        this.store(),
        this.meshInstances = t,
        this.bounds = null,
        this.renderTargets = []
    }
    store() {
        this.castShadows = this.component.castShadows
    }
    restore() {
        this.component.castShadows = this.castShadows
    }
}
const K0 = 15;
class RD {
    constructor(e) {
        this.device = e,
        this.shaderDilate = Ys(e, $.fullscreenQuadVS, hu.dilatePS, "lmDilate"),
        this.constantTexSource = e.scope.resolve("source"),
        this.constantPixelOffset = e.scope.resolve("pixelOffset"),
        this.pixelOffset = new Float32Array(2),
        this.shaderDenoise = null,
        this.sigmas = null,
        this.constantSigmas = null,
        this.kernel = null
    }
    setSourceTexture(e) {
        this.constantTexSource.setValue(e)
    }
    prepare(e, t) {
        this.pixelOffset[0] = 1 / e,
        this.pixelOffset[1] = 1 / t,
        this.constantPixelOffset.setValue(this.pixelOffset)
    }
    prepareDenoise(e, t) {
        this.shaderDenoise || (this.shaderDenoise = Ys(this.device, $.fullscreenQuadVS, hu.bilateralDeNoisePS, "lmBilateralDeNoise"),
        this.sigmas = new Float32Array(2),
        this.constantSigmas = this.device.scope.resolve("sigmas"),
        this.constantKernel = this.device.scope.resolve("kernel[0]"),
        this.bZnorm = this.device.scope.resolve("bZnorm")),
        this.sigmas[0] = e,
        this.sigmas[1] = t,
        this.constantSigmas.setValue(this.sigmas),
        this.evaluateDenoiseUniforms(e, t)
    }
    evaluateDenoiseUniforms(e, t) {
        function s(o, l) {
            return .39894 * Math.exp(-.5 * o * o / (l * l)) / l
        }
        this.kernel = this.kernel || new Float32Array(K0);
        const i = this.kernel
          , n = Math.floor((K0 - 1) / 2);
        for (let o = 0; o <= n; ++o) {
            const l = s(o, e);
            i[n + o] = l,
            i[n - o] = l
        }
        this.constantKernel.setValue(this.kernel);
        const r = 1 / s(0, t);
        this.bZnorm.setValue(r)
    }
}
class ID extends Js {
    constructor(e, t, s, i, n, r) {
        super(e),
        this.viewBindGroups = [],
        this.renderer = t,
        this.camera = s,
        this.worldClusters = i,
        this.receivers = n,
        this.lightArray = r
    }
    destroy() {
        this.viewBindGroups.forEach(e => {
            e.defaultUniformBuffer.destroy(),
            e.destroy()
        }
        ),
        this.viewBindGroups.length = 0
    }
    execute() {
        const e = this.device
          , {renderer: t, camera: s, receivers: i, renderTarget: n, worldClusters: r, lightArray: o} = this;
        r && r.activate(),
        t.setCameraUniforms(s, n),
        e.supportsUniformBuffers && t.setupViewUniformBuffers(this.viewBindGroups, t.viewUniformFormat, t.viewBindGroupFormat, 1),
        t._forwardTime = 0,
        t._shadowMapTime = 0,
        t.renderForward(s, i, o, $i)
    }
}
const LD = 2048
  , DD = 0
  , OD = 1
  , od = new y;
class FD {
    constructor(e, t, s, i, n) {
        this.device = e,
        this.root = t,
        this.scene = s,
        this.renderer = i,
        this.assets = n,
        this.shadowMapCache = i.shadowMapCache,
        this._tempSet = new Set,
        this._initCalled = !1,
        this.passMaterials = [],
        this.ambientAOMaterial = null,
        this.fog = "",
        this.ambientLight = new z,
        this.renderTargets = new Map,
        this.stats = {
            renderPasses: 0,
            lightmapCount: 0,
            totalRenderTime: 0,
            forwardTime: 0,
            fboTime: 0,
            shadowMapTime: 0,
            compileTime: 0,
            shadersLinked: 0
        }
    }
    destroy() {
        var e;
        pn.decRef(this.blackTex),
        this.blackTex = null,
        pn.destroy(),
        this.device = null,
        this.root = null,
        this.scene = null,
        this.renderer = null,
        this.assets = null,
        (e = this.camera) == null || e.destroy(),
        this.camera = null
    }
    initBake(e) {
        if (!this._initCalled) {
            this._initCalled = !0,
            this.lightmapFilters = new RD(e),
            this.constantBakeDir = e.scope.resolve("bakeDir"),
            this.materials = [],
            this.blackTex = new ge(this.device,{
                width: 4,
                height: 4,
                format: ve,
                type: pr,
                name: "lightmapBlack"
            }),
            pn.incRef(this.blackTex);
            const t = new rg;
            t.clearColor.set(0, 0, 0, 0),
            t.clearColorBuffer = !0,
            t.clearDepthBuffer = !1,
            t.clearStencilBuffer = !1,
            t.frustumCulling = !1,
            t.projection = Co,
            t.aspectRatio = 1,
            t.node = new yt,
            this.camera = t
        }
        if (this.scene.clusteredLightingEnabled) {
            const t = new xx(e.supportsAreaLights,e.maxTextureSize, () => {}
            );
            this.lightingParams = t;
            const s = this.scene.lighting;
            t.shadowsEnabled = s.shadowsEnabled,
            t.shadowAtlasResolution = s.shadowAtlasResolution,
            t.cookiesEnabled = s.cookiesEnabled,
            t.cookieAtlasResolution = s.cookieAtlasResolution,
            t.areaLightsEnabled = s.areaLightsEnabled,
            t.cells = new y(3,3,3),
            t.maxLightsPerCell = 4,
            this.worldClusters = new Rm(e),
            this.worldClusters.name = "ClusterLightmapper"
        }
    }
    finishBake(e) {
        this.materials = [];
        function t(s) {
            pn.decRef(s.colorBuffer),
            s.destroy()
        }
        this.renderTargets.forEach(s => {
            t(s)
        }
        ),
        this.renderTargets.clear(),
        e.forEach(s => {
            s.renderTargets.forEach(i => {
                t(i)
            }
            ),
            s.renderTargets.length = 0
        }
        ),
        this.ambientAOMaterial = null,
        this.worldClusters && (this.worldClusters.destroy(),
        this.worldClusters = null)
    }
    createMaterialForPass(e, t, s, i) {
        const n = new at;
        n.name = `lmMaterial-pass:${s}-ambient:${i}`,
        n.chunks.APIVersion = $T;
        const r = `#define UV1LAYOUT
`;
        if (n.chunks.transformVS = r + $.transformVS,
        s === DD) {
            let o = hu.bakeLmEndPS;
            i ? o = `
										dDiffuseLight = ((dDiffuseLight - 0.5) * max(${t.ambientBakeOcclusionContrast.toFixed(1)} + 1.0, 0.0)) + 0.5;
										dDiffuseLight += vec3(${t.ambientBakeOcclusionBrightness.toFixed(1)});
										dDiffuseLight = saturate(dDiffuseLight);
										dDiffuseLight *= dAmbientLight;
								` + o : (n.ambient = new z(0,0,0),
            n.ambientTint = !0),
            n.chunks.basePS = $.basePS + (t.lightmapPixelFormat === ve ? `
#define LIGHTMAP_RGBM
` : ""),
            n.chunks.endPS = o,
            n.lightMap = this.blackTex
        } else
            n.chunks.basePS = $.basePS + `
uniform sampler2D texture_dirLightMap;
uniform float bakeDir;
`,
            n.chunks.endPS = hu.bakeDirLmEndPS;
        return n.chunks.outputAlphaPS = `
`,
        n.chunks.outputAlphaOpaquePS = `
`,
        n.chunks.outputAlphaPremulPS = `
`,
        n.cull = bt,
        n.forceUv1 = !0,
        n.update(),
        n
    }
    createMaterials(e, t, s) {
        for (let i = 0; i < s; i++)
            this.passMaterials[i] || (this.passMaterials[i] = this.createMaterialForPass(e, t, i, !1));
        this.ambientAOMaterial || (this.ambientAOMaterial = this.createMaterialForPass(e, t, 0, !0),
        this.ambientAOMaterial.onUpdateShader = function(i) {
            return i.litOptions.lightMapWithoutAmbient = !0,
            i.litOptions.separateAmbient = !0,
            i
        }
        )
    }
    createTexture(e, t) {
        return new ge(this.device,{
            width: e,
            height: e,
            format: this.scene.lightmapPixelFormat,
            mipmaps: !1,
            type: this.scene.lightmapPixelFormat === ve ? pr : $s,
            minFilter: be,
            magFilter: be,
            addressU: oe,
            addressV: oe,
            name: t
        })
    }
    collectModels(e, t, s) {
        var i, n, r;
        if (!e.enabled)
            return;
        let o;
        if ((i = e.model) != null && i.model && (n = e.model) != null && n.enabled && (s && s.push(new ad(e)),
        e.model.lightmapped && t && (o = e.model.model.meshInstances)),
        (r = e.render) != null && r.enabled && (s && s.push(new ad(e)),
        e.render.lightmapped && t && (o = e.render.meshInstances)),
        o) {
            let l = !0;
            for (let c = 0; c < o.length; c++)
                if (!o[c].mesh.vertexBuffer.format.hasUv1) {
                    l = !1;
                    break
                }
            if (l) {
                const c = [];
                for (let d = 0; d < o.length; d++) {
                    const h = o[d].mesh;
                    this._tempSet.has(h) ? t.push(new ad(e,[o[d]])) : c.push(o[d]),
                    this._tempSet.add(h)
                }
                this._tempSet.clear(),
                c.length > 0 && t.push(new ad(e,c))
            }
        }
        for (let l = 0; l < e._children.length; l++)
            this.collectModels(e._children[l], t, s)
    }
    prepareShadowCasters(e) {
        const t = [];
        for (let s = 0; s < e.length; s++) {
            const i = e[s].component;
            if (i.castShadows = i.castShadowsLightmap,
            i.castShadowsLightmap) {
                const n = e[s].meshInstances;
                for (let r = 0; r < n.length; r++)
                    n[r].visibleThisFrame = !0,
                    t.push(n[r])
            }
        }
        return t
    }
    updateTransforms(e) {
        for (let t = 0; t < e.length; t++) {
            const s = e[t].meshInstances;
            for (let i = 0; i < s.length; i++)
                s[i].node.getWorldTransform()
        }
    }
    calculateLightmapSize(e) {
        let t;
        const s = this.scene.lightmapSizeMultiplier || 16
          , i = od;
        let n, r;
        e.model ? (r = e.model.lightmapSizeMultiplier,
        e.model.asset ? (t = this.assets.get(e.model.asset).data,
        t.area && (n = t.area)) : e.model._area && (t = e.model,
        t._area && (n = t._area))) : e.render && (r = e.render.lightmapSizeMultiplier,
        e.render.type !== "asset" && e.render._area && (t = e.render,
        t._area && (n = t._area)));
        const o = {
            x: 1,
            y: 1,
            z: 1,
            uv: 1
        };
        n && (o.x = n.x,
        o.y = n.y,
        o.z = n.z,
        o.uv = n.uv);
        const l = r || 1;
        o.x *= l,
        o.y *= l,
        o.z *= l;
        const c = e.render || e.model
          , d = this.computeNodeBounds(c.meshInstances);
        i.copy(d.halfExtents);
        let h = o.x * i.y * i.z + o.y * i.x * i.z + o.z * i.x * i.y;
        return h /= o.uv,
        h = Math.sqrt(h),
        Math.min(W.nextPowerOfTwo(h * s), this.scene.lightmapMaxResolution || LD)
    }
    setLightmapping(e, t, s, i) {
        for (let n = 0; n < e.length; n++) {
            const r = e[n]
              , o = r.meshInstances;
            for (let l = 0; l < o.length; l++) {
                const c = o[l];
                if (c.setLightmapped(t),
                t) {
                    i && (c._shaderDefs |= i),
                    c.mask = Ui;
                    for (let d = 0; d < s; d++) {
                        const h = r.renderTargets[d].colorBuffer;
                        h.minFilter = ot,
                        h.magFilter = ot,
                        c.setRealtimeLightmap(Fe.lightmapParamNames[d], h)
                    }
                }
            }
        }
    }
    bake(e, t=Dd) {
        const s = this.device
          , i = Hi();
        this.scene._updateSkyMesh(),
        this.stats.renderPasses = 0,
        this.stats.shadowMapTime = 0,
        this.stats.forwardTime = 0;
        const n = s._shaderStats.linked
          , r = s._renderTargetCreationTime
          , o = s._shaderStats.compileTime
          , l = []
          , c = [];
        if (e) {
            for (let h = 0; h < e.length; h++)
                this.collectModels(e[h], l, null);
            this.collectModels(this.root, null, c)
        } else
            this.collectModels(this.root, l, c);
        if (l.length > 0) {
            this.renderer.shadowRenderer.frameUpdate();
            const h = t === Dd ? 2 : 1;
            this.setLightmapping(l, !1, h),
            this.initBake(s),
            this.bakeInternal(h, l, c);
            let u = ru;
            t === Dd && (u |= Q_),
            this.scene.ambientBake && (u |= eg),
            this.setLightmapping(l, !0, h, u),
            this.finishBake(l)
        }
        const d = Hi();
        this.stats.totalRenderTime = d - i,
        this.stats.shadersLinked = s._shaderStats.linked - n,
        this.stats.compileTime = s._shaderStats.compileTime - o,
        this.stats.fboTime = s._renderTargetCreationTime - r,
        this.stats.lightmapCount = l.length
    }
    allocateTextures(e, t) {
        for (let s = 0; s < e.length; s++) {
            const i = e[s]
              , n = this.calculateLightmapSize(i.node);
            for (let r = 0; r < t; r++) {
                const o = this.createTexture(n, "lightmapper_lightmap_" + s);
                pn.incRef(o),
                i.renderTargets[r] = new It({
                    colorBuffer: o,
                    depth: !1
                })
            }
            if (!this.renderTargets.has(n)) {
                const r = this.createTexture(n, "lightmapper_temp_lightmap_" + n);
                pn.incRef(r),
                this.renderTargets.set(n, new It({
                    colorBuffer: r,
                    depth: !1
                }))
            }
        }
    }
    prepareLightsToBake(e, t, s) {
        if (this.scene.ambientBake) {
            const n = new Y0(this.scene);
            s.push(n)
        }
        const i = this.renderer.lights;
        for (let n = 0; n < i.length; n++) {
            const r = i[n]
              , o = new PD(this.scene,r);
            t.push(o),
            r.enabled && r.mask & zi && (r.mask = zi | Ui | Rs,
            r.shadowUpdateMode = r.type === pe ? tg : ga,
            s.push(o))
        }
        s.sort()
    }
    restoreLights(e) {
        for (let t = 0; t < e.length; t++)
            e[t].restore()
    }
    setupScene() {
        this.fog = this.scene.fog,
        this.ambientLight.copy(this.scene.ambientLight),
        this.scene.fog = Tf,
        this.scene.ambientBake || this.scene.ambientLight.set(0, 0, 0),
        this.renderer.setSceneConstants()
    }
    restoreScene() {
        this.scene.fog = this.fog,
        this.scene.ambientLight.copy(this.ambientLight)
    }
    computeNodeBounds(e) {
        const t = new Pe;
        if (e.length > 0) {
            t.copy(e[0].aabb);
            for (let s = 1; s < e.length; s++)
                t.add(e[s].aabb)
        }
        return t
    }
    computeNodesBounds(e) {
        for (let t = 0; t < e.length; t++) {
            const s = e[t].meshInstances;
            e[t].bounds = this.computeNodeBounds(s)
        }
    }
    computeBounds(e) {
        const t = new Pe;
        for (let s = 0; s < e.length; s++) {
            t.copy(e[0].aabb);
            for (let i = 1; i < e.length; i++)
                t.add(e[i].aabb)
        }
        return t
    }
    backupMaterials(e) {
        for (let t = 0; t < e.length; t++)
            this.materials[t] = e[t].material
    }
    restoreMaterials(e) {
        for (let t = 0; t < e.length; t++)
            e[t].material = this.materials[t]
    }
    lightCameraPrepare(e, t) {
        const s = t.light;
        let i;
        return s.type === He && (i = s.getRenderData(null, 0).shadowCamera,
        i._node.setPosition(s._node.getPosition()),
        i._node.setRotation(s._node.getRotation()),
        i._node.rotateLocal(-90, 0, 0),
        i.projection = Di,
        i.nearClip = s.attenuationEnd / 1e3,
        i.farClip = s.attenuationEnd,
        i.aspectRatio = 1,
        i.fov = s._outerConeAngle * 2,
        this.renderer.updateCameraFrustum(i)),
        i
    }
    lightCameraPrepareAndCull(e, t, s, i) {
        const n = e.light;
        let r = !0;
        if (n.type === pe) {
            od.copy(i.center),
            od.y += i.halfExtents.y,
            this.camera.node.setPosition(od),
            this.camera.node.setEulerAngles(-90, 0, 0),
            this.camera.nearClip = 0,
            this.camera.farClip = i.halfExtents.y * 2;
            const o = Math.max(i.halfExtents.x, i.halfExtents.z);
            this.camera.orthoHeight = o
        } else
            e.lightBounds.intersects(t.bounds) || (r = !1);
        if (n.type === He) {
            let o = !1;
            const l = t.meshInstances;
            for (let c = 0; c < l.length; c++)
                if (l[c]._isVisible(s)) {
                    o = !0;
                    break
                }
            o || (r = !1)
        }
        return r
    }
    setupLightArray(e, t) {
        e[pe].length = 0,
        e[Oe].length = 0,
        e[He].length = 0,
        e[t.type][0] = t,
        t.visibleThisFrame = !0
    }
    renderShadowMap(e, t, s, i) {
        const n = i.light
          , r = this.scene.clusteredLightingEnabled
          , o = n.castShadows && (!r || this.scene.lighting.shadowsEnabled);
        if (!t && o)
            if (!n.shadowMap && !r && (n.shadowMap = this.shadowMapCache.get(this.device, n)),
            n.type === pe) {
                this.renderer._shadowRendererDirectional.cull(n, e, this.camera, s);
                const l = this.renderer._shadowRendererDirectional.getLightRenderPass(n, this.camera);
                l == null || l.render()
            } else {
                if (this.device.isWebGPU)
                    return !0;
                this.renderer._shadowRendererLocal.cull(n, e, s),
                this.renderer.shadowRenderer.render(n, this.camera, !1)
            }
        return !0
    }
    postprocessTextures(e, t, s) {
        const n = this.lightmapFilters.shaderDilate
          , r = this.scene.lightmapFilterEnabled;
        r && this.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange, this.scene.lightmapFilterSmoothness),
        e.setBlendState(ft.NOBLEND),
        e.setDepthState($t.NODEPTH),
        e.setStencilState(null, null);
        for (let o = 0; o < t.length; o++) {
            const l = t[o];
            for (let c = 0; c < s; c++) {
                const d = l.renderTargets[c]
                  , h = d.colorBuffer
                  , u = this.renderTargets.get(h.width)
                  , f = u.colorBuffer;
                this.lightmapFilters.prepare(h.width, h.height);
                for (let p = 0; p < 1; p++)
                    this.lightmapFilters.setSourceTexture(h),
                    ya(e, u, r && c === 0 && p === 0 ? this.lightmapFilters.shaderDenoise : n),
                    this.lightmapFilters.setSourceTexture(f),
                    ya(e, d, n)
            }
        }
    }
    bakeInternal(e, t, s) {
        const i = this.scene
          , n = i.layers
          , r = this.device
          , o = i.clusteredLightingEnabled;
        this.createMaterials(r, i, e),
        this.setupScene(),
        n._update(),
        this.computeNodesBounds(t),
        this.allocateTextures(t, e),
        this.renderer.collectLights(n);
        const l = []
          , c = [];
        this.prepareLightsToBake(n, l, c),
        this.updateTransforms(s);
        const d = this.prepareShadowCasters(s);
        this.renderer.updateCpuSkinMatrices(d),
        this.renderer.gpuUpdate(d);
        const h = this.computeBounds(d);
        let u, f, p, _;
        for (u = 0; u < t.length; u++)
            for (p = t[u].meshInstances,
            f = 0; f < p.length; f++)
                _ = p[f],
                _.setLightmapped(!1),
                _.mask = zi,
                _.setRealtimeLightmap(Fe.lightmapParamNames[0], _.material.lightMap ? _.material.lightMap : this.blackTex),
                _.setRealtimeLightmap(Fe.lightmapParamNames[1], this.blackTex);
        for (f = 0; f < c.length; f++)
            c[f].light.enabled = !1;
        const m = [[], [], []];
        let g, v, x = !1;
        for (u = 0; u < c.length; u++) {
            const S = c[u]
              , w = S instanceof Y0
              , T = S.light.type === pe;
            let b = S.numVirtualLights;
            e > 1 && b > 1 && S.light.bakeDir && (b = 1);
            for (let E = 0; E < b; E++) {
                b > 1 && S.prepareVirtualLight(E, b),
                S.startBake();
                let C = !1;
                const R = this.lightCameraPrepare(r, S);
                for (v = 0; v < t.length; v++) {
                    const F = t[v];
                    if (p = F.meshInstances,
                    !this.lightCameraPrepareAndCull(S, F, R, h))
                        continue;
                    this.setupLightArray(m, S.light);
                    const U = T ? [] : [S.light];
                    for (o && this.renderer.lightTextureAtlas.update(U, this.lightingParams),
                    C = this.renderShadowMap(n, C, d, S),
                    o && this.worldClusters.update(U, this.scene.gammaCorrection, this.lightingParams),
                    this.backupMaterials(p),
                    g = 0; g < e && !(g > 0 && E > 0 || w && g > 0); g++) {
                        const I = F.renderTargets[g]
                          , O = F.renderTargets[g].colorBuffer.width
                          , D = this.renderTargets.get(O)
                          , A = D.colorBuffer;
                        g === 0 ? x = i.updateShaders : x && (i.updateShaders = !0);
                        let k = this.passMaterials[g];
                        for (w && E + 1 === b && g === 0 && (k = this.ambientAOMaterial),
                        f = 0; f < p.length; f++)
                            p[f].material = k;
                        if (this.renderer.updateShaders(p),
                        g === OD && this.constantBakeDir.setValue(S.light.bakeDir ? 1 : 0),
                        r.isWebGPU) {
                            const N = new ID(r,this.renderer,this.camera,o ? this.worldClusters : null,p,m);
                            N.init(D),
                            N.render(),
                            N.destroy()
                        } else
                            this.renderer.setCamera(this.camera, D, !0),
                            o && this.worldClusters.activate(),
                            this.renderer._forwardTime = 0,
                            this.renderer._shadowMapTime = 0,
                            this.renderer.renderForward(this.camera, p, m, $i),
                            r.updateEnd();
                        for (F.renderTargets[g] = D,
                        this.renderTargets.set(O, I),
                        f = 0; f < p.length; f++)
                            _ = p[f],
                            _.setRealtimeLightmap(Fe.lightmapParamNames[g], A),
                            _._shaderDefs |= ru
                    }
                    this.restoreMaterials(p)
                }
                S.endBake(this.shadowMapCache)
            }
        }
        for (this.postprocessTextures(r, t, e),
        v = 0; v < s.length; v++)
            s[v].restore();
        this.restoreLights(l),
        this.restoreScene(),
        o || this.shadowMapCache.clear()
    }
}
class _e extends fe {
    constructor(e, t) {
        super(),
        this.system = void 0,
        this.entity = void 0,
        this.system = e,
        this.entity = t,
        this.system.schema && !this._accessorsBuilt && this.buildAccessors(this.system.schema),
        this.on("set", function(s, i, n) {
            this.fire("set_" + s, s, i, n)
        }),
        this.on("set_enabled", this.onSetEnabled, this)
    }
    static _buildAccessors(e, t) {
        t.forEach(function(s) {
            const i = typeof s == "object" ? s.name : s;
            Object.defineProperty(e, i, {
                get: function() {
                    return this.data[i]
                },
                set: function(n) {
                    const r = this.data
                      , o = r[i];
                    r[i] = n,
                    this.fire("set", i, o, n)
                },
                configurable: !0
            })
        }),
        e._accessorsBuilt = !0
    }
    buildAccessors(e) {
        _e._buildAccessors(this, e)
    }
    onSetEnabled(e, t, s) {
        t !== s && this.entity.enabled && (s ? this.onEnable() : this.onDisable())
    }
    onEnable() {}
    onDisable() {}
    onPostStateChange() {}
    get data() {
        const e = this.system.store[this.entity.getGuid()];
        return e ? e.data : null
    }
}
class it extends fe {
    constructor(e) {
        super(),
        this.app = e,
        this.store = {},
        this.schema = []
    }
    addComponent(e, t={}) {
        const s = new this.ComponentType(this,e)
          , i = new this.DataType;
        return this.store[e.getGuid()] = {
            entity: e,
            data: i
        },
        e[this.id] = s,
        e.c[this.id] = s,
        this.initializeComponentData(s, t, []),
        this.fire("add", e, s),
        s
    }
    removeComponent(e) {
        const t = this.store[e.getGuid()]
          , s = e.c[this.id];
        this.fire("beforeremove", e, s),
        delete this.store[e.getGuid()],
        e[this.id] = void 0,
        delete e.c[this.id],
        this.fire("remove", e, t.data)
    }
    cloneComponent(e, t) {
        const s = this.store[e.getGuid()];
        return this.addComponent(t, s.data)
    }
    initializeComponentData(e, t={}, s) {
        for (let i = 0, n = s.length; i < n; i++) {
            const r = s[i];
            let o, l;
            typeof r == "object" ? (o = r.name,
            l = r.type) : (o = r,
            l = void 0);
            let c = t[o];
            c !== void 0 ? (l !== void 0 && (c = BD(c, l)),
            e[o] = c) : e[o] = e.data[o]
        }
        e.enabled && e.entity.enabled && e.onEnable()
    }
    getPropertiesOfType(e) {
        const t = [];
        return (this.schema || []).forEach(function(i) {
            i && typeof i == "object" && i.type === e && t.push(i)
        }),
        t
    }
    destroy() {
        this.off()
    }
}
function BD(a, e) {
    if (!a)
        return a;
    switch (e) {
    case "rgb":
        return a instanceof z ? a.clone() : new z(a[0],a[1],a[2]);
    case "rgba":
        return a instanceof z ? a.clone() : new z(a[0],a[1],a[2],a[3]);
    case "vec2":
        return a instanceof P ? a.clone() : new P(a[0],a[1]);
    case "vec3":
        return a instanceof y ? a.clone() : new y(a[0],a[1],a[2]);
    case "vec4":
        return a instanceof M ? a.clone() : new M(a[0],a[1],a[2],a[3]);
    case "boolean":
    case "number":
    case "string":
        return a;
    case "entity":
        return a;
    default:
        throw new Error("Could not convert unhandled type: " + e)
    }
}
const Dx = 0
  , Bm = 1
  , km = 2;
class kD {
    constructor() {
        this._left = 1 / 0,
        this._right = -1 / 0,
        this._len = 0,
        this._recip = 0,
        this._p0 = 0,
        this._p1 = 0,
        this._t = 0,
        this._hermite = {
            valid: !1,
            p0: 0,
            m0: 0,
            p1: 0,
            m1: 0
        }
    }
    update(e, t) {
        if (e < this._left || e >= this._right) {
            const s = t.length;
            if (!s)
                this._left = -1 / 0,
                this._right = 1 / 0,
                this._len = 0,
                this._recip = 0,
                this._p0 = this._p1 = 0;
            else if (e < t[0])
                this._left = -1 / 0,
                this._right = t[0],
                this._len = 0,
                this._recip = 0,
                this._p0 = this._p1 = 0;
            else if (e >= t[s - 1])
                this._left = t[s - 1],
                this._right = 1 / 0,
                this._len = 0,
                this._recip = 0,
                this._p0 = this._p1 = s - 1;
            else {
                const i = this._findKey(e, t);
                this._left = t[i],
                this._right = t[i + 1],
                this._len = this._right - this._left;
                const n = 1 / this._len;
                this._recip = isFinite(n) ? n : 0,
                this._p0 = i,
                this._p1 = i + 1
            }
        }
        this._t = this._recip === 0 ? 0 : (e - this._left) * this._recip,
        this._hermite.valid = !1
    }
    _findKey(e, t) {
        let s = 0;
        for (; e >= t[s + 1]; )
            s++;
        return s
    }
    eval(e, t, s) {
        const i = s._data
          , n = s._components
          , r = this._p0 * n;
        if (t === Dx)
            for (let o = 0; o < n; ++o)
                e[o] = i[r + o];
        else {
            const o = this._t
              , l = this._p1 * n;
            switch (t) {
            case Bm:
                for (let c = 0; c < n; ++c)
                    e[c] = W.lerp(i[r + c], i[l + c], o);
                break;
            case km:
                {
                    const c = this._hermite;
                    if (!c.valid) {
                        const p = o * o
                          , _ = o + o
                          , m = 1 - o
                          , g = m * m;
                        c.valid = !0,
                        c.p0 = (1 + _) * g,
                        c.m0 = o * g,
                        c.p1 = p * (3 - _),
                        c.m1 = p * (o - 1)
                    }
                    const d = (this._p0 * 3 + 1) * n
                      , h = (this._p0 * 3 + 2) * n
                      , u = (this._p1 * 3 + 1) * n
                      , f = (this._p1 * 3 + 0) * n;
                    for (let p = 0; p < n; ++p)
                        e[p] = c.p0 * i[d + p] + c.m0 * i[h + p] * this._len + c.p1 * i[u + p] + c.m1 * i[f + p] * this._len;
                    break
                }
            }
        }
    }
}
class Z0 {
    constructor(e) {
        this._name = e.name + "Snapshot",
        this._time = -1,
        this._cache = [],
        this._results = [];
        for (let i = 0; i < e._inputs.length; ++i)
            this._cache[i] = new kD;
        const t = e._curves
          , s = e._outputs;
        for (let i = 0; i < t.length; ++i) {
            const n = t[i]
              , r = s[n._output]
              , o = [];
            for (let l = 0; l < r._components; ++l)
                o[l] = 0;
            this._results[i] = o
        }
    }
}
class Zo {
    constructor(e, t, s, i, n, r) {
        this._name = e.name,
        this._track = e,
        this._snapshot = new Z0(e),
        this._playing = i,
        this._time = t,
        this._speed = s,
        this._loop = n,
        this._blendWeight = 1,
        this._blendOrder = 0,
        this._eventHandler = r,
        this.alignCursorToCurrentTime()
    }
    set name(e) {
        this._name = e
    }
    get name() {
        return this._name
    }
    set track(e) {
        this._track = e,
        this._snapshot = new Z0(e)
    }
    get track() {
        return this._track
    }
    get snapshot() {
        return this._snapshot
    }
    set time(e) {
        this._time = e,
        this.alignCursorToCurrentTime()
    }
    get time() {
        return this._time
    }
    set speed(e) {
        const t = Math.sign(e) !== Math.sign(this._speed);
        this._speed = e,
        t && this.alignCursorToCurrentTime()
    }
    get speed() {
        return this._speed
    }
    set loop(e) {
        this._loop = e
    }
    get loop() {
        return this._loop
    }
    set blendWeight(e) {
        this._blendWeight = e
    }
    get blendWeight() {
        return this._blendWeight
    }
    set blendOrder(e) {
        this._blendOrder = e
    }
    get blendOrder() {
        return this._blendOrder
    }
    set eventCursor(e) {
        this._eventCursor = e
    }
    get eventCursor() {
        return this._eventCursor
    }
    get eventCursorEnd() {
        return this.isReverse ? 0 : this._track.events.length - 1
    }
    get nextEvent() {
        return this._track.events[this._eventCursor]
    }
    get isReverse() {
        return this._speed < 0
    }
    nextEventAheadOfTime(e) {
        return this.nextEvent ? this.isReverse ? this.nextEvent.time <= e : this.nextEvent.time >= e : !1
    }
    nextEventBehindTime(e) {
        return this.nextEvent ? e === this.track.duration ? this.isReverse ? this.nextEvent.time >= e : this.nextEvent.time <= e : this.isReverse ? this.nextEvent.time > e : this.nextEvent.time < e : !1
    }
    resetEventCursor() {
        this._eventCursor = this.isReverse ? this._track.events.length - 1 : 0
    }
    moveEventCursor() {
        this._eventCursor += this.isReverse ? -1 : 1,
        this._eventCursor >= this.track.events.length ? this._eventCursor = 0 : this._eventCursor < 0 && (this._eventCursor = this.track.events.length - 1)
    }
    clipFrameTime(e) {
        const t = Zo.eventFrame;
        t.start = 0,
        t.end = e,
        t.residual = 0,
        this.isReverse ? e < 0 && (t.start = this.track.duration,
        t.end = 0,
        t.residual = e + this.track.duration) : e > this.track.duration && (t.start = 0,
        t.end = this.track.duration,
        t.residual = e - this.track.duration)
    }
    alignCursorToCurrentTime() {
        for (this.resetEventCursor(); this.nextEventBehindTime(this._time) && this._eventCursor !== this.eventCursorEnd; )
            this.moveEventCursor()
    }
    fireNextEvent() {
        this._eventHandler.fire(this.nextEvent.name, Bt({
            track: this.track
        }, this.nextEvent)),
        this.moveEventCursor()
    }
    fireNextEventInFrame(e, t) {
        return this.nextEventAheadOfTime(e) && this.nextEventBehindTime(t) ? (this.fireNextEvent(),
        !0) : !1
    }
    activeEventsForFrame(e, t) {
        const s = Zo.eventFrame;
        this.clipFrameTime(t);
        const i = this.eventCursor;
        for (; this.fireNextEventInFrame(e, s.end) && i !== this.eventCursor; )
            ;
        this.loop && Math.abs(s.residual) > 0 && this.activeEventsForFrame(s.start, s.residual)
    }
    progressForTime(e) {
        return e * this._speed / this._track.duration
    }
    _update(e) {
        if (this._playing) {
            let t = this._time;
            const s = this._track.duration
              , i = this._speed
              , n = this._loop;
            this._track.events.length > 0 && s > 0 && this.activeEventsForFrame(t, t + i * e),
            t += i * e,
            i >= 0 ? t > s && (n ? t = t % s || 0 : (t = this._track.duration,
            this.pause())) : t < 0 && (n ? t = s + (t % s || 0) : (t = 0,
            this.pause())),
            this._time = t
        }
        this._time !== this._snapshot._time && this._track.eval(this._time, this._snapshot)
    }
    play() {
        this._playing = !0,
        this._time = 0
    }
    stop() {
        this._playing = !1,
        this._time = 0
    }
    pause() {
        this._playing = !1
    }
    resume() {
        this._playing = !0
    }
    reset() {
        this._time = 0
    }
}
Zo.eventFrame = {
    start: 0,
    end: 0,
    residual: 0
};
const Ox = "NONE"
  , ND = "PREV_STATE"
  , UD = "NEXT_STATE"
  , zD = "PREV_STATE_NEXT_STATE"
  , VD = "NEXT_STATE_PREV_STATE"
  , GD = "GREATER_THAN"
  , HD = "LESS_THAN"
  , WD = "GREATER_THAN_EQUAL_TO"
  , XD = "LESS_THAN_EQUAL_TO"
  , jD = "EQUAL_TO"
  , $D = "NOT_EQUAL_TO"
  , Q0 = "INTEGER"
  , J0 = "FLOAT"
  , ev = "BOOLEAN"
  , Nd = "TRIGGER"
  , qD = "1D"
  , YD = "2D_DIRECTIONAL"
  , KD = "2D_CARTESIAN"
  , ZD = "DIRECT"
  , Gl = "START"
  , Nm = "END"
  , jr = "ANY"
  , fu = [Gl, Nm, jr]
  , Fx = "OVERWRITE"
  , QD = "ADDITIVE";
class Wt {
    static dot(e, t) {
        const s = e.length;
        let i = 0;
        for (let n = 0; n < s; ++n)
            i += e[n] * t[n];
        return i
    }
    static normalize(e) {
        let t = Wt.dot(e, e);
        if (t > 0) {
            t = 1 / Math.sqrt(t);
            const s = e.length;
            for (let i = 0; i < s; ++i)
                e[i] *= t
        }
    }
    static set(e, t, s) {
        const i = e.length;
        if (s === "quaternion") {
            let n = Wt.dot(t, t);
            n > 0 && (n = 1 / Math.sqrt(n));
            for (let r = 0; r < i; ++r)
                e[r] = t[r] * n
        } else
            for (let n = 0; n < i; ++n)
                e[n] = t[n]
    }
    static blendVec(e, t, s, i) {
        const n = i ? 1 : 1 - s
          , r = e.length;
        for (let o = 0; o < r; ++o)
            e[o] = e[o] * n + t[o] * s
    }
    static blendQuat(e, t, s, i) {
        const n = e.length
          , r = i ? 1 : 1 - s;
        Wt.dot(e, t) < 0 && (s = -s);
        for (let o = 0; o < n; ++o)
            e[o] = e[o] * r + t[o] * s;
        i || Wt.normalize(e)
    }
    static blend(e, t, s, i, n) {
        i === "quaternion" ? Wt.blendQuat(e, t, s, n) : Wt.blendVec(e, t, s, n)
    }
    static stableSort(e, t) {
        const s = e.length;
        for (let i = 0; i < s - 1; ++i)
            for (let n = i + 1; n < s; ++n)
                if (t(e[n], e[i])) {
                    const r = e[i];
                    e[i] = e[n],
                    e[n] = r
                }
    }
}
class Ke {
    constructor(e, t) {
        this._component = e,
        this.mask = new Int8Array(e.layers.length),
        this.weights = new Float32Array(e.layers.length),
        this.totalWeight = 0,
        this.counter = 0,
        this.layerCounter = 0,
        this.valueType = t,
        this.dirty = !0,
        this.value = t === Ke.TYPE_QUAT ? [0, 0, 0, 1] : [0, 0, 0],
        this.baseValue = null,
        this.setter = null
    }
    get _normalizeWeights() {
        return this._component.normalizeWeights
    }
    getWeight(e) {
        return this.dirty && this.updateWeights(),
        this._normalizeWeights && this.totalWeight === 0 || !this.mask[e] ? 0 : this._normalizeWeights ? this.weights[e] / this.totalWeight : W.clamp(this.weights[e], 0, 1)
    }
    _layerBlendType(e) {
        return this._component.layers[e].blendType
    }
    setMask(e, t) {
        this.mask[e] = t,
        this._normalizeWeights && (this._component.layers[e].blendType === Fx && (this.mask = this.mask.fill(0, 0, e)),
        this.dirty = !0)
    }
    updateWeights() {
        this.totalWeight = 0;
        for (let e = 0; e < this.weights.length; e++)
            this.weights[e] = this._component.layers[e].weight,
            this.totalWeight += this.mask[e] * this.weights[e];
        this.dirty = !1
    }
    updateValue(e, t) {
        if (this.counter === 0 && (Wt.set(this.value, Ke.IDENTITY_QUAT_ARR, this.valueType),
        this._normalizeWeights || Wt.blend(this.value, this.baseValue, 1, this.valueType)),
        !(!this.mask[e] || this.getWeight(e) === 0)) {
            if (this._layerBlendType(e) === QD && !this._normalizeWeights)
                if (this.valueType === Ke.TYPE_QUAT) {
                    const s = Ke.q1.set(this.value[0], this.value[1], this.value[2], this.value[3])
                      , i = Ke.q2.set(this.baseValue[0], this.baseValue[1], this.baseValue[2], this.baseValue[3])
                      , n = Ke.q3.set(t[0], t[1], t[2], t[3])
                      , r = i.invert().mul(n);
                    r.slerp(ne.IDENTITY, r, this.getWeight(e)),
                    s.mul(r),
                    Ke.quatArr[0] = s.x,
                    Ke.quatArr[1] = s.y,
                    Ke.quatArr[2] = s.z,
                    Ke.quatArr[3] = s.w,
                    Wt.set(this.value, Ke.quatArr, this.valueType)
                } else
                    Ke.vecArr[0] = t[0] - this.baseValue[0],
                    Ke.vecArr[1] = t[1] - this.baseValue[1],
                    Ke.vecArr[2] = t[2] - this.baseValue[2],
                    Wt.blend(this.value, Ke.vecArr, this.getWeight(e), this.valueType, !0);
            else
                Wt.blend(this.value, t, this.getWeight(e), this.valueType);
            this.setter && this.setter(this.value)
        }
    }
    unbind() {
        this.setter && this.setter(this.baseValue)
    }
}
Ke.TYPE_QUAT = "quaternion";
Ke.TYPE_VEC3 = "vector3";
Ke.q1 = new ne;
Ke.q2 = new ne;
Ke.q3 = new ne;
Ke.quatArr = [0, 0, 0, 1];
Ke.vecArr = [0, 0, 0];
Ke.IDENTITY_QUAT_ARR = [0, 0, 0, 1];
class Bx {
    constructor(e) {
        this._binder = e,
        this._clips = [],
        this._inputs = [],
        this._outputs = [],
        this._targets = {}
    }
    get clips() {
        return this._clips
    }
    addClip(e) {
        const t = this._targets
          , s = this._binder
          , i = e.track.curves
          , n = e.snapshot
          , r = []
          , o = [];
        for (let l = 0; l < i.length; ++l) {
            const d = i[l].paths;
            for (let h = 0; h < d.length; ++h) {
                const u = d[h]
                  , f = s.resolve(u);
                let p = t[f && f.targetPath || null];
                if (!p && f) {
                    p = {
                        target: f,
                        value: [],
                        curves: 0,
                        blendCounter: 0
                    };
                    for (let _ = 0; _ < p.target.components; ++_)
                        p.value.push(0);
                    if (t[f.targetPath] = p,
                    s.animComponent) {
                        if (!s.animComponent.targets[f.targetPath]) {
                            let _;
                            f.targetPath.substring(f.targetPath.length - 13) === "localRotation" ? _ = Ke.TYPE_QUAT : _ = Ke.TYPE_VEC3,
                            s.animComponent.targets[f.targetPath] = new Ke(s.animComponent,_)
                        }
                        s.animComponent.targets[f.targetPath].layerCounter++,
                        s.animComponent.targets[f.targetPath].setMask(s.layerIndex, 1)
                    }
                }
                p && (p.curves++,
                r.push(n._results[l]),
                o.push(p))
            }
        }
        this._clips.push(e),
        this._inputs.push(r),
        this._outputs.push(o)
    }
    removeClip(e) {
        const t = this._targets
          , s = this._binder
          , i = this._clips
          , r = i[e].track.curves;
        for (let o = 0; o < r.length; ++o) {
            const c = r[o].paths;
            for (let d = 0; d < c.length; ++d) {
                const h = c[d]
                  , u = this._binder.resolve(h);
                u && (u.curves--,
                u.curves === 0 && (s.unresolve(h),
                delete t[u.targetPath],
                s.animComponent && s.animComponent.targets[u.targetPath].layerCounter--))
            }
        }
        i.splice(e, 1),
        this._inputs.splice(e, 1),
        this._outputs.splice(e, 1)
    }
    removeClips() {
        for (; this._clips.length > 0; )
            this.removeClip(0)
    }
    updateClipTrack(e, t) {
        this._clips.forEach(s => {
            s.name.includes(e) && (s.track = t)
        }
        ),
        this.rebind()
    }
    findClip(e) {
        const t = this._clips;
        for (let s = 0; s < t.length; ++s) {
            const i = t[s];
            if (i.name === e)
                return i
        }
        return null
    }
    rebind() {
        this._binder.rebind(),
        this._targets = {};
        const e = [...this.clips];
        this.removeClips(),
        e.forEach(t => {
            this.addClip(t)
        }
        )
    }
    assignMask(e) {
        return this._binder.assignMask(e)
    }
    update(e, t=!0) {
        const s = this._clips
          , i = s.map(function(o, l) {
            return l
        });
        Wt.stableSort(i, function(o, l) {
            return s[o].blendOrder < s[l].blendOrder
        });
        for (let o = 0; o < i.length; ++o) {
            const l = i[o]
              , c = s[l]
              , d = this._inputs[l]
              , h = this._outputs[l]
              , u = c.blendWeight;
            if (u > 0 && c._update(e),
            !t)
                break;
            let f, p, _;
            if (u >= 1)
                for (let m = 0; m < d.length; ++m)
                    f = d[m],
                    p = h[m],
                    _ = p.value,
                    Wt.set(_, f, p.target.type),
                    p.blendCounter++;
            else if (u > 0)
                for (let m = 0; m < d.length; ++m)
                    f = d[m],
                    p = h[m],
                    _ = p.value,
                    p.blendCounter === 0 ? Wt.set(_, f, p.target.type) : Wt.blend(_, f, u, p.target.type),
                    p.blendCounter++
        }
        const n = this._targets
          , r = this._binder;
        for (const o in n)
            if (n.hasOwnProperty(o)) {
                const l = n[o];
                if (r.animComponent && l.target.isTransform) {
                    const c = r.animComponent.targets[o];
                    c.counter === c.layerCounter && (c.counter = 0),
                    c.path || (c.path = o,
                    c.baseValue = l.target.get(),
                    c.setter = l.target.set),
                    c.updateValue(r.layerIndex, l.value),
                    c.counter++
                } else
                    l.target.set(l.value);
                l.blendCounter = 0
            }
        this._binder.update(e)
    }
}
class kx {
    constructor(e) {
        this._events = [...e],
        this._events.sort( (t, s) => t.time - s.time)
    }
    get events() {
        return this._events
    }
}
var Nx;
class Nn {
    constructor(e, t, s, i, n, r=new kx([])) {
        this._name = e,
        this._duration = t,
        this._inputs = s,
        this._outputs = i,
        this._curves = n,
        this._animEvents = r
    }
    get name() {
        return this._name
    }
    get duration() {
        return this._duration
    }
    get inputs() {
        return this._inputs
    }
    get outputs() {
        return this._outputs
    }
    get curves() {
        return this._curves
    }
    set events(e) {
        this._animEvents = e
    }
    get events() {
        return this._animEvents.events
    }
    eval(e, t) {
        t._time = e;
        const s = this._inputs
          , i = this._outputs
          , n = this._curves
          , r = t._cache
          , o = t._results;
        for (let l = 0; l < s.length; ++l)
            r[l].update(e, s[l]._data);
        for (let l = 0; l < n.length; ++l) {
            const c = n[l]
              , d = i[c._output]
              , h = o[l];
            r[c._input].eval(h, c._interpolation, d)
        }
    }
}
Nx = Nn;
Nn.EMPTY = Object.freeze(new Nx("empty",Number.MAX_VALUE,[],[],[]));
class yo {
    static joinPath(e, t) {
        t = t || ".";
        const s = function(n) {
            return n.replace(/\\/g, "\\\\").replace(new RegExp("\\" + t,"g"), "\\" + t)
        };
        return e.map(s).join(t)
    }
    static splitPath(e, t) {
        t = t || ".";
        const s = [];
        let i = ""
          , n = 0;
        for (; n < e.length; ) {
            let r = e[n++];
            r === "\\" && n < e.length ? (r = e[n++],
            r === "\\" || r === t ? i += r : i += "\\" + r) : r === t ? (s.push(i),
            i = "") : i += r
        }
        return i.length > 0 && s.push(i),
        s
    }
    static encode(e, t, s) {
        return `${Array.isArray(e) ? e.join("/") : e}/${t}/${Array.isArray(s) ? s.join("/") : s}`
    }
    resolve(e) {
        return null
    }
    unresolve(e) {}
    update(e) {}
}
class Um {
    constructor(e, t, s, i) {
        e.set ? (this._set = e.set,
        this._get = e.get) : this._set = e,
        this._type = t,
        this._components = s,
        this._targetPath = i,
        this._isTransform = this._targetPath.substring(this._targetPath.length - 13) === "localRotation" || this._targetPath.substring(this._targetPath.length - 13) === "localPosition" || this._targetPath.substring(this._targetPath.length - 10) === "localScale"
    }
    get set() {
        return this._set
    }
    get get() {
        return this._get
    }
    get type() {
        return this._type
    }
    get components() {
        return this._components
    }
    get targetPath() {
        return this._targetPath
    }
    get isTransform() {
        return this._isTransform
    }
}
class sr {
    constructor(e) {
        if (this._isPathInMask = (n, r) => {
            const o = this._mask[n];
            if (o) {
                if (o.children || r && o.value !== !1)
                    return !0
            } else
                return !1;
            return !1
        }
        ,
        this.graph = e,
        !e)
            return;
        this._mask = null;
        const t = {};
        (function n(r) {
            t[r.name] = r;
            for (let o = 0; o < r.children.length; ++o)
                n(r.children[o])
        }
        )(e),
        this.nodes = t,
        this.targetCache = {};
        const i = function(r) {
            let o = r;
            for (; o && !(o instanceof V); )
                o = o.parent;
            let l;
            return o && (o.render ? l = o.render.meshInstances : o.model && (l = o.model.meshInstances)),
            l
        };
        this.nodeCounts = {},
        this.activeNodes = [],
        this.handlers = {
            localPosition: function(n) {
                const r = n.localPosition
                  , o = function(c) {
                    r.set(...c)
                };
                return sr.createAnimTarget(o, "vector", 3, n, "localPosition")
            },
            localRotation: function(n) {
                const r = n.localRotation
                  , o = function(c) {
                    r.set(...c)
                };
                return sr.createAnimTarget(o, "quaternion", 4, n, "localRotation")
            },
            localScale: function(n) {
                const r = n.localScale
                  , o = function(c) {
                    r.set(...c)
                };
                return sr.createAnimTarget(o, "vector", 3, n, "localScale")
            },
            weight: function(n, r) {
                r.indexOf("name.") === 0 ? r = r.replace("name.", "") : r = Number(r);
                const o = i(n);
                let l;
                if (o) {
                    for (let c = 0; c < o.length; ++c)
                        if (o[c].node.name === n.name && o[c].morphInstance) {
                            const d = o[c].morphInstance
                              , h = u => {
                                d.setWeight(r, u[0])
                            }
                            ;
                            l || (l = []),
                            l.push(h)
                        }
                }
                if (l) {
                    const c = d => {
                        for (let h = 0; h < l.length; ++h)
                            l[h](d)
                    }
                    ;
                    return sr.createAnimTarget(c, "number", 1, n, `weight.${r}`)
                }
                return null
            },
            materialTexture: (n, r) => {
                const o = i(n);
                if (o) {
                    let l;
                    for (let c = 0; c < o.length; ++c)
                        if (o[c].node.name === n.name) {
                            l = o[c];
                            break
                        }
                    if (l) {
                        const c = d => {
                            const h = this.animComponent.system.app.assets.get(d[0]);
                            h && h.resource && h.type === "texture" && (l.material[r] = h.resource,
                            l.material.update())
                        }
                        ;
                        return sr.createAnimTarget(c, "vector", 1, n, "materialTexture", "material")
                    }
                }
                return null
            }
        }
    }
    _isPathActive(e) {
        if (!this._mask)
            return !0;
        const t = [e.entityPath[0], this.graph.name];
        for (let s = 0; s < t.length; ++s) {
            let i = t[s];
            if (this._isPathInMask(i, e.entityPath.length === 1))
                return !0;
            for (let n = 1; n < e.entityPath.length; n++)
                if (i += "/" + e.entityPath[n],
                this._isPathInMask(i, n === e.entityPath.length - 1))
                    return !0
        }
        return !1
    }
    findNode(e) {
        if (!this._isPathActive(e))
            return null;
        let t;
        return this.graph && (t = this.graph.findByPath(e.entityPath),
        t || (t = this.graph.findByPath(e.entityPath.slice(1)))),
        t || (t = this.nodes[e.entityPath[e.entityPath.length - 1] || ""]),
        t
    }
    static createAnimTarget(e, t, s, i, n, r) {
        const o = yo.encode(i.path, r || "entity", n);
        return new Um(e,t,s,o)
    }
    resolve(e) {
        const t = yo.encode(e.entityPath, e.component, e.propertyPath);
        let s = this.targetCache[t];
        if (s)
            return s;
        const i = this.findNode(e);
        if (!i)
            return null;
        const n = this.handlers[e.propertyPath];
        return !n || (s = n(i),
        !s) ? null : (this.targetCache[t] = s,
        this.nodeCounts[i.path] ? this.nodeCounts[i.path]++ : (this.activeNodes.push(i),
        this.nodeCounts[i.path] = 1),
        s)
    }
    unresolve(e) {
        if (e.component !== "graph")
            return;
        const t = this.nodes[e.entityPath[e.entityPath.length - 1] || ""];
        if (this.nodeCounts[t.path]--,
        this.nodeCounts[t.path] === 0) {
            const s = this.activeNodes
              , i = s.indexOf(t.node)
              , n = s.length;
            i < n - 1 && (s[i] = s[n - 1]),
            s.pop()
        }
    }
    update(e) {
        const t = this.activeNodes;
        for (let s = 0; s < t.length; ++s)
            t[s]._dirtifyLocal()
    }
    assignMask(e) {
        return e !== this._mask ? (this._mask = e,
        !0) : !1
    }
}
class Ux extends _e {
    constructor(e, t) {
        super(e, t),
        this._animations = {},
        this._assets = [],
        this._loop = !0,
        this.animEvaluator = null,
        this.model = null,
        this.skeleton = null,
        this.fromSkel = null,
        this.toSkel = null,
        this.animationsIndex = {},
        this.prevAnim = null,
        this.currAnim = null,
        this.blend = 0,
        this.blending = !1,
        this.blendSpeed = 0,
        this.activate = !0,
        this.speed = 1
    }
    set animations(e) {
        this._animations = e,
        this.onSetAnimations()
    }
    get animations() {
        return this._animations
    }
    set assets(e) {
        const t = this._assets;
        if (t && t.length) {
            for (let i = 0; i < t.length; i++)
                if (t[i]) {
                    const n = this.system.app.assets.get(t[i]);
                    if (n) {
                        n.off("change", this.onAssetChanged, this),
                        n.off("remove", this.onAssetRemoved, this);
                        const r = this.animationsIndex[n.id];
                        this.currAnim === r && this._stopCurrentAnimation(),
                        delete this.animations[r],
                        delete this.animationsIndex[n.id]
                    }
                }
        }
        this._assets = e;
        const s = e.map(i => i instanceof le ? i.id : i);
        this.loadAnimationAssets(s)
    }
    get assets() {
        return this._assets
    }
    set currentTime(e) {
        if (this.skeleton && (this.skeleton.currentTime = e,
        this.skeleton.addTime(0),
        this.skeleton.updateGraph()),
        this.animEvaluator) {
            const t = this.animEvaluator.clips;
            for (let s = 0; s < t.length; ++s)
                t[s].time = e
        }
    }
    get currentTime() {
        if (this.skeleton)
            return this.skeleton._time;
        if (this.animEvaluator) {
            const e = this.animEvaluator.clips;
            if (e.length > 0)
                return e[e.length - 1].time
        }
        return 0
    }
    get duration() {
        return this.currAnim ? this.animations[this.currAnim].duration : 0
    }
    set loop(e) {
        if (this._loop = e,
        this.skeleton && (this.skeleton.looping = e),
        this.animEvaluator)
            for (let t = 0; t < this.animEvaluator.clips.length; ++t)
                this.animEvaluator.clips[t].loop = e
    }
    get loop() {
        return this._loop
    }
    play(e, t=0) {
        if (!(!this.enabled || !this.entity.enabled) && this.animations[e]) {
            if (this.prevAnim = this.currAnim,
            this.currAnim = e,
            this.model) {
                !this.skeleton && !this.animEvaluator && this._createAnimationController();
                const s = this.animations[this.prevAnim]
                  , i = this.animations[this.currAnim];
                if (this.blending = t > 0 && !!this.prevAnim,
                this.blending && (this.blend = 0,
                this.blendSpeed = 1 / t),
                this.skeleton && (this.blending ? (this.fromSkel.animation = s,
                this.fromSkel.addTime(this.skeleton._time),
                this.toSkel.animation = i) : this.skeleton.animation = i),
                this.animEvaluator) {
                    const n = this.animEvaluator;
                    if (this.blending)
                        for (; n.clips.length > 1; )
                            n.removeClip(0);
                    else
                        this.animEvaluator.removeClips();
                    const r = new Zo(this.animations[this.currAnim],0,1,!0,this.loop);
                    r.name = this.currAnim,
                    r.blendWeight = this.blending ? 0 : 1,
                    r.reset(),
                    this.animEvaluator.addClip(r)
                }
            }
            this.playing = !0
        }
    }
    getAnimation(e) {
        return this.animations[e]
    }
    setModel(e) {
        e !== this.model && (this._resetAnimationController(),
        this.model = e,
        this.animations && this.currAnim && this.animations[this.currAnim] && this.play(this.currAnim))
    }
    onSetAnimations() {
        const e = this.entity.model;
        if (e) {
            const t = e.model;
            t && t !== this.model && this.setModel(t)
        }
        if (!this.currAnim && this.activate && this.enabled && this.entity.enabled) {
            const t = Object.keys(this._animations);
            t.length > 0 && this.play(t[0])
        }
    }
    _resetAnimationController() {
        this.skeleton = null,
        this.fromSkel = null,
        this.toSkel = null,
        this.animEvaluator = null
    }
    _createAnimationController() {
        const e = this.model
          , t = this.animations;
        let s = !1
          , i = !1;
        for (const r in t)
            t.hasOwnProperty(r) && (t[r].constructor === Nn ? i = !0 : s = !0);
        const n = e.getGraph();
        s ? (this.fromSkel = new wp(n),
        this.toSkel = new wp(n),
        this.skeleton = new wp(n),
        this.skeleton.looping = this.loop,
        this.skeleton.setGraph(n)) : i && (this.animEvaluator = new Bx(new sr(this.entity)))
    }
    loadAnimationAssets(e) {
        if (!e || !e.length)
            return;
        const t = this.system.app.assets
          , s = n => {
            if (n.resources.length > 1)
                for (let r = 0; r < n.resources.length; r++)
                    this.animations[n.resources[r].name] = n.resources[r],
                    this.animationsIndex[n.id] = n.resources[r].name;
            else
                this.animations[n.name] = n.resource,
                this.animationsIndex[n.id] = n.name;
            this.animations = this.animations
        }
          , i = n => {
            n.off("change", this.onAssetChanged, this),
            n.on("change", this.onAssetChanged, this),
            n.off("remove", this.onAssetRemoved, this),
            n.on("remove", this.onAssetRemoved, this),
            n.resource ? s(n) : (n.once("load", s, this),
            this.enabled && this.entity.enabled && t.load(n))
        }
        ;
        for (let n = 0, r = e.length; n < r; n++) {
            const o = t.get(e[n]);
            o ? i(o) : t.on("add:" + e[n], i)
        }
    }
    onAssetChanged(e, t, s, i) {
        if (t === "resource" || t === "resources")
            if (t === "resources" && s && s.length === 0 && (s = null),
            s) {
                let n = !1;
                if (s.length > 1) {
                    if (i && i.length > 1)
                        for (let r = 0; r < i.length; r++)
                            delete this.animations[i[r].name];
                    else
                        delete this.animations[e.name];
                    n = !1;
                    for (let r = 0; r < s.length; r++)
                        this.animations[s[r].name] = s[r],
                        !n && this.currAnim === s[r].name && this.playing && this.enabled && this.entity.enabled && (n = !0,
                        this.play(s[r].name));
                    n || (this._stopCurrentAnimation(),
                    this.onSetAnimations())
                } else {
                    if (i && i.length > 1)
                        for (let r = 0; r < i.length; r++)
                            delete this.animations[i[r].name];
                    this.animations[e.name] = s[0] || s,
                    n = !1,
                    this.currAnim === e.name && this.playing && this.enabled && this.entity.enabled && (n = !0,
                    this.play(e.name)),
                    n || (this._stopCurrentAnimation(),
                    this.onSetAnimations())
                }
                this.animationsIndex[e.id] = e.name
            } else {
                if (i.length > 1)
                    for (let n = 0; n < i.length; n++)
                        delete this.animations[i[n].name],
                        this.currAnim === i[n].name && this._stopCurrentAnimation();
                else
                    delete this.animations[e.name],
                    this.currAnim === e.name && this._stopCurrentAnimation();
                delete this.animationsIndex[e.id]
            }
    }
    onAssetRemoved(e) {
        if (e.off("remove", this.onAssetRemoved, this),
        this.animations) {
            if (e.resources.length > 1)
                for (let t = 0; t < e.resources.length; t++)
                    delete this.animations[e.resources[t].name],
                    this.currAnim === e.resources[t].name && this._stopCurrentAnimation();
            else
                delete this.animations[e.name],
                this.currAnim === e.name && this._stopCurrentAnimation();
            delete this.animationsIndex[e.id]
        }
    }
    _stopCurrentAnimation() {
        if (this.currAnim = null,
        this.playing = !1,
        this.skeleton && (this.skeleton.currentTime = 0,
        this.skeleton.animation = null),
        this.animEvaluator) {
            for (let e = 0; e < this.animEvaluator.clips.length; ++e)
                this.animEvaluator.clips[e].stop();
            this.animEvaluator.update(0),
            this.animEvaluator.removeClips()
        }
    }
    onEnable() {
        super.onEnable();
        const e = this.assets
          , t = this.system.app.assets;
        if (e)
            for (let s = 0, i = e.length; s < i; s++) {
                let n = e[s];
                n instanceof le || (n = t.get(n)),
                n && !n.resource && t.load(n)
            }
        if (this.activate && !this.currAnim) {
            const s = Object.keys(this.animations);
            s.length > 0 && this.play(s[0])
        }
    }
    onBeforeRemove() {
        for (let e = 0; e < this.assets.length; e++) {
            let t = this.assets[e];
            typeof t == "number" && (t = this.system.app.assets.get(t)),
            t && (t.off("change", this.onAssetChanged, this),
            t.off("remove", this.onAssetRemoved, this))
        }
        this.skeleton = null,
        this.fromSkel = null,
        this.toSkel = null,
        this.animEvaluator = null
    }
    update(e) {
        if (this.blending && (this.blend += e * this.blendSpeed,
        this.blend >= 1 && (this.blend = 1)),
        this.playing) {
            const s = this.skeleton;
            if (s !== null && this.model !== null) {
                if (this.blending)
                    s.blend(this.fromSkel, this.toSkel, this.blend);
                else {
                    const i = e * this.speed;
                    s.addTime(i),
                    this.speed > 0 && s._time === s.animation.duration && !this.loop ? this.playing = !1 : this.speed < 0 && s._time === 0 && !this.loop && (this.playing = !1)
                }
                this.blending && this.blend === 1 && (s.animation = this.toSkel.animation),
                s.updateGraph()
            }
        }
        const t = this.animEvaluator;
        if (t) {
            for (let s = 0; s < t.clips.length; ++s) {
                const i = t.clips[s];
                i.speed = this.speed,
                this.playing ? i.resume() : i.pause()
            }
            this.blending && t.clips.length > 1 && (t.clips[1].blendWeight = this.blend),
            t.update(e)
        }
        this.blending && this.blend === 1 && (this.blending = !1)
    }
}
class JD {
    constructor() {
        this.enabled = !0
    }
}
const zm = ["enabled"];
class e2 extends it {
    constructor(e) {
        super(e),
        this.id = "animation",
        this.ComponentType = Ux,
        this.DataType = JD,
        this.schema = zm,
        this.on("beforeremove", this.onBeforeRemove, this),
        this.app.systems.on("update", this.onUpdate, this)
    }
    initializeComponentData(e, t, s) {
        s = ["activate", "enabled", "loop", "speed", "assets"];
        for (const i of s)
            t.hasOwnProperty(i) && (e[i] = t[i]);
        super.initializeComponentData(e, t, zm)
    }
    cloneComponent(e, t) {
        this.addComponent(t, {}),
        t.animation.assets = e.animation.assets.slice(),
        t.animation.speed = e.animation.speed,
        t.animation.loop = e.animation.loop,
        t.animation.activate = e.animation.activate,
        t.animation.enabled = e.animation.enabled;
        const s = {}
          , i = e.animation.animations;
        for (const o in i)
            i.hasOwnProperty(o) && (s[o] = i[o]);
        t.animation.animations = s;
        const n = {}
          , r = e.animation.animationsIndex;
        for (const o in r)
            r.hasOwnProperty(o) && (n[o] = r[o]);
        return t.animation.animationsIndex = n,
        t.animation
    }
    onBeforeRemove(e, t) {
        t.onBeforeRemove()
    }
    onUpdate(e) {
        const t = this.store;
        for (const s in t)
            if (t.hasOwnProperty(s)) {
                const i = t[s];
                i.data.enabled && i.entity.enabled && i.entity.animation.update(e)
            }
    }
    destroy() {
        super.destroy(),
        this.app.systems.off("update", this.onUpdate, this)
    }
}
_e._buildAccessors(Ux.prototype, zm);
class Dh {
    constructor(e, t, s, i, n=1) {
        this._state = e,
        this._parent = t,
        this._name = s,
        Array.isArray(i) ? (this._point = new P(i[0],i[1]),
        this._pointLength = this._point.length()) : (this._point = i,
        this._pointLength = i),
        this._speed = n,
        this._weightedSpeed = 1,
        this._weight = 1,
        this._animTrack = null
    }
    get parent() {
        return this._parent
    }
    get name() {
        return this._name
    }
    get path() {
        return this._parent ? this._parent.path + "." + this._name : this._name
    }
    get point() {
        return this._point
    }
    get pointLength() {
        return this._pointLength
    }
    set weight(e) {
        this._weight = e
    }
    get weight() {
        return this._parent ? this._parent.weight * this._weight : this._weight
    }
    get normalizedWeight() {
        const e = this._state.totalWeight;
        return e === 0 ? 0 : this.weight / e
    }
    get speed() {
        return this._weightedSpeed * this._speed
    }
    get absoluteSpeed() {
        return Math.abs(this._speed)
    }
    set weightedSpeed(e) {
        this._weightedSpeed = e
    }
    get weightedSpeed() {
        return this._weightedSpeed
    }
    set animTrack(e) {
        this._animTrack = e
    }
    get animTrack() {
        return this._animTrack
    }
}
class al extends Dh {
    constructor(e, t, s, i, n, r, o, l, c) {
        super(e, t, s, i),
        this._parameters = n,
        this._parameterValues = new Array(n.length),
        this._children = [],
        this._findParameter = c,
        this._syncAnimations = o !== !1,
        this._pointCache = {};
        for (let d = 0; d < r.length; d++) {
            const h = r[d];
            h.children ? this._children.push(l(h.type, this, null, s, 1, h.parameter ? [h.parameter] : h.parameters, h.children, l, c)) : this._children.push(new Dh(e,this,h.name,h.point,h.speed))
        }
    }
    get weight() {
        return this.calculateWeights(),
        this._parent ? this._parent.weight * this._weight : this._weight
    }
    get syncAnimations() {
        return this._syncAnimations
    }
    getChild(e) {
        for (let t = 0; t < this._children.length; t++)
            if (this._children[t].name === e)
                return this._children[t];
        return null
    }
    updateParameterValues() {
        let e = !0;
        for (let t = 0; t < this._parameterValues.length; t++) {
            const s = this._findParameter(this._parameters[t]).value;
            this._parameterValues[t] !== s && (this._parameterValues[t] = s,
            e = !1)
        }
        return e
    }
    getNodeWeightedDuration(e) {
        return this._children[e].animTrack.duration / this._children[e].speedMultiplier * this._children[e].weight
    }
    getNodeCount() {
        let e = 0;
        for (let t = 0; t < this._children.length; t++)
            this._children[t].constructor === al ? e += this._children[t].getNodeCount() : e++;
        return e
    }
}
class t2 extends al {
    constructor(e, t, s, i, n, r, o, l, c) {
        r.sort( (d, h) => d.point - h.point),
        super(e, t, s, i, n, r, o, l, c)
    }
    calculateWeights() {
        if (this.updateParameterValues())
            return;
        let e = 0;
        this._children[0].weight = 0;
        for (let t = 0; t < this._children.length; t++) {
            const s = this._children[t];
            if (t !== this._children.length - 1) {
                const i = this._children[t + 1];
                if (s.point === i.point)
                    s.weight = .5,
                    i.weight = .5;
                else if (W.between(this._parameterValues[0], s.point, i.point, !0)) {
                    const n = Math.abs(s.point - i.point)
                      , r = Math.abs(s.point - this._parameterValues[0])
                      , o = (n - r) / n;
                    s.weight = o,
                    i.weight = 1 - o
                } else
                    i.weight = 0
            }
            this._syncAnimations && (e += s.animTrack.duration / s.absoluteSpeed * s.weight)
        }
        if (this._syncAnimations)
            for (let t = 0; t < this._children.length; t++) {
                const s = this._children[t];
                s.weightedSpeed = s.animTrack.duration / s.absoluteSpeed / e
            }
    }
}
class yn extends al {
    pointDistanceCache(e, t) {
        const s = `${e}${t}`;
        return this._pointCache[s] || (this._pointCache[s] = this._children[t].point.clone().sub(this._children[e].point)),
        this._pointCache[s]
    }
    calculateWeights() {
        if (this.updateParameterValues())
            return;
        let e, t;
        yn._p.set(...this._parameterValues),
        e = 0,
        t = 0;
        for (let s = 0; s < this._children.length; s++) {
            const i = this._children[s]
              , n = i.point;
            yn._pip.set(yn._p.x, yn._p.y).sub(n);
            let r = Number.MAX_VALUE;
            for (let o = 0; o < this._children.length; o++) {
                if (s === o)
                    continue;
                const l = this.pointDistanceCache(s, o)
                  , c = W.clamp(1 - yn._pip.dot(l) / l.lengthSq(), 0, 1);
                c < r && (r = c)
            }
            i.weight = r,
            e += r,
            this._syncAnimations && (t += i.animTrack.duration / i.absoluteSpeed * i.weight)
        }
        for (let s = 0; s < this._children.length; s++) {
            const i = this._children[s];
            i.weight = i._weight / e,
            this._syncAnimations && (i.weightedSpeed = i.animTrack.duration / i.absoluteSpeed / t)
        }
    }
}
yn._p = new P;
yn._pip = new P;
class vn extends al {
    pointCache(e, t) {
        const s = `${e}${t}`;
        return this._pointCache[s] || (this._pointCache[s] = new P((this._children[t].pointLength - this._children[e].pointLength) / ((this._children[t].pointLength + this._children[e].pointLength) / 2),P.angleRad(this._children[e].point, this._children[t].point) * 2)),
        this._pointCache[s]
    }
    calculateWeights() {
        if (this.updateParameterValues())
            return;
        let e, t;
        vn._p.set(...this._parameterValues);
        const s = vn._p.length();
        e = 0,
        t = 0;
        for (let i = 0; i < this._children.length; i++) {
            const n = this._children[i]
              , r = n.point
              , o = n.pointLength;
            let l = Number.MAX_VALUE;
            for (let c = 0; c < this._children.length; c++) {
                if (i === c)
                    continue;
                const d = this.pointCache(i, c)
                  , h = this._children[c].pointLength;
                vn._pip.set((s - o) / ((h + o) / 2), P.angleRad(r, vn._p) * 2);
                const u = W.clamp(1 - Math.abs(vn._pip.dot(d) / d.lengthSq()), 0, 1);
                u < l && (l = u)
            }
            n.weight = l,
            e += l,
            this._syncAnimations && (t += n.animTrack.duration / n.absoluteSpeed * n.weight)
        }
        for (let i = 0; i < this._children.length; i++) {
            const n = this._children[i];
            if (n.weight = n._weight / e,
            this._syncAnimations) {
                const r = n.animTrack.duration / t * e;
                n.weightedSpeed = n.absoluteSpeed * r
            }
        }
    }
}
vn._p = new P;
vn._pip = new P;
class s2 extends al {
    calculateWeights() {
        if (this.updateParameterValues())
            return;
        let e = 0
          , t = 0;
        for (let s = 0; s < this._children.length; s++)
            if (e += Math.max(this._parameterValues[s], 0),
            this._syncAnimations) {
                const i = this._children[s];
                t += i.animTrack.duration / i.absoluteSpeed * i.weight
            }
        for (let s = 0; s < this._children.length; s++) {
            const i = this._children[s]
              , n = Math.max(this._parameterValues[s], 0);
            e ? (i.weight = n / e,
            this._syncAnimations && (i.weightedSpeed = i.animTrack.duration / i.absoluteSpeed / t)) : (i.weight = 0,
            this._syncAnimations && (i.weightedSpeed = 0))
        }
    }
}
class tv {
    constructor(e, t, s=1, i=!0, n) {
        this._animations = {},
        this._animationList = [],
        this._controller = e,
        this._name = t,
        this._speed = s,
        this._loop = i,
        this._hasAnimations = !1,
        n ? this._blendTree = this._createTree(n.type, this, null, t, 1, n.parameter ? [n.parameter] : n.parameters, n.children, n.syncAnimations, this._createTree, this._controller.findParameter) : this._blendTree = new Dh(this,null,t,1,s)
    }
    _createTree(e, t, s, i, n, r, o, l, c, d) {
        switch (e) {
        case qD:
            return new t2(t,s,i,n,r,o,l,c,d);
        case KD:
            return new yn(t,s,i,n,r,o,l,c,d);
        case YD:
            return new vn(t,s,i,n,r,o,l,c,d);
        case ZD:
            return new s2(t,s,i,n,r,o,l,c,d)
        }
    }
    _getNodeFromPath(e) {
        let t = this._blendTree;
        for (let s = 1; s < e.length; s++)
            t = t.getChild(e[s]);
        return t
    }
    addAnimation(e, t) {
        const s = e.join(".")
          , i = this._animationList.findIndex(function(n) {
            return n.path === s
        });
        if (i >= 0)
            this._animationList[i].animTrack = t;
        else {
            const n = this._getNodeFromPath(e);
            n.animTrack = t,
            this._animationList.push(n)
        }
        this._updateHasAnimations()
    }
    _updateHasAnimations() {
        this._hasAnimations = this._animationList.length > 0 && this._animationList.every(e => e.animTrack && e.animTrack !== Nn.EMPTY)
    }
    get name() {
        return this._name
    }
    set animations(e) {
        this._animationList = e,
        this._updateHasAnimations()
    }
    get animations() {
        return this._animationList
    }
    get hasAnimations() {
        return this._hasAnimations
    }
    set speed(e) {
        this._speed = e
    }
    get speed() {
        return this._speed
    }
    set loop(e) {
        this._loop = e
    }
    get loop() {
        return this._loop
    }
    get nodeCount() {
        return !this._blendTree || this._blendTree.constructor === Dh ? 1 : this._blendTree.getNodeCount()
    }
    get playable() {
        return fu.indexOf(this.name) !== -1 || this.animations.length === this.nodeCount
    }
    get looping() {
        if (this.animations.length > 0) {
            const e = this.name + "." + this.animations[0].animTrack.name
              , t = this._controller.animEvaluator.findClip(e);
            if (t)
                return t.loop
        }
        return !1
    }
    get totalWeight() {
        let e = 0;
        for (let t = 0; t < this.animations.length; t++)
            e += this.animations[t].weight;
        return e
    }
    get timelineDuration() {
        let e = 0;
        for (let t = 0; t < this.animations.length; t++) {
            const s = this.animations[t];
            s.animTrack.duration > e && (e = s.animTrack.duration)
        }
        return e
    }
}
class pu {
    constructor({from: e, to: t, time: s=0, priority: i=0, conditions: n=[], exitTime: r=null, transitionOffset: o=null, interruptionSource: l=Ox}) {
        this._from = e,
        this._to = t,
        this._time = s,
        this._priority = i,
        this._conditions = n,
        this._exitTime = r,
        this._transitionOffset = o,
        this._interruptionSource = l
    }
    get from() {
        return this._from
    }
    set to(e) {
        this._to = e
    }
    get to() {
        return this._to
    }
    get time() {
        return this._time
    }
    get priority() {
        return this._priority
    }
    get conditions() {
        return this._conditions
    }
    get exitTime() {
        return this._exitTime
    }
    get transitionOffset() {
        return this._transitionOffset
    }
    get interruptionSource() {
        return this._interruptionSource
    }
    get hasExitTime() {
        return !!this.exitTime
    }
}
class i2 {
    constructor(e, t, s, i, n, r, o) {
        this.findParameter = l => this._findParameter(l),
        this._animEvaluator = e,
        this._states = {},
        this._stateNames = [],
        this._eventHandler = n,
        this._findParameter = r,
        this._consumeTrigger = o;
        for (let l = 0; l < t.length; l++)
            this._states[t[l].name] = new tv(this,t[l].name,t[l].speed,t[l].loop,t[l].blendTree),
            this._stateNames.push(t[l].name);
        this._transitions = s.map(l => new pu(Bt({}, l))),
        this._findTransitionsFromStateCache = {},
        this._findTransitionsBetweenStatesCache = {},
        this._previousStateName = null,
        this._activeStateName = Gl,
        this._activeStateDuration = 0,
        this._activeStateDurationDirty = !0,
        this._playing = !1,
        this._activate = i,
        this._currTransitionTime = 1,
        this._totalTransitionTime = 1,
        this._isTransitioning = !1,
        this._transitionInterruptionSource = Ox,
        this._transitionPreviousStates = [],
        this._timeInState = 0,
        this._timeInStateBefore = 0
    }
    get animEvaluator() {
        return this._animEvaluator
    }
    set activeState(e) {
        this._activeStateName = e
    }
    get activeState() {
        return this._findState(this._activeStateName)
    }
    get activeStateName() {
        return this._activeStateName
    }
    get activeStateAnimations() {
        return this.activeState.animations
    }
    set previousState(e) {
        this._previousStateName = e
    }
    get previousState() {
        return this._findState(this._previousStateName)
    }
    get previousStateName() {
        return this._previousStateName
    }
    get playable() {
        let e = !0;
        for (let t = 0; t < this._stateNames.length; t++)
            this._states[this._stateNames[t]].playable || (e = !1);
        return e
    }
    set playing(e) {
        this._playing = e
    }
    get playing() {
        return this._playing
    }
    get activeStateProgress() {
        return this._getActiveStateProgressForTime(this._timeInState)
    }
    get activeStateDuration() {
        if (this._activeStateDurationDirty) {
            let e = 0;
            for (let t = 0; t < this.activeStateAnimations.length; t++) {
                const s = this._animEvaluator.findClip(this.activeStateAnimations[t].name);
                s && (e = Math.max(e, s.track.duration))
            }
            this._activeStateDuration = e,
            this._activeStateDurationDirty = !1
        }
        return this._activeStateDuration
    }
    set activeStateCurrentTime(e) {
        this._timeInStateBefore = e,
        this._timeInState = e;
        for (let t = 0; t < this.activeStateAnimations.length; t++) {
            const s = this.animEvaluator.findClip(this.activeStateAnimations[t].name);
            s && (s.time = e)
        }
    }
    get activeStateCurrentTime() {
        return this._timeInState
    }
    get transitioning() {
        return this._isTransitioning
    }
    get transitionProgress() {
        return this._currTransitionTime / this._totalTransitionTime
    }
    get states() {
        return this._stateNames
    }
    assignMask(e) {
        return this._animEvaluator.assignMask(e)
    }
    _findState(e) {
        return this._states[e]
    }
    _getActiveStateProgressForTime(e) {
        if (this.activeStateName === Gl || this.activeStateName === Nm || this.activeStateName === jr)
            return 1;
        const t = this._animEvaluator.findClip(this.activeStateAnimations[0].name);
        return t ? t.progressForTime(e) : null
    }
    _findTransitionsFromState(e) {
        let t = this._findTransitionsFromStateCache[e];
        return t || (t = this._transitions.filter(function(s) {
            return s.from === e
        }),
        Lh(t),
        this._findTransitionsFromStateCache[e] = t),
        t
    }
    _findTransitionsBetweenStates(e, t) {
        let s = this._findTransitionsBetweenStatesCache[e + "->" + t];
        return s || (s = this._transitions.filter(function(i) {
            return i.from === e && i.to === t
        }),
        Lh(s),
        this._findTransitionsBetweenStatesCache[e + "->" + t] = s),
        s
    }
    _transitionHasConditionsMet(e) {
        const t = e.conditions;
        for (let s = 0; s < t.length; s++) {
            const i = t[s]
              , n = this._findParameter(i.parameterName);
            switch (i.predicate) {
            case GD:
                if (!(n.value > i.value))
                    return !1;
                break;
            case HD:
                if (!(n.value < i.value))
                    return !1;
                break;
            case WD:
                if (!(n.value >= i.value))
                    return !1;
                break;
            case XD:
                if (!(n.value <= i.value))
                    return !1;
                break;
            case jD:
                if (n.value !== i.value)
                    return !1;
                break;
            case $D:
                if (n.value === i.value)
                    return !1;
                break
            }
        }
        return !0
    }
    _findTransition(e, t) {
        let s = [];
        if (e && t)
            s = s.concat(this._findTransitionsBetweenStates(e, t));
        else if (!this._isTransitioning)
            s = s.concat(this._findTransitionsFromState(this._activeStateName)),
            s = s.concat(this._findTransitionsFromState(jr));
        else
            switch (this._transitionInterruptionSource) {
            case ND:
                s = s.concat(this._findTransitionsFromState(this._previousStateName)),
                s = s.concat(this._findTransitionsFromState(jr));
                break;
            case UD:
                s = s.concat(this._findTransitionsFromState(this._activeStateName)),
                s = s.concat(this._findTransitionsFromState(jr));
                break;
            case zD:
                s = s.concat(this._findTransitionsFromState(this._previousStateName)),
                s = s.concat(this._findTransitionsFromState(this._activeStateName)),
                s = s.concat(this._findTransitionsFromState(jr));
                break;
            case VD:
                s = s.concat(this._findTransitionsFromState(this._activeStateName)),
                s = s.concat(this._findTransitionsFromState(this._previousStateName)),
                s = s.concat(this._findTransitionsFromState(jr));
                break
            }
        if (s = s.filter(i => {
            if (i.to === this.activeStateName)
                return !1;
            if (i.hasExitTime) {
                let n = this._getActiveStateProgressForTime(this._timeInStateBefore)
                  , r = this._getActiveStateProgressForTime(this._timeInState);
                if (i.exitTime < 1 && this.activeState.loop && (n -= Math.floor(n),
                r -= Math.floor(r)),
                r === n) {
                    if (r !== i.exitTime)
                        return null
                } else if (!(i.exitTime > n && i.exitTime <= r))
                    return null
            }
            return this._transitionHasConditionsMet(i)
        }
        ),
        s.length > 0) {
            const i = s[0];
            if (i.to === Nm) {
                const n = this._findTransitionsFromState(Gl)[0];
                i.to = n.to
            }
            return i
        }
        return null
    }
    updateStateFromTransition(e) {
        let t, s, i;
        this.previousState = e.from ? this.activeStateName : null,
        this.activeState = e.to,
        this._activeStateDurationDirty = !0;
        for (let c = 0; c < e.conditions.length; c++) {
            const d = e.conditions[c];
            this._findParameter(d.parameterName).type === Nd && this._consumeTrigger(d.parameterName)
        }
        if (this.previousState) {
            this._isTransitioning || (this._transitionPreviousStates = []),
            this._transitionPreviousStates.push({
                name: this._previousStateName,
                weight: 1
            });
            const c = Math.min(this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1, 1);
            for (let d = 0; d < this._transitionPreviousStates.length; d++) {
                this._isTransitioning ? d !== this._transitionPreviousStates.length - 1 ? this._transitionPreviousStates[d].weight *= 1 - c : this._transitionPreviousStates[d].weight = c : this._transitionPreviousStates[d].weight = 1,
                t = this._findState(this._transitionPreviousStates[d].name);
                for (let h = 0; h < t.animations.length; h++)
                    s = t.animations[h],
                    i = this._animEvaluator.findClip(s.name + ".previous." + d),
                    i || (i = this._animEvaluator.findClip(s.name),
                    i.name = s.name + ".previous." + d),
                    d !== this._transitionPreviousStates.length - 1 && i.pause()
            }
        }
        this._isTransitioning = !0,
        this._totalTransitionTime = e.time,
        this._currTransitionTime = 0,
        this._transitionInterruptionSource = e.interruptionSource;
        const n = this.activeState
          , r = e.transitionOffset && e.transitionOffset > 0 && e.transitionOffset < 1;
        let o = 0
          , l = 0;
        if (r) {
            const c = n.timelineDuration * e.transitionOffset;
            o = c,
            l = c
        }
        this._timeInState = o,
        this._timeInStateBefore = l;
        for (let c = 0; c < n.animations.length; c++) {
            if (i = this._animEvaluator.findClip(n.animations[c].name),
            i)
                i.reset();
            else {
                const d = Number.isFinite(n.animations[c].speed) ? n.animations[c].speed : n.speed;
                i = new Zo(n.animations[c].animTrack,this._timeInState,d,!0,n.loop,this._eventHandler),
                i.name = n.animations[c].name,
                this._animEvaluator.addClip(i)
            }
            if (e.time > 0 ? i.blendWeight = 0 : i.blendWeight = n.animations[c].normalizedWeight,
            i.play(),
            r)
                i.time = n.timelineDuration * e.transitionOffset;
            else {
                const d = n.speed >= 0 ? 0 : this.activeStateDuration;
                i.time = d
            }
        }
    }
    _transitionToState(e) {
        if (!this._findState(e))
            return;
        let t = this._findTransition(this._activeStateName, e);
        t || (this._animEvaluator.removeClips(),
        t = new pu({
            from: null,
            to: e
        })),
        this.updateStateFromTransition(t)
    }
    assignAnimation(e, t, s, i) {
        const n = e.split(".");
        let r = this._findState(n[0]);
        r || (r = new tv(this,n[0],s),
        this._states[n[0]] = r,
        this._stateNames.push(n[0])),
        r.addAnimation(n, t),
        this._animEvaluator.updateClipTrack(r.name, t),
        s !== void 0 && (r.speed = s),
        i !== void 0 && (r.loop = i),
        !this._playing && this._activate && this.playable && this.play(),
        this._activeStateDurationDirty = !0
    }
    removeNodeAnimations(e) {
        if (fu.indexOf(e) !== -1)
            return !1;
        const t = this._findState(e);
        return t ? (t.animations = [],
        !0) : !1
    }
    play(e) {
        e && this._transitionToState(e),
        this._playing = !0
    }
    pause() {
        this._playing = !1
    }
    reset() {
        this._previousStateName = null,
        this._activeStateName = Gl,
        this._playing = !1,
        this._currTransitionTime = 1,
        this._totalTransitionTime = 1,
        this._isTransitioning = !1,
        this._timeInState = 0,
        this._timeInStateBefore = 0,
        this._animEvaluator.removeClips()
    }
    rebind() {
        this._animEvaluator.rebind()
    }
    update(e) {
        if (!this._playing)
            return;
        let t, s, i;
        (this.activeState.loop || this._timeInState < this.activeStateDuration) && (this._timeInStateBefore = this._timeInState,
        this._timeInState += e * this.activeState.speed,
        !this.activeState.loop && this._timeInState > this.activeStateDuration && (this._timeInState = this.activeStateDuration,
        e = this.activeStateDuration - this._timeInStateBefore));
        const n = this._findTransition(this._activeStateName);
        if (n && this.updateStateFromTransition(n),
        this._isTransitioning)
            if (this._currTransitionTime += e,
            this._currTransitionTime <= this._totalTransitionTime) {
                const r = this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1;
                for (let o = 0; o < this._transitionPreviousStates.length; o++) {
                    t = this._findState(this._transitionPreviousStates[o].name);
                    const l = this._transitionPreviousStates[o].weight;
                    for (let c = 0; c < t.animations.length; c++)
                        s = t.animations[c],
                        i = this._animEvaluator.findClip(s.name + ".previous." + o),
                        i && (i.blendWeight = (1 - r) * s.normalizedWeight * l)
                }
                t = this.activeState;
                for (let o = 0; o < t.animations.length; o++)
                    s = t.animations[o],
                    this._animEvaluator.findClip(s.name).blendWeight = r * s.normalizedWeight
            } else {
                this._isTransitioning = !1;
                const r = this.activeStateAnimations.length
                  , o = this._animEvaluator.clips.length;
                for (let l = 0; l < o - r; l++)
                    this._animEvaluator.removeClip(0);
                this._transitionPreviousStates = [],
                t = this.activeState;
                for (let l = 0; l < t.animations.length; l++)
                    s = t.animations[l],
                    i = this._animEvaluator.findClip(s.name),
                    i && (i.blendWeight = s.normalizedWeight)
            }
        else if (this.activeState._blendTree.constructor !== Dh) {
            t = this.activeState;
            for (let r = 0; r < t.animations.length; r++)
                s = t.animations[r],
                i = this._animEvaluator.findClip(s.name),
                i && (i.blendWeight = s.normalizedWeight,
                s.parent.syncAnimations && (i.speed = s.speed))
        }
        this._animEvaluator.update(e, this.activeState.hasAnimations)
    }
}
const Mp = new P
  , ld = new y
  , Ml = new M
  , Pl = new z
  , Rl = new ne;
class fn extends sr {
    constructor(e, t, s, i, n) {
        super(t),
        this.animComponent = e,
        this._mask = i,
        this.layerName = s,
        this.layerIndex = n
    }
    static _packFloat(e) {
        return e[0]
    }
    static _packBoolean(e) {
        return !!e[0]
    }
    static _packVec2(e) {
        return Mp.x = e[0],
        Mp.y = e[1],
        Mp
    }
    static _packVec3(e) {
        return ld.x = e[0],
        ld.y = e[1],
        ld.z = e[2],
        ld
    }
    static _packVec4(e) {
        return Ml.x = e[0],
        Ml.y = e[1],
        Ml.z = e[2],
        Ml.w = e[3],
        Ml
    }
    static _packColor(e) {
        return Pl.r = e[0],
        Pl.g = e[1],
        Pl.b = e[2],
        Pl.a = e[3],
        Pl
    }
    static _packQuat(e) {
        return Rl.x = e[0],
        Rl.y = e[1],
        Rl.z = e[2],
        Rl.w = e[3],
        Rl
    }
    resolve(e) {
        const t = yo.encode(e.entityPath, e.component, e.propertyPath);
        let s = this.targetCache[t];
        if (s)
            return s;
        let i, n, r;
        switch (e.component) {
        case "entity":
            i = this._getEntityFromHierarchy(e.entityPath),
            r = yo.encode(i.path, "entity", e.propertyPath),
            n = i;
            break;
        case "graph":
            if (n = this.findNode(e),
            !n)
                return null;
            r = yo.encode(n.path, "graph", e.propertyPath);
            break;
        default:
            if (i = this._getEntityFromHierarchy(e.entityPath),
            n = i.findComponent(e.component),
            !n)
                return null;
            r = yo.encode(i.path, e.component, e.propertyPath);
            break
        }
        return s = this._createAnimTargetForProperty(n, e.propertyPath, r),
        this.targetCache[t] = s,
        s
    }
    update(e) {
        const t = this.activeNodes;
        if (t)
            for (let s = 0; s < t.length; s++)
                t[s]._dirtifyLocal()
    }
    _getEntityFromHierarchy(e) {
        if (!this.animComponent.entity.name === e[0])
            return null;
        const t = this.animComponent.entity;
        return e.length === 1 ? t : t._parent.findByPath(e)
    }
    _resolvePath(e, t, s) {
        const i = t.length - (s ? 0 : 1);
        for (let n = 0; n < i; n++)
            e = e[t[n]];
        return e
    }
    _setter(e, t, s) {
        const i = this._resolvePath(e, t)
          , n = t[t.length - 1]
          , r = "set" + n.substring(0, 1).toUpperCase() + n.substring(1);
        if (i[r]) {
            let c = i["get" + n.substring(0, 1).toUpperCase() + n.substring(1)].bind(i)();
            c = [c.x, c.y, c.z, c.w];
            const d = i[r].bind(i);
            return {
                set: h => {
                    d(s(h))
                }
                ,
                get: () => c
            }
        }
        const o = i[n];
        if (typeof o == "object" && o.hasOwnProperty("copy"))
            return function(l) {
                o.copy(s(l))
            }
            ;
        if ([P, y, M, z, ne].indexOf(i.constructor) !== -1 && t.length > 1) {
            const l = t.length > 2 ? this._resolvePath(e, t.slice(0, -1)) : e
              , c = t[t.length - 2];
            return function(d) {
                i[n] = s(d),
                l[c] = i
            }
        }
        return function(l) {
            i[n] = s(l)
        }
    }
    _createAnimTargetForProperty(e, t, s) {
        if (this.handlers && t[0].startsWith("weight."))
            return this.handlers.weight(e, t[0].replace("weight.", ""));
        if (this.handlers && t[0] === "material" && t.length === 2) {
            const l = t[1];
            if (l.endsWith("Map"))
                return this.handlers.materialTexture(e, l)
        }
        const i = this._resolvePath(e, t, !0);
        if (typeof i > "u")
            return null;
        let n, r, o;
        if (typeof i == "number")
            n = this._setter(e, t, fn._packFloat),
            r = "vector",
            o = 1;
        else if (typeof i == "boolean")
            n = this._setter(e, t, fn._packBoolean),
            r = "vector",
            o = 1;
        else if (typeof i == "object")
            switch (i.constructor) {
            case P:
                n = this._setter(e, t, fn._packVec2),
                r = "vector",
                o = 2;
                break;
            case y:
                n = this._setter(e, t, fn._packVec3),
                r = "vector",
                o = 3;
                break;
            case M:
                n = this._setter(e, t, fn._packVec4),
                r = "vector",
                o = 4;
                break;
            case z:
                n = this._setter(e, t, fn._packColor),
                r = "vector",
                o = 4;
                break;
            case ne:
                n = this._setter(e, t, fn._packQuat),
                r = "quaternion",
                o = 4;
                break;
            default:
                return null
            }
        return t.indexOf("material") !== -1 ? new Um(function(l) {
            n(l),
            e.material.update()
        }
        ,r,o,s) : new Um(n,r,o,s)
    }
    rebind() {
        this.targetCache = {},
        this.animComponent.rootBone ? this.graph = this.animComponent.rootBone : this.graph = this.animComponent.entity;
        const e = {};
        (function s(i) {
            e[i.name] = i;
            for (let n = 0; n < i.children.length; ++n)
                s(i.children[n])
        }
        )(this.graph),
        this.nodes = e
    }
}
class n2 {
    constructor(e, t, s, i=1, n=Fx, r=!0) {
        this._name = e,
        this._controller = t,
        this._component = s,
        this._weight = i,
        this._blendType = n,
        this._normalizedWeight = r,
        this._mask = null,
        this._blendTime = 0,
        this._blendTimeElapsed = 0,
        this._startingWeight = 0,
        this._targetWeight = 0
    }
    get name() {
        return this._name
    }
    set playing(e) {
        this._controller.playing = e
    }
    get playing() {
        return this._controller.playing
    }
    get playable() {
        return this._controller.playable
    }
    get activeState() {
        return this._controller.activeStateName
    }
    get previousState() {
        return this._controller.previousStateName
    }
    get activeStateProgress() {
        return this._controller.activeStateProgress
    }
    get activeStateDuration() {
        return this._controller.activeStateDuration
    }
    set activeStateCurrentTime(e) {
        const t = this._controller
          , s = t.playing;
        t.playing = !0,
        t.activeStateCurrentTime = e,
        s || t.update(0),
        t.playing = s
    }
    get activeStateCurrentTime() {
        return this._controller.activeStateCurrentTime
    }
    get transitioning() {
        return this._controller.transitioning
    }
    get transitionProgress() {
        return this.transitioning ? this._controller.transitionProgress : null
    }
    get states() {
        return this._controller.states
    }
    set weight(e) {
        this._weight = e,
        this._component.dirtifyTargets()
    }
    get weight() {
        return this._weight
    }
    set blendType(e) {
        e !== this._blendType && (this._blendType = e,
        this._controller.normalizeWeights && this._component.rebind())
    }
    get blendType() {
        return this._blendType
    }
    set mask(e) {
        this._controller.assignMask(e) && this._component.rebind(),
        this._mask = e
    }
    get mask() {
        return this._mask
    }
    play(e) {
        this._controller.play(e)
    }
    pause() {
        this._controller.pause()
    }
    reset() {
        this._controller.reset()
    }
    rebind() {
        this._controller.rebind()
    }
    update(e) {
        this._blendTime && (this._blendTimeElapsed < this._blendTime ? (this.weight = W.lerp(this._startingWeight, this._targetWeight, this._blendTimeElapsed / this._blendTime),
        this._blendTimeElapsed += e) : (this.weight = this._targetWeight,
        this._blendTime = 0,
        this._blendTimeElapsed = 0,
        this._startingWeight = 0,
        this._targetWeight = 0)),
        this._controller.update(e)
    }
    blendToWeight(e, t) {
        this._startingWeight = this.weight,
        this._targetWeight = e,
        this._blendTime = Math.max(0, t),
        this._blendTimeElapsed = 0
    }
    assignMask(e) {
        this._controller.assignMask(e) && this._component.rebind(),
        this._mask = e
    }
    assignAnimation(e, t, s, i) {
        t instanceof Nn && (this._controller.assignAnimation(e, t, s, i),
        this._controller._transitions.length === 0 && this._controller._transitions.push(new pu({
            from: "START",
            to: e
        })),
        this._component.activate && this._component.playable && (this._component.playing = !0))
    }
    removeNodeAnimations(e) {
        this._controller.removeNodeAnimations(e) && (this._component.playing = !1)
    }
    getAnimationAsset(e) {
        return this._component.animationAssets[`${this.name}:${e}`]
    }
    transition(e, t=0, s=null) {
        this._controller.updateStateFromTransition(new pu({
            from: this._controller.activeStateName,
            to: e,
            time: t,
            transitionOffset: s
        }))
    }
}
class Ud {
    constructor(e) {
        if (this._layers = [],
        this._parameters = {},
        Array.isArray(e.layers))
            this._layers = e.layers;
        else
            for (const t in e.layers) {
                const s = e.layers[t]
                  , i = {
                    name: s.name,
                    blendType: s.blendType,
                    weight: s.weight,
                    states: [],
                    transitions: []
                };
                for (let n = 0; n < s.states.length; n++)
                    i.states.push(e.states[s.states[n]]);
                for (let n = 0; n < s.transitions.length; n++) {
                    const r = e.transitions[s.transitions[n]];
                    if (r.conditions && !Array.isArray(r.conditions)) {
                        const o = Object.keys(r.conditions)
                          , l = [];
                        for (let c = 0; c < o.length; c++) {
                            const d = r.conditions[o[c]];
                            d.parameterName && l.push(d)
                        }
                        r.conditions = l
                    }
                    Number.isInteger(r.from) && (r.from = e.states[r.from].name),
                    Number.isInteger(r.to) && (r.to = e.states[r.to].name),
                    i.transitions.push(r)
                }
                this._layers.push(i)
            }
        for (const t in e.parameters) {
            const s = e.parameters[t];
            this._parameters[s.name] = {
                type: s.type,
                value: s.value
            }
        }
    }
    get parameters() {
        return Object.assign({}, this._parameters)
    }
    get layers() {
        return this._layers
    }
}
class zx extends _e {
    constructor(e, t) {
        super(e, t),
        this.findParameter = s => this._parameters[s],
        this.consumeTrigger = s => {
            this._consumedTriggers.add(s)
        }
        ,
        this._stateGraphAsset = null,
        this._animationAssets = {},
        this._speed = 1,
        this._activate = !0,
        this._playing = !1,
        this._rootBone = null,
        this._stateGraph = null,
        this._layers = [],
        this._layerIndices = {},
        this._parameters = {},
        this._targets = {},
        this._consumedTriggers = new Set,
        this._normalizeWeights = !1
    }
    set stateGraphAsset(e) {
        if (e === null) {
            this.removeStateGraph();
            return
        }
        this._stateGraphAsset && this.system.app.assets.get(this._stateGraphAsset).off("change", this._onStateGraphAssetChangeEvent, this);
        let t, s;
        e instanceof le ? (t = e.id,
        s = this.system.app.assets.get(t),
        s || (this.system.app.assets.add(e),
        s = this.system.app.assets.get(t))) : (t = e,
        s = this.system.app.assets.get(t)),
        !(!s || this._stateGraphAsset === t) && (s.resource ? (this._stateGraph = s.resource,
        this.loadStateGraph(this._stateGraph),
        s.on("change", this._onStateGraphAssetChangeEvent, this)) : (s.once("load", i => {
            this._stateGraph = i.resource,
            this.loadStateGraph(this._stateGraph)
        }
        ),
        s.on("change", this._onStateGraphAssetChangeEvent, this),
        this.system.app.assets.load(s)),
        this._stateGraphAsset = t)
    }
    get stateGraphAsset() {
        return this._stateGraphAsset
    }
    set normalizeWeights(e) {
        this._normalizeWeights = e,
        this.unbind()
    }
    get normalizeWeights() {
        return this._normalizeWeights
    }
    set animationAssets(e) {
        this._animationAssets = e,
        this.loadAnimationAssets()
    }
    get animationAssets() {
        return this._animationAssets
    }
    set speed(e) {
        this._speed = e
    }
    get speed() {
        return this._speed
    }
    set activate(e) {
        this._activate = e
    }
    get activate() {
        return this._activate
    }
    set playing(e) {
        this._playing = e
    }
    get playing() {
        return this._playing
    }
    set rootBone(e) {
        if (typeof e == "string") {
            const t = this.entity.root.findByGuid(e);
            this._rootBone = t
        } else
            e instanceof V ? this._rootBone = e : this._rootBone = null;
        this.rebind()
    }
    get rootBone() {
        return this._rootBone
    }
    set stateGraph(e) {
        this._stateGraph = e
    }
    get stateGraph() {
        return this._stateGraph
    }
    get layers() {
        return this._layers
    }
    set layerIndices(e) {
        this._layerIndices = e
    }
    get layerIndices() {
        return this._layerIndices
    }
    set parameters(e) {
        this._parameters = e
    }
    get parameters() {
        return this._parameters
    }
    set targets(e) {
        this._targets = e
    }
    get targets() {
        return this._targets
    }
    get playable() {
        for (let e = 0; e < this._layers.length; e++)
            if (!this._layers[e].playable)
                return !1;
        return !0
    }
    get baseLayer() {
        return this._layers.length > 0 ? this._layers[0] : null
    }
    _onStateGraphAssetChangeEvent(e) {
        const t = this.animationAssets
          , s = this.layers.map(i => i.mask);
        this.removeStateGraph(),
        this._stateGraph = new Ud(e._data),
        this.loadStateGraph(this._stateGraph),
        this.animationAssets = t,
        this.loadAnimationAssets(),
        this.layers.forEach( (i, n) => {
            i.mask = s[n]
        }
        ),
        this.rebind()
    }
    dirtifyTargets() {
        const e = Object.values(this._targets);
        for (let t = 0; t < e.length; t++)
            e[t].dirty = !0
    }
    _addLayer({name: e, states: t, transitions: s, weight: i, mask: n, blendType: r}) {
        let o;
        this.rootBone ? o = this.rootBone : o = this.entity;
        const l = this._layers.length
          , c = new fn(this,o,e,n,l)
          , d = new Bx(c)
          , h = new i2(d,t,s,this._activate,this,this.findParameter,this.consumeTrigger);
        return this._layers.push(new n2(e,h,this,i,r)),
        this._layerIndices[e] = l,
        this._layers[l]
    }
    addLayer(e, t, s, i) {
        const n = this.findAnimationLayer(e);
        if (n)
            return n;
        const r = [{
            name: "START",
            speed: 1
        }]
          , o = [];
        return this._addLayer({
            name: e,
            states: r,
            transitions: o,
            weight: t,
            mask: s,
            blendType: i
        })
    }
    _assignParameters(e) {
        this._parameters = {};
        const t = Object.keys(e.parameters);
        for (let s = 0; s < t.length; s++) {
            const i = t[s];
            this._parameters[i] = {
                type: e.parameters[i].type,
                value: e.parameters[i].value
            }
        }
    }
    loadStateGraph(e) {
        this._stateGraph = e,
        this._assignParameters(e),
        this._layers = [];
        let t = !1;
        for (let s = 0; s < e.layers.length; s++) {
            const i = e.layers[s];
            this._addLayer(Bt({}, i)),
            i.states.some(n => n.blendTree) && (t = !0)
        }
        t || this.setupAnimationAssets()
    }
    setupAnimationAssets() {
        for (let e = 0; e < this._layers.length; e++) {
            const t = this._layers[e]
              , s = t.name;
            for (let i = 0; i < t.states.length; i++) {
                const n = t.states[i];
                if (fu.indexOf(n) === -1) {
                    const r = s + ":" + n;
                    this._animationAssets[r] || (this._animationAssets[r] = {
                        asset: null
                    })
                }
            }
        }
        this.loadAnimationAssets()
    }
    loadAnimationAssets() {
        for (let e = 0; e < this._layers.length; e++) {
            const t = this._layers[e];
            for (let s = 0; s < t.states.length; s++) {
                const i = t.states[s];
                if (fu.indexOf(i) !== -1)
                    continue;
                const n = this._animationAssets[t.name + ":" + i];
                if (!n || !n.asset) {
                    this.findAnimationLayer(t.name).assignAnimation(i, Nn.EMPTY);
                    continue
                }
                const r = n.asset
                  , o = this.system.app.assets.get(r);
                o && (o.resource ? this.onAnimationAssetLoaded(t.name, i, o) : (o.once("load", (function(l, c) {
                    return (function(d) {
                        this.onAnimationAssetLoaded(l, c, d)
                    }
                    ).bind(this)
                }
                ).bind(this)(t.name, i)),
                this.system.app.assets.load(o)))
            }
        }
    }
    onAnimationAssetLoaded(e, t, s) {
        this.findAnimationLayer(e).assignAnimation(t, s.resource)
    }
    removeStateGraph() {
        this._stateGraph = null,
        this._stateGraphAsset = null,
        this._animationAssets = {},
        this._layers = [],
        this._layerIndices = {},
        this._parameters = {},
        this._playing = !1,
        this.unbind(),
        this._targets = {}
    }
    reset() {
        this._assignParameters(this._stateGraph);
        for (let e = 0; e < this._layers.length; e++) {
            const t = this._layers[e].playing;
            this._layers[e].reset(),
            this._layers[e].playing = t
        }
    }
    unbind() {
        this._normalizeWeights || Object.keys(this._targets).forEach(e => {
            this._targets[e].unbind()
        }
        )
    }
    rebind() {
        this._targets = {};
        for (let e = 0; e < this._layers.length; e++)
            this._layers[e].rebind()
    }
    findAnimationLayer(e) {
        const t = this._layerIndices[e];
        return this._layers[t] || null
    }
    addAnimationState(e, t, s=1, i=!0, n="Base") {
        this._stateGraph || this.loadStateGraph(new Ud({
            layers: [{
                name: n,
                states: [{
                    name: "START",
                    speed: 1
                }, {
                    name: e,
                    speed: s,
                    loop: i,
                    defaultState: !0
                }],
                transitions: [{
                    from: "START",
                    to: e
                }]
            }],
            parameters: {}
        }));
        const r = this.findAnimationLayer(n);
        if (r)
            r.assignAnimation(e, t, s, i);
        else {
            var o;
            (o = this.addLayer(n)) == null || o.assignAnimation(e, t, s, i)
        }
    }
    assignAnimation(e, t, s, i=1, n=!0) {
        if (!this._stateGraph && e.indexOf(".") === -1) {
            this.loadStateGraph(new Ud({
                layers: [{
                    name: "Base",
                    states: [{
                        name: "START",
                        speed: 1
                    }, {
                        name: e,
                        speed: i,
                        loop: n,
                        defaultState: !0
                    }],
                    transitions: [{
                        from: "START",
                        to: e
                    }]
                }],
                parameters: {}
            })),
            this.baseLayer.assignAnimation(e, t);
            return
        }
        const r = s ? this.findAnimationLayer(s) : this.baseLayer;
        r && r.assignAnimation(e, t, i, n)
    }
    removeNodeAnimations(e, t) {
        const s = t ? this.findAnimationLayer(t) : this.baseLayer;
        s && s.removeNodeAnimations(e)
    }
    getParameterValue(e, t) {
        const s = this._parameters[e];
        if (s && s.type === t)
            return s.value
    }
    setParameterValue(e, t, s) {
        const i = this._parameters[e];
        if (i && i.type === t) {
            i.value = s;
            return
        }
    }
    getFloat(e) {
        return this.getParameterValue(e, J0)
    }
    setFloat(e, t) {
        this.setParameterValue(e, J0, t)
    }
    getInteger(e) {
        return this.getParameterValue(e, Q0)
    }
    setInteger(e, t) {
        typeof t == "number" && t % 1 === 0 && this.setParameterValue(e, Q0, t)
    }
    getBoolean(e) {
        return this.getParameterValue(e, ev)
    }
    setBoolean(e, t) {
        this.setParameterValue(e, ev, !!t)
    }
    getTrigger(e) {
        return this.getParameterValue(e, Nd)
    }
    setTrigger(e, t=!1) {
        this.setParameterValue(e, Nd, !0),
        t && this._consumedTriggers.add(e)
    }
    resetTrigger(e) {
        this.setParameterValue(e, Nd, !1)
    }
    onBeforeRemove() {
        Number.isFinite(this._stateGraphAsset) && this.system.app.assets.get(this._stateGraphAsset).off("change", this._onStateGraphAssetChangeEvent, this)
    }
    update(e) {
        for (let t = 0; t < this.layers.length; t++)
            this.layers[t].update(e * this.speed);
        this._consumedTriggers.forEach(t => {
            this.parameters[t].value = !1
        }
        ),
        this._consumedTriggers.clear()
    }
    resolveDuplicatedEntityReferenceProperties(e, t) {
        e.rootBone && t[e.rootBone.getGuid()] ? this.rootBone = t[e.rootBone.getGuid()] : this.rebind()
    }
}
class r2 {
    constructor() {
        this.enabled = !0
    }
}
const Vm = ["enabled"];
class a2 extends it {
    constructor(e) {
        super(e),
        this.id = "anim",
        this.ComponentType = zx,
        this.DataType = r2,
        this.schema = Vm,
        this.on("beforeremove", this.onBeforeRemove, this),
        this.app.systems.on("animationUpdate", this.onAnimationUpdate, this)
    }
    initializeComponentData(e, t, s) {
        super.initializeComponentData(e, t, Vm);
        const i = ["animationAssets", "stateGraph", "layers", "masks"];
        Object.keys(t).forEach(n => {
            i.includes(n) || (e[n] = t[n])
        }
        ),
        t.stateGraph && (e.stateGraph = t.stateGraph,
        e.loadStateGraph(e.stateGraph)),
        t.layers ? t.layers.forEach( (n, r) => {
            n._controller.states.forEach(o => {
                n._controller._states[o]._animationList.forEach(l => {
                    if (!l.animTrack || l.animTrack === Nn.EMPTY) {
                        const c = this.app.assets.get(n._component._animationAssets[n.name + ":" + l.name].asset);
                        c && !c.loaded && c.once("load", () => {
                            e.layers[r].assignAnimation(l.name, c.resource)
                        }
                        )
                    } else
                        e.layers[r].assignAnimation(l.name, l.animTrack)
                }
                )
            }
            )
        }
        ) : t.animationAssets && (e.animationAssets = Object.assign(e.animationAssets, t.animationAssets)),
        t.masks && Object.keys(t.masks).forEach(n => {
            if (e.layers[n]) {
                const r = t.masks[n].mask
                  , o = {};
                Object.keys(r).forEach(l => {
                    o[decodeURI(l)] = r[l]
                }
                ),
                e.layers[n].mask = o
            }
        }
        )
    }
    onAnimationUpdate(e) {
        const t = this.store;
        for (const s in t)
            if (t.hasOwnProperty(s)) {
                const i = t[s].entity.anim;
                i.data.enabled && i.entity.enabled && i.playing && i.update(e)
            }
    }
    cloneComponent(e, t) {
        let s;
        (!e.anim.rootBone || e.anim.rootBone === e) && (s = {},
        e.anim.layers.forEach( (n, r) => {
            if (n.mask) {
                const o = {};
                Object.keys(n.mask).forEach(l => {
                    const c = l.split("/");
                    c.shift();
                    const d = [t.name, ...c].join("/");
                    o[d] = n.mask[l]
                }
                ),
                s[r] = {
                    mask: o
                }
            }
        }
        ));
        const i = {
            stateGraphAsset: e.anim.stateGraphAsset,
            animationAssets: e.anim.animationAssets,
            speed: e.anim.speed,
            activate: e.anim.activate,
            playing: e.anim.playing,
            rootBone: e.anim.rootBone,
            stateGraph: e.anim.stateGraph,
            layers: e.anim.layers,
            layerIndices: e.anim.layerIndices,
            parameters: e.anim.parameters,
            normalizeWeights: e.anim.normalizeWeights,
            masks: s
        };
        return this.addComponent(t, i)
    }
    onBeforeRemove(e, t) {
        t.onBeforeRemove()
    }
    destroy() {
        super.destroy(),
        this.app.systems.off("animationUpdate", this.onAnimationUpdate, this)
    }
}
_e._buildAccessors(zx.prototype, Vm);
class Vx extends _e {
    constructor(e, t) {
        super(e, t)
    }
    setCurrentListener() {
        if (this.enabled && this.entity.audiolistener && this.entity.enabled) {
            this.system.current = this.entity;
            const e = this.system.current.getPosition();
            this.system.manager.listener.setPosition(e)
        }
    }
    onEnable() {
        this.setCurrentListener()
    }
    onDisable() {
        this.system.current === this.entity && (this.system.current = null)
    }
}
class o2 {
    constructor() {
        this.enabled = !0
    }
}
const Gx = ["enabled"];
class l2 extends it {
    constructor(e) {
        super(e),
        this.id = "audiolistener",
        this.ComponentType = Vx,
        this.DataType = o2,
        this.schema = Gx,
        this.manager = e.soundManager,
        this.current = null,
        this.app.systems.on("update", this.onUpdate, this)
    }
    initializeComponentData(e, t, s) {
        s = ["enabled"],
        super.initializeComponentData(e, t, s)
    }
    onUpdate(e) {
        if (this.current) {
            const t = this.current.getPosition();
            this.manager.listener.setPosition(t);
            const s = this.current.getWorldTransform();
            this.manager.listener.setOrientation(s)
        }
    }
    destroy() {
        super.destroy(),
        this.app.systems.off("update", this.onUpdate, this)
    }
}
_e._buildAccessors(Vx.prototype, Gx);
class Hx extends _e {
    constructor(e, t) {
        super(e, t),
        this.on("set_assets", this.onSetAssets, this),
        this.on("set_loop", this.onSetLoop, this),
        this.on("set_volume", this.onSetVolume, this),
        this.on("set_pitch", this.onSetPitch, this),
        this.on("set_minDistance", this.onSetMinDistance, this),
        this.on("set_maxDistance", this.onSetMaxDistance, this),
        this.on("set_rollOffFactor", this.onSetRollOffFactor, this),
        this.on("set_distanceModel", this.onSetDistanceModel, this),
        this.on("set_3d", this.onSet3d, this)
    }
    play(e) {
        if (!this.enabled || !this.entity.enabled)
            return;
        this.channel && this.stop();
        let t;
        const s = this.data;
        if (s.sources[e])
            if (!s["3d"])
                t = this.system.manager.playSound(s.sources[e], s),
                s.currentSource = e,
                s.channel = t;
            else {
                const i = this.entity.getPosition();
                t = this.system.manager.playSound3d(s.sources[e], i, s),
                s.currentSource = e,
                s.channel = t
            }
    }
    pause() {
        this.channel && this.channel.pause()
    }
    unpause() {
        this.channel && this.channel.paused && this.channel.unpause()
    }
    stop() {
        this.channel && (this.channel.stop(),
        this.channel = null)
    }
    onSetAssets(e, t, s) {
        const i = []
          , n = s.length;
        if (t && t.length) {
            for (let r = 0; r < t.length; r++)
                if (t[r]) {
                    const o = this.system.app.assets.get(t[r]);
                    o && (o.off("change", this.onAssetChanged, this),
                    o.off("remove", this.onAssetRemoved, this),
                    this.currentSource === o.name && this.stop())
                }
        }
        if (n)
            for (let r = 0; r < n; r++)
                t.indexOf(s[r]) < 0 && (s[r]instanceof le ? i.push(s[r].id) : i.push(s[r]));
        !this.system._inTools && i.length && this.loadAudioSourceAssets(i)
    }
    onAssetChanged(e, t, s, i) {
        t === "resource" && this.data.sources && (this.data.sources[e.name] = s,
        this.data.currentSource === e.name && this.channel && (this.channel.paused ? (this.play(e.name),
        this.pause()) : this.play(e.name)))
    }
    onAssetRemoved(e) {
        e.off("remove", this.onAssetRemoved, this),
        this.data.sources[e.name] && (delete this.data.sources[e.name],
        this.data.currentSource === e.name && (this.stop(),
        this.data.currentSource = null))
    }
    onSetLoop(e, t, s) {
        t !== s && this.channel && this.channel.setLoop(s)
    }
    onSetVolume(e, t, s) {
        t !== s && this.channel && this.channel.setVolume(s)
    }
    onSetPitch(e, t, s) {
        t !== s && this.channel && this.channel.setPitch(s)
    }
    onSetMaxDistance(e, t, s) {
        t !== s && this.channel instanceof nr && this.channel.setMaxDistance(s)
    }
    onSetMinDistance(e, t, s) {
        t !== s && this.channel instanceof nr && this.channel.setMinDistance(s)
    }
    onSetRollOffFactor(e, t, s) {
        t !== s && this.channel instanceof nr && this.channel.setRollOffFactor(s)
    }
    onSetDistanceModel(e, t, s) {
        t !== s && this.channel instanceof nr && this.channel.setDistanceModel(s)
    }
    onSet3d(e, t, s) {
        if (t !== s && this.system.initialized && this.currentSource) {
            let i = !1
              , n = !1;
            this.channel && (i = this.channel.paused,
            n = this.channel.suspended),
            this.play(this.currentSource),
            this.channel && (this.channel.paused = i,
            this.channel.suspended = n)
        }
    }
    onEnable() {
        const e = this.data.assets;
        if (e) {
            const t = this.system.app.assets;
            for (let s = 0, i = e.length; s < i; s++) {
                let n = e[s];
                n instanceof le || (n = t.get(n)),
                n && !n.resource && t.load(n)
            }
        }
        this.system.initialized && (this.data.activate && !this.channel ? this.play(this.currentSource) : this.unpause())
    }
    onDisable() {
        this.pause()
    }
    loadAudioSourceAssets(e) {
        const t = e.map(l => this.system.app.assets.get(l))
          , s = {};
        let i = null
          , n = t.length;
        const r = l => {
            n--
        }
          , o = () => {
            this.data.sources = s,
            this.data.currentSource = i,
            this.enabled && this.activate && i && this.onEnable()
        }
        ;
        t.forEach( (l, c) => {
            l ? (i = i || l.name,
            l.off("change", this.onAssetChanged, this),
            l.on("change", this.onAssetChanged, this),
            l.off("remove", this.onAssetRemoved, this),
            l.on("remove", this.onAssetRemoved, this),
            l.off("error", r, this),
            l.on("error", r, this),
            l.ready(d => {
                s[d.name] = d.resource,
                n--,
                n === 0 && o()
            }
            ),
            !l.resource && this.enabled && this.entity.enabled && this.system.app.assets.load(l)) : (n--,
            n === 0 && o(),
            this.system.app.assets.on("add:" + e[c], d => {
                d.ready(h => {
                    this.data.sources[h.name] = h.resource
                }
                ),
                d.resource || this.system.app.assets.load(d)
            }
            ))
        }
        )
    }
}
class h2 {
    constructor() {
        this.enabled = !0,
        this.assets = [],
        this.activate = !0,
        this.volume = 1,
        this.pitch = 1,
        this.loop = !1,
        this["3d"] = !0,
        this.minDistance = 1,
        this.maxDistance = 1e4,
        this.rollOffFactor = 1,
        this.distanceModel = Ou,
        this.paused = !0,
        this.sources = {},
        this.currentSource = null,
        this.channel = null
    }
}
const Wx = ["enabled", "assets", "volume", "pitch", "loop", "activate", "3d", "minDistance", "maxDistance", "rollOffFactor", "distanceModel", "sources", "currentSource", "channel"];
class c2 extends it {
    constructor(e) {
        super(e),
        this.id = "audiosource",
        this.ComponentType = Hx,
        this.DataType = h2,
        this.schema = Wx,
        this.manager = e.soundManager,
        this.initialized = !1,
        this.app.systems.on("initialize", this.onInitialize, this),
        this.app.systems.on("update", this.onUpdate, this),
        this.on("remove", this.onRemove, this)
    }
    initializeComponentData(e, t, s) {
        s = ["activate", "volume", "pitch", "loop", "3d", "minDistance", "maxDistance", "rollOffFactor", "distanceModel", "enabled", "assets"],
        super.initializeComponentData(e, t, s),
        e.paused = !(e.enabled && e.activate)
    }
    onInitialize(e) {
        e.audiosource && e.enabled && e.audiosource.enabled && e.audiosource.activate && e.audiosource.play(e.audiosource.currentSource);
        const t = e._children;
        for (let s = 0, i = t.length; s < i; s++)
            t[s]instanceof V && this.onInitialize(t[s]);
        this.initialized = !0
    }
    onUpdate(e) {
        const t = this.store;
        for (const s in t)
            if (t.hasOwnProperty(s)) {
                const i = t[s]
                  , n = i.entity
                  , r = i.data;
                if (r.enabled && n.enabled && r.channel instanceof nr) {
                    const o = n.getPosition();
                    r.channel.setPosition(o)
                }
            }
    }
    onRemove(e, t) {
        t.channel && (t.channel.stop(),
        t.channel = null)
    }
    setVolume(e) {
        this.manager.setVolume(e)
    }
    destroy() {
        super.destroy(),
        this.app.systems.off("initialize", this.onInitialize, this),
        this.app.systems.off("update", this.onUpdate, this)
    }
}
_e._buildAccessors(Hx.prototype, Wx);
class Yr extends fe {
    constructor(e, t, s) {
        if (super(),
        !e || !(e instanceof _e))
            throw new Error("The parentComponent argument is required and must be a Component");
        if (!t || typeof t != "string")
            throw new Error("The propertyName argument is required and must be a string");
        if (s && typeof s != "object")
            throw new Error("If provided, the eventConfig argument must be an object");
        this._parentComponent = e,
        this._entityPropertyName = t,
        this._entity = null,
        this._app = e.system.app,
        this._configureEventListeners(s || {}, {
            "entity#destroy": this._onEntityDestroy
        }),
        this._toggleLifecycleListeners("on")
    }
    _configureEventListeners(e, t) {
        const s = this._parseEventListenerConfig(e, "external", this._parentComponent)
          , i = this._parseEventListenerConfig(t, "internal", this);
        this._eventListenerConfigs = s.concat(i),
        this._listenerStatusFlags = {},
        this._gainListeners = {},
        this._loseListeners = {}
    }
    _parseEventListenerConfig(e, t, s) {
        return Object.keys(e).map(function(i, n) {
            const r = i.split("#")
              , o = r[0]
              , l = r[1]
              , c = e[i];
            if (r.length !== 2 || typeof o != "string" || o.length === 0 || typeof l != "string" || l.length === 0)
                throw new Error("Invalid event listener description: `" + i + "`");
            if (typeof c != "function")
                throw new Error("Invalid or missing callback for event listener `" + i + "`");
            return {
                id: t + "_" + n + "_" + i,
                sourceName: o,
                eventName: l,
                callback: c,
                scope: s
            }
        }, this)
    }
    _toggleLifecycleListeners(e) {
        this._parentComponent[e]("set_" + this._entityPropertyName, this._onSetEntity, this),
        this._parentComponent.system[e]("beforeremove", this._onParentComponentRemove, this),
        this._app.systems[e]("postPostInitialize", this._updateEntityReference, this),
        this._app[e]("tools:sceneloaded", this._onSceneLoaded, this);
        const t = [];
        for (let s = 0; s < this._eventListenerConfigs.length; ++s) {
            const i = this._eventListenerConfigs[s]
              , n = this._app.systems[i.sourceName];
            n && (t.indexOf(n) === -1 && t.push(n),
            n && i.eventName === "gain" && (this._gainListeners[i.sourceName] = i),
            n && i.eventName === "lose" && (this._loseListeners[i.sourceName] = i))
        }
        for (let s = 0; s < t.length; ++s)
            t[s][e]("add", this._onComponentAdd, this),
            t[s][e]("beforeremove", this._onComponentRemove, this)
    }
    _onSetEntity(e, t, s) {
        if (s instanceof V)
            this._updateEntityReference();
        else {
            if (s != null && typeof s != "string") {
                console.warn("Entity field `" + this._entityPropertyName + "` was set to unexpected type '" + typeof s + "'");
                return
            }
            t !== s && this._updateEntityReference()
        }
    }
    onParentComponentEnable() {
        this._entity || this._updateEntityReference()
    }
    _onSceneLoaded() {
        this._updateEntityReference()
    }
    _updateEntityReference() {
        let e = this._parentComponent.data[this._entityPropertyName], t;
        if (e instanceof V)
            t = e,
            e = t.getGuid(),
            this._parentComponent.data[this._entityPropertyName] = e;
        else {
            const i = this._parentComponent.system.app.root;
            t = this._parentComponent.entity.isDescendantOf(i) && e ? i.findByGuid(e) : null
        }
        this._entity !== t && (this._entity && this._onBeforeEntityChange(),
        this._entity = t,
        this._entity && this._onAfterEntityChange(),
        this.fire("set:entity", this._entity))
    }
    _onBeforeEntityChange() {
        this._toggleEntityListeners("off"),
        this._callAllGainOrLoseListeners(this._loseListeners)
    }
    _onAfterEntityChange() {
        this._toggleEntityListeners("on"),
        this._callAllGainOrLoseListeners(this._gainListeners)
    }
    _onComponentAdd(e, t) {
        const s = t.system.id;
        e === this._entity && (this._callGainOrLoseListener(s, this._gainListeners),
        this._toggleComponentListeners("on", s))
    }
    _onComponentRemove(e, t) {
        const s = t.system.id;
        e === this._entity && (this._callGainOrLoseListener(s, this._loseListeners),
        this._toggleComponentListeners("off", s, !0))
    }
    _callAllGainOrLoseListeners(e) {
        for (const t in this._entity.c)
            this._callGainOrLoseListener(t, e)
    }
    _callGainOrLoseListener(e, t) {
        if (this._entity.c.hasOwnProperty(e) && t[e]) {
            const s = t[e];
            s.callback.call(s.scope)
        }
    }
    _toggleEntityListeners(e, t) {
        if (this._entity)
            for (let s = 0; s < this._eventListenerConfigs.length; ++s)
                this._safeToggleListener(e, this._eventListenerConfigs[s], t)
    }
    _toggleComponentListeners(e, t, s) {
        for (let i = 0; i < this._eventListenerConfigs.length; ++i) {
            const n = this._eventListenerConfigs[i];
            n.sourceName === t && this._safeToggleListener(e, n, s)
        }
    }
    _safeToggleListener(e, t, s) {
        const i = e === "on";
        if (i && this._listenerStatusFlags[t.id])
            return;
        const n = this._getEventSource(t.sourceName, s);
        n && (n[e](t.eventName, t.callback, t.scope),
        this._listenerStatusFlags[t.id] = i)
    }
    _getEventSource(e, t) {
        if (e === "entity")
            return this._entity;
        const s = this._entity[e];
        return s || (t || console.warn("Entity has no component with name " + e),
        null)
    }
    _onEntityDestroy(e) {
        this._entity === e && (this._toggleEntityListeners("off", !0),
        this._entity = null)
    }
    _onParentComponentRemove(e, t) {
        t === this._parentComponent && (this._toggleLifecycleListeners("off"),
        this._toggleEntityListeners("off", !0))
    }
    hasComponent(e) {
        return this._entity && this._entity.c ? !!this._entity.c[e] : !1
    }
    get entity() {
        return this._entity
    }
}
const mu = 0
  , sv = 1
  , us = "group"
  , Ae = "image"
  , Oh = "text"
  , zd = "stretch"
  , d2 = "contain"
  , u2 = "cover"
  , mt = {
    DEFAULT: "DEFAULT",
    HOVER: "HOVER",
    PRESSED: "PRESSED",
    INACTIVE: "INACTIVE"
}
  , vc = {};
vc[mt.DEFAULT] = "_defaultTint";
vc[mt.HOVER] = "hoverTint";
vc[mt.PRESSED] = "pressedTint";
vc[mt.INACTIVE] = "inactiveTint";
const Sc = {};
Sc[mt.DEFAULT] = "_defaultSpriteAsset";
Sc[mt.HOVER] = "hoverSpriteAsset";
Sc[mt.PRESSED] = "pressedSpriteAsset";
Sc[mt.INACTIVE] = "inactiveSpriteAsset";
const xc = {};
xc[mt.DEFAULT] = "_defaultSpriteFrame";
xc[mt.HOVER] = "hoverSpriteFrame";
xc[mt.PRESSED] = "pressedSpriteFrame";
xc[mt.INACTIVE] = "inactiveSpriteFrame";
class Lt extends _e {
    constructor(e, t) {
        super(e, t),
        this._visualState = mt.DEFAULT,
        this._isHovering = !1,
        this._hoveringCounter = 0,
        this._isPressed = !1,
        this._defaultTint = new z(1,1,1,1),
        this._defaultSpriteAsset = null,
        this._defaultSpriteFrame = 0,
        this._imageReference = new Yr(this,"imageEntity",{
            "element#gain": this._onImageElementGain,
            "element#lose": this._onImageElementLose,
            "element#set:color": this._onSetColor,
            "element#set:opacity": this._onSetOpacity,
            "element#set:spriteAsset": this._onSetSpriteAsset,
            "element#set:spriteFrame": this._onSetSpriteFrame
        }),
        this._toggleLifecycleListeners("on", e)
    }
    _toggleLifecycleListeners(e, t) {
        this[e]("set_active", this._onSetActive, this),
        this[e]("set_transitionMode", this._onSetTransitionMode, this),
        this[e]("set_hoverTint", this._onSetTransitionValue, this),
        this[e]("set_pressedTint", this._onSetTransitionValue, this),
        this[e]("set_inactiveTint", this._onSetTransitionValue, this),
        this[e]("set_hoverSpriteAsset", this._onSetTransitionValue, this),
        this[e]("set_hoverSpriteFrame", this._onSetTransitionValue, this),
        this[e]("set_pressedSpriteAsset", this._onSetTransitionValue, this),
        this[e]("set_pressedSpriteFrame", this._onSetTransitionValue, this),
        this[e]("set_inactiveSpriteAsset", this._onSetTransitionValue, this),
        this[e]("set_inactiveSpriteFrame", this._onSetTransitionValue, this),
        t.app.systems.element[e]("add", this._onElementComponentAdd, this),
        t.app.systems.element[e]("beforeremove", this._onElementComponentRemove, this)
    }
    _onSetActive(e, t, s) {
        t !== s && this._updateVisualState()
    }
    _onSetTransitionMode(e, t, s) {
        t !== s && (this._cancelTween(),
        this._resetToDefaultVisualState(t),
        this._forceReapplyVisualState())
    }
    _onSetTransitionValue(e, t, s) {
        t !== s && this._forceReapplyVisualState()
    }
    _onElementComponentRemove(e) {
        this.entity === e && this._toggleHitElementListeners("off")
    }
    _onElementComponentAdd(e) {
        this.entity === e && this._toggleHitElementListeners("on")
    }
    _onImageElementLose() {
        this._cancelTween(),
        this._resetToDefaultVisualState(this.transitionMode)
    }
    _onImageElementGain() {
        this._storeDefaultVisualState(),
        this._forceReapplyVisualState()
    }
    _toggleHitElementListeners(e) {
        if (this.entity.element) {
            const t = e === "on";
            if (t && this._hasHitElementListeners)
                return;
            this.entity.element[e]("mouseenter", this._onMouseEnter, this),
            this.entity.element[e]("mouseleave", this._onMouseLeave, this),
            this.entity.element[e]("mousedown", this._onMouseDown, this),
            this.entity.element[e]("mouseup", this._onMouseUp, this),
            this.entity.element[e]("touchstart", this._onTouchStart, this),
            this.entity.element[e]("touchend", this._onTouchEnd, this),
            this.entity.element[e]("touchleave", this._onTouchLeave, this),
            this.entity.element[e]("touchcancel", this._onTouchCancel, this),
            this.entity.element[e]("selectstart", this._onSelectStart, this),
            this.entity.element[e]("selectend", this._onSelectEnd, this),
            this.entity.element[e]("selectenter", this._onSelectEnter, this),
            this.entity.element[e]("selectleave", this._onSelectLeave, this),
            this.entity.element[e]("click", this._onClick, this),
            this._hasHitElementListeners = t
        }
    }
    _storeDefaultVisualState() {
        if (this._imageReference.hasComponent("element")) {
            const e = this._imageReference.entity.element;
            e.type !== us && (this._storeDefaultColor(e.color),
            this._storeDefaultOpacity(e.opacity),
            this._storeDefaultSpriteAsset(e.spriteAsset),
            this._storeDefaultSpriteFrame(e.spriteFrame))
        }
    }
    _storeDefaultColor(e) {
        this._defaultTint.r = e.r,
        this._defaultTint.g = e.g,
        this._defaultTint.b = e.b
    }
    _storeDefaultOpacity(e) {
        this._defaultTint.a = e
    }
    _storeDefaultSpriteAsset(e) {
        this._defaultSpriteAsset = e
    }
    _storeDefaultSpriteFrame(e) {
        this._defaultSpriteFrame = e
    }
    _onSetColor(e) {
        this._isApplyingTint || (this._storeDefaultColor(e),
        this._forceReapplyVisualState())
    }
    _onSetOpacity(e) {
        this._isApplyingTint || (this._storeDefaultOpacity(e),
        this._forceReapplyVisualState())
    }
    _onSetSpriteAsset(e) {
        this._isApplyingSprite || (this._storeDefaultSpriteAsset(e),
        this._forceReapplyVisualState())
    }
    _onSetSpriteFrame(e) {
        this._isApplyingSprite || (this._storeDefaultSpriteFrame(e),
        this._forceReapplyVisualState())
    }
    _onMouseEnter(e) {
        this._isHovering = !0,
        this._updateVisualState(),
        this._fireIfActive("mouseenter", e)
    }
    _onMouseLeave(e) {
        this._isHovering = !1,
        this._isPressed = !1,
        this._updateVisualState(),
        this._fireIfActive("mouseleave", e)
    }
    _onMouseDown(e) {
        this._isPressed = !0,
        this._updateVisualState(),
        this._fireIfActive("mousedown", e)
    }
    _onMouseUp(e) {
        this._isPressed = !1,
        this._updateVisualState(),
        this._fireIfActive("mouseup", e)
    }
    _onTouchStart(e) {
        this._isPressed = !0,
        this._updateVisualState(),
        this._fireIfActive("touchstart", e)
    }
    _onTouchEnd(e) {
        e.event.preventDefault(),
        this._isPressed = !1,
        this._updateVisualState(),
        this._fireIfActive("touchend", e)
    }
    _onTouchLeave(e) {
        this._isPressed = !1,
        this._updateVisualState(),
        this._fireIfActive("touchleave", e)
    }
    _onTouchCancel(e) {
        this._isPressed = !1,
        this._updateVisualState(),
        this._fireIfActive("touchcancel", e)
    }
    _onSelectStart(e) {
        this._isPressed = !0,
        this._updateVisualState(),
        this._fireIfActive("selectstart", e)
    }
    _onSelectEnd(e) {
        this._isPressed = !1,
        this._updateVisualState(),
        this._fireIfActive("selectend", e)
    }
    _onSelectEnter(e) {
        this._hoveringCounter++,
        this._hoveringCounter === 1 && (this._isHovering = !0,
        this._updateVisualState()),
        this._fireIfActive("selectenter", e)
    }
    _onSelectLeave(e) {
        this._hoveringCounter--,
        this._hoveringCounter === 0 && (this._isHovering = !1,
        this._isPressed = !1,
        this._updateVisualState()),
        this._fireIfActive("selectleave", e)
    }
    _onClick(e) {
        this._fireIfActive("click", e)
    }
    _fireIfActive(e, t) {
        this.data.active && this.fire(e, t)
    }
    _updateVisualState(e) {
        const t = this._visualState
          , s = this._determineVisualState();
        if ((t !== s || e) && this.enabled)
            switch (this._visualState = s,
            t === mt.HOVER && this._fireIfActive("hoverend"),
            t === mt.PRESSED && this._fireIfActive("pressedend"),
            s === mt.HOVER && this._fireIfActive("hoverstart"),
            s === mt.PRESSED && this._fireIfActive("pressedstart"),
            this.transitionMode) {
            case mu:
                {
                    const i = vc[this._visualState]
                      , n = this[i];
                    this._applyTint(n);
                    break
                }
            case sv:
                {
                    const i = Sc[this._visualState]
                      , n = xc[this._visualState]
                      , r = this[i]
                      , o = this[n];
                    this._applySprite(r, o);
                    break
                }
            }
    }
    _forceReapplyVisualState() {
        this._updateVisualState(!0)
    }
    _resetToDefaultVisualState(e) {
        if (this._imageReference.hasComponent("element"))
            switch (e) {
            case mu:
                this._cancelTween(),
                this._applyTintImmediately(this._defaultTint);
                break;
            case sv:
                this._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame);
                break
            }
    }
    _determineVisualState() {
        if (this.active) {
            if (this._isPressed)
                return mt.PRESSED;
            if (this._isHovering)
                return mt.HOVER
        } else
            return mt.INACTIVE;
        return mt.DEFAULT
    }
    _applySprite(e, t) {
        t = t || 0,
        this._imageReference.hasComponent("element") && (this._isApplyingSprite = !0,
        this._imageReference.entity.element.spriteAsset !== e && (this._imageReference.entity.element.spriteAsset = e),
        this._imageReference.entity.element.spriteFrame !== t && (this._imageReference.entity.element.spriteFrame = t),
        this._isApplyingSprite = !1)
    }
    _applyTint(e) {
        this._cancelTween(),
        this.fadeDuration === 0 ? this._applyTintImmediately(e) : this._applyTintWithTween(e)
    }
    _applyTintImmediately(e) {
        if (!e || !this._imageReference.hasComponent("element") || this._imageReference.entity.element.type === us)
            return;
        const t = iv(e);
        this._isApplyingTint = !0,
        t.equals(this._imageReference.entity.element.color) || (this._imageReference.entity.element.color = t),
        this._imageReference.entity.element.opacity !== e.a && (this._imageReference.entity.element.opacity = e.a),
        this._isApplyingTint = !1
    }
    _applyTintWithTween(e) {
        if (!e || !this._imageReference.hasComponent("element") || this._imageReference.entity.element.type === us)
            return;
        const t = iv(e)
          , s = this._imageReference.entity.element.color
          , i = this._imageReference.entity.element.opacity;
        t.equals(s) && e.a === i || (this._tweenInfo = {
            startTime: Hi(),
            from: new z(s.r,s.g,s.b,i),
            to: e.clone(),
            lerpColor: new z
        })
    }
    _updateTintTween() {
        const e = Hi() - this._tweenInfo.startTime;
        let t = this.fadeDuration === 0 ? 1 : e / this.fadeDuration;
        if (t = W.clamp(t, 0, 1),
        Math.abs(t - 1) > 1e-5) {
            const s = this._tweenInfo.lerpColor;
            s.lerp(this._tweenInfo.from, this._tweenInfo.to, t),
            this._applyTintImmediately(new z(s.r,s.g,s.b,s.a))
        } else
            this._applyTintImmediately(this._tweenInfo.to),
            this._cancelTween()
    }
    _cancelTween() {
        delete this._tweenInfo
    }
    onUpdate() {
        this._tweenInfo && this._updateTintTween()
    }
    onEnable() {
        this._isHovering = !1,
        this._hoveringCounter = 0,
        this._isPressed = !1,
        this._imageReference.onParentComponentEnable(),
        this._toggleHitElementListeners("on"),
        this._forceReapplyVisualState()
    }
    onDisable() {
        this._toggleHitElementListeners("off"),
        this._resetToDefaultVisualState(this.transitionMode)
    }
    onRemove() {
        this._toggleLifecycleListeners("off", this.system),
        this.onDisable()
    }
}
Lt.EVENT_MOUSEDOWN = "mousedown";
Lt.EVENT_MOUSEUP = "mouseup";
Lt.EVENT_MOUSEENTER = "mouseenter";
Lt.EVENT_MOUSELEAVE = "mouseleave";
Lt.EVENT_CLICK = "click";
Lt.EVENT_TOUCHSTART = "touchstart";
Lt.EVENT_TOUCHEND = "touchend";
Lt.EVENT_TOUCHCANCEL = "touchcancel";
Lt.EVENT_TOUCHLEAVE = "touchleave";
Lt.EVENT_SELECTSTART = "selectstart";
Lt.EVENT_SELECTEND = "selectend";
Lt.EVENT_SELECTENTER = "selectenter";
Lt.EVENT_SELECTLEAVE = "selectleave";
Lt.EVENT_HOVERSTART = "hoverstart";
Lt.EVENT_HOVEREND = "hoverend";
Lt.EVENT_PRESSEDSTART = "pressedstart";
Lt.EVENT_PRESSEDEND = "pressedend";
function iv(a) {
    return new z(a.r,a.g,a.b)
}
class f2 {
    constructor() {
        this.enabled = !0,
        this.active = !0,
        this.imageEntity = null,
        this.hitPadding = new M,
        this.transitionMode = mu,
        this.hoverTint = new z(.75,.75,.75),
        this.pressedTint = new z(.5,.5,.5),
        this.inactiveTint = new z(.25,.25,.25),
        this.fadeDuration = 0,
        this.hoverSpriteAsset = null,
        this.hoverSpriteFrame = 0,
        this.pressedSpriteAsset = null,
        this.pressedSpriteFrame = 0,
        this.inactiveSpriteAsset = null,
        this.inactiveSpriteFrame = 0
    }
}
const Gm = ["enabled", "active", {
    name: "imageEntity",
    type: "entity"
}, {
    name: "hitPadding",
    type: "vec4"
}, "transitionMode", {
    name: "hoverTint",
    type: "rgba"
}, {
    name: "pressedTint",
    type: "rgba"
}, {
    name: "inactiveTint",
    type: "rgba"
}, "fadeDuration", "hoverSpriteAsset", "hoverSpriteFrame", "pressedSpriteAsset", "pressedSpriteFrame", "inactiveSpriteAsset", "inactiveSpriteFrame"];
class p2 extends it {
    constructor(e) {
        super(e),
        this.id = "button",
        this.ComponentType = Lt,
        this.DataType = f2,
        this.schema = Gm,
        this.on("beforeremove", this._onRemoveComponent, this),
        this.app.systems.on("update", this.onUpdate, this)
    }
    initializeComponentData(e, t, s) {
        super.initializeComponentData(e, t, Gm)
    }
    onUpdate(e) {
        const t = this.store;
        for (const s in t) {
            const i = t[s].entity
              , n = i.button;
            n.enabled && i.enabled && n.onUpdate()
        }
    }
    _onRemoveComponent(e, t) {
        t.onRemove()
    }
    destroy() {
        super.destroy(),
        this.app.systems.off("update", this.onUpdate, this)
    }
}
_e._buildAccessors(Lt.prototype, Gm);
const nv = new y
  , rv = new ne;
class Pa extends _e {
    constructor(e, t) {
        super(e, t),
        this._compoundParent = null,
        this._hasOffset = !1,
        this.entity.on("insert", this._onInsert, this),
        this.on("set_type", this.onSetType, this),
        this.on("set_halfExtents", this.onSetHalfExtents, this),
        this.on("set_linearOffset", this.onSetOffset, this),
        this.on("set_angularOffset", this.onSetOffset, this),
        this.on("set_radius", this.onSetRadius, this),
        this.on("set_height", this.onSetHeight, this),
        this.on("set_axis", this.onSetAxis, this),
        this.on("set_asset", this.onSetAsset, this),
        this.on("set_renderAsset", this.onSetRenderAsset, this),
        this.on("set_model", this.onSetModel, this),
        this.on("set_render", this.onSetRender, this)
    }
    onSetType(e, t, s) {
        t !== s && this.system.changeType(this, t, s)
    }
    onSetHalfExtents(e, t, s) {
        const i = this.data.type;
        this.data.initialized && i === "box" && this.system.recreatePhysicalShapes(this)
    }
    onSetOffset(e, t, s) {
        this._hasOffset = !this.data.linearOffset.equals(y.ZERO) || !this.data.angularOffset.equals(ne.IDENTITY),
        this.data.initialized && this.system.recreatePhysicalShapes(this)
    }
    onSetRadius(e, t, s) {
        const i = this.data.type;
        this.data.initialized && (i === "sphere" || i === "capsule" || i === "cylinder" || i === "cone") && this.system.recreatePhysicalShapes(this)
    }
    onSetHeight(e, t, s) {
        const i = this.data.type;
        this.data.initialized && (i === "capsule" || i === "cylinder" || i === "cone") && this.system.recreatePhysicalShapes(this)
    }
    onSetAxis(e, t, s) {
        const i = this.data.type;
        this.data.initialized && (i === "capsule" || i === "cylinder" || i === "cone") && this.system.recreatePhysicalShapes(this)
    }
    onSetAsset(e, t, s) {
        const i = this.system.app.assets;
        if (t) {
            const n = i.get(t);
            n && n.off("remove", this.onAssetRemoved, this)
        }
        if (s) {
            s instanceof le && (this.data.asset = s.id);
            const n = i.get(this.data.asset);
            n && (n.off("remove", this.onAssetRemoved, this),
            n.on("remove", this.onAssetRemoved, this))
        }
        this.data.initialized && this.data.type === "mesh" && (s || (this.data.model = null),
        this.system.recreatePhysicalShapes(this))
    }
    onSetRenderAsset(e, t, s) {
        const i = this.system.app.assets;
        if (t) {
            const n = i.get(t);
            n && n.off("remove", this.onRenderAssetRemoved, this)
        }
        if (s) {
            s instanceof le && (this.data.renderAsset = s.id);
            const n = i.get(this.data.renderAsset);
            n && (n.off("remove", this.onRenderAssetRemoved, this),
            n.on("remove", this.onRenderAssetRemoved, this))
        }
        this.data.initialized && this.data.type === "mesh" && (s || (this.data.render = null),
        this.system.recreatePhysicalShapes(this))
    }
    onSetModel(e, t, s) {
        this.data.initialized && this.data.type === "mesh" && this.system.implementations.mesh.doRecreatePhysicalShape(this)
    }
    onSetRender(e, t, s) {
        this.onSetModel(e, t, s)
    }
    onAssetRemoved(e) {
        e.off("remove", this.onAssetRemoved, this),
        this.data.asset === e.id && (this.asset = null)
    }
    onRenderAssetRemoved(e) {
        e.off("remove", this.onRenderAssetRemoved, this),
        this.data.renderAsset === e.id && (this.renderAsset = null)
    }
    _getCompoundChildShapeIndex(e) {
        const t = this.data.shape
          , s = t.getNumChildShapes();
        for (let i = 0; i < s; i++)
            if (t.getChildShape(i).ptr === e.ptr)
                return i;
        return null
    }
    _onInsert(e) {
        if (!(typeof Ammo > "u")) {
            if (this._compoundParent)
                this.system.recreatePhysicalShapes(this);
            else if (!this.entity.rigidbody) {
                let t = this.entity.parent;
                for (; t; ) {
                    if (t.collision && t.collision.type === "compound") {
                        t.collision.shape.getNumChildShapes() === 0 ? this.system.recreatePhysicalShapes(t.collision) : this.system.recreatePhysicalShapes(this);
                        break
                    }
                    t = t.parent
                }
            }
        }
    }
    _updateCompound() {
        const e = this.entity;
        if (e._dirtyWorld) {
            let t = e._dirtyLocal
              , s = e;
            for (; s && !t && !(s.collision && s.collision === this._compoundParent); )
                s._dirtyLocal && (t = !0),
                s = s.parent;
            if (t) {
                e.forEach(this.system.implementations.compound._updateEachDescendantTransform, e);
                const i = this._compoundParent.entity.rigidbody;
                i && i.activate()
            }
        }
    }
    getShapePosition() {
        const e = this.entity.getPosition();
        if (this._hasOffset) {
            const t = this.entity.getRotation()
              , s = this.data.linearOffset;
            return rv.copy(t).transformVector(s, nv),
            nv.add(e)
        }
        return e
    }
    getShapeRotation() {
        const e = this.entity.getRotation();
        return this._hasOffset ? rv.copy(e).mul(this.data.angularOffset) : e
    }
    onEnable() {
        if (this.data.type === "mesh" && (this.data.asset || this.data.renderAsset) && this.data.initialized) {
            const e = this.system.app.assets.get(this.data.asset || this.data.renderAsset);
            if (e && (!e.resource || !this.data.shape)) {
                this.system.recreatePhysicalShapes(this);
                return
            }
        }
        if (this.entity.rigidbody)
            this.entity.rigidbody.enabled && this.entity.rigidbody.enableSimulation();
        else if (this._compoundParent && this !== this._compoundParent)
            if (this._compoundParent.shape.getNumChildShapes() === 0)
                this.system.recreatePhysicalShapes(this._compoundParent);
            else {
                const e = this.system._getNodeTransform(this.entity, this._compoundParent.entity);
                this._compoundParent.shape.addChildShape(e, this.data.shape),
                Ammo.destroy(e),
                this._compoundParent.entity.rigidbody && this._compoundParent.entity.rigidbody.activate()
            }
        else
            this.entity.trigger && this.entity.trigger.enable()
    }
    onDisable() {
        this.entity.rigidbody ? this.entity.rigidbody.disableSimulation() : this._compoundParent && this !== this._compoundParent ? this._compoundParent.entity._destroying || (this.system._removeCompoundChild(this._compoundParent, this.data.shape),
        this._compoundParent.entity.rigidbody && this._compoundParent.entity.rigidbody.activate()) : this.entity.trigger && this.entity.trigger.disable()
    }
    onBeforeRemove() {
        this.asset && (this.asset = null),
        this.renderAsset && (this.renderAsset = null),
        this.entity.off("insert", this._onInsert, this),
        this.off()
    }
}
Pa.EVENT_CONTACT = "contact";
Pa.EVENT_COLLISIONSTART = "collisionstart";
Pa.EVENT_COLLISIONEND = "collisionend";
Pa.EVENT_TRIGGERENTER = "triggerenter";
Pa.EVENT_TRIGGERLEAVE = "triggerleave";
class m2 {
    constructor() {
        this.enabled = !0,
        this.type = "box",
        this.halfExtents = new y(.5,.5,.5),
        this.linearOffset = new y,
        this.angularOffset = new ne,
        this.radius = .5,
        this.axis = 1,
        this.height = 2,
        this.asset = null,
        this.renderAsset = null,
        this.shape = null,
        this.model = null,
        this.render = null,
        this.initialized = !1
    }
}
const Il = "static"
  , ai = "dynamic"
  , Ya = "kinematic"
  , _2 = 2
  , Hl = 4
  , Hm = 1
  , av = 4
  , Xx = 5
  , g2 = 1
  , ov = 2
  , y2 = 4
  , lv = 16
  , hv = 65535
  , Wm = 65533;
let oi, Br, Ka;
class jx {
    constructor(e, t, s) {
        this.entity = t.entity,
        this.component = t,
        this.app = e,
        typeof Ammo < "u" && !oi && (oi = new Ammo.btVector3,
        Br = new Ammo.btQuaternion,
        Ka = new Ammo.btTransform),
        this.initialize(s)
    }
    initialize(e) {
        const t = this.entity
          , s = e.shape;
        if (s && typeof Ammo < "u") {
            t.trigger && t.trigger.destroy();
            const i = 1
              , n = this.component;
            if (n) {
                const o = n.getShapePosition()
                  , l = n.getShapeRotation();
                oi.setValue(o.x, o.y, o.z),
                Br.setValue(l.x, l.y, l.z, l.w)
            } else {
                const o = t.getPosition()
                  , l = t.getRotation();
                oi.setValue(o.x, o.y, o.z),
                Br.setValue(l.x, l.y, l.z, l.w)
            }
            Ka.setOrigin(oi),
            Ka.setRotation(Br);
            const r = this.app.systems.rigidbody.createBody(i, s, Ka);
            r.setRestitution(0),
            r.setFriction(0),
            r.setDamping(0, 0),
            oi.setValue(0, 0, 0),
            r.setLinearFactor(oi),
            r.setAngularFactor(oi),
            r.setCollisionFlags(r.getCollisionFlags() | Hl),
            r.entity = t,
            this.body = r,
            this.component.enabled && t.enabled && this.enable()
        }
    }
    destroy() {
        const e = this.body;
        e && (this.disable(),
        this.app.systems.rigidbody.destroyBody(e))
    }
    _getEntityTransform(e) {
        const t = this.component;
        if (t) {
            const s = t.getShapePosition()
              , i = t.getShapeRotation();
            oi.setValue(s.x, s.y, s.z),
            Br.setValue(i.x, i.y, i.z, i.w)
        } else {
            const s = this.entity.getPosition()
              , i = this.entity.getRotation();
            oi.setValue(s.x, s.y, s.z),
            Br.setValue(i.x, i.y, i.z, i.w)
        }
        e.setOrigin(oi),
        e.setRotation(Br)
    }
    updateTransform() {
        this._getEntityTransform(Ka);
        const e = this.body;
        e.setWorldTransform(Ka),
        e.activate()
    }
    enable() {
        const e = this.body;
        if (!e)
            return;
        const t = this.app.systems;
        t.rigidbody.addBody(e, lv, Wm ^ lv),
        t.rigidbody._triggers.push(this),
        e.forceActivationState(Hm),
        this.updateTransform()
    }
    disable() {
        const e = this.body;
        if (!e)
            return;
        const t = this.app.systems
          , s = t.rigidbody._triggers.indexOf(this);
        s > -1 && t.rigidbody._triggers.splice(s, 1),
        t.rigidbody.removeBody(e),
        e.forceActivationState(Xx)
    }
}
const hd = new ee
  , v2 = new y
  , S2 = new y
  , kr = new ne
  , x2 = new yt
  , $x = ["enabled", "type", "halfExtents", "linearOffset", "angularOffset", "radius", "axis", "height", "asset", "renderAsset", "shape", "model", "render"];
class Ra {
    constructor(e) {
        this.system = e
    }
    beforeInitialize(e, t) {
        t.shape = null,
        t.model = new kn,
        t.model.graph = new yt
    }
    afterInitialize(e, t) {
        this.recreatePhysicalShapes(e),
        e.data.initialized = !0
    }
    reset(e, t) {
        this.beforeInitialize(e, t),
        this.afterInitialize(e, t)
    }
    recreatePhysicalShapes(e) {
        const t = e.entity
          , s = e.data;
        if (typeof Ammo < "u") {
            t.trigger && (t.trigger.destroy(),
            delete t.trigger),
            s.shape && (e._compoundParent && (this.system._removeCompoundChild(e._compoundParent, s.shape),
            e._compoundParent.entity.rigidbody && e._compoundParent.entity.rigidbody.activate()),
            this.destroyShape(s)),
            s.shape = this.createPhysicalShape(e.entity, s);
            const i = !e._compoundParent;
            if (s.type === "compound" && (!e._compoundParent || e === e._compoundParent))
                e._compoundParent = e,
                t.forEach(this._addEachDescendant, e);
            else if (s.type !== "compound" && (e._compoundParent && e === e._compoundParent && t.forEach(this.system.implementations.compound._updateEachDescendant, e),
            !e.rigidbody)) {
                e._compoundParent = null;
                let n = t.parent;
                for (; n; ) {
                    if (n.collision && n.collision.type === "compound") {
                        e._compoundParent = n.collision;
                        break
                    }
                    n = n.parent
                }
            }
            e._compoundParent && e !== e._compoundParent && (i && e._compoundParent.shape.getNumChildShapes() === 0 ? this.system.recreatePhysicalShapes(e._compoundParent) : (this.system.updateCompoundChildTransform(t),
            e._compoundParent.entity.rigidbody && e._compoundParent.entity.rigidbody.activate())),
            t.rigidbody ? (t.rigidbody.disableSimulation(),
            t.rigidbody.createBody(),
            t.enabled && t.rigidbody.enabled && t.rigidbody.enableSimulation()) : e._compoundParent || (t.trigger ? t.trigger.initialize(s) : t.trigger = new jx(this.system.app,e,s))
        }
    }
    createPhysicalShape(e, t) {}
    updateTransform(e, t, s, i) {
        e.entity.trigger && e.entity.trigger.updateTransform()
    }
    destroyShape(e) {
        e.shape && (Ammo.destroy(e.shape),
        e.shape = null)
    }
    beforeRemove(e, t) {
        t.data.shape && (t._compoundParent && !t._compoundParent.entity._destroying && (this.system._removeCompoundChild(t._compoundParent, t.data.shape),
        t._compoundParent.entity.rigidbody && t._compoundParent.entity.rigidbody.activate()),
        t._compoundParent = null,
        this.destroyShape(t.data))
    }
    remove(e, t) {
        e.rigidbody && e.rigidbody.body && e.rigidbody.disableSimulation(),
        e.trigger && (e.trigger.destroy(),
        delete e.trigger)
    }
    clone(e, t) {
        const s = this.system.store[e.getGuid()]
          , i = {
            enabled: s.data.enabled,
            type: s.data.type,
            halfExtents: [s.data.halfExtents.x, s.data.halfExtents.y, s.data.halfExtents.z],
            linearOffset: [s.data.linearOffset.x, s.data.linearOffset.y, s.data.linearOffset.z],
            angularOffset: [s.data.angularOffset.x, s.data.angularOffset.y, s.data.angularOffset.z, s.data.angularOffset.w],
            radius: s.data.radius,
            axis: s.data.axis,
            height: s.data.height,
            asset: s.data.asset,
            renderAsset: s.data.renderAsset,
            model: s.data.model,
            render: s.data.render
        };
        return this.system.addComponent(t, i)
    }
}
class w2 extends Ra {
    createPhysicalShape(e, t) {
        if (typeof Ammo < "u") {
            const s = t.halfExtents
              , i = new Ammo.btVector3(s ? s.x : .5,s ? s.y : .5,s ? s.z : .5)
              , n = new Ammo.btBoxShape(i);
            return Ammo.destroy(i),
            n
        }
    }
}
class b2 extends Ra {
    createPhysicalShape(e, t) {
        if (typeof Ammo < "u")
            return new Ammo.btSphereShape(t.radius)
    }
}
class T2 extends Ra {
    createPhysicalShape(e, t) {
        var s, i, n;
        const r = (s = t.axis) != null ? s : 1
          , o = (i = t.radius) != null ? i : .5
          , l = Math.max(((n = t.height) != null ? n : 2) - 2 * o, 0);
        let c = null;
        if (typeof Ammo < "u")
            switch (r) {
            case 0:
                c = new Ammo.btCapsuleShapeX(o,l);
                break;
            case 1:
                c = new Ammo.btCapsuleShape(o,l);
                break;
            case 2:
                c = new Ammo.btCapsuleShapeZ(o,l);
                break
            }
        return c
    }
}
class C2 extends Ra {
    createPhysicalShape(e, t) {
        var s, i, n;
        const r = (s = t.axis) != null ? s : 1
          , o = (i = t.radius) != null ? i : .5
          , l = (n = t.height) != null ? n : 1;
        let c = null
          , d = null;
        if (typeof Ammo < "u")
            switch (r) {
            case 0:
                c = new Ammo.btVector3(l * .5,o,o),
                d = new Ammo.btCylinderShapeX(c);
                break;
            case 1:
                c = new Ammo.btVector3(o,l * .5,o),
                d = new Ammo.btCylinderShape(c);
                break;
            case 2:
                c = new Ammo.btVector3(o,o,l * .5),
                d = new Ammo.btCylinderShapeZ(c);
                break
            }
        return c && Ammo.destroy(c),
        d
    }
}
class E2 extends Ra {
    createPhysicalShape(e, t) {
        var s, i, n;
        const r = (s = t.axis) != null ? s : 1
          , o = (i = t.radius) != null ? i : .5
          , l = (n = t.height) != null ? n : 1;
        let c = null;
        if (typeof Ammo < "u")
            switch (r) {
            case 0:
                c = new Ammo.btConeShapeX(o,l);
                break;
            case 1:
                c = new Ammo.btConeShape(o,l);
                break;
            case 2:
                c = new Ammo.btConeShapeZ(o,l);
                break
            }
        return c
    }
}
class A2 extends Ra {
    beforeInitialize(e, t) {}
    createAmmoMesh(e, t, s) {
        let i;
        if (this.system._triMeshCache[e.id])
            i = this.system._triMeshCache[e.id];
        else {
            const c = e.vertexBuffer
              , d = c.getFormat();
            let h, u;
            for (let T = 0; T < d.elements.length; T++) {
                const b = d.elements[T];
                if (b.name === ut) {
                    u = new Float32Array(c.lock(),b.offset),
                    h = b.stride / 4;
                    break
                }
            }
            const f = [];
            e.getIndices(f);
            const p = e.primitive[0].count / 3
              , _ = new Ammo.btVector3
              , m = new Ammo.btVector3
              , g = new Ammo.btVector3;
            let v, x, S;
            const w = e.primitive[0].base;
            i = new Ammo.btTriangleMesh,
            this.system._triMeshCache[e.id] = i;
            for (let T = 0; T < p; T++)
                v = f[w + T * 3] * h,
                x = f[w + T * 3 + 1] * h,
                S = f[w + T * 3 + 2] * h,
                _.setValue(u[v], u[v + 1], u[v + 2]),
                m.setValue(u[x], u[x + 1], u[x + 2]),
                g.setValue(u[S], u[S + 1], u[S + 2]),
                i.addTriangle(_, m, g, !0);
            Ammo.destroy(_),
            Ammo.destroy(m),
            Ammo.destroy(g)
        }
        const n = !0
          , r = new Ammo.btBvhTriangleMeshShape(i,n)
          , o = this.system._getNodeScaling(t);
        r.setLocalScaling(o),
        Ammo.destroy(o);
        const l = this.system._getNodeTransform(t);
        s.addChildShape(l, r),
        Ammo.destroy(l)
    }
    createPhysicalShape(e, t) {
        if (!(typeof Ammo > "u") && (t.model || t.render)) {
            const s = new Ammo.btCompoundShape;
            if (t.model) {
                const o = t.model.meshInstances;
                for (let l = 0; l < o.length; l++)
                    this.createAmmoMesh(o[l].mesh, o[l].node, s)
            } else if (t.render) {
                const o = t.render.meshes;
                for (let l = 0; l < o.length; l++)
                    this.createAmmoMesh(o[l], x2, s)
            }
            const n = e.getWorldTransform().getScale()
              , r = new Ammo.btVector3(n.x,n.y,n.z);
            return s.setLocalScaling(r),
            Ammo.destroy(r),
            s
        }
    }
    recreatePhysicalShapes(e) {
        const t = e.data;
        if ((t.renderAsset || t.asset) && e.enabled && e.entity.enabled) {
            this.loadAsset(e, t.renderAsset || t.asset, t.renderAsset ? "render" : "model");
            return
        }
        this.doRecreatePhysicalShape(e)
    }
    loadAsset(e, t, s) {
        const i = e.data
          , n = this.system.app.assets
          , r = i[s]
          , o = d => {
            i[s] === r && (i[s] = d.resource,
            this.doRecreatePhysicalShape(e))
        }
          , l = d => {
            d.ready(h => {
                if (h.data.containerAsset) {
                    const u = n.get(h.data.containerAsset);
                    u.loaded ? o(h) : (u.ready( () => {
                        o(h)
                    }
                    ),
                    n.load(u))
                } else
                    o(h)
            }
            ),
            n.load(d)
        }
          , c = n.get(t);
        c ? l(c) : n.once("add:" + t, l)
    }
    doRecreatePhysicalShape(e) {
        const t = e.entity
          , s = e.data;
        s.model || s.render ? (this.destroyShape(s),
        s.shape = this.createPhysicalShape(t, s),
        t.rigidbody ? (t.rigidbody.disableSimulation(),
        t.rigidbody.createBody(),
        t.enabled && t.rigidbody.enabled && t.rigidbody.enableSimulation()) : t.trigger ? t.trigger.initialize(s) : t.trigger = new jx(this.system.app,e,s)) : (this.beforeRemove(t, e),
        this.remove(t, s))
    }
    updateTransform(e, t, s, i) {
        if (e.shape) {
            const r = e.entity.getWorldTransform().getScale()
              , o = e.shape.getLocalScaling();
            (r.x !== o.x() || r.y !== o.y() || r.z !== o.z()) && this.doRecreatePhysicalShape(e)
        }
        super.updateTransform(e, t, s, i)
    }
    destroyShape(e) {
        if (!e.shape)
            return;
        const t = e.shape.getNumChildShapes();
        for (let s = 0; s < t; s++) {
            const i = e.shape.getChildShape(s);
            Ammo.destroy(i)
        }
        Ammo.destroy(e.shape),
        e.shape = null
    }
}
class M2 extends Ra {
    createPhysicalShape(e, t) {
        if (typeof Ammo < "u")
            return new Ammo.btCompoundShape
    }
    _addEachDescendant(e) {
        !e.collision || e.rigidbody || (e.collision._compoundParent = this,
        e !== this.entity && e.collision.system.recreatePhysicalShapes(e.collision))
    }
    _updateEachDescendant(e) {
        e.collision && e.collision._compoundParent === this && (e.collision._compoundParent = null,
        e !== this.entity && !e.rigidbody && e.collision.system.recreatePhysicalShapes(e.collision))
    }
    _updateEachDescendantTransform(e) {
        !e.collision || e.collision._compoundParent !== this.collision._compoundParent || this.collision.system.updateCompoundChildTransform(e)
    }
}
class P2 extends it {
    constructor(e) {
        super(e),
        this.id = "collision",
        this.ComponentType = Pa,
        this.DataType = m2,
        this.schema = $x,
        this.implementations = {},
        this._triMeshCache = {},
        this.on("beforeremove", this.onBeforeRemove, this),
        this.on("remove", this.onRemove, this)
    }
    initializeComponentData(e, t, s) {
        s = ["type", "halfExtents", "radius", "axis", "height", "shape", "model", "asset", "render", "renderAsset", "enabled", "linearOffset", "angularOffset"];
        const i = {};
        for (let o = 0, l = s.length; o < l; o++) {
            const c = s[o];
            i[c] = t[c]
        }
        let n;
        if (t.hasOwnProperty("asset") ? (n = s.indexOf("model"),
        n !== -1 && s.splice(n, 1),
        n = s.indexOf("render"),
        n !== -1 && s.splice(n, 1)) : t.hasOwnProperty("model") && (n = s.indexOf("asset"),
        n !== -1 && s.splice(n, 1)),
        i.type || (i.type = e.data.type),
        e.data.type = i.type,
        Array.isArray(i.halfExtents) && (i.halfExtents = new y(i.halfExtents)),
        Array.isArray(i.linearOffset) && (i.linearOffset = new y(i.linearOffset)),
        Array.isArray(i.angularOffset)) {
            const o = i.angularOffset;
            o.length === 3 ? i.angularOffset = new ne().setFromEulerAngles(o[0], o[1], o[2]) : i.angularOffset = new ne(i.angularOffset)
        }
        const r = this._createImplementation(i.type);
        r.beforeInitialize(e, i),
        super.initializeComponentData(e, i, s),
        r.afterInitialize(e, i)
    }
    _createImplementation(e) {
        if (this.implementations[e] === void 0) {
            let t;
            switch (e) {
            case "box":
                t = new w2(this);
                break;
            case "sphere":
                t = new b2(this);
                break;
            case "capsule":
                t = new T2(this);
                break;
            case "cylinder":
                t = new C2(this);
                break;
            case "cone":
                t = new E2(this);
                break;
            case "mesh":
                t = new A2(this);
                break;
            case "compound":
                t = new M2(this);
                break
            }
            this.implementations[e] = t
        }
        return this.implementations[e]
    }
    _getImplementation(e) {
        return this.implementations[e.collision.data.type]
    }
    cloneComponent(e, t) {
        return this._getImplementation(e).clone(e, t)
    }
    onBeforeRemove(e, t) {
        this.implementations[t.data.type].beforeRemove(e, t),
        t.onBeforeRemove()
    }
    onRemove(e, t) {
        this.implementations[t.type].remove(e, t)
    }
    updateCompoundChildTransform(e) {
        if (this._removeCompoundChild(e.collision._compoundParent, e.collision.data.shape),
        e.enabled && e.collision.enabled) {
            const t = this._getNodeTransform(e, e.collision._compoundParent.entity);
            e.collision._compoundParent.shape.addChildShape(t, e.collision.data.shape),
            Ammo.destroy(t)
        }
    }
    _removeCompoundChild(e, t) {
        if (e.shape.removeChildShape)
            e.shape.removeChildShape(t);
        else {
            const s = e._getCompoundChildShapeIndex(t);
            s !== null && e.shape.removeChildShapeByIndex(s)
        }
    }
    onTransformChanged(e, t, s, i) {
        this.implementations[e.data.type].updateTransform(e, t, s, i)
    }
    changeType(e, t, s) {
        this.implementations[t].beforeRemove(e.entity, e),
        this.implementations[t].remove(e.entity, e.data),
        this._createImplementation(s).reset(e, e.data)
    }
    recreatePhysicalShapes(e) {
        this.implementations[e.data.type].recreatePhysicalShapes(e)
    }
    _calculateNodeRelativeTransform(e, t) {
        if (e === t) {
            const s = e.getWorldTransform().getScale();
            hd.setScale(s.x, s.y, s.z)
        } else
            this._calculateNodeRelativeTransform(e.parent, t),
            hd.mul(e.getLocalTransform())
    }
    _getNodeScaling(e) {
        const s = e.getWorldTransform().getScale();
        return new Ammo.btVector3(s.x,s.y,s.z)
    }
    _getNodeTransform(e, t) {
        let s, i;
        t ? (this._calculateNodeRelativeTransform(e, t),
        s = v2,
        i = kr,
        hd.getTranslation(s),
        i.setFromMat4(hd)) : (s = e.getPosition(),
        i = e.getRotation());
        const n = new Ammo.btQuaternion
          , r = new Ammo.btTransform;
        r.setIdentity();
        const o = r.getOrigin()
          , l = e.collision;
        if (l && l._hasOffset) {
            const c = l.data.linearOffset
              , d = l.data.angularOffset
              , h = S2;
            kr.copy(i).transformVector(c, h),
            h.add(s),
            kr.copy(i).mul(d),
            o.setValue(h.x, h.y, h.z),
            n.setValue(kr.x, kr.y, kr.z, kr.w)
        } else
            o.setValue(s.x, s.y, s.z),
            n.setValue(i.x, i.y, i.z, i.w);
        return r.setRotation(n),
        Ammo.destroy(n),
        Ammo.destroy(o),
        r
    }
    destroy() {
        for (const e in this._triMeshCache)
            Ammo.destroy(this._triMeshCache[e]);
        this._triMeshCache = null,
        super.destroy()
    }
}
_e._buildAccessors(Pa.prototype, $x);
const R2 = new Os;
class I2 {
    constructor(e, t, s) {
        this._entity = e,
        this._element = e.element,
        this.model = new kn,
        this.node = new yt,
        this.model.graph = this.node,
        this.mesh = t,
        this.meshInstance = new Fe(this.mesh,s,this.node),
        this.meshInstance.name = "ImageElement: " + e.name,
        this.meshInstance.castShadow = !1,
        this.meshInstance.receiveShadow = !1,
        this._meshDirty = !1,
        this.model.meshInstances.push(this.meshInstance),
        this._entity.addChild(this.model.graph),
        this.model._entity = this._entity,
        this.unmaskMeshInstance = null
    }
    destroy() {
        this.setMaterial(null),
        this._element.removeModelFromLayers(this.model),
        this.model.destroy(),
        this.model = null,
        this.node = null,
        this.mesh = null,
        this.meshInstance = null,
        this._entity = null,
        this._element = null
    }
    setMesh(e) {
        this.meshInstance && (this.mesh = e,
        this.meshInstance.mesh = e,
        this.meshInstance.visible = !!e,
        this.unmaskMeshInstance && (this.unmaskMeshInstance.mesh = e),
        this.forceUpdateAabb())
    }
    setMask(e) {
        if (this.meshInstance) {
            if (e) {
                this.unmaskMeshInstance = new Fe(this.mesh,this.meshInstance.material,this.node),
                this.unmaskMeshInstance.name = "Unmask: " + this._entity.name,
                this.unmaskMeshInstance.castShadow = !1,
                this.unmaskMeshInstance.receiveShadow = !1,
                this.unmaskMeshInstance.pick = !1,
                this.model.meshInstances.push(this.unmaskMeshInstance);
                for (const t in this.meshInstance.parameters)
                    this.unmaskMeshInstance.setParameter(t, this.meshInstance.parameters[t].data)
            } else {
                const t = this.model.meshInstances.indexOf(this.unmaskMeshInstance);
                t >= 0 && this.model.meshInstances.splice(t, 1),
                this.unmaskMeshInstance = null
            }
            this._entity.enabled && this._element.enabled && (this._element.removeModelFromLayers(this.model),
            this._element.addModelToLayers(this.model))
        }
    }
    setMaterial(e) {
        this.meshInstance && (this.meshInstance.material = e,
        this.unmaskMeshInstance && (this.unmaskMeshInstance.material = e))
    }
    setParameter(e, t) {
        this.meshInstance && (this.meshInstance.setParameter(e, t),
        this.unmaskMeshInstance && this.unmaskMeshInstance.setParameter(e, t))
    }
    deleteParameter(e) {
        this.meshInstance && (this.meshInstance.deleteParameter(e),
        this.unmaskMeshInstance && this.unmaskMeshInstance.deleteParameter(e))
    }
    setUnmaskDrawOrder() {
        if (!this.meshInstance)
            return;
        const e = function t(s) {
            let i;
            const n = s.children
              , r = n.length;
            if (r) {
                for (let l = 0; l < r; l++)
                    n[l].element && (i = n[l]);
                if (!i)
                    return null;
                const o = t(i);
                return o || i
            }
            return null
        };
        if (this.unmaskMeshInstance) {
            const t = e(this._entity);
            t && t.element ? this.unmaskMeshInstance.drawOrder = t.element.drawOrder + t.element.getMaskOffset() : this.unmaskMeshInstance.drawOrder = this.meshInstance.drawOrder + this._element.getMaskOffset()
        }
    }
    setDrawOrder(e) {
        this.meshInstance && (this.meshInstance.drawOrder = e)
    }
    setCull(e) {
        if (!this.meshInstance)
            return;
        const t = this._element;
        let s = null;
        e && t._isScreenSpace() && (s = function(i) {
            return t.isVisibleForCamera(i)
        }
        ),
        this.meshInstance.cull = e,
        this.meshInstance.isVisibleFunc = s,
        this.unmaskMeshInstance && (this.unmaskMeshInstance.cull = e,
        this.unmaskMeshInstance.isVisibleFunc = s)
    }
    setScreenSpace(e) {
        this.meshInstance && (this.meshInstance.screenSpace = e,
        this.unmaskMeshInstance && (this.unmaskMeshInstance.screenSpace = e))
    }
    setLayer(e) {
        this.meshInstance && (this.meshInstance.layer = e,
        this.unmaskMeshInstance && (this.unmaskMeshInstance.layer = e))
    }
    forceUpdateAabb(e) {
        this.meshInstance && (this.meshInstance._aabbVer = -1,
        this.unmaskMeshInstance && (this.unmaskMeshInstance._aabbVer = -1))
    }
    setAabbFunc(e) {
        this.meshInstance && (this.meshInstance._updateAabbFunc = e,
        this.unmaskMeshInstance && (this.unmaskMeshInstance._updateAabbFunc = e))
    }
}
class L2 {
    constructor(e) {
        this._element = e,
        this._entity = e.entity,
        this._system = e.system,
        this._textureAsset = null,
        this._texture = null,
        this._materialAsset = null,
        this._material = null,
        this._spriteAsset = null,
        this._sprite = null,
        this._spriteFrame = 0,
        this._pixelsPerUnit = null,
        this._targetAspectRatio = -1,
        this._rect = new M(0,0,1,1),
        this._mask = !1,
        this._maskRef = 0,
        this._outerScale = new P,
        this._outerScaleUniform = new Float32Array(2),
        this._innerOffset = new M,
        this._innerOffsetUniform = new Float32Array(4),
        this._atlasRect = new M,
        this._atlasRectUniform = new Float32Array(4),
        this._defaultMesh = this._createMesh(),
        this._renderable = new I2(this._entity,this._defaultMesh,this._material),
        this._color = new z(1,1,1,1),
        this._colorUniform = new Float32Array([1, 1, 1]),
        this._renderable.setParameter("material_emissive", this._colorUniform),
        this._renderable.setParameter("material_opacity", 1),
        this._updateAabbFunc = this._updateAabb.bind(this),
        this._onScreenChange(this._element.screen),
        this._element.on("resize", this._onParentResizeOrPivotChange, this),
        this._element.on("set:pivot", this._onParentResizeOrPivotChange, this),
        this._element.on("screen:set:screenspace", this._onScreenSpaceChange, this),
        this._element.on("set:screen", this._onScreenChange, this),
        this._element.on("set:draworder", this._onDrawOrderChange, this),
        this._element.on("screen:set:resolution", this._onResolutionChange, this)
    }
    destroy() {
        this.textureAsset = null,
        this.spriteAsset = null,
        this.materialAsset = null,
        this._renderable.setMesh(this._defaultMesh),
        this._renderable.destroy(),
        this._defaultMesh = null,
        this._element.off("resize", this._onParentResizeOrPivotChange, this),
        this._element.off("set:pivot", this._onParentResizeOrPivotChange, this),
        this._element.off("screen:set:screenspace", this._onScreenSpaceChange, this),
        this._element.off("set:screen", this._onScreenChange, this),
        this._element.off("set:draworder", this._onDrawOrderChange, this),
        this._element.off("screen:set:resolution", this._onResolutionChange, this)
    }
    _onResolutionChange(e) {}
    _onParentResizeOrPivotChange() {
        this._renderable.mesh && this._updateMesh(this._renderable.mesh)
    }
    _onScreenSpaceChange(e) {
        this._updateMaterial(e)
    }
    _onScreenChange(e, t) {
        e ? this._updateMaterial(e.screen.screenSpace) : this._updateMaterial(!1)
    }
    _onDrawOrderChange(e) {
        this._renderable.setDrawOrder(e),
        this.mask && this._element.screen && this._element.screen.screen.once("syncdraworder", function() {
            this._renderable.setUnmaskDrawOrder()
        }, this)
    }
    _hasUserMaterial() {
        return !!this._materialAsset || !!this._material && this._system.defaultImageMaterials.indexOf(this._material) === -1
    }
    _use9Slicing() {
        return this.sprite && (this.sprite.renderMode === xt || this.sprite.renderMode === _t)
    }
    _updateMaterial(e) {
        const t = !!this._mask
          , s = !!(this.sprite && this.sprite.renderMode === xt)
          , i = !!(this.sprite && this.sprite.renderMode === _t);
        this._hasUserMaterial() || (this._material = this._system.getImageElementMaterial(e, t, s, i)),
        this._renderable && (this._renderable.setCull(!this._element._isScreenSpace() || this._element._isScreenCulled()),
        this._renderable.setMaterial(this._material),
        this._renderable.setScreenSpace(e),
        this._renderable.setLayer(e ? QE : X_))
    }
    _createMesh() {
        const e = this._element
          , t = e.calculatedWidth
          , s = e.calculatedHeight
          , i = this._rect
          , n = this._system.app.graphicsDevice
          , r = new Float32Array([t, 0, 0, 0, 0, 1, i.x + i.z, 1 - i.y, t, s, 0, 0, 0, 1, i.x + i.z, 1 - (i.y + i.w), 0, 0, 0, 0, 0, 1, i.x, 1 - i.y, 0, s, 0, 0, 0, 1, i.x, 1 - (i.y + i.w)])
          , o = R2.get(n, () => new fs(n,[{
            semantic: ut,
            components: 3,
            type: Me
        }, {
            semantic: Is,
            components: 3,
            type: Me
        }, {
            semantic: Ls,
            components: 2,
            type: Me
        }]))
          , l = new xi(n,o,4,es,r.buffer)
          , c = new ms(n);
        return c.vertexBuffer = l,
        c.primitive[0].type = Ks,
        c.primitive[0].base = 0,
        c.primitive[0].count = 4,
        c.primitive[0].indexed = !1,
        c.aabb.setMinMax(y.ZERO, new y(t,s,0)),
        this._updateMesh(c),
        c
    }
    _updateMesh(e) {
        const t = this._element;
        let s = t.calculatedWidth
          , i = t.calculatedHeight;
        if (t.fitMode !== zd && this._targetAspectRatio > 0) {
            const r = t.calculatedWidth / t.calculatedHeight;
            t.fitMode === d2 && r > this._targetAspectRatio || t.fitMode === u2 && r < this._targetAspectRatio ? s = t.calculatedHeight * this._targetAspectRatio : i = t.calculatedWidth / this._targetAspectRatio
        }
        const n = t._isScreenSpace();
        if (this._updateMaterial(n),
        this._renderable && this._renderable.forceUpdateAabb(),
        this.sprite && (this.sprite.renderMode === xt || this.sprite.renderMode === _t)) {
            const r = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]]
              , o = 2 / r.rect.z
              , l = 2 / r.rect.w;
            this._innerOffset.set(r.border.x * o, r.border.y * l, r.border.z * o, r.border.w * l);
            const c = this.sprite.atlas.texture;
            this._atlasRect.set(r.rect.x / c.width, r.rect.y / c.height, r.rect.z / c.width, r.rect.w / c.height);
            const d = this._pixelsPerUnit !== null ? this._pixelsPerUnit : this.sprite.pixelsPerUnit
              , h = r.rect.z / d
              , u = r.rect.w / d;
            this._outerScale.set(Math.max(s, this._innerOffset.x * h), Math.max(i, this._innerOffset.y * u));
            let f = h
              , p = u;
            this._outerScale.x /= h,
            this._outerScale.y /= u,
            f *= W.clamp(s / (this._innerOffset.x * h), 1e-4, 1),
            p *= W.clamp(i / (this._innerOffset.y * u), 1e-4, 1),
            this._renderable && (this._innerOffsetUniform[0] = this._innerOffset.x,
            this._innerOffsetUniform[1] = this._innerOffset.y,
            this._innerOffsetUniform[2] = this._innerOffset.z,
            this._innerOffsetUniform[3] = this._innerOffset.w,
            this._renderable.setParameter("innerOffset", this._innerOffsetUniform),
            this._atlasRectUniform[0] = this._atlasRect.x,
            this._atlasRectUniform[1] = this._atlasRect.y,
            this._atlasRectUniform[2] = this._atlasRect.z,
            this._atlasRectUniform[3] = this._atlasRect.w,
            this._renderable.setParameter("atlasRect", this._atlasRectUniform),
            this._outerScaleUniform[0] = this._outerScale.x,
            this._outerScaleUniform[1] = this._outerScale.y,
            this._renderable.setParameter("outerScale", this._outerScaleUniform),
            this._renderable.setAabbFunc(this._updateAabbFunc),
            this._renderable.node.setLocalScale(f, p, 1),
            this._renderable.node.setLocalPosition((.5 - t.pivot.x) * s, (.5 - t.pivot.y) * i, 0))
        } else {
            const r = e.vertexBuffer
              , o = new Float32Array(r.lock())
              , l = t.pivot.x
              , c = t.pivot.y;
            o[0] = s - l * s,
            o[1] = 0 - c * i,
            o[8] = s - l * s,
            o[9] = i - c * i,
            o[16] = 0 - l * s,
            o[17] = 0 - c * i,
            o[24] = 0 - l * s,
            o[25] = i - c * i;
            let d = 1
              , h = 1
              , u = this._rect;
            if (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {
                const _ = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
                _ && (u = _.rect,
                d = this._sprite.atlas.texture.width,
                h = this._sprite.atlas.texture.height)
            }
            o[6] = (u.x + u.z) / d,
            o[7] = 1 - u.y / h,
            o[14] = (u.x + u.z) / d,
            o[15] = 1 - (u.y + u.w) / h,
            o[22] = u.x / d,
            o[23] = 1 - u.y / h,
            o[30] = u.x / d,
            o[31] = 1 - (u.y + u.w) / h,
            r.unlock();
            const f = new y(0 - l * s,0 - c * i,0)
              , p = new y(s - l * s,i - c * i,0);
            e.aabb.setMinMax(f, p),
            this._renderable && (this._renderable.node.setLocalScale(1, 1, 1),
            this._renderable.node.setLocalPosition(0, 0, 0),
            this._renderable.setAabbFunc(null))
        }
        this._meshDirty = !1
    }
    _updateSprite() {
        let e = !1
          , t = null;
        if (this._targetAspectRatio = -1,
        this._sprite && this._sprite.atlas) {
            t = this._sprite.meshes[this.spriteFrame],
            e = this._sprite.renderMode === xt || this._sprite.renderMode === _t;
            const s = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
            (s == null ? void 0 : s.rect.w) > 0 && (this._targetAspectRatio = s.rect.z / s.rect.w)
        }
        this.mesh = e ? t : this._defaultMesh,
        this.refreshMesh()
    }
    refreshMesh() {
        this.mesh && (this._element._beingInitialized ? this._meshDirty = !0 : this._updateMesh(this.mesh))
    }
    _updateAabb(e) {
        return e.center.set(0, 0, 0),
        e.halfExtents.set(this._outerScale.x * .5, this._outerScale.y * .5, .001),
        e.setFromTransformedAabb(e, this._renderable.node.getWorldTransform()),
        e
    }
    _toggleMask() {
        this._element._dirtifyMask();
        const e = this._element._isScreenSpace();
        this._updateMaterial(e),
        this._renderable.setMask(!!this._mask)
    }
    _onMaterialLoad(e) {
        this.material = e.resource
    }
    _onMaterialAdded(e) {
        this._system.app.assets.off("add:" + e.id, this._onMaterialAdded, this),
        this._materialAsset === e.id && this._bindMaterialAsset(e)
    }
    _bindMaterialAsset(e) {
        this._entity.enabled && (e.on("load", this._onMaterialLoad, this),
        e.on("change", this._onMaterialChange, this),
        e.on("remove", this._onMaterialRemove, this),
        e.resource ? this._onMaterialLoad(e) : this._system.app.assets.load(e))
    }
    _unbindMaterialAsset(e) {
        e.off("load", this._onMaterialLoad, this),
        e.off("change", this._onMaterialChange, this),
        e.off("remove", this._onMaterialRemove, this)
    }
    _onMaterialChange() {}
    _onMaterialRemove() {}
    _onTextureAdded(e) {
        this._system.app.assets.off("add:" + e.id, this._onTextureAdded, this),
        this._textureAsset === e.id && this._bindTextureAsset(e)
    }
    _bindTextureAsset(e) {
        this._entity.enabled && (e.on("load", this._onTextureLoad, this),
        e.on("change", this._onTextureChange, this),
        e.on("remove", this._onTextureRemove, this),
        e.resource ? this._onTextureLoad(e) : this._system.app.assets.load(e))
    }
    _unbindTextureAsset(e) {
        e.off("load", this._onTextureLoad, this),
        e.off("change", this._onTextureChange, this),
        e.off("remove", this._onTextureRemove, this)
    }
    _onTextureLoad(e) {
        this.texture = e.resource
    }
    _onTextureChange(e) {}
    _onTextureRemove(e) {}
    _onSpriteAssetAdded(e) {
        this._system.app.assets.off("add:" + e.id, this._onSpriteAssetAdded, this),
        this._spriteAsset === e.id && this._bindSpriteAsset(e)
    }
    _bindSpriteAsset(e) {
        this._entity.enabled && (e.on("load", this._onSpriteAssetLoad, this),
        e.on("change", this._onSpriteAssetChange, this),
        e.on("remove", this._onSpriteAssetRemove, this),
        e.resource ? this._onSpriteAssetLoad(e) : this._system.app.assets.load(e))
    }
    _unbindSpriteAsset(e) {
        e.off("load", this._onSpriteAssetLoad, this),
        e.off("change", this._onSpriteAssetChange, this),
        e.off("remove", this._onSpriteAssetRemove, this),
        e.data.textureAtlasAsset && this._system.app.assets.off("load:" + e.data.textureAtlasAsset, this._onTextureAtlasLoad, this)
    }
    _onSpriteAssetLoad(e) {
        if (!e || !e.resource)
            this.sprite = null;
        else if (e.resource.atlas)
            this.sprite = e.resource;
        else {
            const t = e.data.textureAtlasAsset;
            if (t) {
                const s = this._system.app.assets;
                s.off("load:" + t, this._onTextureAtlasLoad, this),
                s.once("load:" + t, this._onTextureAtlasLoad, this)
            }
        }
    }
    _onSpriteAssetChange(e) {
        this._onSpriteAssetLoad(e)
    }
    _onSpriteAssetRemove(e) {}
    _bindSprite(e) {
        e.on("set:meshes", this._onSpriteMeshesChange, this),
        e.on("set:pixelsPerUnit", this._onSpritePpuChange, this),
        e.on("set:atlas", this._onAtlasTextureChange, this),
        e.atlas && e.atlas.on("set:texture", this._onAtlasTextureChange, this)
    }
    _unbindSprite(e) {
        e.off("set:meshes", this._onSpriteMeshesChange, this),
        e.off("set:pixelsPerUnit", this._onSpritePpuChange, this),
        e.off("set:atlas", this._onAtlasTextureChange, this),
        e.atlas && e.atlas.off("set:texture", this._onAtlasTextureChange, this)
    }
    _onSpriteMeshesChange() {
        this._sprite && (this._spriteFrame = W.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1)),
        this._updateSprite()
    }
    _onSpritePpuChange() {
        this.sprite.renderMode !== gn && this._pixelsPerUnit === null && this._updateSprite()
    }
    _onAtlasTextureChange() {
        this.sprite && this.sprite.atlas && this.sprite.atlas.texture ? (this._renderable.setParameter("texture_emissiveMap", this._sprite.atlas.texture),
        this._renderable.setParameter("texture_opacityMap", this._sprite.atlas.texture)) : (this._renderable.deleteParameter("texture_emissiveMap"),
        this._renderable.deleteParameter("texture_opacityMap"))
    }
    _onTextureAtlasLoad(e) {
        const t = this._spriteAsset;
        t instanceof le ? this._onSpriteAssetLoad(t) : this._onSpriteAssetLoad(this._system.app.assets.get(t))
    }
    onEnable() {
        if (this._materialAsset) {
            const e = this._system.app.assets.get(this._materialAsset);
            e && e.resource !== this._material && this._bindMaterialAsset(e)
        }
        if (this._textureAsset) {
            const e = this._system.app.assets.get(this._textureAsset);
            e && e.resource !== this._texture && this._bindTextureAsset(e)
        }
        if (this._spriteAsset) {
            const e = this._system.app.assets.get(this._spriteAsset);
            e && e.resource !== this._sprite && this._bindSpriteAsset(e)
        }
        this._element.addModelToLayers(this._renderable.model)
    }
    onDisable() {
        this._element.removeModelFromLayers(this._renderable.model)
    }
    _setStencil(e) {
        this._renderable.meshInstance.stencilFront = e,
        this._renderable.meshInstance.stencilBack = e;
        let t = 0;
        if (this._element.maskedBy && (t = this._element.maskedBy.element._image._maskRef),
        this._renderable.unmaskMeshInstance) {
            const s = new qs({
                ref: t + 1,
                func: Yd,
                zpass: ET
            });
            this._renderable.unmaskMeshInstance.stencilFront = s,
            this._renderable.unmaskMeshInstance.stencilBack = s
        }
    }
    set color(e) {
        const t = e.r
          , s = e.g
          , i = e.b;
        (this._color.r !== t || this._color.g !== s || this._color.b !== i) && (this._color.r = t,
        this._color.g = s,
        this._color.b = i,
        this._colorUniform[0] = t,
        this._colorUniform[1] = s,
        this._colorUniform[2] = i,
        this._renderable.setParameter("material_emissive", this._colorUniform)),
        this._element && this._element.fire("set:color", this._color)
    }
    get color() {
        return this._color
    }
    set opacity(e) {
        e !== this._color.a && (this._color.a = e,
        this._renderable.setParameter("material_opacity", e)),
        this._element && this._element.fire("set:opacity", e)
    }
    get opacity() {
        return this._color.a
    }
    set rect(e) {
        let t, s, i, n;
        e instanceof M ? (t = e.x,
        s = e.y,
        i = e.z,
        n = e.w) : (t = e[0],
        s = e[1],
        i = e[2],
        n = e[3]),
        !(t === this._rect.x && s === this._rect.y && i === this._rect.z && n === this._rect.w) && (this._rect.set(t, s, i, n),
        this._renderable.mesh && (this._element._beingInitialized ? this._meshDirty = !0 : this._updateMesh(this._renderable.mesh)))
    }
    get rect() {
        return this._rect
    }
    _removeMaterialAssetEvents() {
        if (this._materialAsset) {
            const e = this._system.app.assets;
            e.off("add:" + this._materialAsset, this._onMaterialAdded, this);
            const t = e.get(this._materialAsset);
            t && (t.off("load", this._onMaterialLoad, this),
            t.off("change", this._onMaterialChange, this),
            t.off("remove", this._onMaterialRemove, this))
        }
    }
    set material(e) {
        if (this._material !== e) {
            if (!e) {
                const t = this._element._isScreenSpace();
                this.mask ? e = t ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial : e = t ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial
            }
            if (this._material = e,
            this._materialAsset) {
                const t = this._system.app.assets.get(this._materialAsset);
                (!t || t.resource !== e) && (this._removeMaterialAssetEvents(),
                this._materialAsset = null)
            }
            e && (this._renderable.setMaterial(e),
            this._hasUserMaterial() ? (this._renderable.deleteParameter("material_opacity"),
            this._renderable.deleteParameter("material_emissive")) : (this._colorUniform[0] = this._color.r,
            this._colorUniform[1] = this._color.g,
            this._colorUniform[2] = this._color.b,
            this._renderable.setParameter("material_emissive", this._colorUniform),
            this._renderable.setParameter("material_opacity", this._color.a)))
        }
    }
    get material() {
        return this._material
    }
    set materialAsset(e) {
        const t = this._system.app.assets;
        let s = e;
        if (e instanceof le && (s = e.id),
        this._materialAsset !== s)
            if (this._removeMaterialAssetEvents(),
            this._materialAsset = s,
            this._materialAsset) {
                const i = t.get(this._materialAsset);
                i ? this._bindMaterialAsset(i) : (this._materialAsset = null,
                this.material = null,
                this._materialAsset = s,
                t.on("add:" + this._materialAsset, this._onMaterialAdded, this))
            } else
                this._materialAsset = null,
                this.material = null,
                this._materialAsset = s
    }
    get materialAsset() {
        return this._materialAsset
    }
    set texture(e) {
        if (this._texture !== e) {
            if (this._textureAsset) {
                const t = this._system.app.assets.get(this._textureAsset);
                t && t.resource !== e && (this.textureAsset = null)
            }
            if (this._texture = e,
            e) {
                this._spriteAsset && (this.spriteAsset = null),
                this._renderable.setParameter("texture_emissiveMap", this._texture),
                this._renderable.setParameter("texture_opacityMap", this._texture),
                this._colorUniform[0] = this._color.r,
                this._colorUniform[1] = this._color.g,
                this._colorUniform[2] = this._color.b,
                this._renderable.setParameter("material_emissive", this._colorUniform),
                this._renderable.setParameter("material_opacity", this._color.a);
                const t = this._texture.width / this._texture.height;
                t !== this._targetAspectRatio && (this._targetAspectRatio = t,
                this._element.fitMode !== zd && this.refreshMesh())
            } else
                this._renderable.deleteParameter("texture_emissiveMap"),
                this._renderable.deleteParameter("texture_opacityMap"),
                this._targetAspectRatio = -1,
                this._element.fitMode !== zd && this.refreshMesh()
        }
    }
    get texture() {
        return this._texture
    }
    set textureAsset(e) {
        const t = this._system.app.assets;
        let s = e;
        if (e instanceof le && (s = e.id),
        this._textureAsset !== s) {
            if (this._textureAsset) {
                t.off("add:" + this._textureAsset, this._onTextureAdded, this);
                const i = t.get(this._textureAsset);
                i && (i.off("load", this._onTextureLoad, this),
                i.off("change", this._onTextureChange, this),
                i.off("remove", this._onTextureRemove, this))
            }
            if (this._textureAsset = s,
            this._textureAsset) {
                const i = t.get(this._textureAsset);
                i ? this._bindTextureAsset(i) : (this.texture = null,
                t.on("add:" + this._textureAsset, this._onTextureAdded, this))
            } else
                this.texture = null
        }
    }
    get textureAsset() {
        return this._textureAsset
    }
    set spriteAsset(e) {
        const t = this._system.app.assets;
        let s = e;
        if (e instanceof le && (s = e.id),
        this._spriteAsset !== s) {
            if (this._spriteAsset) {
                t.off("add:" + this._spriteAsset, this._onSpriteAssetAdded, this);
                const i = t.get(this._spriteAsset);
                i && this._unbindSpriteAsset(i)
            }
            if (this._spriteAsset = s,
            this._spriteAsset) {
                const i = t.get(this._spriteAsset);
                i ? this._bindSpriteAsset(i) : (this.sprite = null,
                t.on("add:" + this._spriteAsset, this._onSpriteAssetAdded, this))
            } else
                this.sprite = null
        }
        this._element && this._element.fire("set:spriteAsset", s)
    }
    get spriteAsset() {
        return this._spriteAsset
    }
    set sprite(e) {
        if (this._sprite !== e) {
            if (this._sprite && this._unbindSprite(this._sprite),
            this._spriteAsset) {
                const t = this._system.app.assets.get(this._spriteAsset);
                t && t.resource !== e && (this.spriteAsset = null)
            }
            this._sprite = e,
            this._sprite && (this._bindSprite(this._sprite),
            this._textureAsset && (this.textureAsset = null)),
            this._sprite && this._sprite.atlas && this._sprite.atlas.texture ? (this._renderable.setParameter("texture_emissiveMap", this._sprite.atlas.texture),
            this._renderable.setParameter("texture_opacityMap", this._sprite.atlas.texture)) : (this._renderable.deleteParameter("texture_emissiveMap"),
            this._renderable.deleteParameter("texture_opacityMap")),
            this._sprite && (this._spriteFrame = W.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1)),
            this._updateSprite()
        }
    }
    get sprite() {
        return this._sprite
    }
    set spriteFrame(e) {
        const t = this._spriteFrame;
        this._sprite ? this._spriteFrame = W.clamp(e, 0, this._sprite.frameKeys.length - 1) : this._spriteFrame = e,
        this._spriteFrame !== t && this._updateSprite(),
        this._element && this._element.fire("set:spriteFrame", e)
    }
    get spriteFrame() {
        return this._spriteFrame
    }
    set mesh(e) {
        this._renderable.setMesh(e),
        this._defaultMesh === e ? this._renderable.setAabbFunc(null) : this._renderable.setAabbFunc(this._updateAabbFunc)
    }
    get mesh() {
        return this._renderable.mesh
    }
    set mask(e) {
        this._mask !== e && (this._mask = e,
        this._toggleMask())
    }
    get mask() {
        return this._mask
    }
    set pixelsPerUnit(e) {
        this._pixelsPerUnit !== e && (this._pixelsPerUnit = e,
        this._sprite && (this._sprite.renderMode === xt || this._sprite.renderMode === _t) && this._updateSprite())
    }
    get pixelsPerUnit() {
        return this._pixelsPerUnit
    }
    get aabb() {
        return this._renderable.meshInstance ? this._renderable.meshInstance.aabb : null
    }
}
class D2 extends fe {
    constructor(e) {
        super(),
        this._app = e,
        e.i18n.on("set:locale", this._onSetLocale, this),
        this._autoLoad = !1,
        this._disableLocalization = !1,
        this._defaultAsset = null,
        this._localizedAsset = null
    }
    set defaultAsset(e) {
        const t = e instanceof le ? e.id : e;
        this._defaultAsset !== t && (this._defaultAsset && this._unbindDefaultAsset(),
        this._defaultAsset = t,
        this._defaultAsset && this._bindDefaultAsset(),
        this._onSetLocale(this._app.i18n.locale))
    }
    get defaultAsset() {
        return this._defaultAsset
    }
    set localizedAsset(e) {
        const t = e instanceof le ? e.id : e;
        this._localizedAsset !== t && (this._localizedAsset && (this._app.assets.off("add:" + this._localizedAsset, this._onLocalizedAssetAdd, this),
        this._unbindLocalizedAsset(),
        this._localizedAsset = null),
        this._localizedAsset = t,
        this._localizedAsset && (this._app.assets.get(this._localizedAsset) ? this._bindLocalizedAsset() : this._app.assets.once("add:" + this._localizedAsset, this._onLocalizedAssetAdd, this)))
    }
    get localizedAsset() {
        return this._localizedAsset
    }
    set autoLoad(e) {
        this._autoLoad !== e && (this._autoLoad = e,
        this._autoLoad && this._localizedAsset && (this._unbindLocalizedAsset(),
        this._bindLocalizedAsset()))
    }
    get autoLoad() {
        return this._autoLoad
    }
    set disableLocalization(e) {
        this._disableLocalization !== e && (this._disableLocalization = e,
        this._onSetLocale(this._app.i18n.locale))
    }
    get disableLocalization() {
        return this._disableLocalization
    }
    _bindDefaultAsset() {
        const e = this._app.assets.get(this._defaultAsset);
        e ? this._onDefaultAssetAdd(e) : this._app.assets.once("add:" + this._defaultAsset, this._onDefaultAssetAdd, this)
    }
    _unbindDefaultAsset() {
        if (!this._defaultAsset)
            return;
        this._app.assets.off("add:" + this._defaultAsset, this._onDefaultAssetAdd, this);
        const e = this._app.assets.get(this._defaultAsset);
        e && (e.off("add:localized", this._onLocaleAdd, this),
        e.off("remove:localized", this._onLocaleRemove, this),
        e.off("remove", this._onDefaultAssetRemove, this))
    }
    _onDefaultAssetAdd(e) {
        this._defaultAsset === e.id && (e.on("add:localized", this._onLocaleAdd, this),
        e.on("remove:localized", this._onLocaleRemove, this),
        e.once("remove", this._onDefaultAssetRemove, this))
    }
    _onDefaultAssetRemove(e) {
        this._defaultAsset === e.id && (e.off("add:localized", this._onLocaleAdd, this),
        e.off("remove:localized", this._onLocaleAdd, this),
        this._app.assets.once("add:" + this._defaultAsset, this._onDefaultAssetAdd, this))
    }
    _bindLocalizedAsset() {
        if (!this._autoLoad)
            return;
        const e = this._app.assets.get(this._localizedAsset);
        e && (e.on("load", this._onLocalizedAssetLoad, this),
        e.on("change", this._onLocalizedAssetChange, this),
        e.on("remove", this._onLocalizedAssetRemove, this),
        e.resource ? this._onLocalizedAssetLoad(e) : this._app.assets.load(e))
    }
    _unbindLocalizedAsset() {
        const e = this._app.assets.get(this._localizedAsset);
        e && (e.off("load", this._onLocalizedAssetLoad, this),
        e.off("change", this._onLocalizedAssetChange, this),
        e.off("remove", this._onLocalizedAssetRemove, this))
    }
    _onLocalizedAssetAdd(e) {
        this._localizedAsset === e.id && this._bindLocalizedAsset()
    }
    _onLocalizedAssetLoad(e) {
        this.fire("load", e)
    }
    _onLocalizedAssetChange(e, t, s, i) {
        this.fire("change", e, t, s, i)
    }
    _onLocalizedAssetRemove(e) {
        this._localizedAsset === e.id && (this.localizedAsset = this._defaultAsset),
        this.fire("remove", e)
    }
    _onLocaleAdd(e, t) {
        this._app.i18n.locale === e && this._onSetLocale(e)
    }
    _onLocaleRemove(e, t) {
        this._app.i18n.locale === e && this._onSetLocale(e)
    }
    _onSetLocale(e) {
        if (!this._defaultAsset) {
            this.localizedAsset = null;
            return
        }
        const t = this._app.assets.get(this._defaultAsset);
        if (!t || this._disableLocalization) {
            this.localizedAsset = this._defaultAsset;
            return
        }
        const s = t.getLocalizedAssetId(e);
        if (!s) {
            this.localizedAsset = this._defaultAsset;
            return
        }
        this.localizedAsset = s
    }
    destroy() {
        this.defaultAsset = null,
        this._app.i18n.off("set:locale", this._onSetLocale, this),
        this.off()
    }
}
const _u = "msdf"
  , O2 = "bitmap"
  , Wl = 0
  , uo = 1
  , Xm = 2
  , qx = 3
  , jm = 4
  , $m = 5
  , qm = 6
  , Ym = 7
  , cv = 8
  , F2 = ` 	
\r\v\f`
  , B2 = /[A-Z|a-z|0-9|_|-|/]/;
class k2 {
    constructor(e) {
        this._symbols = e,
        this._index = 0,
        this._last = 0,
        this._cur = this._symbols.length > 0 ? this._symbols[0] : null,
        this._buf = [],
        this._mode = "text",
        this._error = null
    }
    read() {
        let e = this._read();
        for (; e === cv; )
            e = this._read();
        return e !== Wl && e !== uo && (this._last = this._index),
        e
    }
    buf() {
        return this._buf
    }
    last() {
        return this._last
    }
    error() {
        return this._error
    }
    debugPrint() {
        const e = ["EOF", "ERROR", "TEXT", "OPEN_BRACKET", "CLOSE_BRACKET", "EQUALS", "STRING", "IDENTIFIER", "WHITESPACE"];
        let t = this.read()
          , s = "";
        for (; s += (s.length > 0 ? `
` : "") + e[t] + " '" + this.buf().join("") + "'",
        !(t === Wl || t === uo); )
            t = this.read();
        return s
    }
    _read() {
        return this._buf = [],
        this._eof() ? Wl : this._mode === "text" ? this._text() : this._tag()
    }
    _text() {
        for (; ; )
            switch (this._cur) {
            case null:
                return this._buf.length > 0 ? Xm : Wl;
            case "[":
                return this._mode = "tag",
                this._buf.length > 0 ? Xm : this._tag();
            case "\\":
                switch (this._next(),
                this._cur) {
                case "[":
                    this._store();
                    break;
                default:
                    this._output("\\");
                    break
                }
                break;
            default:
                this._store();
                break
            }
    }
    _tag() {
        switch (this._cur) {
        case null:
            return this._error = "unexpected end of input reading tag",
            uo;
        case "[":
            return this._store(),
            qx;
        case "]":
            return this._store(),
            this._mode = "text",
            jm;
        case "=":
            return this._store(),
            $m;
        case " ":
        case "	":
        case `
`:
        case "\r":
        case "\v":
        case "\f":
            return this._whitespace();
        case '"':
            return this._string();
        default:
            return this._isIdentifierSymbol(this._cur) ? this._identifier() : (this._error = "unrecognized character",
            uo)
        }
    }
    _whitespace() {
        for (this._store(); F2.indexOf(this._cur) !== -1; )
            this._store();
        return cv
    }
    _string() {
        for (this._next(); ; )
            switch (this._cur) {
            case null:
                return this._error = "unexpected end of input reading string",
                uo;
            case '"':
                return this._next(),
                qm;
            default:
                this._store();
                break
            }
    }
    _identifier() {
        for (this._store(); this._cur !== null && this._isIdentifierSymbol(this._cur); )
            this._store();
        return Ym
    }
    _isIdentifierSymbol(e) {
        return e.length === 1 && e.match(B2) !== null
    }
    _eof() {
        return this._cur === null
    }
    _next() {
        return this._eof() || (this._index++,
        this._cur = this._index < this._symbols.length ? this._symbols[this._index] : null),
        this._cur
    }
    _store() {
        return this._buf.push(this._cur),
        this._next()
    }
    _output(e) {
        this._buf.push(e)
    }
}
class N2 {
    constructor(e) {
        this._scanner = new k2(e),
        this._error = null
    }
    parse(e, t) {
        for (; ; )
            switch (this._scanner.read()) {
            case Wl:
                return !0;
            case uo:
                return !1;
            case Xm:
                Array.prototype.push.apply(e, this._scanner.buf());
                break;
            case qx:
                if (!this._parseTag(e, t))
                    return !1;
                break;
            default:
                return !1
            }
    }
    error() {
        return "Error evaluating markup at #" + this._scanner.last().toString() + " (" + (this._scanner.error() || this._error) + ")"
    }
    _parseTag(e, t) {
        let s = this._scanner.read();
        if (s !== Ym)
            return this._error = "expected identifier",
            !1;
        const i = this._scanner.buf().join("");
        if (i[0] === "/") {
            for (let r = t.length - 1; r >= 0; --r)
                if (i === "/" + t[r].name && t[r].end === null)
                    return t[r].end = e.length,
                    s = this._scanner.read(),
                    s !== jm ? (this._error = "expected close bracket",
                    !1) : !0;
            return this._error = "failed to find matching tag",
            !1
        }
        const n = {
            name: i,
            value: null,
            attributes: {},
            start: e.length,
            end: null
        };
        if (s = this._scanner.read(),
        s === $m) {
            if (s = this._scanner.read(),
            s !== qm)
                return this._error = "expected string",
                !1;
            n.value = this._scanner.buf().join(""),
            s = this._scanner.read()
        }
        for (; ; ) {
            switch (s) {
            case jm:
                return t.push(n),
                !0;
            case Ym:
                {
                    const r = this._scanner.buf().join("");
                    if (s = this._scanner.read(),
                    s !== $m)
                        return this._error = "expected equals",
                        !1;
                    if (s = this._scanner.read(),
                    s !== qm)
                        return this._error = "expected string",
                        !1;
                    const o = this._scanner.buf().join("");
                    n.attributes[r] = o;
                    break
                }
            default:
                return this._error = "expected close bracket or identifier",
                !1
            }
            s = this._scanner.read()
        }
    }
}
function Yx(a, e) {
    for (const t in e) {
        if (!e.hasOwnProperty(t))
            continue;
        const s = e[t];
        s instanceof Object ? (a.hasOwnProperty(t) || (a[t] = {}),
        Yx(a[t], e[t])) : a[t] = s
    }
}
function U2(a) {
    if (a.length === 0)
        return null;
    const e = {};
    for (let t = 0; t < a.length; ++t) {
        const s = a[t]
          , i = {};
        i[s.name] = {
            value: s.value,
            attributes: s.attributes
        },
        Yx(e, i)
    }
    return e
}
function z2(a, e) {
    if (a.length === 0)
        return null;
    const t = {};
    for (let d = 0; d < a.length; ++d) {
        const h = a[d];
        t.hasOwnProperty(h.start) ? t[h.start].open === null ? t[h.start].open = [h] : t[h.start].open.push(h) : t[h.start] = {
            open: [h],
            close: null
        },
        t.hasOwnProperty(h.end) ? t[h.end].close === null ? t[h.end].close = [h] : t[h.end].close.push(h) : t[h.end] = {
            open: null,
            close: [h]
        }
    }
    let s = [];
    function i(d) {
        s = s.filter(function(h) {
            return d.find(function(u) {
                return u === h
            }) === void 0
        })
    }
    function n(d) {
        for (let h = 0; h < d.length; ++h)
            s.push(d[h])
    }
    const r = Object.keys(t).sort(function(d, h) {
        return d - h
    })
      , o = [];
    for (let d = 0; d < r.length; ++d) {
        const h = t[r[d]];
        h.close !== null && i(h.close),
        h.open !== null && n(h.open),
        o.push({
            start: r[d],
            tags: U2(s)
        })
    }
    const l = [];
    let c = null;
    for (let d = 0; d < o.length; ++d) {
        const h = o[d];
        for (; l.length < h.start; )
            l.push(c ? c.tags : null);
        c = h
    }
    for (; l.length < e; )
        l.push(null);
    return l
}
function V2(a) {
    const e = new N2(a)
      , t = []
      , s = [];
    if (!e.parse(t, s))
        return console.warn(e.error()),
        {
            symbols: a,
            tags: null
        };
    const i = s.find(function(r) {
        return r.end === null
    });
    if (i)
        return console.warn(`Markup error: found unclosed tag='${i.name}'`),
        {
            symbols: a,
            tags: null
        };
    const n = z2(s, t.length);
    return {
        symbols: t,
        tags: n
    }
}
class G2 {
    static evaluate(e) {
        return V2(e)
    }
}
class H2 {
    constructor() {
        this.count = 0,
        this.quad = 0,
        this.lines = {},
        this.positions = [],
        this.normals = [],
        this.uvs = [],
        this.colors = [],
        this.indices = [],
        this.outlines = [],
        this.shadows = [],
        this.meshInstance = null
    }
}
function W2(a, e) {
    const t = new ms(a);
    return t.setPositions(e.positions),
    t.setNormals(e.normals),
    t.setColors32(e.colors),
    t.setUvs(0, e.uvs),
    t.setIndices(e.indices),
    t.setVertexStream(Qr, e.outlines, 3, void 0, Me, !1),
    t.setVertexStream(Jr, e.shadows, 3, void 0, Me, !1),
    t.update(),
    t
}
const dv = /^[\r\n]$/
  , X2 = /^[ \t]$/
  , uv = /^[ \t\-]|[\u200b]$/
  , j2 = /^[a-z0-9]$/i
  , fv = /^[\u1100-\u11ff]|[\u3000-\u9fff]|[\ua960-\ua97f]|[\uac00-\ud7ff]$/
  , $2 = /^[]$/
  , q2 = ["", "", "", "", "", "", "", "", "", "", "", "", ""]
  , Y2 = {
    width: 0,
    height: 0,
    xadvance: 0,
    xoffset: 0,
    yoffset: 0
}
  , pv = new z
  , K2 = new P;
class Z2 {
    constructor(e) {
        this._element = e,
        this._system = e.system,
        this._entity = e.entity,
        this._text = "",
        this._symbols = [],
        this._colorPalette = [],
        this._outlinePalette = [],
        this._shadowPalette = [],
        this._symbolColors = null,
        this._symbolOutlineParams = null,
        this._symbolShadowParams = null,
        this._i18nKey = null,
        this._fontAsset = new D2(this._system.app),
        this._fontAsset.disableLocalization = !0,
        this._fontAsset.on("load", this._onFontLoad, this),
        this._fontAsset.on("change", this._onFontChange, this),
        this._fontAsset.on("remove", this._onFontRemove, this),
        this._font = null,
        this._color = new z(1,1,1,1),
        this._colorUniform = new Float32Array(3),
        this._spacing = 1,
        this._fontSize = 32,
        this._fontMinY = 0,
        this._fontMaxY = 0,
        this._originalFontSize = 32,
        this._maxFontSize = 32,
        this._minFontSize = 8,
        this._autoFitWidth = !1,
        this._autoFitHeight = !1,
        this._maxLines = -1,
        this._lineHeight = 32,
        this._scaledLineHeight = 32,
        this._wrapLines = !1,
        this._drawOrder = 0,
        this._alignment = new P(.5,.5),
        this._autoWidth = !0,
        this._autoHeight = !0,
        this.width = 0,
        this.height = 0,
        this._node = new yt,
        this._model = new kn,
        this._model.graph = this._node,
        this._entity.addChild(this._node),
        this._meshInfo = [],
        this._material = null,
        this._aabbDirty = !0,
        this._aabb = new Pe,
        this._noResize = !1,
        this._currentMaterialType = null,
        this._maskedMaterialSrc = null,
        this._rtlReorder = !1,
        this._unicodeConverter = !1,
        this._rtl = !1,
        this._outlineColor = new z(0,0,0,1),
        this._outlineColorUniform = new Float32Array(4),
        this._outlineThicknessScale = .2,
        this._outlineThickness = 0,
        this._shadowColor = new z(0,0,0,1),
        this._shadowColorUniform = new Float32Array(4),
        this._shadowOffsetScale = .005,
        this._shadowOffset = new P(0,0),
        this._shadowOffsetUniform = new Float32Array(2),
        this._enableMarkup = !1,
        this._onScreenChange(this._element.screen),
        e.on("resize", this._onParentResize, this),
        e.on("set:screen", this._onScreenChange, this),
        e.on("screen:set:screenspace", this._onScreenSpaceChange, this),
        e.on("set:draworder", this._onDrawOrderChange, this),
        e.on("set:pivot", this._onPivotChange, this),
        this._system.app.i18n.on("set:locale", this._onLocaleSet, this),
        this._system.app.i18n.on("data:add", this._onLocalizationData, this),
        this._system.app.i18n.on("data:remove", this._onLocalizationData, this),
        this._rangeStart = 0,
        this._rangeEnd = 0
    }
    destroy() {
        this._setMaterial(null),
        this._model && (this._element.removeModelFromLayers(this._model),
        this._model.destroy(),
        this._model = null),
        this._fontAsset.destroy(),
        this.font = null,
        this._element.off("resize", this._onParentResize, this),
        this._element.off("set:screen", this._onScreenChange, this),
        this._element.off("screen:set:screenspace", this._onScreenSpaceChange, this),
        this._element.off("set:draworder", this._onDrawOrderChange, this),
        this._element.off("set:pivot", this._onPivotChange, this),
        this._system.app.i18n.off("set:locale", this._onLocaleSet, this),
        this._system.app.i18n.off("data:add", this._onLocalizationData, this),
        this._system.app.i18n.off("data:remove", this._onLocalizationData, this)
    }
    _onParentResize(e, t) {
        this._noResize || this._font && this._updateText()
    }
    _onScreenChange(e) {
        e ? this._updateMaterial(e.screen.screenSpace) : this._updateMaterial(!1)
    }
    _onScreenSpaceChange(e) {
        this._updateMaterial(e)
    }
    _onDrawOrderChange(e) {
        if (this._drawOrder = e,
        this._model)
            for (let t = 0, s = this._model.meshInstances.length; t < s; t++)
                this._model.meshInstances[t].drawOrder = e
    }
    _onPivotChange(e) {
        this._font && this._updateText()
    }
    _onLocaleSet(e) {
        if (this._i18nKey) {
            if (this.fontAsset) {
                const t = this._system.app.assets.get(this.fontAsset);
                (!t || !t.resource || t.resource !== this._font) && (this.font = null)
            }
            this._resetLocalizedText()
        }
    }
    _onLocalizationData(e, t) {
        this._i18nKey && t[this._i18nKey] && this._resetLocalizedText()
    }
    _resetLocalizedText() {
        this._setText(this._system.app.i18n.getText(this._i18nKey))
    }
    _setText(e) {
        if (this.unicodeConverter) {
            const t = this._system.getUnicodeConverter();
            t ? e = t(e) : console.warn("Element created with unicodeConverter option but no unicodeConverter function registered")
        }
        this._text !== e && (this._font && this._updateText(e),
        this._text = e)
    }
    _updateText(e) {
        let t;
        if (e === void 0 && (e = this._text),
        this._symbols = Rd.getSymbols(e.normalize ? e.normalize("NFC") : e),
        this._symbols.length === 0 && (this._symbols = [" "]),
        this._enableMarkup) {
            const h = G2.evaluate(this._symbols);
            this._symbols = h.symbols,
            t = h.tags || []
        }
        if (this._rtlReorder) {
            const h = this._system.app.systems.element.getRtlReorder();
            if (h) {
                const u = h(this._symbols);
                this._rtl = u.rtl,
                this._symbols = u.mapping.map(function(f) {
                    return this._symbols[f]
                }, this),
                t && (t = u.mapping.map(function(f) {
                    return t[f]
                }))
            } else
                console.warn("Element created with rtlReorder option but no rtlReorder function registered")
        } else
            this._rtl = !1;
        const s = (h, u) => `${h.toString(!0).toLowerCase()}:${u.toFixed(2)}`
          , i = (h, u) => `${h.toString(!0).toLowerCase()}:${u.x.toFixed(2)}:${u.y.toFixed(2)}`;
        if (t) {
            const h = {}
              , u = {}
              , f = {};
            this._colorPalette = [Math.round(this._color.r * 255), Math.round(this._color.g * 255), Math.round(this._color.b * 255)],
            this._outlinePalette = [Math.round(this._outlineColor.r * 255), Math.round(this._outlineColor.g * 255), Math.round(this._outlineColor.b * 255), Math.round(this._outlineColor.a * 255), Math.round(this._outlineThickness * 255)],
            this._shadowPalette = [Math.round(this._shadowColor.r * 255), Math.round(this._shadowColor.g * 255), Math.round(this._shadowColor.b * 255), Math.round(this._shadowColor.a * 255), Math.round(this._shadowOffset.x * 127), Math.round(this._shadowOffset.y * 127)],
            this._symbolColors = [],
            this._symbolOutlineParams = [],
            this._symbolShadowParams = [],
            h[this._color.toString(!1).toLowerCase()] = 0,
            u[s(this._outlineColor, this._outlineThickness)] = 0,
            f[i(this._shadowColor, this._shadowOffset)] = 0;
            for (let p = 0, _ = this._symbols.length; p < _; ++p) {
                const m = t[p];
                let g = 0;
                if (m && m.color && m.color.value) {
                    const S = m.color.value;
                    if (S.length === 7 && S[0] === "#") {
                        const w = S.substring(1).toLowerCase();
                        h.hasOwnProperty(w) ? g = h[w] : /^([0-9a-f]{2}){3}$/.test(w) && (g = this._colorPalette.length / 3,
                        h[w] = g,
                        this._colorPalette.push(parseInt(w.substring(0, 2), 16)),
                        this._colorPalette.push(parseInt(w.substring(2, 4), 16)),
                        this._colorPalette.push(parseInt(w.substring(4, 6), 16)))
                    }
                }
                this._symbolColors.push(g);
                let v = 0;
                if (m && m.outline && (m.outline.attributes.color || m.outline.attributes.thickness)) {
                    let S = m.outline.attributes.color ? pv.fromString(m.outline.attributes.color) : this._outlineColor
                      , w = Number(m.outline.attributes.thickness);
                    (Number.isNaN(S.r) || Number.isNaN(S.g) || Number.isNaN(S.b) || Number.isNaN(S.a)) && (S = this._outlineColor),
                    Number.isNaN(w) && (w = this._outlineThickness);
                    const T = s(S, w);
                    u.hasOwnProperty(T) ? v = u[T] : (v = this._outlinePalette.length / 5,
                    u[T] = v,
                    this._outlinePalette.push(Math.round(S.r * 255), Math.round(S.g * 255), Math.round(S.b * 255), Math.round(S.a * 255), Math.round(w * 255)))
                }
                this._symbolOutlineParams.push(v);
                let x = 0;
                if (m && m.shadow && (m.shadow.attributes.color || m.shadow.attributes.offset || m.shadow.attributes.offsetX || m.shadow.attributes.offsetY)) {
                    let S = m.shadow.attributes.color ? pv.fromString(m.shadow.attributes.color) : this._shadowColor;
                    const w = Number(m.shadow.attributes.offset)
                      , T = Number(m.shadow.attributes.offsetX)
                      , b = Number(m.shadow.attributes.offsetY);
                    (Number.isNaN(S.r) || Number.isNaN(S.g) || Number.isNaN(S.b) || Number.isNaN(S.a)) && (S = this._shadowColor);
                    const E = K2.set(Number.isNaN(T) ? Number.isNaN(w) ? this._shadowOffset.x : w : T, Number.isNaN(b) ? Number.isNaN(w) ? this._shadowOffset.y : w : b)
                      , C = i(S, E);
                    f.hasOwnProperty(C) ? x = f[C] : (x = this._shadowPalette.length / 6,
                    f[C] = x,
                    this._shadowPalette.push(Math.round(S.r * 255), Math.round(S.g * 255), Math.round(S.b * 255), Math.round(S.a * 255), Math.round(E.x * 127), Math.round(E.y * 127)))
                }
                this._symbolShadowParams.push(x)
            }
        } else
            this._colorPalette = [],
            this._symbolColors = null,
            this._symbolOutlineParams = null,
            this._symbolShadowParams = null;
        this._updateMaterialEmissive(),
        this._updateMaterialOutline(),
        this._updateMaterialShadow();
        const n = this._calculateCharsPerTexture();
        let r = !1;
        const o = this._element
          , l = o._isScreenSpace()
          , c = o._isScreenCulled()
          , d = function(u) {
            return o.isVisibleForCamera(u)
        };
        for (let h = 0, u = this._meshInfo.length; h < u; h++) {
            const f = n[h] || 0
              , p = this._meshInfo[h];
            if (p.count !== f) {
                if (r || (o.removeModelFromLayers(this._model),
                r = !0),
                p.count = f,
                p.positions.length = p.normals.length = f * 3 * 4,
                p.indices.length = f * 3 * 2,
                p.uvs.length = f * 2 * 4,
                p.colors.length = f * 4 * 4,
                p.outlines.length = f * 4 * 3,
                p.shadows.length = f * 4 * 3,
                p.meshInstance && this._removeMeshInstance(p.meshInstance),
                f === 0) {
                    p.meshInstance = null;
                    continue
                }
                for (let g = 0; g < f; g++)
                    p.indices[g * 3 * 2 + 0] = g * 4,
                    p.indices[g * 3 * 2 + 1] = g * 4 + 1,
                    p.indices[g * 3 * 2 + 2] = g * 4 + 3,
                    p.indices[g * 3 * 2 + 3] = g * 4 + 2,
                    p.indices[g * 3 * 2 + 4] = g * 4 + 3,
                    p.indices[g * 3 * 2 + 5] = g * 4 + 1,
                    p.normals[g * 4 * 3 + 0] = 0,
                    p.normals[g * 4 * 3 + 1] = 0,
                    p.normals[g * 4 * 3 + 2] = -1,
                    p.normals[g * 4 * 3 + 3] = 0,
                    p.normals[g * 4 * 3 + 4] = 0,
                    p.normals[g * 4 * 3 + 5] = -1,
                    p.normals[g * 4 * 3 + 6] = 0,
                    p.normals[g * 4 * 3 + 7] = 0,
                    p.normals[g * 4 * 3 + 8] = -1,
                    p.normals[g * 4 * 3 + 9] = 0,
                    p.normals[g * 4 * 3 + 10] = 0,
                    p.normals[g * 4 * 3 + 11] = -1;
                const _ = W2(this._system.app.graphicsDevice, p)
                  , m = new Fe(_,this._material,this._node);
                if (m.name = "Text Element: " + this._entity.name,
                m.castShadow = !1,
                m.receiveShadow = !1,
                m.cull = !l,
                m.screenSpace = l,
                m.drawOrder = this._drawOrder,
                c && (m.cull = !0,
                m.isVisibleFunc = d),
                this._setTextureParams(m, this._font.textures[h]),
                m.setParameter("material_emissive", this._colorUniform),
                m.setParameter("material_opacity", this._color.a),
                m.setParameter("font_sdfIntensity", this._font.intensity),
                m.setParameter("font_pxrange", this._getPxRange(this._font)),
                m.setParameter("font_textureWidth", this._font.data.info.maps[h].width),
                m.setParameter("outline_color", this._outlineColorUniform),
                m.setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness),
                m.setParameter("shadow_color", this._shadowColorUniform),
                this._symbolShadowParams)
                    this._shadowOffsetUniform[0] = 0,
                    this._shadowOffsetUniform[1] = 0;
                else {
                    const g = -this._font.data.info.maps[h].width / this._font.data.info.maps[h].height;
                    this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x,
                    this._shadowOffsetUniform[1] = g * this._shadowOffsetScale * this._shadowOffset.y
                }
                m.setParameter("shadow_offset", this._shadowOffsetUniform),
                p.meshInstance = m,
                this._model.meshInstances.push(m)
            }
        }
        this._element.maskedBy && this._element._setMaskedBy(this._element.maskedBy),
        r && this._element.enabled && this._entity.enabled && this._element.addModelToLayers(this._model),
        this._updateMeshes(),
        this._rangeStart = 0,
        this._rangeEnd = this._symbols.length,
        this._updateRenderRange()
    }
    _removeMeshInstance(e) {
        e.destroy();
        const t = this._model.meshInstances.indexOf(e);
        t !== -1 && this._model.meshInstances.splice(t, 1)
    }
    _setMaterial(e) {
        if (this._material = e,
        this._model)
            for (let t = 0, s = this._model.meshInstances.length; t < s; t++) {
                const i = this._model.meshInstances[t];
                i.material = e
            }
    }
    _updateMaterial(e) {
        const t = this._element
          , s = t._isScreenCulled()
          , i = function(o) {
            return t.isVisibleForCamera(o)
        }
          , n = this._font && this._font.type === _u;
        if (this._material = this._system.getTextElementMaterial(e, n, this._enableMarkup),
        this._model)
            for (let r = 0, o = this._model.meshInstances.length; r < o; r++) {
                const l = this._model.meshInstances[r];
                l.cull = !e,
                l.material = this._material,
                l.screenSpace = e,
                s ? (l.cull = !0,
                l.isVisibleFunc = i) : l.isVisibleFunc = null
            }
    }
    _updateMaterialEmissive() {
        this._symbolColors ? (this._colorUniform[0] = 1,
        this._colorUniform[1] = 1,
        this._colorUniform[2] = 1) : (this._colorUniform[0] = this._color.r,
        this._colorUniform[1] = this._color.g,
        this._colorUniform[2] = this._color.b)
    }
    _updateMaterialOutline() {
        this._symbolOutlineParams ? (this._outlineColorUniform[0] = 0,
        this._outlineColorUniform[1] = 0,
        this._outlineColorUniform[2] = 0,
        this._outlineColorUniform[3] = 1) : (this._outlineColorUniform[0] = this._outlineColor.r,
        this._outlineColorUniform[1] = this._outlineColor.g,
        this._outlineColorUniform[2] = this._outlineColor.b,
        this._outlineColorUniform[3] = this._outlineColor.a)
    }
    _updateMaterialShadow() {
        this._symbolOutlineParams ? (this._shadowColorUniform[0] = 0,
        this._shadowColorUniform[1] = 0,
        this._shadowColorUniform[2] = 0,
        this._shadowColorUniform[3] = 0) : (this._shadowColorUniform[0] = this._shadowColor.r,
        this._shadowColorUniform[1] = this._shadowColor.g,
        this._shadowColorUniform[2] = this._shadowColor.b,
        this._shadowColorUniform[3] = this._shadowColor.a)
    }
    _isWordBoundary(e) {
        return uv.test(e)
    }
    _isValidNextChar(e) {
        return e !== null && !$2.test(e)
    }
    _isNextCJKBoundary(e, t) {
        return fv.test(e) && (uv.test(t) || j2.test(t))
    }
    _isNextCJKWholeWord(e) {
        return fv.test(e)
    }
    _updateMeshes() {
        const e = this._font.data
          , t = this
          , s = Math.min(this._minFontSize, this._maxFontSize)
          , i = this._maxFontSize
          , n = this._shouldAutoFit();
        n && (this._fontSize = this._maxFontSize);
        const r = 32
          , o = this._symbols.length;
        let l = 0
          , c = 0
          , d = 0
          , h = 0
          , u = 1
          , f = 0
          , p = 0
          , _ = 0
          , m = 0
          , g = 0
          , v = 0;
        const x = Math.abs(this._element.anchor.x - this._element.anchor.z) >= 1e-4;
        let S = this._element.calculatedWidth;
        (this.autoWidth && !x || !this._wrapLines) && (S = Number.POSITIVE_INFINITY);
        let w = 0, T = 0, b, E, C, R;
        function F(A, k, N) {
            t._lineWidths.push(Math.abs(N));
            const H = _ > k ? k + 1 : _
              , K = _ > k ? _ + 1 : k
              , q = A.slice(H, K);
            if (v) {
                let se = q.length;
                for (; se-- && v > 0; )
                    dv.test(q[se]) && (q.splice(se, 1),
                    v--)
            }
            t._lineContents.push(q.join("")),
            l = 0,
            c -= t._scaledLineHeight,
            u++,
            m = 0,
            g = 0,
            v = 0,
            f = 0,
            _ = k
        }
        let L = !0;
        for (; L; ) {
            L = !1,
            n ? this._scaledLineHeight = this._lineHeight * this._fontSize / (this._maxFontSize || 1e-4) : this._scaledLineHeight = this._lineHeight,
            this.width = 0,
            this.height = 0,
            this._lineWidths = [],
            this._lineContents = [],
            l = 0,
            c = 0,
            d = 0,
            h = 0,
            u = 1,
            f = 0,
            p = 0,
            _ = 0,
            m = 0,
            g = 0,
            v = 0;
            const A = this._fontSize / r;
            w = this._fontMinY * A,
            T = this._fontMaxY * A;
            for (let ue = 0; ue < this._meshInfo.length; ue++)
                this._meshInfo[ue].quad = 0,
                this._meshInfo[ue].lines = {};
            let k = 255
              , N = 255
              , H = 255
              , K = 255 + 255 * 256
              , q = 255 + 255 * 256
              , se = 0
              , ie = 255 + 255 * 256
              , ae = 255 + 255 * 256
              , he = 127 + 127 * 256;
            for (let ue = 0; ue < o; ue++) {
                if (b = this._symbols[ue],
                R = ue + 1 >= o ? null : this._symbols[ue + 1],
                dv.test(b)) {
                    v++,
                    (!this._wrapLines || this._maxLines < 0 || u < this._maxLines) && (F(this._symbols, ue, h),
                    p = ue + 1,
                    _ = ue + 1);
                    continue
                }
                let Vt = 0, qt = 0, Yt = 0, Da = 1, Bg, kg;
                if (E = e.chars[b],
                !E)
                    if (q2.indexOf(b) !== -1)
                        E = Y2;
                    else if (e.chars[" "])
                        E = e.chars[" "];
                    else
                        for (const Ve in e.chars) {
                            E = e.chars[Ve];
                            break
                        }
                if (E) {
                    let Ve = 0;
                    if (g > 0) {
                        const Pc = this._font.data.kerning;
                        if (Pc) {
                            const Rc = Pc[Rd.getCodePoint(this._symbols[ue - 1]) || 0];
                            Rc && (Ve = Rc[Rd.getCodePoint(this._symbols[ue]) || 0] || 0)
                        }
                    }
                    Bg = E.scale || 1,
                    kg = (E.width + E.height) / 2,
                    Da = A * kg / Bg,
                    Yt = (E.xadvance + Ve) * A,
                    Vt = (E.xoffset - Ve) * A,
                    qt = E.yoffset * A
                } else
                    console.error(`Couldn't substitute missing character: '${b}'`);
                const Ng = X2.test(b)
                  , Of = E && E.map || 0
                  , sb = -this._font.data.info.maps[Of].width / this._font.data.info.maps[Of].height
                  , re = this._meshInfo[Of]
                  , Ug = l + this._spacing * Yt;
                if (Ug > S && g > 0 && !Ng && (this._maxLines < 0 || u < this._maxLines))
                    if (m === 0)
                        p = ue,
                        F(this._symbols, ue, h);
                    else {
                        const Ve = Math.max(ue - p, 0);
                        if (this._meshInfo.length <= 1)
                            re.lines[u - 1] -= Ve,
                            re.quad -= Ve;
                        else {
                            const Pc = p
                              , Rc = ue;
                            for (let kf = Pc; kf < Rc; kf++) {
                                const ib = this._symbols[kf]
                                  , Vg = e.chars[ib]
                                  , Gg = this._meshInfo[Vg && Vg.map || 0];
                                Gg.lines[u - 1] -= 1,
                                Gg.quad -= 1
                            }
                        }
                        ue -= Ve + 1,
                        F(this._symbols, p, f);
                        continue
                    }
                C = re.quad,
                re.lines[u - 1] = C;
                let Mc = l - Vt
                  , Ff = Mc + Da;
                const Bf = c - qt
                  , zg = Bf + Da;
                if (this._rtl) {
                    const Ve = Da - Vt - this._spacing * Yt - Vt;
                    Mc -= Ve,
                    Ff -= Ve
                }
                re.positions[C * 4 * 3 + 0] = Mc,
                re.positions[C * 4 * 3 + 1] = Bf,
                re.positions[C * 4 * 3 + 2] = d,
                re.positions[C * 4 * 3 + 3] = Ff,
                re.positions[C * 4 * 3 + 4] = Bf,
                re.positions[C * 4 * 3 + 5] = d,
                re.positions[C * 4 * 3 + 6] = Ff,
                re.positions[C * 4 * 3 + 7] = zg,
                re.positions[C * 4 * 3 + 8] = d,
                re.positions[C * 4 * 3 + 9] = Mc,
                re.positions[C * 4 * 3 + 10] = zg,
                re.positions[C * 4 * 3 + 11] = d,
                this.width = Math.max(this.width, Ug);
                let Vn;
                if (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth && (Vn = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 1e-4)),
                Vn = W.clamp(Vn, s, i),
                Vn !== this._element.fontSize)) {
                    this._fontSize = Vn,
                    L = !0;
                    break
                }
                if (this.height = Math.max(this.height, T - (c + w)),
                this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight && (Vn = W.clamp(this._fontSize - 1, s, i),
                Vn !== this._element.fontSize)) {
                    this._fontSize = Vn,
                    L = !0;
                    break
                }
                l += this._spacing * Yt,
                Ng || (h = l),
                (this._isWordBoundary(b) || this._isValidNextChar(R) && (this._isNextCJKBoundary(b, R) || this._isNextCJKWholeWord(R))) && (m++,
                f = h,
                p = ue + 1),
                g++;
                const Gn = this._getUv(b);
                if (re.uvs[C * 4 * 2 + 0] = Gn[0],
                re.uvs[C * 4 * 2 + 1] = 1 - Gn[1],
                re.uvs[C * 4 * 2 + 2] = Gn[2],
                re.uvs[C * 4 * 2 + 3] = 1 - Gn[1],
                re.uvs[C * 4 * 2 + 4] = Gn[2],
                re.uvs[C * 4 * 2 + 5] = 1 - Gn[3],
                re.uvs[C * 4 * 2 + 6] = Gn[0],
                re.uvs[C * 4 * 2 + 7] = 1 - Gn[3],
                this._symbolColors) {
                    const Ve = this._symbolColors[ue] * 3;
                    k = this._colorPalette[Ve],
                    N = this._colorPalette[Ve + 1],
                    H = this._colorPalette[Ve + 2]
                }
                if (re.colors[C * 4 * 4 + 0] = k,
                re.colors[C * 4 * 4 + 1] = N,
                re.colors[C * 4 * 4 + 2] = H,
                re.colors[C * 4 * 4 + 3] = 255,
                re.colors[C * 4 * 4 + 4] = k,
                re.colors[C * 4 * 4 + 5] = N,
                re.colors[C * 4 * 4 + 6] = H,
                re.colors[C * 4 * 4 + 7] = 255,
                re.colors[C * 4 * 4 + 8] = k,
                re.colors[C * 4 * 4 + 9] = N,
                re.colors[C * 4 * 4 + 10] = H,
                re.colors[C * 4 * 4 + 11] = 255,
                re.colors[C * 4 * 4 + 12] = k,
                re.colors[C * 4 * 4 + 13] = N,
                re.colors[C * 4 * 4 + 14] = H,
                re.colors[C * 4 * 4 + 15] = 255,
                this._symbolOutlineParams) {
                    const Ve = this._symbolOutlineParams[ue] * 5;
                    K = this._outlinePalette[Ve] + this._outlinePalette[Ve + 1] * 256,
                    q = this._outlinePalette[Ve + 2] + this._outlinePalette[Ve + 3] * 256,
                    se = this._outlinePalette[Ve + 4]
                }
                if (re.outlines[C * 4 * 3 + 0] = K,
                re.outlines[C * 4 * 3 + 1] = q,
                re.outlines[C * 4 * 3 + 2] = se,
                re.outlines[C * 4 * 3 + 3] = K,
                re.outlines[C * 4 * 3 + 4] = q,
                re.outlines[C * 4 * 3 + 5] = se,
                re.outlines[C * 4 * 3 + 6] = K,
                re.outlines[C * 4 * 3 + 7] = q,
                re.outlines[C * 4 * 3 + 8] = se,
                re.outlines[C * 4 * 3 + 9] = K,
                re.outlines[C * 4 * 3 + 10] = q,
                re.outlines[C * 4 * 3 + 11] = se,
                this._symbolShadowParams) {
                    const Ve = this._symbolShadowParams[ue] * 6;
                    ie = this._shadowPalette[Ve] + this._shadowPalette[Ve + 1] * 256,
                    ae = this._shadowPalette[Ve + 2] + this._shadowPalette[Ve + 3] * 256,
                    he = this._shadowPalette[Ve + 4] + 127 + Math.round(sb * this._shadowPalette[Ve + 5] + 127) * 256
                }
                re.shadows[C * 4 * 3 + 0] = ie,
                re.shadows[C * 4 * 3 + 1] = ae,
                re.shadows[C * 4 * 3 + 2] = he,
                re.shadows[C * 4 * 3 + 3] = ie,
                re.shadows[C * 4 * 3 + 4] = ae,
                re.shadows[C * 4 * 3 + 5] = he,
                re.shadows[C * 4 * 3 + 6] = ie,
                re.shadows[C * 4 * 3 + 7] = ae,
                re.shadows[C * 4 * 3 + 8] = he,
                re.shadows[C * 4 * 3 + 9] = ie,
                re.shadows[C * 4 * 3 + 10] = ae,
                re.shadows[C * 4 * 3 + 11] = he,
                re.quad++
            }
            L || _ < o && F(this._symbols, o, l)
        }
        this._noResize = !0,
        this.autoWidth = this._autoWidth,
        this.autoHeight = this._autoHeight,
        this._noResize = !1;
        const U = this._element.pivot.x
          , I = this._element.pivot.y
          , O = this._alignment.x
          , D = this._alignment.y;
        for (let A = 0; A < this._meshInfo.length; A++) {
            if (this._meshInfo[A].count === 0)
                continue;
            let k = 0;
            for (const q in this._meshInfo[A].lines) {
                const se = this._meshInfo[A].lines[q]
                  , ie = this._lineWidths[parseInt(q, 10)]
                  , ae = -U * this._element.calculatedWidth + O * (this._element.calculatedWidth - ie) * (this._rtl ? -1 : 1)
                  , he = (1 - I) * this._element.calculatedHeight - T - (1 - D) * (this._element.calculatedHeight - this.height);
                for (let ue = k; ue <= se; ue++)
                    this._meshInfo[A].positions[ue * 4 * 3] += ae,
                    this._meshInfo[A].positions[ue * 4 * 3 + 3] += ae,
                    this._meshInfo[A].positions[ue * 4 * 3 + 6] += ae,
                    this._meshInfo[A].positions[ue * 4 * 3 + 9] += ae,
                    this._meshInfo[A].positions[ue * 4 * 3 + 1] += he,
                    this._meshInfo[A].positions[ue * 4 * 3 + 4] += he,
                    this._meshInfo[A].positions[ue * 4 * 3 + 7] += he,
                    this._meshInfo[A].positions[ue * 4 * 3 + 10] += he;
                if (this._rtl)
                    for (let ue = k; ue <= se; ue++) {
                        const nt = ue * 4 * 3;
                        for (let Yt = 0; Yt < 4; ++Yt)
                            this._meshInfo[A].positions[nt + Yt * 3] = this._element.calculatedWidth - this._meshInfo[A].positions[nt + Yt * 3] + ae * 2;
                        const Vt = this._meshInfo[A].positions[nt + 3]
                          , qt = this._meshInfo[A].positions[nt + 6];
                        this._meshInfo[A].positions[nt + 3] = this._meshInfo[A].positions[nt + 0],
                        this._meshInfo[A].positions[nt + 6] = this._meshInfo[A].positions[nt + 9],
                        this._meshInfo[A].positions[nt + 0] = Vt,
                        this._meshInfo[A].positions[nt + 9] = qt
                    }
                k = se + 1
            }
            const N = this._meshInfo[A].count * 4
              , H = this._meshInfo[A].quad * 4
              , K = new sh(this._meshInfo[A].meshInstance.mesh.vertexBuffer);
            for (let q = 0; q < N; q++)
                q >= H ? (K.element[ut].set(0, 0, 0),
                K.element[Ls].set(0, 0),
                K.element[jt].set(0, 0, 0, 0),
                K.element[Qr].set(0, 0, 0, 0),
                K.element[Jr].set(0, 0, 0, 0)) : (K.element[ut].set(this._meshInfo[A].positions[q * 3 + 0], this._meshInfo[A].positions[q * 3 + 1], this._meshInfo[A].positions[q * 3 + 2]),
                K.element[Ls].set(this._meshInfo[A].uvs[q * 2 + 0], this._meshInfo[A].uvs[q * 2 + 1]),
                K.element[jt].set(this._meshInfo[A].colors[q * 4 + 0], this._meshInfo[A].colors[q * 4 + 1], this._meshInfo[A].colors[q * 4 + 2], this._meshInfo[A].colors[q * 4 + 3]),
                K.element[Qr].set(this._meshInfo[A].outlines[q * 3 + 0], this._meshInfo[A].outlines[q * 3 + 1], this._meshInfo[A].outlines[q * 3 + 2]),
                K.element[Jr].set(this._meshInfo[A].shadows[q * 3 + 0], this._meshInfo[A].shadows[q * 3 + 1], this._meshInfo[A].shadows[q * 3 + 2])),
                K.next();
            K.end(),
            this._meshInfo[A].meshInstance.mesh.aabb.compute(this._meshInfo[A].positions),
            this._meshInfo[A].meshInstance._aabbVer = -1
        }
        this._aabbDirty = !0
    }
    _onFontRender() {
        this.font = this._font
    }
    _onFontLoad(e) {
        this.font !== e.resource && (this.font = e.resource)
    }
    _onFontChange(e, t, s, i) {
        if (t === "data") {
            this._font.data = s;
            const n = this._font.data.info.maps.length;
            for (let r = 0; r < n; r++) {
                if (!this._meshInfo[r])
                    continue;
                const o = this._meshInfo[r].meshInstance;
                o && (o.setParameter("font_sdfIntensity", this._font.intensity),
                o.setParameter("font_pxrange", this._getPxRange(this._font)),
                o.setParameter("font_textureWidth", this._font.data.info.maps[r].width))
            }
        }
    }
    _onFontRemove(e) {}
    _setTextureParams(e, t) {
        this._font && (this._font.type === _u ? (e.deleteParameter("texture_emissiveMap"),
        e.deleteParameter("texture_opacityMap"),
        e.setParameter("texture_msdfMap", t)) : this._font.type === O2 && (e.deleteParameter("texture_msdfMap"),
        e.setParameter("texture_emissiveMap", t),
        e.setParameter("texture_opacityMap", t)))
    }
    _getPxRange(e) {
        const t = Object.keys(this._font.data.chars);
        for (let s = 0; s < t.length; s++) {
            const i = this._font.data.chars[t[s]];
            if (i.range)
                return (i.scale || 1) * i.range
        }
        return 2
    }
    _getUv(e) {
        const t = this._font.data;
        if (!t.chars[e]) {
            const f = " ";
            return t.chars[f] ? this._getUv(f) : [0, 0, 0, 0]
        }
        const s = t.chars[e].map
          , i = t.info.maps[s].width
          , n = t.info.maps[s].height
          , r = t.chars[e].x
          , o = t.chars[e].y
          , l = r
          , c = o
          , d = r + t.chars[e].width
          , h = o - t.chars[e].height
          , u = 1 - t.chars[e].height / n;
        return [l / i, u - c / n, d / i, u - h / n]
    }
    onEnable() {
        this._fontAsset.autoLoad = !0,
        this._model && this._element.addModelToLayers(this._model)
    }
    onDisable() {
        this._fontAsset.autoLoad = !1,
        this._model && this._element.removeModelFromLayers(this._model)
    }
    _setStencil(e) {
        if (this._model) {
            const t = this._model.meshInstances;
            for (let s = 0; s < t.length; s++)
                t[s].stencilFront = e,
                t[s].stencilBack = e
        }
    }
    _shouldAutoFitWidth() {
        return this._autoFitWidth && !this._autoWidth
    }
    _shouldAutoFitHeight() {
        return this._autoFitHeight && !this._autoHeight
    }
    _shouldAutoFit() {
        return this._autoFitWidth && !this._autoWidth || this._autoFitHeight && !this._autoHeight
    }
    _calculateCharsPerTexture(e) {
        const t = {};
        e === void 0 && (e = this._symbols.length);
        for (let s = 0, i = e; s < i; s++) {
            const n = this._symbols[s];
            let r = this._font.data.chars[n];
            r || (r = this._font.data.chars[" "],
            r || (r = this._font.data.chars[Object.keys(this._font.data.chars)[0]]));
            const o = r.map;
            t[o] ? t[o]++ : t[o] = 1
        }
        return t
    }
    _updateRenderRange() {
        const e = this._rangeStart === 0 ? 0 : this._calculateCharsPerTexture(this._rangeStart)
          , t = this._rangeEnd === 0 ? 0 : this._calculateCharsPerTexture(this._rangeEnd);
        for (let s = 0, i = this._meshInfo.length; s < i; s++) {
            const n = e[s] || 0
              , r = t[s] || 0
              , o = this._meshInfo[s].meshInstance;
            if (o) {
                const l = o.mesh;
                l && (l.primitive[0].base = n * 3 * 2,
                l.primitive[0].count = (r - n) * 3 * 2)
            }
        }
    }
    set text(e) {
        this._i18nKey = null;
        const t = e != null && e.toString() || "";
        this._setText(t)
    }
    get text() {
        return this._text
    }
    set key(e) {
        const t = e !== null ? e.toString() : null;
        this._i18nKey !== t && (this._i18nKey = t,
        t ? (this._fontAsset.disableLocalization = !1,
        this._resetLocalizedText()) : this._fontAsset.disableLocalization = !0)
    }
    get key() {
        return this._i18nKey
    }
    set color(e) {
        const t = e.r
          , s = e.g
          , i = e.b;
        if (!(this._color.r === t && this._color.g === s && this._color.b === i) && (this._color.r = t,
        this._color.g = s,
        this._color.b = i,
        !!this._model)) {
            if (this._symbolColors)
                this._font && this._updateText();
            else {
                this._colorUniform[0] = this._color.r,
                this._colorUniform[1] = this._color.g,
                this._colorUniform[2] = this._color.b;
                for (let n = 0, r = this._model.meshInstances.length; n < r; n++)
                    this._model.meshInstances[n].setParameter("material_emissive", this._colorUniform)
            }
            this._element && this._element.fire("set:color", this._color)
        }
    }
    get color() {
        return this._color
    }
    set opacity(e) {
        if (this._color.a !== e && (this._color.a = e,
        this._model))
            for (let t = 0, s = this._model.meshInstances.length; t < s; t++)
                this._model.meshInstances[t].setParameter("material_opacity", e);
        this._element && this._element.fire("set:opacity", e)
    }
    get opacity() {
        return this._color.a
    }
    set lineHeight(e) {
        const t = this._lineHeight;
        this._lineHeight = e,
        this._scaledLineHeight = e,
        t !== e && this._font && this._updateText()
    }
    get lineHeight() {
        return this._lineHeight
    }
    set wrapLines(e) {
        const t = this._wrapLines;
        this._wrapLines = e,
        t !== e && this._font && this._updateText()
    }
    get wrapLines() {
        return this._wrapLines
    }
    get lines() {
        return this._lineContents
    }
    set spacing(e) {
        const t = this._spacing;
        this._spacing = e,
        t !== e && this._font && this._updateText()
    }
    get spacing() {
        return this._spacing
    }
    set fontSize(e) {
        const t = this._fontSize;
        this._fontSize = e,
        this._originalFontSize = e,
        t !== e && this._font && this._updateText()
    }
    get fontSize() {
        return this._fontSize
    }
    set fontAsset(e) {
        this._fontAsset.defaultAsset = e
    }
    get fontAsset() {
        return this._fontAsset.localizedAsset
    }
    set font(e) {
        let t;
        if (this._font && (t = this._font.type,
        this._font.off && this._font.off("render", this._onFontRender, this)),
        this._font = e,
        this._fontMinY = 0,
        this._fontMaxY = 0,
        !e)
            return;
        const s = this._font.data;
        for (const n in s.chars) {
            const r = s.chars[n];
            r.bounds && (this._fontMinY = Math.min(this._fontMinY, r.bounds[1]),
            this._fontMaxY = Math.max(this._fontMaxY, r.bounds[3]))
        }
        if (this._font.on && this._font.on("render", this._onFontRender, this),
        this._fontAsset.localizedAsset && this._system.app.assets.get(this._fontAsset.localizedAsset).resource !== this._font && (this._fontAsset.defaultAsset = null),
        e.type !== t) {
            const n = this._element._isScreenSpace();
            this._updateMaterial(n)
        }
        for (let n = 0, r = this._font.textures.length; n < r; n++)
            if (!this._meshInfo[n])
                this._meshInfo[n] = new H2;
            else {
                const o = this._meshInfo[n].meshInstance;
                o && (o.setParameter("font_sdfIntensity", this._font.intensity),
                o.setParameter("font_pxrange", this._getPxRange(this._font)),
                o.setParameter("font_textureWidth", this._font.data.info.maps[n].width),
                this._setTextureParams(o, this._font.textures[n]))
            }
        let i = !1;
        for (let n = this._font.textures.length; n < this._meshInfo.length; n++)
            this._meshInfo[n].meshInstance && (i || (this._element.removeModelFromLayers(this._model),
            i = !0),
            this._removeMeshInstance(this._meshInfo[n].meshInstance));
        this._meshInfo.length > this._font.textures.length && (this._meshInfo.length = this._font.textures.length),
        this._updateText()
    }
    get font() {
        return this._font
    }
    set alignment(e) {
        e instanceof P ? this._alignment.set(e.x, e.y) : this._alignment.set(e[0], e[1]),
        this._font && this._updateText()
    }
    get alignment() {
        return this._alignment
    }
    set autoWidth(e) {
        const t = this._autoWidth;
        if (this._autoWidth = e,
        e && Math.abs(this._element.anchor.x - this._element.anchor.z) < 1e-4 && (this._element.width = this.width),
        t !== e) {
            const s = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
            s !== this._fontSize && (this._fontSize = s,
            this._font && this._updateText())
        }
    }
    get autoWidth() {
        return this._autoWidth
    }
    set autoHeight(e) {
        const t = this._autoHeight;
        if (this._autoHeight = e,
        e && Math.abs(this._element.anchor.y - this._element.anchor.w) < 1e-4 && (this._element.height = this.height),
        t !== e) {
            const s = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
            s !== this._fontSize && (this._fontSize = s,
            this._font && this._updateText())
        }
    }
    get autoHeight() {
        return this._autoHeight
    }
    set rtlReorder(e) {
        this._rtlReorder !== e && (this._rtlReorder = e,
        this._font && this._updateText())
    }
    get rtlReorder() {
        return this._rtlReorder
    }
    set unicodeConverter(e) {
        this._unicodeConverter !== e && (this._unicodeConverter = e,
        this._setText(this._text))
    }
    get unicodeConverter() {
        return this._unicodeConverter
    }
    get aabb() {
        if (this._aabbDirty) {
            let e = !1;
            for (let t = 0; t < this._meshInfo.length; t++)
                this._meshInfo[t].meshInstance && (e ? this._aabb.add(this._meshInfo[t].meshInstance.aabb) : (this._aabb.copy(this._meshInfo[t].meshInstance.aabb),
                e = !0));
            this._aabbDirty = !1
        }
        return this._aabb
    }
    set outlineColor(e) {
        const t = e instanceof z ? e.r : e[0]
          , s = e instanceof z ? e.g : e[1]
          , i = e instanceof z ? e.b : e[2]
          , n = e instanceof z ? e.a : e[3];
        if (!(this._outlineColor.r === t && this._outlineColor.g === s && this._outlineColor.b === i && this._outlineColor.a === n) && (this._outlineColor.r = t,
        this._outlineColor.g = s,
        this._outlineColor.b = i,
        this._outlineColor.a = n,
        !!this._model)) {
            if (this._symbolOutlineParams)
                this._font && this._updateText();
            else {
                this._outlineColorUniform[0] = this._outlineColor.r,
                this._outlineColorUniform[1] = this._outlineColor.g,
                this._outlineColorUniform[2] = this._outlineColor.b,
                this._outlineColorUniform[3] = this._outlineColor.a;
                for (let r = 0, o = this._model.meshInstances.length; r < o; r++)
                    this._model.meshInstances[r].setParameter("outline_color", this._outlineColorUniform)
            }
            this._element && this._element.fire("set:outline", this._color)
        }
    }
    get outlineColor() {
        return this._outlineColor
    }
    set outlineThickness(e) {
        const t = this._outlineThickness;
        if (this._outlineThickness = e,
        t !== e && this._font) {
            if (!this._model)
                return;
            if (this._symbolOutlineParams)
                this._font && this._updateText();
            else
                for (let s = 0, i = this._model.meshInstances.length; s < i; s++)
                    this._model.meshInstances[s].setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness)
        }
    }
    get outlineThickness() {
        return this._outlineThickness
    }
    set shadowColor(e) {
        const t = e instanceof z ? e.r : e[0]
          , s = e instanceof z ? e.g : e[1]
          , i = e instanceof z ? e.b : e[2]
          , n = e instanceof z ? e.a : e[3];
        if (!(this._shadowColor.r === t && this._shadowColor.g === s && this._shadowColor.b === i && this._shadowColor.a === n) && (this._shadowColor.r = t,
        this._shadowColor.g = s,
        this._shadowColor.b = i,
        this._shadowColor.a = n,
        !!this._model))
            if (this._symbolShadowParams)
                this._font && this._updateText();
            else {
                this._shadowColorUniform[0] = this._shadowColor.r,
                this._shadowColorUniform[1] = this._shadowColor.g,
                this._shadowColorUniform[2] = this._shadowColor.b,
                this._shadowColorUniform[3] = this._shadowColor.a;
                for (let r = 0, o = this._model.meshInstances.length; r < o; r++)
                    this._model.meshInstances[r].setParameter("shadow_color", this._shadowColorUniform)
            }
    }
    get shadowColor() {
        return this._shadowColor
    }
    set shadowOffset(e) {
        const t = e instanceof P ? e.x : e[0]
          , s = e instanceof P ? e.y : e[1];
        if (!(this._shadowOffset.x === t && this._shadowOffset.y === s) && (this._shadowOffset.set(t, s),
        this._font && this._model))
            if (this._symbolShadowParams)
                this._updateText();
            else
                for (let i = 0, n = this._model.meshInstances.length; i < n; i++) {
                    const r = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;
                    this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x,
                    this._shadowOffsetUniform[1] = r * this._shadowOffsetScale * this._shadowOffset.y,
                    this._model.meshInstances[i].setParameter("shadow_offset", this._shadowOffsetUniform)
                }
    }
    get shadowOffset() {
        return this._shadowOffset
    }
    set minFontSize(e) {
        this._minFontSize !== e && (this._minFontSize = e,
        this.font && this._shouldAutoFit() && this._updateText())
    }
    get minFontSize() {
        return this._minFontSize
    }
    set maxFontSize(e) {
        this._maxFontSize !== e && (this._maxFontSize = e,
        this.font && this._shouldAutoFit() && this._updateText())
    }
    get maxFontSize() {
        return this._maxFontSize
    }
    set autoFitWidth(e) {
        this._autoFitWidth !== e && (this._autoFitWidth = e,
        this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize,
        this.font && this._updateText())
    }
    get autoFitWidth() {
        return this._autoFitWidth
    }
    set autoFitHeight(e) {
        this._autoFitHeight !== e && (this._autoFitHeight = e,
        this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize,
        this.font && this._updateText())
    }
    get autoFitHeight() {
        return this._autoFitHeight
    }
    set maxLines(e) {
        this._maxLines !== e && (e === null && this._maxLines === -1 || (this._maxLines = e === null ? -1 : e,
        this.font && this._wrapLines && this._updateText()))
    }
    get maxLines() {
        return this._maxLines
    }
    set enableMarkup(e) {
        if (e = !!e,
        this._enableMarkup === e)
            return;
        this._enableMarkup = e,
        this.font && this._updateText();
        const t = this._element._isScreenSpace();
        this._updateMaterial(t)
    }
    get enableMarkup() {
        return this._enableMarkup
    }
    get symbols() {
        return this._symbols
    }
    get symbolColors() {
        return this._symbolColors === null ? null : this._symbolColors.map(function(e) {
            return this._colorPalette.slice(e * 3, e * 3 + 3)
        }, this)
    }
    get symbolOutlineParams() {
        return this._symbolOutlineParams === null ? null : this._symbolOutlineParams.map(function(e) {
            return this._outlinePalette.slice(e * 5, e * 5 + 5)
        }, this)
    }
    get symbolShadowParams() {
        return this._symbolShadowParams === null ? null : this._symbolShadowParams.map(function(e) {
            return this._shadowPalette.slice(e * 6, e * 6 + 6)
        }, this)
    }
    get rtl() {
        return this._rtl
    }
    set rangeStart(e) {
        e = Math.max(0, Math.min(e, this._symbols.length)),
        e !== this._rangeStart && (this._rangeStart = e,
        this._updateRenderRange())
    }
    get rangeStart() {
        return this._rangeStart
    }
    set rangeEnd(e) {
        e = Math.max(this._rangeStart, Math.min(e, this._symbols.length)),
        e !== this._rangeEnd && (this._rangeEnd = e,
        this._updateRenderRange())
    }
    get rangeEnd() {
        return this._rangeEnd
    }
}
const Pp = new y
  , mv = new ee
  , ln = new y
  , Q2 = new y
  , Bs = new ee
  , cd = new ee
  , dd = new ee
  , Za = new ee;
class ts extends _e {
    constructor(e, t) {
        super(e, t),
        this._beingInitialized = !1,
        this._anchor = new M,
        this._localAnchor = new M,
        this._pivot = new P,
        this._width = this._calculatedWidth = 32,
        this._height = this._calculatedHeight = 32,
        this._margin = new M(0,0,-32,-32),
        this._modelTransform = new ee,
        this._screenToWorld = new ee,
        this._anchorTransform = new ee,
        this._anchorDirty = !0,
        this._parentWorldTransform = new ee,
        this._screenTransform = new ee,
        this._screenCorners = [new y, new y, new y, new y],
        this._canvasCorners = [new P, new P, new P, new P],
        this._worldCorners = [new y, new y, new y, new y],
        this._cornersDirty = !0,
        this._canvasCornersDirty = !0,
        this._worldCornersDirty = !0,
        this.entity.on("insert", this._onInsert, this),
        this._patch(),
        this.screen = null,
        this._type = us,
        this._image = null,
        this._text = null,
        this._group = null,
        this._drawOrder = 0,
        this._fitMode = zd,
        this._useInput = !1,
        this._layers = [Cf],
        this._addedModels = [],
        this._batchGroupId = -1,
        this._offsetReadAt = 0,
        this._maskOffset = .5,
        this._maskedBy = null
    }
    get _absLeft() {
        return this._localAnchor.x + this._margin.x
    }
    get _absRight() {
        return this._localAnchor.z - this._margin.z
    }
    get _absTop() {
        return this._localAnchor.w - this._margin.w
    }
    get _absBottom() {
        return this._localAnchor.y + this._margin.y
    }
    get _hasSplitAnchorsX() {
        return Math.abs(this._anchor.x - this._anchor.z) > .001
    }
    get _hasSplitAnchorsY() {
        return Math.abs(this._anchor.y - this._anchor.w) > .001
    }
    get aabb() {
        return this._image ? this._image.aabb : this._text ? this._text.aabb : null
    }
    set anchor(e) {
        e instanceof M ? this._anchor.copy(e) : this._anchor.set(...e),
        !this.entity._parent && !this.screen ? this._calculateLocalAnchors() : this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY),
        this._anchorDirty = !0,
        this.entity._dirtyLocal || this.entity._dirtifyLocal(),
        this.fire("set:anchor", this._anchor)
    }
    get anchor() {
        return this._anchor
    }
    set batchGroupId(e) {
        if (this._batchGroupId !== e) {
            if (this.entity.enabled && this._batchGroupId >= 0) {
                var t;
                (t = this.system.app.batcher) == null || t.remove(gt.ELEMENT, this.batchGroupId, this.entity)
            }
            if (this.entity.enabled && e >= 0) {
                var s;
                (s = this.system.app.batcher) == null || s.insert(gt.ELEMENT, e, this.entity)
            }
            e < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled && (this._image && this._image._renderable.model ? this.addModelToLayers(this._image._renderable.model) : this._text && this._text._model && this.addModelToLayers(this._text._model)),
            this._batchGroupId = e
        }
    }
    get batchGroupId() {
        return this._batchGroupId
    }
    set bottom(e) {
        this._margin.y = e;
        const t = this.entity.getLocalPosition()
          , s = this._absTop
          , i = this._localAnchor.y + e;
        this._setHeight(s - i),
        t.y = e + this._calculatedHeight * this._pivot.y,
        this.entity.setLocalPosition(t)
    }
    get bottom() {
        return this._margin.y
    }
    set calculatedWidth(e) {
        this._setCalculatedWidth(e, !0)
    }
    get calculatedWidth() {
        return this._calculatedWidth
    }
    set calculatedHeight(e) {
        this._setCalculatedHeight(e, !0)
    }
    get calculatedHeight() {
        return this._calculatedHeight
    }
    get canvasCorners() {
        if (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace)
            return this._canvasCorners;
        const e = this.system.app.graphicsDevice
          , t = this.screenCorners
          , s = e.canvas.clientWidth / e.width
          , i = e.canvas.clientHeight / e.height;
        for (let n = 0; n < 4; n++)
            this._canvasCorners[n].set(t[n].x * s, (e.height - t[n].y) * i);
        return this._canvasCornersDirty = !1,
        this._canvasCorners
    }
    set drawOrder(e) {
        let t = 0;
        this.screen && (t = this.screen.screen.priority),
        e > 16777215 && (e = 16777215),
        this._drawOrder = (t << 24) + e,
        this.fire("set:draworder", this._drawOrder)
    }
    get drawOrder() {
        return this._drawOrder
    }
    set height(e) {
        this._height = e,
        this._hasSplitAnchorsY || this._setCalculatedHeight(e, !0),
        this.fire("set:height", this._height)
    }
    get height() {
        return this._height
    }
    set layers(e) {
        if (this._addedModels.length)
            for (let t = 0; t < this._layers.length; t++) {
                const s = this.system.app.scene.layers.getLayerById(this._layers[t]);
                if (s)
                    for (let i = 0; i < this._addedModels.length; i++)
                        s.removeMeshInstances(this._addedModels[i].meshInstances)
            }
        if (this._layers = e,
        !(!this.enabled || !this.entity.enabled || !this._addedModels.length))
            for (let t = 0; t < this._layers.length; t++) {
                const s = this.system.app.scene.layers.getLayerById(this._layers[t]);
                if (s)
                    for (let i = 0; i < this._addedModels.length; i++)
                        s.addMeshInstances(this._addedModels[i].meshInstances)
            }
    }
    get layers() {
        return this._layers
    }
    set left(e) {
        this._margin.x = e;
        const t = this.entity.getLocalPosition()
          , s = this._absRight
          , i = this._localAnchor.x + e;
        this._setWidth(s - i),
        t.x = e + this._calculatedWidth * this._pivot.x,
        this.entity.setLocalPosition(t)
    }
    get left() {
        return this._margin.x
    }
    set margin(e) {
        this._margin.copy(e),
        this._calculateSize(!0, !0),
        this.fire("set:margin", this._margin)
    }
    get margin() {
        return this._margin
    }
    get maskedBy() {
        return this._maskedBy
    }
    set pivot(e) {
        const {pivot: t, margin: s} = this
          , i = t.x
          , n = t.y;
        e instanceof P ? t.copy(e) : t.set(...e);
        const r = s.x + s.z
          , o = t.x - i;
        s.x += r * o,
        s.z -= r * o;
        const l = s.y + s.w
          , c = t.y - n;
        s.y += l * c,
        s.w -= l * c,
        this._anchorDirty = !0,
        this._cornersDirty = !0,
        this._worldCornersDirty = !0,
        this._calculateSize(!1, !1),
        this._flagChildrenAsDirty(),
        this.fire("set:pivot", t)
    }
    get pivot() {
        return this._pivot
    }
    set right(e) {
        this._margin.z = e;
        const t = this.entity.getLocalPosition()
          , s = this._absLeft
          , i = this._localAnchor.z - e;
        this._setWidth(i - s),
        t.x = this._localAnchor.z - this._localAnchor.x - e - this._calculatedWidth * (1 - this._pivot.x),
        this.entity.setLocalPosition(t)
    }
    get right() {
        return this._margin.z
    }
    get screenCorners() {
        if (!this._cornersDirty || !this.screen)
            return this._screenCorners;
        const e = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];
        this._screenCorners[0].set(this._absLeft, this._absBottom, 0),
        this._screenCorners[1].set(this._absRight, this._absBottom, 0),
        this._screenCorners[2].set(this._absRight, this._absTop, 0),
        this._screenCorners[3].set(this._absLeft, this._absTop, 0);
        const t = this.screen.screen.screenSpace;
        for (let s = 0; s < 4; s++)
            this._screenTransform.transformPoint(this._screenCorners[s], this._screenCorners[s]),
            t && this._screenCorners[s].mulScalar(this.screen.screen.scale),
            e && this._screenCorners[s].add(e);
        return this._cornersDirty = !1,
        this._canvasCornersDirty = !0,
        this._worldCornersDirty = !0,
        this._screenCorners
    }
    get textWidth() {
        return this._text ? this._text.width : 0
    }
    get textHeight() {
        return this._text ? this._text.height : 0
    }
    set top(e) {
        this._margin.w = e;
        const t = this.entity.getLocalPosition()
          , s = this._absBottom
          , i = this._localAnchor.w - e;
        this._setHeight(i - s),
        t.y = this._localAnchor.w - this._localAnchor.y - e - this._calculatedHeight * (1 - this._pivot.y),
        this.entity.setLocalPosition(t)
    }
    get top() {
        return this._margin.w
    }
    set type(e) {
        e !== this._type && (this._type = e,
        this._image && (this._image.destroy(),
        this._image = null),
        this._text && (this._text.destroy(),
        this._text = null),
        e === Ae ? this._image = new L2(this) : e === Oh && (this._text = new Z2(this)))
    }
    get type() {
        return this._type
    }
    set useInput(e) {
        this._useInput !== e && (this._useInput = e,
        this.system.app.elementInput ? e ? this.enabled && this.entity.enabled && this.system.app.elementInput.addElement(this) : this.system.app.elementInput.removeElement(this) : this._useInput,
        this.fire("set:useInput", e))
    }
    get useInput() {
        return this._useInput
    }
    set fitMode(e) {
        this._fitMode = e,
        this._calculateSize(!0, !0),
        this._image && this._image.refreshMesh()
    }
    get fitMode() {
        return this._fitMode
    }
    set width(e) {
        this._width = e,
        this._hasSplitAnchorsX || this._setCalculatedWidth(e, !0),
        this.fire("set:width", this._width)
    }
    get width() {
        return this._width
    }
    get worldCorners() {
        if (!this._worldCornersDirty)
            return this._worldCorners;
        if (this.screen) {
            const e = this.screenCorners;
            if (!this.screen.screen.screenSpace) {
                Bs.copy(this.screen.screen._screenMatrix),
                Bs.data[13] = -Bs.data[13],
                Bs.mul2(this.screen.getWorldTransform(), Bs);
                for (let t = 0; t < 4; t++)
                    Bs.transformPoint(e[t], this._worldCorners[t])
            }
        } else {
            const e = this.entity.getLocalPosition();
            Bs.setTranslate(-e.x, -e.y, -e.z),
            cd.setTRS(y.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale()),
            dd.setTranslate(e.x, e.y, e.z);
            const t = this.entity.parent ? this.entity.parent : this.entity;
            Za.copy(t.getWorldTransform()),
            Za.mul(dd).mul(cd).mul(Bs),
            ln.set(e.x - this.pivot.x * this.calculatedWidth, e.y - this.pivot.y * this.calculatedHeight, e.z),
            Za.transformPoint(ln, this._worldCorners[0]),
            ln.set(e.x + (1 - this.pivot.x) * this.calculatedWidth, e.y - this.pivot.y * this.calculatedHeight, e.z),
            Za.transformPoint(ln, this._worldCorners[1]),
            ln.set(e.x + (1 - this.pivot.x) * this.calculatedWidth, e.y + (1 - this.pivot.y) * this.calculatedHeight, e.z),
            Za.transformPoint(ln, this._worldCorners[2]),
            ln.set(e.x - this.pivot.x * this.calculatedWidth, e.y + (1 - this.pivot.y) * this.calculatedHeight, e.z),
            Za.transformPoint(ln, this._worldCorners[3])
        }
        return this._worldCornersDirty = !1,
        this._worldCorners
    }
    _patch() {
        this.entity._sync = this._sync,
        this.entity.setPosition = this._setPosition,
        this.entity.setLocalPosition = this._setLocalPosition
    }
    _unpatch() {
        this.entity._sync = V.prototype._sync,
        this.entity.setPosition = V.prototype.setPosition,
        this.entity.setLocalPosition = V.prototype.setLocalPosition
    }
    _setPosition(e, t, s) {
        if (!this.element.screen) {
            V.prototype.setPosition.call(this, e, t, s);
            return
        }
        e instanceof y ? Pp.copy(e) : Pp.set(e, t, s),
        this.getWorldTransform(),
        mv.copy(this.element._screenToWorld).invert(),
        mv.transformPoint(Pp, this.localPosition),
        this._dirtyLocal || this._dirtifyLocal()
    }
    _setLocalPosition(e, t, s) {
        e instanceof y ? this.localPosition.copy(e) : this.localPosition.set(e, t, s);
        const i = this.element
          , n = this.localPosition
          , r = i._pivot;
        i._margin.x = n.x - i._calculatedWidth * r.x,
        i._margin.z = i._localAnchor.z - i._localAnchor.x - i._calculatedWidth - i._margin.x,
        i._margin.y = n.y - i._calculatedHeight * r.y,
        i._margin.w = i._localAnchor.w - i._localAnchor.y - i._calculatedHeight - i._margin.y,
        this._dirtyLocal || this._dirtifyLocal()
    }
    _sync() {
        const e = this.element
          , t = e.screen;
        if (t) {
            if (e._anchorDirty) {
                let s = 0
                  , i = 0
                  , n = 0
                  , r = 1;
                if (this._parent && this._parent.element)
                    s = this._parent.element.calculatedWidth,
                    i = this._parent.element.calculatedHeight,
                    n = this._parent.element.pivot.x,
                    r = this._parent.element.pivot.y;
                else {
                    const o = t.screen.resolution;
                    s = o.x / t.screen.scale,
                    i = o.y / t.screen.scale
                }
                e._anchorTransform.setTranslate(s * (e.anchor.x - n), -(i * (r - e.anchor.y)), 0),
                e._anchorDirty = !1,
                e._calculateLocalAnchors()
            }
            e._sizeDirty && e._calculateSize(!1, !1)
        }
        if (this._dirtyLocal) {
            this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
            const s = this.localPosition
              , i = e._pivot;
            e._margin.x = s.x - e._calculatedWidth * i.x,
            e._margin.z = e._localAnchor.z - e._localAnchor.x - e._calculatedWidth - e._margin.x,
            e._margin.y = s.y - e._calculatedHeight * i.y,
            e._margin.w = e._localAnchor.w - e._localAnchor.y - e._calculatedHeight - e._margin.y,
            this._dirtyLocal = !1
        }
        if (!t) {
            this._dirtyWorld && (e._cornersDirty = !0,
            e._canvasCornersDirty = !0,
            e._worldCornersDirty = !0),
            V.prototype._sync.call(this);
            return
        }
        if (this._dirtyWorld) {
            if (this._parent === null)
                this.worldTransform.copy(this.localTransform);
            else if (this._parent.element ? e._screenToWorld.mul2(this._parent.element._modelTransform, e._anchorTransform) : e._screenToWorld.copy(e._anchorTransform),
            e._modelTransform.mul2(e._screenToWorld, this.localTransform),
            t) {
                e._screenToWorld.mul2(t.screen._screenMatrix, e._screenToWorld),
                t.screen.screenSpace || e._screenToWorld.mul2(t.worldTransform, e._screenToWorld),
                this.worldTransform.mul2(e._screenToWorld, this.localTransform);
                const s = e._parentWorldTransform;
                s.setIdentity();
                const i = this._parent;
                i && i.element && i !== t && (Bs.setTRS(y.ZERO, i.getLocalRotation(), i.getLocalScale()),
                s.mul2(i.element._parentWorldTransform, Bs));
                const n = ln;
                n.set(0, 0, this.localPosition.z);
                const r = Q2;
                r.set(e._absLeft + e._pivot.x * e.calculatedWidth, e._absBottom + e._pivot.y * e.calculatedHeight, 0),
                Bs.setTranslate(-r.x, -r.y, -r.z),
                cd.setTRS(n, this.getLocalRotation(), this.getLocalScale()),
                dd.setTranslate(r.x, r.y, r.z),
                e._screenTransform.mul2(e._parentWorldTransform, dd).mul(cd).mul(Bs),
                e._cornersDirty = !0,
                e._canvasCornersDirty = !0,
                e._worldCornersDirty = !0
            } else
                this.worldTransform.copy(e._modelTransform);
            this._dirtyWorld = !1
        }
    }
    _onInsert(e) {
        const t = this._parseUpToScreen();
        this.entity._dirtifyWorld(),
        this._updateScreen(t.screen),
        this._dirtifyMask()
    }
    _dirtifyMask() {
        let e = this.entity;
        for (; e; ) {
            const t = e.parent;
            if ((t === null || t.screen) && e.element) {
                (!this.system._prerender || !this.system._prerender.length) && (this.system._prerender = [],
                this.system.app.once("prerender", this._onPrerender, this));
                const s = this.system._prerender.indexOf(this.entity);
                s >= 0 && this.system._prerender.splice(s, 1),
                this.system._prerender.indexOf(e) < 0 && this.system._prerender.push(e)
            }
            e = t
        }
    }
    _onPrerender() {
        for (let e = 0; e < this.system._prerender.length; e++) {
            const t = this.system._prerender[e];
            t.element && t.element.syncMask(1)
        }
        this.system._prerender.length = 0
    }
    _bindScreen(e) {
        e._bindElement(this)
    }
    _unbindScreen(e) {
        e._unbindElement(this)
    }
    _updateScreen(e) {
        this.screen && this.screen !== e && this._unbindScreen(this.screen.screen);
        const t = this.screen;
        this.screen = e,
        this.screen && this._bindScreen(this.screen.screen),
        this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY),
        this.fire("set:screen", this.screen, t),
        this._anchorDirty = !0;
        const s = this.entity.children;
        for (let i = 0, n = s.length; i < n; i++)
            s[i].element && s[i].element._updateScreen(e);
        this.screen && this.screen.screen.syncDrawOrder()
    }
    syncMask(e) {
        const t = this._parseUpToScreen();
        this._updateMask(t.mask, e)
    }
    _setMaskedBy(e) {
        const t = this._image || this._text;
        if (e) {
            const s = e.element._image._maskRef;
            t == null || t._setStencil(new qs({
                ref: s,
                func: Yd
            })),
            this._maskedBy = e
        } else
            t == null || t._setStencil(null),
            this._maskedBy = null
    }
    _updateMask(e, t) {
        if (e) {
            if (this._setMaskedBy(e),
            this.mask) {
                const r = e.element._image._maskRef
                  , o = new qs({
                    ref: r,
                    func: Yd,
                    zpass: CT
                });
                this._image._setStencil(o),
                this._image._maskRef = t,
                t++,
                e = this.entity
            }
            const n = this.entity.children;
            for (let r = 0, o = n.length; r < o; r++) {
                var s;
                (s = n[r].element) == null || s._updateMask(e, t)
            }
            this.mask && t--
        } else {
            if (this._setMaskedBy(null),
            this.mask) {
                const r = new qs({
                    ref: t,
                    func: Mn,
                    zpass: TT
                });
                this._image._setStencil(r),
                this._image._maskRef = t,
                t++,
                e = this.entity
            }
            const n = this.entity.children;
            for (let r = 0, o = n.length; r < o; r++) {
                var i;
                (i = n[r].element) == null || i._updateMask(e, t)
            }
            this.mask && t--
        }
    }
    _parseUpToScreen() {
        const e = {
            screen: null,
            mask: null
        };
        let t = this.entity._parent;
        for (; t && !t.screen; )
            t.element && t.element.mask && (e.mask || (e.mask = t)),
            t = t.parent;
        return t && t.screen && (e.screen = t),
        e
    }
    _onScreenResize(e) {
        this._anchorDirty = !0,
        this._cornersDirty = !0,
        this._worldCornersDirty = !0,
        this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY),
        this.fire("screen:set:resolution", e)
    }
    _onScreenSpaceChange() {
        this.fire("screen:set:screenspace", this.screen.screen.screenSpace)
    }
    _onScreenRemove() {
        this.screen && (this.screen._destroying ? this.screen = null : this._updateScreen(null))
    }
    _calculateLocalAnchors() {
        let e = 1e3
          , t = 1e3;
        const s = this.entity._parent;
        if (s && s.element)
            e = s.element.calculatedWidth,
            t = s.element.calculatedHeight;
        else if (this.screen) {
            const i = this.screen.screen.resolution
              , n = this.screen.screen.scale;
            e = i.x / n,
            t = i.y / n
        }
        this._localAnchor.set(this._anchor.x * e, this._anchor.y * t, this._anchor.z * e, this._anchor.w * t)
    }
    getOffsetPosition(e, t) {
        const s = this.entity.getLocalPosition().clone();
        return s.x += e,
        s.y += t,
        this._screenToWorld.transformPoint(s, s),
        s
    }
    onLayersChanged(e, t) {
        this.addModelToLayers(this._image ? this._image._renderable.model : this._text._model),
        e.off("add", this.onLayerAdded, this),
        e.off("remove", this.onLayerRemoved, this),
        t.on("add", this.onLayerAdded, this),
        t.on("remove", this.onLayerRemoved, this)
    }
    onLayerAdded(e) {
        this.layers.indexOf(e.id) < 0 || (this._image ? e.addMeshInstances(this._image._renderable.model.meshInstances) : this._text && e.addMeshInstances(this._text._model.meshInstances))
    }
    onLayerRemoved(e) {
        this.layers.indexOf(e.id) < 0 || (this._image ? e.removeMeshInstances(this._image._renderable.model.meshInstances) : this._text && e.removeMeshInstances(this._text._model.meshInstances))
    }
    onEnable() {
        if (this._image && this._image.onEnable(),
        this._text && this._text.onEnable(),
        this._group && this._group.onEnable(),
        this.useInput && this.system.app.elementInput && this.system.app.elementInput.addElement(this),
        this.system.app.scene.on("set:layers", this.onLayersChanged, this),
        this.system.app.scene.layers && (this.system.app.scene.layers.on("add", this.onLayerAdded, this),
        this.system.app.scene.layers.on("remove", this.onLayerRemoved, this)),
        this._batchGroupId >= 0) {
            var e;
            (e = this.system.app.batcher) == null || e.insert(gt.ELEMENT, this.batchGroupId, this.entity)
        }
        this.fire("enableelement")
    }
    onDisable() {
        if (this.system.app.scene.off("set:layers", this.onLayersChanged, this),
        this.system.app.scene.layers && (this.system.app.scene.layers.off("add", this.onLayerAdded, this),
        this.system.app.scene.layers.off("remove", this.onLayerRemoved, this)),
        this._image && this._image.onDisable(),
        this._text && this._text.onDisable(),
        this._group && this._group.onDisable(),
        this.system.app.elementInput && this.useInput && this.system.app.elementInput.removeElement(this),
        this._batchGroupId >= 0) {
            var e;
            (e = this.system.app.batcher) == null || e.remove(gt.ELEMENT, this.batchGroupId, this.entity)
        }
        this.fire("disableelement")
    }
    onRemove() {
        this.entity.off("insert", this._onInsert, this),
        this._unpatch(),
        this._image && this._image.destroy(),
        this._text && this._text.destroy(),
        this.system.app.elementInput && this.useInput && this.system.app.elementInput.removeElement(this),
        this.screen && this.screen.screen && (this._unbindScreen(this.screen.screen),
        this.screen.screen.syncDrawOrder()),
        this.off()
    }
    _calculateSize(e, t) {
        if (!this.entity._parent && !this.screen)
            return;
        this._calculateLocalAnchors();
        const s = this._absRight - this._absLeft
          , i = this._absTop - this._absBottom;
        e ? this._setWidth(s) : this._setCalculatedWidth(s, !1),
        t ? this._setHeight(i) : this._setCalculatedHeight(i, !1);
        const n = this.entity.getLocalPosition();
        n.x = this._margin.x + this._calculatedWidth * this._pivot.x,
        n.y = this._margin.y + this._calculatedHeight * this._pivot.y,
        this.entity.setLocalPosition(n),
        this._sizeDirty = !1
    }
    _setWidth(e) {
        this._width = e,
        this._setCalculatedWidth(e, !1),
        this.fire("set:width", this._width)
    }
    _setHeight(e) {
        this._height = e,
        this._setCalculatedHeight(e, !1),
        this.fire("set:height", this._height)
    }
    _setCalculatedWidth(e, t) {
        if (!(Math.abs(e - this._calculatedWidth) <= 1e-4)) {
            if (this._calculatedWidth = e,
            this.entity._dirtifyLocal(),
            t) {
                const s = this.entity.getLocalPosition()
                  , i = this._pivot;
                this._margin.x = s.x - this._calculatedWidth * i.x,
                this._margin.z = this._localAnchor.z - this._localAnchor.x - this._calculatedWidth - this._margin.x
            }
            this._flagChildrenAsDirty(),
            this.fire("set:calculatedWidth", this._calculatedWidth),
            this.fire("resize", this._calculatedWidth, this._calculatedHeight)
        }
    }
    _setCalculatedHeight(e, t) {
        if (!(Math.abs(e - this._calculatedHeight) <= 1e-4)) {
            if (this._calculatedHeight = e,
            this.entity._dirtifyLocal(),
            t) {
                const s = this.entity.getLocalPosition()
                  , i = this._pivot;
                this._margin.y = s.y - this._calculatedHeight * i.y,
                this._margin.w = this._localAnchor.w - this._localAnchor.y - this._calculatedHeight - this._margin.y
            }
            this._flagChildrenAsDirty(),
            this.fire("set:calculatedHeight", this._calculatedHeight),
            this.fire("resize", this._calculatedWidth, this._calculatedHeight)
        }
    }
    _flagChildrenAsDirty() {
        const e = this.entity._children;
        for (let t = 0, s = e.length; t < s; t++)
            e[t].element && (e[t].element._anchorDirty = !0,
            e[t].element._sizeDirty = !0)
    }
    addModelToLayers(e) {
        this._addedModels.push(e);
        for (let t = 0; t < this.layers.length; t++) {
            const s = this.system.app.scene.layers.getLayerById(this.layers[t]);
            s && s.addMeshInstances(e.meshInstances)
        }
    }
    removeModelFromLayers(e) {
        const t = this._addedModels.indexOf(e);
        t >= 0 && this._addedModels.splice(t, 1);
        for (let s = 0; s < this.layers.length; s++) {
            const i = this.system.app.scene.layers.getLayerById(this.layers[s]);
            i && i.removeMeshInstances(e.meshInstances)
        }
    }
    getMaskOffset() {
        const e = this.system.app.frame;
        this._offsetReadAt !== e && (this._maskOffset = .5,
        this._offsetReadAt = e);
        const t = this._maskOffset;
        return this._maskOffset -= .001,
        t
    }
    isVisibleForCamera(e) {
        let t, s, i, n;
        if (this.maskedBy) {
            const h = this.maskedBy.element.screenCorners;
            t = Math.min(Math.min(h[0].x, h[1].x), Math.min(h[2].x, h[3].x)),
            s = Math.max(Math.max(h[0].x, h[1].x), Math.max(h[2].x, h[3].x)),
            n = Math.min(Math.min(h[0].y, h[1].y), Math.min(h[2].y, h[3].y)),
            i = Math.max(Math.max(h[0].y, h[1].y), Math.max(h[2].y, h[3].y))
        } else {
            const h = this.system.app.graphicsDevice.width
              , u = this.system.app.graphicsDevice.height
              , f = e._rect.z * h
              , p = e._rect.w * u;
            t = e._rect.x * h,
            s = t + f,
            i = (1 - e._rect.y) * u,
            n = i - p
        }
        const r = this.screenCorners
          , o = Math.min(Math.min(r[0].x, r[1].x), Math.min(r[2].x, r[3].x))
          , l = Math.max(Math.max(r[0].x, r[1].x), Math.max(r[2].x, r[3].x))
          , c = Math.min(Math.min(r[0].y, r[1].y), Math.min(r[2].y, r[3].y))
          , d = Math.max(Math.max(r[0].y, r[1].y), Math.max(r[2].y, r[3].y));
        return !(l < t || o > s || c > i || d < n)
    }
    _isScreenSpace() {
        return this.screen && this.screen.screen ? this.screen.screen.screenSpace : !1
    }
    _isScreenCulled() {
        return this.screen && this.screen.screen ? this.screen.screen.cull : !1
    }
    _dirtyBatch() {
        if (this.batchGroupId !== -1) {
            var e;
            (e = this.system.app.batcher) == null || e.markGroupDirty(this.batchGroupId)
        }
    }
}
ts.EVENT_MOUSEDOWN = "mousedown";
ts.EVENT_MOUSEUP = "mouseup";
ts.EVENT_MOUSEENTER = "mouseenter";
ts.EVENT_MOUSELEAVE = "mouseleave";
ts.EVENT_MOUSEMOVE = "mousemove";
ts.EVENT_MOUSEWHEEL = "mousewheel";
ts.EVENT_CLICK = "click";
ts.EVENT_TOUCHSTART = "touchstart";
ts.EVENT_TOUCHEND = "touchend";
ts.EVENT_TOUCHMOVE = "touchmove";
ts.EVENT_TOUCHCANCEL = "touchcancel";
function Ce(a) {
    Object.defineProperty(ts.prototype, a, {
        get: function() {
            return this._text ? this._text[a] : this._image ? this._image[a] : null
        },
        set: function(e) {
            this._text ? (this._text[a] !== e && this._dirtyBatch(),
            this._text[a] = e) : this._image && (this._image[a] !== e && this._dirtyBatch(),
            this._image[a] = e)
        }
    })
}
Ce("fontSize");
Ce("minFontSize");
Ce("maxFontSize");
Ce("maxLines");
Ce("autoFitWidth");
Ce("autoFitHeight");
Ce("color");
Ce("font");
Ce("fontAsset");
Ce("spacing");
Ce("lineHeight");
Ce("wrapLines");
Ce("lines");
Ce("alignment");
Ce("autoWidth");
Ce("autoHeight");
Ce("rtlReorder");
Ce("unicodeConverter");
Ce("text");
Ce("key");
Ce("texture");
Ce("textureAsset");
Ce("material");
Ce("materialAsset");
Ce("sprite");
Ce("spriteAsset");
Ce("spriteFrame");
Ce("pixelsPerUnit");
Ce("opacity");
Ce("rect");
Ce("mask");
Ce("outlineColor");
Ce("outlineThickness");
Ce("shadowColor");
Ce("shadowOffset");
Ce("enableMarkup");
Ce("rangeStart");
Ce("rangeEnd");
class J2 {
    constructor() {
        this.enabled = !0
    }
}
const Kx = ["enabled"];
class eO extends it {
    constructor(e) {
        super(e),
        this.id = "element",
        this.ComponentType = ts,
        this.DataType = J2,
        this.schema = Kx,
        this._unicodeConverter = null,
        this._rtlReorder = null,
        this._defaultTexture = new ge(e.graphicsDevice,{
            width: 1,
            height: 1,
            format: ve,
            name: "element-system"
        });
        const t = this._defaultTexture.lock()
          , s = new Uint8Array(4);
        s[0] = 255,
        s[1] = 255,
        s[2] = 255,
        s[3] = 255,
        t.set(s),
        this._defaultTexture.unlock(),
        this.defaultImageMaterial = null,
        this.defaultImage9SlicedMaterial = null,
        this.defaultImage9TiledMaterial = null,
        this.defaultImageMaskMaterial = null,
        this.defaultImage9SlicedMaskMaterial = null,
        this.defaultImage9TiledMaskMaterial = null,
        this.defaultScreenSpaceImageMaterial = null,
        this.defaultScreenSpaceImage9SlicedMaterial = null,
        this.defaultScreenSpaceImage9TiledMaterial = null,
        this.defaultScreenSpaceImageMask9SlicedMaterial = null,
        this.defaultScreenSpaceImageMask9TiledMaterial = null,
        this.defaultScreenSpaceImageMaskMaterial = null,
        this._defaultTextMaterials = {},
        this.defaultImageMaterials = [],
        this.on("beforeremove", this.onRemoveComponent, this)
    }
    destroy() {
        super.destroy(),
        this._defaultTexture.destroy()
    }
    initializeComponentData(e, t, s) {
        e._beingInitialized = !0,
        t.anchor !== void 0 && (t.anchor instanceof M ? e.anchor.copy(t.anchor) : e.anchor.set(t.anchor[0], t.anchor[1], t.anchor[2], t.anchor[3])),
        t.pivot !== void 0 && (t.pivot instanceof P ? e.pivot.copy(t.pivot) : e.pivot.set(t.pivot[0], t.pivot[1]));
        const i = Math.abs(e.anchor.x - e.anchor.z) > .001
          , n = Math.abs(e.anchor.y - e.anchor.w) > .001;
        let r = !1, o;
        t.margin !== void 0 && (t.margin instanceof M ? e.margin.copy(t.margin) : e._margin.set(t.margin[0], t.margin[1], t.margin[2], t.margin[3]),
        r = !0),
        t.left !== void 0 && (e._margin.x = t.left,
        r = !0),
        t.bottom !== void 0 && (e._margin.y = t.bottom,
        r = !0),
        t.right !== void 0 && (e._margin.z = t.right,
        r = !0),
        t.top !== void 0 && (e._margin.w = t.top,
        r = !0),
        r && (e.margin = e._margin);
        let l = !1;
        t.width !== void 0 && !i ? e.width = t.width : i && (l = !0),
        t.height !== void 0 && !n ? e.height = t.height : n && (l = !0),
        l && (e.anchor = e.anchor),
        t.enabled !== void 0 && (e.enabled = t.enabled),
        t.useInput !== void 0 && (e.useInput = t.useInput),
        t.fitMode !== void 0 && (e.fitMode = t.fitMode),
        e.batchGroupId = t.batchGroupId === void 0 || t.batchGroupId === null ? -1 : t.batchGroupId,
        t.layers && Array.isArray(t.layers) && (e.layers = t.layers.slice(0)),
        t.type !== void 0 && (e.type = t.type),
        e.type === Ae ? (t.rect !== void 0 && (e.rect = t.rect),
        t.color !== void 0 && (o = t.color,
        o instanceof z || (o = new z(t.color[0],t.color[1],t.color[2])),
        e.color = o),
        t.opacity !== void 0 && (e.opacity = t.opacity),
        t.textureAsset !== void 0 && (e.textureAsset = t.textureAsset),
        t.texture && (e.texture = t.texture),
        t.spriteAsset !== void 0 && (e.spriteAsset = t.spriteAsset),
        t.sprite && (e.sprite = t.sprite),
        t.spriteFrame !== void 0 && (e.spriteFrame = t.spriteFrame),
        t.pixelsPerUnit !== void 0 && t.pixelsPerUnit !== null && (e.pixelsPerUnit = t.pixelsPerUnit),
        t.materialAsset !== void 0 && (e.materialAsset = t.materialAsset),
        t.material && (e.material = t.material),
        t.mask !== void 0 && (e.mask = t.mask)) : e.type === Oh && (t.autoWidth !== void 0 && (e.autoWidth = t.autoWidth),
        t.autoHeight !== void 0 && (e.autoHeight = t.autoHeight),
        t.rtlReorder !== void 0 && (e.rtlReorder = t.rtlReorder),
        t.unicodeConverter !== void 0 && (e.unicodeConverter = t.unicodeConverter),
        t.text !== null && t.text !== void 0 ? e.text = t.text : t.key !== null && t.key !== void 0 && (e.key = t.key),
        t.color !== void 0 && (o = t.color,
        o instanceof z || (o = new z(o[0],o[1],o[2])),
        e.color = o),
        t.opacity !== void 0 && (e.opacity = t.opacity),
        t.spacing !== void 0 && (e.spacing = t.spacing),
        t.fontSize !== void 0 && (e.fontSize = t.fontSize,
        t.lineHeight || (e.lineHeight = t.fontSize)),
        t.lineHeight !== void 0 && (e.lineHeight = t.lineHeight),
        t.maxLines !== void 0 && (e.maxLines = t.maxLines),
        t.wrapLines !== void 0 && (e.wrapLines = t.wrapLines),
        t.minFontSize !== void 0 && (e.minFontSize = t.minFontSize),
        t.maxFontSize !== void 0 && (e.maxFontSize = t.maxFontSize),
        t.autoFitWidth && (e.autoFitWidth = t.autoFitWidth),
        t.autoFitHeight && (e.autoFitHeight = t.autoFitHeight),
        t.fontAsset !== void 0 && (e.fontAsset = t.fontAsset),
        t.font !== void 0 && (e.font = t.font),
        t.alignment !== void 0 && (e.alignment = t.alignment),
        t.outlineColor !== void 0 && (e.outlineColor = t.outlineColor),
        t.outlineThickness !== void 0 && (e.outlineThickness = t.outlineThickness),
        t.shadowColor !== void 0 && (e.shadowColor = t.shadowColor),
        t.shadowOffset !== void 0 && (e.shadowOffset = t.shadowOffset),
        t.enableMarkup !== void 0 && (e.enableMarkup = t.enableMarkup));
        const c = e._parseUpToScreen();
        c.screen && e._updateScreen(c.screen),
        super.initializeComponentData(e, t, s),
        e._beingInitialized = !1,
        e.type === Ae && e._image._meshDirty && e._image._updateMesh(e._image.mesh)
    }
    onRemoveComponent(e, t) {
        t.onRemove()
    }
    cloneComponent(e, t) {
        const s = e.element
          , i = {
            enabled: s.enabled,
            width: s.width,
            height: s.height,
            anchor: s.anchor.clone(),
            pivot: s.pivot.clone(),
            margin: s.margin.clone(),
            alignment: s.alignment && s.alignment.clone() || s.alignment,
            autoWidth: s.autoWidth,
            autoHeight: s.autoHeight,
            type: s.type,
            rect: s.rect && s.rect.clone() || s.rect,
            rtlReorder: s.rtlReorder,
            unicodeConverter: s.unicodeConverter,
            materialAsset: s.materialAsset,
            material: s.material,
            color: s.color && s.color.clone() || s.color,
            opacity: s.opacity,
            textureAsset: s.textureAsset,
            texture: s.texture,
            spriteAsset: s.spriteAsset,
            sprite: s.sprite,
            spriteFrame: s.spriteFrame,
            pixelsPerUnit: s.pixelsPerUnit,
            spacing: s.spacing,
            lineHeight: s.lineHeight,
            wrapLines: s.wrapLines,
            layers: s.layers,
            fontSize: s.fontSize,
            minFontSize: s.minFontSize,
            maxFontSize: s.maxFontSize,
            autoFitWidth: s.autoFitWidth,
            autoFitHeight: s.autoFitHeight,
            maxLines: s.maxLines,
            fontAsset: s.fontAsset,
            font: s.font,
            useInput: s.useInput,
            fitMode: s.fitMode,
            batchGroupId: s.batchGroupId,
            mask: s.mask,
            outlineColor: s.outlineColor && s.outlineColor.clone() || s.outlineColor,
            outlineThickness: s.outlineThickness,
            shadowColor: s.shadowColor && s.shadowColor.clone() || s.shadowColor,
            shadowOffset: s.shadowOffset && s.shadowOffset.clone() || s.shadowOffset,
            enableMarkup: s.enableMarkup
        };
        return s.key !== void 0 && s.key !== null ? i.key = s.key : i.text = s.text,
        this.addComponent(t, i)
    }
    getTextElementMaterial(e, t, s) {
        const i = (e && 1) | (t && 2) | (s && 4);
        let n = this._defaultTextMaterials[i];
        if (n)
            return n;
        let r = "TextMaterial";
        return n = new at,
        t ? (n.msdfMap = this._defaultTexture,
        n.msdfTextAttribute = s,
        n.emissive.set(1, 1, 1)) : (r = "Bitmap" + r,
        n.emissive.set(.5, .5, .5),
        n.emissiveMap = this._defaultTexture,
        n.emissiveTint = !0,
        n.opacityMap = this._defaultTexture,
        n.opacityMapChannel = "a"),
        e && (r = "ScreenSpace" + r,
        n.depthTest = !1),
        n.name = "default" + r,
        n.useLighting = !1,
        n.useGammaTonemap = !1,
        n.useFog = !1,
        n.useSkybox = !1,
        n.diffuse.set(0, 0, 0),
        n.opacity = .5,
        n.blendType = _a,
        n.depthWrite = !1,
        n.emissiveVertexColor = !0,
        n.update(),
        this._defaultTextMaterials[i] = n,
        n
    }
    _createBaseImageMaterial() {
        const e = new at;
        return e.diffuse.set(0, 0, 0),
        e.emissive.set(.5, .5, .5),
        e.emissiveMap = this._defaultTexture,
        e.emissiveTint = !0,
        e.opacityMap = this._defaultTexture,
        e.opacityMapChannel = "a",
        e.opacityTint = !0,
        e.opacity = 0,
        e.useLighting = !1,
        e.useGammaTonemap = !1,
        e.useFog = !1,
        e.useSkybox = !1,
        e.blendType = _a,
        e.depthWrite = !1,
        e
    }
    getImageElementMaterial(e, t, s, i) {
        return e ? t ? s ? (this.defaultScreenSpaceImageMask9SlicedMaterial || (this.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial(),
        this.defaultScreenSpaceImageMask9SlicedMaterial.name = "defaultScreenSpaceImageMask9SlicedMaterial",
        this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = xt,
        this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = !1,
        this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1,
        this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = !1,
        this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = !1,
        this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = !1,
        this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = !1,
        this.defaultScreenSpaceImageMask9SlicedMaterial.update(),
        this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial)),
        this.defaultScreenSpaceImageMask9SlicedMaterial) : i ? (this.defaultScreenSpaceImageMask9TiledMaterial || (this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone(),
        this.defaultScreenSpaceImageMask9TiledMaterial.name = "defaultScreenSpaceImageMask9TiledMaterial",
        this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = _t,
        this.defaultScreenSpaceImageMask9TiledMaterial.depthTest = !1,
        this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1,
        this.defaultScreenSpaceImageMask9TiledMaterial.redWrite = !1,
        this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = !1,
        this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = !1,
        this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = !1,
        this.defaultScreenSpaceImageMask9TiledMaterial.update(),
        this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial)),
        this.defaultScreenSpaceImageMask9TiledMaterial) : (this.defaultScreenSpaceImageMaskMaterial || (this.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial(),
        this.defaultScreenSpaceImageMaskMaterial.name = "defaultScreenSpaceImageMaskMaterial",
        this.defaultScreenSpaceImageMaskMaterial.depthTest = !1,
        this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1,
        this.defaultScreenSpaceImageMaskMaterial.redWrite = !1,
        this.defaultScreenSpaceImageMaskMaterial.greenWrite = !1,
        this.defaultScreenSpaceImageMaskMaterial.blueWrite = !1,
        this.defaultScreenSpaceImageMaskMaterial.alphaWrite = !1,
        this.defaultScreenSpaceImageMaskMaterial.update(),
        this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial)),
        this.defaultScreenSpaceImageMaskMaterial) : s ? (this.defaultScreenSpaceImage9SlicedMaterial || (this.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial(),
        this.defaultScreenSpaceImage9SlicedMaterial.name = "defaultScreenSpaceImage9SlicedMaterial",
        this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = xt,
        this.defaultScreenSpaceImage9SlicedMaterial.depthTest = !1,
        this.defaultScreenSpaceImage9SlicedMaterial.update(),
        this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial)),
        this.defaultScreenSpaceImage9SlicedMaterial) : i ? (this.defaultScreenSpaceImage9TiledMaterial || (this.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial(),
        this.defaultScreenSpaceImage9TiledMaterial.name = "defaultScreenSpaceImage9TiledMaterial",
        this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = _t,
        this.defaultScreenSpaceImage9TiledMaterial.depthTest = !1,
        this.defaultScreenSpaceImage9TiledMaterial.update(),
        this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial)),
        this.defaultScreenSpaceImage9TiledMaterial) : (this.defaultScreenSpaceImageMaterial || (this.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial(),
        this.defaultScreenSpaceImageMaterial.name = "defaultScreenSpaceImageMaterial",
        this.defaultScreenSpaceImageMaterial.depthTest = !1,
        this.defaultScreenSpaceImageMaterial.update(),
        this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial)),
        this.defaultScreenSpaceImageMaterial) : t ? s ? (this.defaultImage9SlicedMaskMaterial || (this.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial(),
        this.defaultImage9SlicedMaskMaterial.name = "defaultImage9SlicedMaskMaterial",
        this.defaultImage9SlicedMaskMaterial.nineSlicedMode = xt,
        this.defaultImage9SlicedMaskMaterial.alphaTest = 1,
        this.defaultImage9SlicedMaskMaterial.redWrite = !1,
        this.defaultImage9SlicedMaskMaterial.greenWrite = !1,
        this.defaultImage9SlicedMaskMaterial.blueWrite = !1,
        this.defaultImage9SlicedMaskMaterial.alphaWrite = !1,
        this.defaultImage9SlicedMaskMaterial.update(),
        this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial)),
        this.defaultImage9SlicedMaskMaterial) : i ? (this.defaultImage9TiledMaskMaterial || (this.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial(),
        this.defaultImage9TiledMaskMaterial.name = "defaultImage9TiledMaskMaterial",
        this.defaultImage9TiledMaskMaterial.nineSlicedMode = _t,
        this.defaultImage9TiledMaskMaterial.alphaTest = 1,
        this.defaultImage9TiledMaskMaterial.redWrite = !1,
        this.defaultImage9TiledMaskMaterial.greenWrite = !1,
        this.defaultImage9TiledMaskMaterial.blueWrite = !1,
        this.defaultImage9TiledMaskMaterial.alphaWrite = !1,
        this.defaultImage9TiledMaskMaterial.update(),
        this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial)),
        this.defaultImage9TiledMaskMaterial) : (this.defaultImageMaskMaterial || (this.defaultImageMaskMaterial = this._createBaseImageMaterial(),
        this.defaultImageMaskMaterial.name = "defaultImageMaskMaterial",
        this.defaultImageMaskMaterial.alphaTest = 1,
        this.defaultImageMaskMaterial.redWrite = !1,
        this.defaultImageMaskMaterial.greenWrite = !1,
        this.defaultImageMaskMaterial.blueWrite = !1,
        this.defaultImageMaskMaterial.alphaWrite = !1,
        this.defaultImageMaskMaterial.update(),
        this.defaultImageMaterials.push(this.defaultImageMaskMaterial)),
        this.defaultImageMaskMaterial) : s ? (this.defaultImage9SlicedMaterial || (this.defaultImage9SlicedMaterial = this._createBaseImageMaterial(),
        this.defaultImage9SlicedMaterial.name = "defaultImage9SlicedMaterial",
        this.defaultImage9SlicedMaterial.nineSlicedMode = xt,
        this.defaultImage9SlicedMaterial.update(),
        this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial)),
        this.defaultImage9SlicedMaterial) : i ? (this.defaultImage9TiledMaterial || (this.defaultImage9TiledMaterial = this._createBaseImageMaterial(),
        this.defaultImage9TiledMaterial.name = "defaultImage9TiledMaterial",
        this.defaultImage9TiledMaterial.nineSlicedMode = _t,
        this.defaultImage9TiledMaterial.update(),
        this.defaultImageMaterials.push(this.defaultImage9TiledMaterial)),
        this.defaultImage9TiledMaterial) : (this.defaultImageMaterial || (this.defaultImageMaterial = this._createBaseImageMaterial(),
        this.defaultImageMaterial.name = "defaultImageMaterial",
        this.defaultImageMaterial.update(),
        this.defaultImageMaterials.push(this.defaultImageMaterial)),
        this.defaultImageMaterial)
    }
    registerUnicodeConverter(e) {
        this._unicodeConverter = e
    }
    registerRtlReorder(e) {
        this._rtlReorder = e
    }
    getUnicodeConverter() {
        return this._unicodeConverter
    }
    getRtlReorder() {
        return this._rtlReorder
    }
}
_e._buildAccessors(ts.prototype, Kx);
const Qa = "free"
  , Ja = "limited"
  , eo = "locked"
  , tO = ["angularDampingX", "angularDampingY", "angularDampingZ", "angularEquilibriumX", "angularEquilibriumY", "angularEquilibriumZ", "angularLimitsX", "angularLimitsY", "angularLimitsZ", "angularMotionX", "angularMotionY", "angularMotionZ", "angularSpringX", "angularSpringY", "angularSpringZ", "angularStiffnessX", "angularStiffnessY", "angularStiffnessZ", "breakForce", "enableCollision", "enabled", "entityA", "entityB", "linearDampingX", "linearDampingY", "linearDampingZ", "linearEquilibriumX", "linearEquilibriumY", "linearEquilibriumZ", "linearLimitsX", "linearLimitsY", "linearLimitsZ", "linearMotionX", "linearMotionY", "linearMotionZ", "linearSpringX", "linearSpringY", "linearSpringZ", "linearStiffnessX", "linearStiffnessY", "linearStiffnessZ"];
class fg extends _e {
    constructor(e, t) {
        super(e, t),
        this._constraint = null,
        this._entityA = null,
        this._entityB = null,
        this._breakForce = 34e37,
        this._enableCollision = !0,
        this._linearMotionX = eo,
        this._linearLimitsX = new P(0,0),
        this._linearSpringX = !1,
        this._linearStiffnessX = 0,
        this._linearDampingX = 1,
        this._linearEquilibriumX = 0,
        this._linearMotionY = eo,
        this._linearLimitsY = new P(0,0),
        this._linearSpringY = !1,
        this._linearStiffnessY = 0,
        this._linearDampingY = 1,
        this._linearEquilibriumY = 0,
        this._linearMotionZ = eo,
        this._linearLimitsZ = new P(0,0),
        this._linearSpringZ = !1,
        this._linearStiffnessZ = 0,
        this._linearDampingZ = 1,
        this._linearEquilibriumZ = 0,
        this._angularMotionX = eo,
        this._angularLimitsX = new P(0,0),
        this._angularSpringX = !1,
        this._angularStiffnessX = 0,
        this._angularDampingX = 1,
        this._angularEquilibriumX = 0,
        this._angularMotionY = eo,
        this._angularLimitsY = new P(0,0),
        this._angularSpringY = !1,
        this._angularStiffnessY = 0,
        this._angularDampingY = 1,
        this._angularEquilibriumY = 0,
        this._angularMotionZ = eo,
        this._angularLimitsZ = new P(0,0),
        this._angularSpringZ = !1,
        this._angularEquilibriumZ = 0,
        this._angularDampingZ = 1,
        this._angularStiffnessZ = 0,
        this.on("set_enabled", this._onSetEnabled, this)
    }
    set entityA(e) {
        this._destroyConstraint(),
        this._entityA = e,
        this._createConstraint()
    }
    get entityA() {
        return this._entityA
    }
    set entityB(e) {
        this._destroyConstraint(),
        this._entityB = e,
        this._createConstraint()
    }
    get entityB() {
        return this._entityB
    }
    set breakForce(e) {
        this._constraint && this._breakForce !== e && (this._constraint.setBreakingImpulseThreshold(e),
        this._breakForce = e)
    }
    get breakForce() {
        return this._breakForce
    }
    set enableCollision(e) {
        this._destroyConstraint(),
        this._enableCollision = e,
        this._createConstraint()
    }
    get enableCollision() {
        return this._enableCollision
    }
    set angularLimitsX(e) {
        this._angularLimitsX.equals(e) || (this._angularLimitsX.copy(e),
        this._updateAngularLimits())
    }
    get angularLimitsX() {
        return this._angularLimitsX
    }
    set angularMotionX(e) {
        this._angularMotionX !== e && (this._angularMotionX = e,
        this._updateAngularLimits())
    }
    get angularMotionX() {
        return this._angularMotionX
    }
    set angularLimitsY(e) {
        this._angularLimitsY.equals(e) || (this._angularLimitsY.copy(e),
        this._updateAngularLimits())
    }
    get angularLimitsY() {
        return this._angularLimitsY
    }
    set angularMotionY(e) {
        this._angularMotionY !== e && (this._angularMotionY = e,
        this._updateAngularLimits())
    }
    get angularMotionY() {
        return this._angularMotionY
    }
    set angularLimitsZ(e) {
        this._angularLimitsZ.equals(e) || (this._angularLimitsZ.copy(e),
        this._updateAngularLimits())
    }
    get angularLimitsZ() {
        return this._angularLimitsZ
    }
    set angularMotionZ(e) {
        this._angularMotionZ !== e && (this._angularMotionZ = e,
        this._updateAngularLimits())
    }
    get angularMotionZ() {
        return this._angularMotionZ
    }
    set linearLimitsX(e) {
        this._linearLimitsX.equals(e) || (this._linearLimitsX.copy(e),
        this._updateLinearLimits())
    }
    get linearLimitsX() {
        return this._linearLimitsX
    }
    set linearMotionX(e) {
        this._linearMotionX !== e && (this._linearMotionX = e,
        this._updateLinearLimits())
    }
    get linearMotionX() {
        return this._linearMotionX
    }
    set linearLimitsY(e) {
        this._linearLimitsY.equals(e) || (this._linearLimitsY.copy(e),
        this._updateLinearLimits())
    }
    get linearLimitsY() {
        return this._linearLimitsY
    }
    set linearMotionY(e) {
        this._linearMotionY !== e && (this._linearMotionY = e,
        this._updateLinearLimits())
    }
    get linearMotionY() {
        return this._linearMotionY
    }
    set linearLimitsZ(e) {
        this._linearLimitsZ.equals(e) || (this._linearLimitsZ.copy(e),
        this._updateLinearLimits())
    }
    get linearLimitsZ() {
        return this._linearLimitsZ
    }
    set linearMotionZ(e) {
        this._linearMotionZ !== e && (this._linearMotionZ = e,
        this._updateLinearLimits())
    }
    get linearMotionZ() {
        return this._linearMotionZ
    }
    _convertTransform(e, t) {
        const s = e.getTranslation()
          , i = new ne;
        i.setFromMat4(e);
        const n = new Ammo.btVector3(s.x,s.y,s.z)
          , r = new Ammo.btQuaternion(i.x,i.y,i.z,i.w);
        t.setOrigin(n),
        t.setRotation(r),
        Ammo.destroy(n),
        Ammo.destroy(r)
    }
    _updateAngularLimits() {
        const e = this._constraint;
        if (e) {
            let t, s, i, n, r, o;
            this._angularMotionX === Ja ? (t = this._angularLimitsX.x * W.DEG_TO_RAD,
            n = this._angularLimitsX.y * W.DEG_TO_RAD) : this._angularMotionX === Qa ? (t = 1,
            n = 0) : t = n = 0,
            this._angularMotionY === Ja ? (s = this._angularLimitsY.x * W.DEG_TO_RAD,
            r = this._angularLimitsY.y * W.DEG_TO_RAD) : this._angularMotionY === Qa ? (s = 1,
            r = 0) : s = r = 0,
            this._angularMotionZ === Ja ? (i = this._angularLimitsZ.x * W.DEG_TO_RAD,
            o = this._angularLimitsZ.y * W.DEG_TO_RAD) : this._angularMotionZ === Qa ? (i = 1,
            o = 0) : i = o = 0;
            const l = new Ammo.btVector3(t,s,i);
            e.setAngularLowerLimit(l),
            l.setValue(n, r, o),
            e.setAngularUpperLimit(l),
            Ammo.destroy(l)
        }
    }
    _updateLinearLimits() {
        const e = this._constraint;
        if (e) {
            let t, s, i, n, r, o;
            this._linearMotionX === Ja ? (t = this._linearLimitsX.x,
            n = this._linearLimitsX.y) : this._linearMotionX === Qa ? (t = 1,
            n = 0) : t = n = 0,
            this._linearMotionY === Ja ? (s = this._linearLimitsY.x,
            r = this._linearLimitsY.y) : this._linearMotionY === Qa ? (s = 1,
            r = 0) : s = r = 0,
            this._linearMotionZ === Ja ? (i = this._linearLimitsZ.x,
            o = this._linearLimitsZ.y) : this._linearMotionZ === Qa ? (i = 1,
            o = 0) : i = o = 0;
            const l = new Ammo.btVector3(t,s,i);
            e.setLinearLowerLimit(l),
            l.setValue(n, r, o),
            e.setLinearUpperLimit(l),
            Ammo.destroy(l)
        }
    }
    _createConstraint() {
        if (this._entityA && this._entityA.rigidbody) {
            this._destroyConstraint();
            const e = new ee
              , t = this._entityA.rigidbody.body;
            t.activate();
            const s = this.entity.getWorldTransform()
              , n = this._entityA.getWorldTransform().clone().invert();
            e.mul2(n, s);
            const r = new Ammo.btTransform;
            if (this._convertTransform(e, r),
            this._entityB && this._entityB.rigidbody) {
                const d = this._entityB.rigidbody.body;
                d.activate();
                const u = this._entityB.getWorldTransform().clone().invert();
                e.mul2(u, s);
                const f = new Ammo.btTransform;
                this._convertTransform(e, f),
                this._constraint = new Ammo.btGeneric6DofSpringConstraint(t,d,r,f,!this._enableCollision),
                Ammo.destroy(f)
            } else
                this._constraint = new Ammo.btGeneric6DofSpringConstraint(t,r,!this._enableCollision);
            Ammo.destroy(r);
            const o = ["X", "Y", "Z", "X", "Y", "Z"];
            for (let d = 0; d < 6; d++) {
                const h = d < 3 ? "_linear" : "_angular";
                this._constraint.enableSpring(d, this[h + "Spring" + o[d]]),
                this._constraint.setDamping(d, this[h + "Damping" + o[d]]),
                this._constraint.setEquilibriumPoint(d, this[h + "Equilibrium" + o[d]]),
                this._constraint.setStiffness(d, this[h + "Stiffness" + o[d]])
            }
            this._constraint.setBreakingImpulseThreshold(this._breakForce),
            this._updateLinearLimits(),
            this._updateAngularLimits(),
            this.system.app.systems.rigidbody.dynamicsWorld.addConstraint(this._constraint, !this._enableCollision)
        }
    }
    _destroyConstraint() {
        this._constraint && (this.system.app.systems.rigidbody.dynamicsWorld.removeConstraint(this._constraint),
        Ammo.destroy(this._constraint),
        this._constraint = null)
    }
    initFromData(e) {
        for (const t of tO)
            e.hasOwnProperty(t) && (e[t]instanceof P ? this["_" + t].copy(e[t]) : this["_" + t] = e[t]);
        this._createConstraint()
    }
    onEnable() {
        this._createConstraint()
    }
    onDisable() {
        this._destroyConstraint()
    }
    _onSetEnabled(e, t, s) {}
    _onBeforeRemove() {
        this.fire("remove")
    }
}
const sO = {
    Damping: "setDamping",
    Equilibrium: "setEquilibriumPoint",
    Spring: "enableSpring",
    Stiffness: "setStiffness"
};
["linear", "angular"].forEach(a => {
    ["Damping", "Equilibrium", "Spring", "Stiffness"].forEach(e => {
        ["X", "Y", "Z"].forEach(t => {
            const s = a + e + t
              , i = "_" + s;
            let n = a === "linear" ? 0 : 3;
            t === "Y" && (n += 1),
            t === "Z" && (n += 2),
            Object.defineProperty(fg.prototype, s, {
                get: function() {
                    return this[i]
                },
                set: function(r) {
                    this[i] !== r && (this[i] = r,
                    this._constraint[sO[e]](n, r))
                }
            })
        }
        )
    }
    )
}
);
class iO {
    constructor() {
        this.enabled = !0
    }
}
const Zx = ["enabled"];
class nO extends it {
    constructor(e) {
        super(e),
        this.id = "joint",
        this.app = e,
        this.ComponentType = fg,
        this.DataType = iO,
        this.schema = Zx
    }
    initializeComponentData(e, t, s) {
        e.initFromData(t)
    }
}
_e._buildAccessors(fg.prototype, Zx);
class Qx extends _e {
    constructor(e, t) {
        super(e, t),
        this._minWidth = 0,
        this._minHeight = 0,
        this._maxWidth = null,
        this._maxHeight = null,
        this._fitWidthProportion = 0,
        this._fitHeightProportion = 0,
        this._excludeFromLayout = !1
    }
    set minWidth(e) {
        e !== this._minWidth && (this._minWidth = e,
        this.fire("resize"))
    }
    get minWidth() {
        return this._minWidth
    }
    set minHeight(e) {
        e !== this._minHeight && (this._minHeight = e,
        this.fire("resize"))
    }
    get minHeight() {
        return this._minHeight
    }
    set maxWidth(e) {
        e !== this._maxWidth && (this._maxWidth = e,
        this.fire("resize"))
    }
    get maxWidth() {
        return this._maxWidth
    }
    set maxHeight(e) {
        e !== this._maxHeight && (this._maxHeight = e,
        this.fire("resize"))
    }
    get maxHeight() {
        return this._maxHeight
    }
    set fitWidthProportion(e) {
        e !== this._fitWidthProportion && (this._fitWidthProportion = e,
        this.fire("resize"))
    }
    get fitWidthProportion() {
        return this._fitWidthProportion
    }
    set fitHeightProportion(e) {
        e !== this._fitHeightProportion && (this._fitHeightProportion = e,
        this.fire("resize"))
    }
    get fitHeightProportion() {
        return this._fitHeightProportion
    }
    set excludeFromLayout(e) {
        e !== this._excludeFromLayout && (this._excludeFromLayout = e,
        this.fire("resize"))
    }
    get excludeFromLayout() {
        return this._excludeFromLayout
    }
}
class rO {
    constructor() {
        this.enabled = !0
    }
}
const Jx = ["enabled"];
class aO extends it {
    constructor(e) {
        super(e),
        this.id = "layoutchild",
        this.ComponentType = Qx,
        this.DataType = rO,
        this.schema = Jx
    }
    initializeComponentData(e, t, s) {
        t.enabled !== void 0 && (e.enabled = t.enabled),
        t.minWidth !== void 0 && (e.minWidth = t.minWidth),
        t.minHeight !== void 0 && (e.minHeight = t.minHeight),
        t.maxWidth !== void 0 && (e.maxWidth = t.maxWidth),
        t.maxHeight !== void 0 && (e.maxHeight = t.maxHeight),
        t.fitWidthProportion !== void 0 && (e.fitWidthProportion = t.fitWidthProportion),
        t.fitHeightProportion !== void 0 && (e.fitHeightProportion = t.fitHeightProportion),
        t.excludeFromLayout !== void 0 && (e.excludeFromLayout = t.excludeFromLayout),
        super.initializeComponentData(e, t, s)
    }
    cloneComponent(e, t) {
        const s = e.layoutchild;
        return this.addComponent(t, {
            enabled: s.enabled,
            minWidth: s.minWidth,
            minHeight: s.minHeight,
            maxWidth: s.maxWidth,
            maxHeight: s.maxHeight,
            fitWidthProportion: s.fitWidthProportion,
            fitHeightProportion: s.fitHeightProportion,
            excludeFromLayout: s.excludeFromLayout
        })
    }
}
_e._buildAccessors(Qx.prototype, Jx);
const Fh = 0
  , oO = 1
  , _v = 2
  , lO = 3
  , gu = {};
gu[Se] = {
    axis: "x",
    size: "width",
    calculatedSize: "calculatedWidth",
    minSize: "minWidth",
    maxSize: "maxWidth",
    fitting: "widthFitting",
    fittingProportion: "fitWidthProportion"
};
gu[Re] = {
    axis: "y",
    size: "height",
    calculatedSize: "calculatedHeight",
    minSize: "minHeight",
    maxSize: "maxHeight",
    fitting: "heightFitting",
    fittingProportion: "fitHeightProportion"
};
const pg = {};
pg[Se] = Re;
pg[Re] = Se;
const hO = {
    minWidth: 0,
    minHeight: 0,
    maxWidth: Number.POSITIVE_INFINITY,
    maxHeight: Number.POSITIVE_INFINITY,
    width: null,
    height: null,
    fitWidthProportion: 0,
    fitHeightProportion: 0
}
  , Ss = {
    NONE: "NONE",
    APPLY_STRETCHING: "APPLY_STRETCHING",
    APPLY_SHRINKING: "APPLY_SHRINKING"
}
  , xs = new P;
function ew(a) {
    let e;
    const t = gu[a]
      , s = gu[pg[a]];
    function i(A, k) {
        return -k[t.size] * A.pivot[t.axis]
    }
    function n(A, k) {
        return -k[s.size] * A.pivot[s.axis]
    }
    function r(A, k) {
        return k[t.size] * (1 - A.pivot[t.axis])
    }
    function o(A, k) {
        A = A.filter(l),
        e = k,
        xs.x = e.containerSize.x - e.padding.x - e.padding.z,
        xs.y = e.containerSize.y - e.padding.y - e.padding.w,
        c(A);
        const N = h(d(A))
          , H = f(N, u(N))
          , K = x(N, H);
        return S(N, H, K),
        w(N, H, K),
        T(N)
    }
    function l(A) {
        const k = A.entity.layoutchild;
        return !k || !k.enabled || !k.excludeFromLayout
    }
    function c(A) {
        for (let k = 0; k < A.length; ++k) {
            const N = A[k]
              , H = N.anchor;
            (H.x !== 0 || H.y !== 0 || H.z !== 0 || H.w !== 0) && (N.anchor = M.ZERO)
        }
    }
    function d(A) {
        if (!e.wrap)
            return [A];
        const k = [[]]
          , N = b(A);
        let H = 0;
        const K = e[t.fitting] === _v;
        for (let q = 0; q < A.length; ++q) {
            k[k.length - 1].length > 0 && (H += e.spacing[t.axis]);
            const se = N[q][t.size];
            H += se,
            !K && H > xs[t.axis] && k[k.length - 1].length !== 0 && (H = se,
            k.push([])),
            k[k.length - 1].push(A[q]),
            K && H > xs[t.axis] && q !== A.length - 1 && (H = 0,
            k.push([]))
        }
        return k
    }
    function h(A) {
        const k = e.orientation === Se && e.reverseX || e.orientation === Re && e.reverseY
          , N = e.orientation === Se && e.reverseY || e.orientation === Re && e.reverseX;
        if (k)
            for (let H = 0; H < A.length; ++H)
                k && A[H].reverse();
        return N && A.reverse(),
        A
    }
    function u(A) {
        const k = [];
        for (let N = 0; N < A.length; ++N) {
            const H = A[N]
              , K = b(H)
              , q = _(K, t)
              , se = p(e[t.fitting], q, xs[t.axis]);
            se === Ss.APPLY_STRETCHING ? m(K, q, t) : se === Ss.APPLY_SHRINKING && g(K, q, t),
            k.push(K)
        }
        return k
    }
    function f(A, k) {
        const N = []
          , H = [];
        for (let se = 0; se < A.length; ++se) {
            const ie = A[se];
            ie.largestElement = null,
            ie.largestSize = {
                width: Number.NEGATIVE_INFINITY,
                height: Number.NEGATIVE_INFINITY
            };
            for (let ae = 0; ae < ie.length; ++ae) {
                const he = k[se][ae];
                he[s.size] > ie.largestSize[s.size] && (ie.largestElement = ie[ae],
                ie.largestSize = he)
            }
            N.push(ie.largestElement),
            H.push(ie.largestSize)
        }
        const K = _(H, s)
          , q = p(e[s.fitting], K, xs[s.axis]);
        q === Ss.APPLY_STRETCHING ? m(H, K, s) : q === Ss.APPLY_SHRINKING && g(H, K, s);
        for (let se = 0; se < A.length; ++se) {
            const ie = A[se];
            for (let ae = 0; ae < ie.length; ++ae) {
                const he = k[se][ae]
                  , ue = he[s.size]
                  , nt = A.length === 1 ? xs[s.axis] : ie.largestSize[s.size]
                  , Vt = p(e[s.fitting], ue, nt);
                Vt === Ss.APPLY_STRETCHING ? he[s.size] = Math.min(nt, he[s.maxSize]) : Vt === Ss.APPLY_SHRINKING && (he[s.size] = Math.max(nt, he[s.minSize]))
            }
        }
        return k
    }
    function p(A, k, N) {
        switch (A) {
        case Fh:
            return Ss.NONE;
        case oO:
            return k < N ? Ss.APPLY_STRETCHING : Ss.NONE;
        case _v:
            return k >= N ? Ss.APPLY_SHRINKING : Ss.NONE;
        case lO:
            return k < N ? Ss.APPLY_STRETCHING : Ss.APPLY_SHRINKING;
        default:
            throw new Error(`Unrecognized fitting mode: ${A}`)
        }
    }
    function _(A, k) {
        const N = R(A, k.size)
          , H = (A.length - 1) * e.spacing[k.axis];
        return N + H
    }
    function m(A, k, N) {
        const H = U(A, N.maxSize)
          , K = F(A, N.fittingProportion)
          , q = D(K, H);
        let se = xs[N.axis] - k;
        for (let ie = 0; ie < A.length; ++ie) {
            const ae = H[ie]
              , he = v(ae, se, K, q)
              , ue = A[ae][N.size] + he
              , nt = A[ae][N.maxSize]
              , Vt = Math.min(ue, nt);
            A[ae][N.size] = Vt;
            const qt = Math.max(ue - Vt, 0)
              , Yt = he - qt;
            se -= Yt
        }
    }
    function g(A, k, N) {
        const H = U(A, N.minSize, !0)
          , K = F(A, N.fittingProportion)
          , q = L(K)
          , se = D(q, H);
        let ie = k - xs[N.axis];
        for (let ae = 0; ae < A.length; ++ae) {
            const he = H[ae]
              , ue = v(he, ie, q, se)
              , nt = A[he][N.size] - ue
              , Vt = A[he][N.minSize]
              , qt = Math.max(nt, Vt);
            A[he][N.size] = qt;
            const Yt = Math.max(qt - nt, 0)
              , Da = ue - Yt;
            ie -= Da
        }
    }
    function v(A, k, N, H) {
        const K = N[A]
          , q = H[A];
        return Math.abs(K) < 1e-5 && Math.abs(q) < 1e-5 ? k : k * K / q
    }
    function x(A, k) {
        const N = {};
        N[t.axis] = 0,
        N[s.axis] = 0,
        A[t.size] = Number.NEGATIVE_INFINITY;
        const H = [];
        for (let K = 0; K < A.length; ++K) {
            const q = A[K];
            if (q.length === 0) {
                H.push([]);
                continue
            }
            const se = []
              , ie = k[K];
            for (let ae = 0; ae < q.length; ++ae) {
                const he = q[ae]
                  , ue = ie[ae];
                N[s.axis] -= n(he, ue),
                N[t.axis] -= i(he, ue),
                se[ae] = {},
                se[ae][t.axis] = N[t.axis],
                se[ae][s.axis] = N[s.axis],
                N[s.axis] += n(he, ue),
                N[t.axis] += r(he, ue) + e.spacing[t.axis]
            }
            q[t.size] = N[t.axis] - e.spacing[t.axis],
            q[s.size] = q.largestSize[s.size],
            A[t.size] = Math.max(A[t.size], q[t.size]),
            N[t.axis] = 0,
            N[s.axis] += q[s.size] + e.spacing[s.axis],
            H.push(se)
        }
        return A[s.size] = N[s.axis] - e.spacing[s.axis],
        H
    }
    function S(A, k, N) {
        const H = e.alignment[t.axis]
          , K = e.alignment[s.axis]
          , q = e.padding[t.axis]
          , se = e.padding[s.axis];
        for (let ie = 0; ie < A.length; ++ie) {
            const ae = A[ie]
              , he = k[ie]
              , ue = N[ie]
              , nt = (xs[t.axis] - ae[t.size]) * H + q
              , Vt = (xs[s.axis] - A[s.size]) * K + se;
            for (let qt = 0; qt < ae.length; ++qt) {
                const Yt = (ae[s.size] - he[qt][s.size]) * e.alignment[s.axis];
                ue[qt][t.axis] += nt,
                ue[qt][s.axis] += Vt + Yt
            }
        }
    }
    function w(A, k, N) {
        for (let H = 0; H < A.length; ++H) {
            const K = A[H]
              , q = k[H]
              , se = N[H];
            for (let ie = 0; ie < K.length; ++ie) {
                const ae = K[ie];
                ae[t.calculatedSize] = q[ie][t.size],
                ae[s.calculatedSize] = q[ie][s.size],
                e.orientation === Se ? ae.entity.setLocalPosition(se[ie][t.axis], se[ie][s.axis], ae.entity.getLocalPosition().z) : ae.entity.setLocalPosition(se[ie][s.axis], se[ie][t.axis], ae.entity.getLocalPosition().z)
            }
        }
    }
    function T(A) {
        const k = A.width
          , N = A.height
          , H = (xs.x - k) * e.alignment.x + e.padding.x
          , K = (xs.y - N) * e.alignment.y + e.padding.y;
        return {
            bounds: new M(H,K,k,N)
        }
    }
    function b(A) {
        const k = [];
        for (let N = 0; N < A.length; ++N) {
            const H = A[N]
              , K = Math.max(E(H, "minWidth"), 0)
              , q = Math.max(E(H, "minHeight"), 0)
              , se = Math.max(E(H, "maxWidth"), K)
              , ie = Math.max(E(H, "maxHeight"), q)
              , ae = C(E(H, "width"), K, se)
              , he = C(E(H, "height"), q, ie)
              , ue = E(H, "fitWidthProportion")
              , nt = E(H, "fitHeightProportion");
            k.push({
                minWidth: K,
                minHeight: q,
                maxWidth: se,
                maxHeight: ie,
                width: ae,
                height: he,
                fitWidthProportion: ue,
                fitHeightProportion: nt
            })
        }
        return k
    }
    function E(A, k) {
        const N = A.entity.layoutchild;
        return N && N.enabled && N[k] !== void 0 && N[k] !== null ? N[k] : A[k] !== void 0 ? A[k] : hO[k]
    }
    function C(A, k, N) {
        return Math.min(Math.max(A, k), N)
    }
    function R(A, k) {
        return A.reduce(function(N, H) {
            return N + H[k]
        }, 0)
    }
    function F(A, k) {
        const N = R(A, k)
          , H = []
          , K = A.length;
        if (N === 0)
            for (let q = 0; q < K; ++q)
                H.push(1 / K);
        else
            for (let q = 0; q < K; ++q)
                H.push(A[q][k] / N);
        return H
    }
    function L(A) {
        if (A.length === 1)
            return [1];
        const k = []
          , N = A.length;
        for (let H = 0; H < N; ++H)
            k.push((1 - A[H]) / (N - 1));
        return k
    }
    function U(A, k, N) {
        return A.forEach(I),
        A.slice().sort(function(H, K) {
            return N ? K[k] - H[k] : H[k] - K[k]
        }).map(O)
    }
    function I(A, k) {
        A.index = k
    }
    function O(A) {
        return A.index
    }
    function D(A, k) {
        const N = [];
        N[k[A.length - 1]] = A[k[A.length - 1]];
        for (let H = A.length - 2; H >= 0; --H)
            N[k[H]] = N[k[H + 1]] + A[k[H]];
        return N
    }
    return o
}
const mg = {};
mg[Se] = ew(Se);
mg[Re] = ew(Re);
class cO {
    calculateLayout(e, t) {
        const s = mg[t.orientation];
        if (s)
            return s(e, t);
        throw new Error("Unrecognized orientation value: " + t.orientation)
    }
}
function gv(a) {
    return a.element
}
function dO(a) {
    return a.enabled && a.element && a.element.enabled
}
class tw extends _e {
    constructor(e, t) {
        super(e, t),
        this._orientation = Se,
        this._reverseX = !1,
        this._reverseY = !0,
        this._alignment = new P(0,1),
        this._padding = new M,
        this._spacing = new P,
        this._widthFitting = Fh,
        this._heightFitting = Fh,
        this._wrap = !1,
        this._layoutCalculator = new cO,
        this._listenForReflowEvents(this.entity, "on"),
        this.entity.children.forEach(s => {
            this._listenForReflowEvents(s, "on")
        }
        ),
        this.entity.on("childinsert", this._onChildInsert, this),
        this.entity.on("childremove", this._onChildRemove, this),
        e.app.systems.element.on("add", this._onElementOrLayoutComponentAdd, this),
        e.app.systems.element.on("beforeremove", this._onElementOrLayoutComponentRemove, this),
        e.app.systems.layoutchild.on("add", this._onElementOrLayoutComponentAdd, this),
        e.app.systems.layoutchild.on("beforeremove", this._onElementOrLayoutComponentRemove, this)
    }
    set orientation(e) {
        e !== this._orientation && (this._orientation = e,
        this._scheduleReflow())
    }
    get orientation() {
        return this._orientation
    }
    set reverseX(e) {
        e !== this._reverseX && (this._reverseX = e,
        this._scheduleReflow())
    }
    get reverseX() {
        return this._reverseX
    }
    set reverseY(e) {
        e !== this._reverseY && (this._reverseY = e,
        this._scheduleReflow())
    }
    get reverseY() {
        return this._reverseY
    }
    set alignment(e) {
        e.equals(this._alignment) || (this._alignment.copy(e),
        this._scheduleReflow())
    }
    get alignment() {
        return this._alignment
    }
    set padding(e) {
        e.equals(this._padding) || (this._padding.copy(e),
        this._scheduleReflow())
    }
    get padding() {
        return this._padding
    }
    set spacing(e) {
        e.equals(this._spacing) || (this._spacing.copy(e),
        this._scheduleReflow())
    }
    get spacing() {
        return this._spacing
    }
    set widthFitting(e) {
        e !== this._widthFitting && (this._widthFitting = e,
        this._scheduleReflow())
    }
    get widthFitting() {
        return this._widthFitting
    }
    set heightFitting(e) {
        e !== this._heightFitting && (this._heightFitting = e,
        this._scheduleReflow())
    }
    get heightFitting() {
        return this._heightFitting
    }
    set wrap(e) {
        e !== this._wrap && (this._wrap = e,
        this._scheduleReflow())
    }
    get wrap() {
        return this._wrap
    }
    _isSelfOrChild(e) {
        return e === this.entity || this.entity.children.indexOf(e) !== -1
    }
    _listenForReflowEvents(e, t) {
        e.element && (e.element[t]("enableelement", this._scheduleReflow, this),
        e.element[t]("disableelement", this._scheduleReflow, this),
        e.element[t]("resize", this._scheduleReflow, this),
        e.element[t]("set:pivot", this._scheduleReflow, this)),
        e.layoutchild && (e.layoutchild[t]("set_enabled", this._scheduleReflow, this),
        e.layoutchild[t]("resize", this._scheduleReflow, this))
    }
    _onElementOrLayoutComponentAdd(e) {
        this._isSelfOrChild(e) && (this._listenForReflowEvents(e, "on"),
        this._scheduleReflow())
    }
    _onElementOrLayoutComponentRemove(e) {
        this._isSelfOrChild(e) && (this._listenForReflowEvents(e, "off"),
        this._scheduleReflow())
    }
    _onChildInsert(e) {
        this._listenForReflowEvents(e, "on"),
        this._scheduleReflow()
    }
    _onChildRemove(e) {
        this._listenForReflowEvents(e, "off"),
        this._scheduleReflow()
    }
    _scheduleReflow() {
        this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow && this.system.scheduleReflow(this)
    }
    reflow() {
        const e = gv(this.entity)
          , t = this.entity.children.filter(dO).map(gv);
        if (!e || t.length === 0)
            return;
        const s = Math.max(e.calculatedWidth, 0)
          , i = Math.max(e.calculatedHeight, 0)
          , n = {
            orientation: this._orientation,
            reverseX: this._reverseX,
            reverseY: this._reverseY,
            alignment: this._alignment,
            padding: this._padding,
            spacing: this._spacing,
            widthFitting: this._widthFitting,
            heightFitting: this._heightFitting,
            wrap: this._wrap,
            containerSize: new P(s,i)
        };
        this._isPerformingReflow = !0;
        const r = this._layoutCalculator.calculateLayout(t, n);
        this._isPerformingReflow = !1,
        this.fire("reflow", r)
    }
    onEnable() {
        this._scheduleReflow()
    }
    onRemove() {
        this.entity.off("childinsert", this._onChildInsert, this),
        this.entity.off("childremove", this._onChildRemove, this),
        this._listenForReflowEvents(this.entity, "off"),
        this.entity.children.forEach(e => {
            this._listenForReflowEvents(e, "off")
        }
        ),
        this.system.app.systems.element.off("add", this._onElementOrLayoutComponentAdd, this),
        this.system.app.systems.element.off("beforeremove", this._onElementOrLayoutComponentRemove, this),
        this.system.app.systems.layoutchild.off("add", this._onElementOrLayoutComponentAdd, this),
        this.system.app.systems.layoutchild.off("beforeremove", this._onElementOrLayoutComponentRemove, this)
    }
}
class uO {
    constructor() {
        this.enabled = !0
    }
}
const sw = ["enabled"]
  , fO = 100;
class pO extends it {
    constructor(e) {
        super(e),
        this.id = "layoutgroup",
        this.ComponentType = tw,
        this.DataType = uO,
        this.schema = sw,
        this._reflowQueue = [],
        this.on("beforeremove", this._onRemoveComponent, this),
        this.app.systems.on("postUpdate", this._onPostUpdate, this)
    }
    initializeComponentData(e, t, s) {
        t.enabled !== void 0 && (e.enabled = t.enabled),
        t.orientation !== void 0 && (e.orientation = t.orientation),
        t.reverseX !== void 0 && (e.reverseX = t.reverseX),
        t.reverseY !== void 0 && (e.reverseY = t.reverseY),
        t.alignment !== void 0 && (e.alignment = Array.isArray(t.alignment) ? new P(t.alignment) : t.alignment),
        t.padding !== void 0 && (e.padding = Array.isArray(t.padding) ? new M(t.padding) : t.padding),
        t.spacing !== void 0 && (e.spacing = Array.isArray(t.spacing) ? new P(t.spacing) : t.spacing),
        t.widthFitting !== void 0 && (e.widthFitting = t.widthFitting),
        t.heightFitting !== void 0 && (e.heightFitting = t.heightFitting),
        t.wrap !== void 0 && (e.wrap = t.wrap),
        super.initializeComponentData(e, t, s)
    }
    cloneComponent(e, t) {
        const s = e.layoutgroup;
        return this.addComponent(t, {
            enabled: s.enabled,
            orientation: s.orientation,
            reverseX: s.reverseX,
            reverseY: s.reverseY,
            alignment: s.alignment,
            padding: s.padding,
            spacing: s.spacing,
            widthFitting: s.widthFitting,
            heightFitting: s.heightFitting,
            wrap: s.wrap
        })
    }
    scheduleReflow(e) {
        this._reflowQueue.indexOf(e) === -1 && this._reflowQueue.push(e)
    }
    _onPostUpdate() {
        this._processReflowQueue()
    }
    _processReflowQueue() {
        if (this._reflowQueue.length === 0)
            return;
        let e = 0;
        for (; this._reflowQueue.length > 0; ) {
            const t = this._reflowQueue.slice();
            this._reflowQueue.length = 0,
            t.sort(function(s, i) {
                return s.entity.graphDepth - i.entity.graphDepth
            });
            for (let s = 0; s < t.length; ++s)
                t[s].reflow();
            if (++e >= fO) {
                console.warn("Max reflow iterations limit reached, bailing.");
                break
            }
        }
    }
    _onRemoveComponent(e, t) {
        t.onRemove()
    }
    destroy() {
        super.destroy(),
        this.app.systems.off("postUpdate", this._onPostUpdate, this)
    }
}
_e._buildAccessors(tw.prototype, sw);
class iw extends _e {
    constructor(e, t) {
        super(e, t),
        this._type = "asset",
        this._asset = null,
        this._model = null,
        this._mapping = {},
        this._castShadows = !0,
        this._receiveShadows = !0,
        this._materialAsset = null,
        this._material = void 0,
        this._castShadowsLightmap = !0,
        this._lightmapped = !1,
        this._lightmapSizeMultiplier = 1,
        this.isStatic = !1,
        this._layers = [Bn],
        this._batchGroupId = -1,
        this._customAabb = null,
        this._area = null,
        this._materialEvents = null,
        this._clonedModel = !1,
        this._material = e.defaultMaterial,
        t.on("remove", this.onRemoveChild, this),
        t.on("removehierarchy", this.onRemoveChild, this),
        t.on("insert", this.onInsertChild, this),
        t.on("inserthierarchy", this.onInsertChild, this)
    }
    set meshInstances(e) {
        this._model && (this._model.meshInstances = e)
    }
    get meshInstances() {
        return this._model ? this._model.meshInstances : null
    }
    set customAabb(e) {
        if (this._customAabb = e,
        this._model) {
            const t = this._model.meshInstances;
            if (t)
                for (let s = 0; s < t.length; s++)
                    t[s].setCustomAabb(this._customAabb)
        }
    }
    get customAabb() {
        return this._customAabb
    }
    set type(e) {
        if (this._type !== e)
            if (this._area = null,
            this._type = e,
            e === "asset")
                this._asset !== null ? this._bindModelAsset(this._asset) : this.model = null;
            else {
                const t = ox(this.system.app.graphicsDevice, e);
                this._area = t.area;
                const s = t.mesh
                  , i = new yt
                  , n = new kn;
                n.graph = i,
                n.meshInstances = [new Fe(s,this._material,i)],
                this.model = n,
                this._asset = null
            }
    }
    get type() {
        return this._type
    }
    set asset(e) {
        const t = this.system.app.assets;
        let s = e;
        if (e instanceof le && (s = e.id),
        this._asset !== s) {
            if (this._asset) {
                t.off("add:" + this._asset, this._onModelAssetAdded, this);
                const i = t.get(this._asset);
                i && this._unbindModelAsset(i)
            }
            if (this._asset = s,
            this._asset) {
                const i = t.get(this._asset);
                i ? this._bindModelAsset(i) : (this.model = null,
                t.on("add:" + this._asset, this._onModelAssetAdded, this))
            } else
                this.model = null
        }
    }
    get asset() {
        return this._asset
    }
    set model(e) {
        if (this._model !== e && !(e && e._immutable) && (this._model && (this._model._immutable = !1,
        this.removeModelFromLayers(),
        this._model.getGraph().destroy(),
        delete this._model._entity,
        this._clonedModel && (this._model.destroy(),
        this._clonedModel = !1)),
        this._model = e,
        this._model)) {
            this._model._immutable = !0;
            const t = this._model.meshInstances;
            for (let s = 0; s < t.length; s++)
                t[s].castShadow = this._castShadows,
                t[s].receiveShadow = this._receiveShadows,
                t[s].setCustomAabb(this._customAabb);
            this.lightmapped = this._lightmapped,
            this.entity.addChild(this._model.graph),
            this.enabled && this.entity.enabled && this.addModelToLayers(),
            this._model._entity = this.entity,
            this.entity.animation && this.entity.animation.setModel(this._model),
            this.entity.anim && this.entity.anim.rebind(),
            this.type === "asset" ? this.mapping = this._mapping : this._unsetMaterialEvents()
        }
    }
    get model() {
        return this._model
    }
    set lightmapped(e) {
        if (e !== this._lightmapped && (this._lightmapped = e,
        this._model)) {
            const t = this._model.meshInstances;
            for (let s = 0; s < t.length; s++)
                t[s].setLightmapped(e)
        }
    }
    get lightmapped() {
        return this._lightmapped
    }
    set castShadows(e) {
        if (this._castShadows === e)
            return;
        const t = this._model;
        if (t) {
            const s = this.layers
              , i = this.system.app.scene;
            if (this._castShadows && !e)
                for (let r = 0; r < s.length; r++) {
                    const o = this.system.app.scene.layers.getLayerById(this.layers[r]);
                    o && o.removeShadowCasters(t.meshInstances)
                }
            const n = t.meshInstances;
            for (let r = 0; r < n.length; r++)
                n[r].castShadow = e;
            if (!this._castShadows && e)
                for (let r = 0; r < s.length; r++) {
                    const o = i.layers.getLayerById(s[r]);
                    o && o.addShadowCasters(t.meshInstances)
                }
        }
        this._castShadows = e
    }
    get castShadows() {
        return this._castShadows
    }
    set receiveShadows(e) {
        if (this._receiveShadows !== e && (this._receiveShadows = e,
        this._model)) {
            const t = this._model.meshInstances;
            for (let s = 0, i = t.length; s < i; s++)
                t[s].receiveShadow = e
        }
    }
    get receiveShadows() {
        return this._receiveShadows
    }
    set castShadowsLightmap(e) {
        this._castShadowsLightmap = e
    }
    get castShadowsLightmap() {
        return this._castShadowsLightmap
    }
    set lightmapSizeMultiplier(e) {
        this._lightmapSizeMultiplier = e
    }
    get lightmapSizeMultiplier() {
        return this._lightmapSizeMultiplier
    }
    set layers(e) {
        const t = this.system.app.scene.layers;
        if (this.meshInstances)
            for (let s = 0; s < this._layers.length; s++) {
                const i = t.getLayerById(this._layers[s]);
                i && i.removeMeshInstances(this.meshInstances)
            }
        this._layers.length = 0;
        for (let s = 0; s < e.length; s++)
            this._layers[s] = e[s];
        if (!(!this.enabled || !this.entity.enabled || !this.meshInstances))
            for (let s = 0; s < this._layers.length; s++) {
                const i = t.getLayerById(this._layers[s]);
                i && i.addMeshInstances(this.meshInstances)
            }
    }
    get layers() {
        return this._layers
    }
    set batchGroupId(e) {
        if (this._batchGroupId !== e) {
            if (this.entity.enabled && this._batchGroupId >= 0) {
                var t;
                (t = this.system.app.batcher) == null || t.remove(gt.MODEL, this.batchGroupId, this.entity)
            }
            if (this.entity.enabled && e >= 0) {
                var s;
                (s = this.system.app.batcher) == null || s.insert(gt.MODEL, e, this.entity)
            }
            e < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled && this.addModelToLayers(),
            this._batchGroupId = e
        }
    }
    get batchGroupId() {
        return this._batchGroupId
    }
    set materialAsset(e) {
        let t = e;
        e instanceof le && (t = e.id);
        const s = this.system.app.assets;
        if (t !== this._materialAsset) {
            if (this._materialAsset) {
                s.off("add:" + this._materialAsset, this._onMaterialAssetAdd, this);
                const i = s.get(this._materialAsset);
                i && this._unbindMaterialAsset(i)
            }
            if (this._materialAsset = t,
            this._materialAsset) {
                const i = s.get(this._materialAsset);
                i ? this._bindMaterialAsset(i) : (this._setMaterial(this.system.defaultMaterial),
                s.on("add:" + this._materialAsset, this._onMaterialAssetAdd, this))
            } else
                this._setMaterial(this.system.defaultMaterial)
        }
    }
    get materialAsset() {
        return this._materialAsset
    }
    set material(e) {
        this._material !== e && (this.materialAsset = null,
        this._setMaterial(e))
    }
    get material() {
        return this._material
    }
    set mapping(e) {
        if (this._type !== "asset" || (this._unsetMaterialEvents(),
        e || (e = {}),
        this._mapping = e,
        !this._model))
            return;
        const t = this._model.meshInstances
          , s = this.asset ? this.system.app.assets.get(this.asset) : null
          , i = s ? s.data.mapping : null;
        let n = null;
        for (let r = 0, o = t.length; r < o; r++)
            if (e[r] !== void 0)
                e[r] ? (n = this.system.app.assets.get(e[r]),
                this._loadAndSetMeshInstanceMaterial(n, t[r], r)) : t[r].material = this.system.defaultMaterial;
            else if (i)
                if (i[r] && (i[r].material || i[r].path)) {
                    if (i[r].material !== void 0)
                        n = this.system.app.assets.get(i[r].material);
                    else if (i[r].path !== void 0) {
                        const l = this._getMaterialAssetUrl(i[r].path);
                        l && (n = this.system.app.assets.getByUrl(l))
                    }
                    this._loadAndSetMeshInstanceMaterial(n, t[r], r)
                } else
                    t[r].material = this.system.defaultMaterial
    }
    get mapping() {
        return this._mapping
    }
    addModelToLayers() {
        const e = this.system.app.scene.layers;
        for (let t = 0; t < this._layers.length; t++) {
            const s = e.getLayerById(this._layers[t]);
            s && s.addMeshInstances(this.meshInstances)
        }
    }
    removeModelFromLayers() {
        const e = this.system.app.scene.layers;
        for (let t = 0; t < this._layers.length; t++) {
            const s = e.getLayerById(this._layers[t]);
            s && s.removeMeshInstances(this.meshInstances)
        }
    }
    onRemoveChild() {
        this._model && this.removeModelFromLayers()
    }
    onInsertChild() {
        this._model && this.enabled && this.entity.enabled && this.addModelToLayers()
    }
    onRemove() {
        this.asset = null,
        this.model = null,
        this.materialAsset = null,
        this._unsetMaterialEvents(),
        this.entity.off("remove", this.onRemoveChild, this),
        this.entity.off("insert", this.onInsertChild, this)
    }
    onLayersChanged(e, t) {
        this.addModelToLayers(),
        e.off("add", this.onLayerAdded, this),
        e.off("remove", this.onLayerRemoved, this),
        t.on("add", this.onLayerAdded, this),
        t.on("remove", this.onLayerRemoved, this)
    }
    onLayerAdded(e) {
        this.layers.indexOf(e.id) < 0 || e.addMeshInstances(this.meshInstances)
    }
    onLayerRemoved(e) {
        this.layers.indexOf(e.id) < 0 || e.removeMeshInstances(this.meshInstances)
    }
    _setMaterialEvent(e, t, s, i) {
        const n = t + ":" + s;
        this.system.app.assets.on(n, i, this),
        this._materialEvents || (this._materialEvents = []),
        this._materialEvents[e] || (this._materialEvents[e] = {}),
        this._materialEvents[e][n] = {
            id: s,
            handler: i
        }
    }
    _unsetMaterialEvents() {
        const e = this.system.app.assets
          , t = this._materialEvents;
        if (t) {
            for (let s = 0, i = t.length; s < i; s++) {
                if (!t[s])
                    continue;
                const n = t[s];
                for (const r in n)
                    e.off(r, n[r].handler, this)
            }
            this._materialEvents = null
        }
    }
    _getAssetByIdOrPath(e) {
        let t = null;
        if (!isNaN(parseInt(e, 10)))
            t = this.system.app.assets.get(e);
        else if (this.asset) {
            const i = this._getMaterialAssetUrl(e);
            i && (t = this.system.app.assets.getByUrl(i))
        }
        return t
    }
    _getMaterialAssetUrl(e) {
        if (!this.asset)
            return null;
        const t = this.system.app.assets.get(this.asset);
        return t ? t.getAbsoluteUrl(e) : null
    }
    _loadAndSetMeshInstanceMaterial(e, t, s) {
        const i = this.system.app.assets;
        e && (e.resource ? (t.material = e.resource,
        this._setMaterialEvent(s, "remove", e.id, function() {
            t.material = this.system.defaultMaterial
        })) : (this._setMaterialEvent(s, "load", e.id, function(n) {
            t.material = n.resource,
            this._setMaterialEvent(s, "remove", e.id, function() {
                t.material = this.system.defaultMaterial
            })
        }),
        this.enabled && this.entity.enabled && i.load(e)))
    }
    onEnable() {
        const e = this.system.app
          , t = e.scene;
        t.on("set:layers", this.onLayersChanged, this),
        t.layers && (t.layers.on("add", this.onLayerAdded, this),
        t.layers.on("remove", this.onLayerRemoved, this));
        const s = this._type === "asset";
        let i;
        if (this._model ? this.addModelToLayers() : s && this._asset && (i = e.assets.get(this._asset),
        i && i.resource !== this._model && this._bindModelAsset(i)),
        this._materialAsset && (i = e.assets.get(this._materialAsset),
        i && i.resource !== this._material && this._bindMaterialAsset(i)),
        s && this._mapping)
            for (const r in this._mapping)
                this._mapping[r] && (i = this._getAssetByIdOrPath(this._mapping[r]),
                i && !i.resource && e.assets.load(i));
        if (this._batchGroupId >= 0) {
            var n;
            (n = e.batcher) == null || n.insert(gt.MODEL, this.batchGroupId, this.entity)
        }
    }
    onDisable() {
        const e = this.system.app
          , t = e.scene;
        if (t.off("set:layers", this.onLayersChanged, this),
        t.layers && (t.layers.off("add", this.onLayerAdded, this),
        t.layers.off("remove", this.onLayerRemoved, this)),
        this._batchGroupId >= 0) {
            var s;
            (s = e.batcher) == null || s.remove(gt.MODEL, this.batchGroupId, this.entity)
        }
        this._model && this.removeModelFromLayers()
    }
    hide() {
        if (this._model) {
            const e = this._model.meshInstances;
            for (let t = 0, s = e.length; t < s; t++)
                e[t].visible = !1
        }
    }
    show() {
        if (this._model) {
            const e = this._model.meshInstances;
            for (let t = 0, s = e.length; t < s; t++)
                e[t].visible = !0
        }
    }
    _bindMaterialAsset(e) {
        if (e.on("load", this._onMaterialAssetLoad, this),
        e.on("unload", this._onMaterialAssetUnload, this),
        e.on("remove", this._onMaterialAssetRemove, this),
        e.on("change", this._onMaterialAssetChange, this),
        e.resource)
            this._onMaterialAssetLoad(e);
        else {
            if (!this.enabled || !this.entity.enabled)
                return;
            this.system.app.assets.load(e)
        }
    }
    _unbindMaterialAsset(e) {
        e.off("load", this._onMaterialAssetLoad, this),
        e.off("unload", this._onMaterialAssetUnload, this),
        e.off("remove", this._onMaterialAssetRemove, this),
        e.off("change", this._onMaterialAssetChange, this)
    }
    _onMaterialAssetAdd(e) {
        this.system.app.assets.off("add:" + e.id, this._onMaterialAssetAdd, this),
        this._materialAsset === e.id && this._bindMaterialAsset(e)
    }
    _onMaterialAssetLoad(e) {
        this._setMaterial(e.resource)
    }
    _onMaterialAssetUnload(e) {
        this._setMaterial(this.system.defaultMaterial)
    }
    _onMaterialAssetRemove(e) {
        this._onMaterialAssetUnload(e)
    }
    _onMaterialAssetChange(e) {}
    _bindModelAsset(e) {
        if (this._unbindModelAsset(e),
        e.on("load", this._onModelAssetLoad, this),
        e.on("unload", this._onModelAssetUnload, this),
        e.on("change", this._onModelAssetChange, this),
        e.on("remove", this._onModelAssetRemove, this),
        e.resource)
            this._onModelAssetLoad(e);
        else {
            if (!this.enabled || !this.entity.enabled)
                return;
            this.system.app.assets.load(e)
        }
    }
    _unbindModelAsset(e) {
        e.off("load", this._onModelAssetLoad, this),
        e.off("unload", this._onModelAssetUnload, this),
        e.off("change", this._onModelAssetChange, this),
        e.off("remove", this._onModelAssetRemove, this)
    }
    _onModelAssetAdded(e) {
        this.system.app.assets.off("add:" + e.id, this._onModelAssetAdded, this),
        e.id === this._asset && this._bindModelAsset(e)
    }
    _onModelAssetLoad(e) {
        this.model = e.resource.clone(),
        this._clonedModel = !0
    }
    _onModelAssetUnload(e) {
        this.model = null
    }
    _onModelAssetChange(e, t, s, i) {
        t === "data" && (this.mapping = this._mapping)
    }
    _onModelAssetRemove(e) {
        this.model = null
    }
    _setMaterial(e) {
        if (this._material === e)
            return;
        this._material = e;
        const t = this._model;
        if (t && this._type !== "asset") {
            const s = t.meshInstances;
            for (let i = 0, n = s.length; i < n; i++)
                s[i].material = e
        }
    }
}
class mO {
    constructor() {
        this.enabled = !0
    }
}
const nw = ["enabled"];
class _O extends it {
    constructor(e) {
        super(e),
        this.id = "model",
        this.ComponentType = iw,
        this.DataType = mO,
        this.schema = nw,
        this.defaultMaterial = _c(e.graphicsDevice),
        this.on("beforeremove", this.onRemove, this)
    }
    initializeComponentData(e, t, s) {
        s = ["material", "materialAsset", "asset", "castShadows", "receiveShadows", "castShadowsLightmap", "lightmapped", "lightmapSizeMultiplier", "type", "mapping", "layers", "isStatic", "batchGroupId"],
        (t.batchGroupId === null || t.batchGroupId === void 0) && (t.batchGroupId = -1),
        t.layers && t.layers.length && (t.layers = t.layers.slice(0));
        for (let i = 0; i < s.length; i++)
            t.hasOwnProperty(s[i]) && (e[s[i]] = t[s[i]]);
        t.aabbCenter && t.aabbHalfExtents && (e.customAabb = new Pe(new y(t.aabbCenter),new y(t.aabbHalfExtents))),
        super.initializeComponentData(e, t, ["enabled"])
    }
    cloneComponent(e, t) {
        const s = {
            type: e.model.type,
            asset: e.model.asset,
            castShadows: e.model.castShadows,
            receiveShadows: e.model.receiveShadows,
            castShadowsLightmap: e.model.castShadowsLightmap,
            lightmapped: e.model.lightmapped,
            lightmapSizeMultiplier: e.model.lightmapSizeMultiplier,
            isStatic: e.model.isStatic,
            enabled: e.model.enabled,
            layers: e.model.layers,
            batchGroupId: e.model.batchGroupId,
            mapping: or({}, e.model.mapping)
        };
        let i = e.model.materialAsset;
        !(i instanceof le) && i != null && (i = this.app.assets.get(i));
        const n = e.model.material;
        (!n || n === this.defaultMaterial || !i || n === i.resource) && (s.materialAsset = i);
        const r = this.addComponent(t, s);
        if (e.model.model && e.model.type === "asset" && !e.model.asset && (r.model = e.model.model.clone(),
        r._clonedModel = !0),
        s.materialAsset || (r.material = n),
        e.model.model) {
            const o = e.model.model.meshInstances
              , l = r.model.meshInstances;
            for (let c = 0; c < o.length; c++)
                l[c].mask = o[c].mask,
                l[c].material = o[c].material,
                l[c].layer = o[c].layer,
                l[c].receiveShadow = o[c].receiveShadow
        }
        return e.model.customAabb && (r.customAabb = e.model.customAabb.clone()),
        r
    }
    onRemove(e, t) {
        t.onRemove()
    }
}
_e._buildAccessors(iw.prototype, nw);
const gO = ["emitterExtents", "emitterRadius", "emitterExtentsInner", "emitterRadiusInner", "loop", "initialVelocity", "animSpeed", "normalMap", "particleNormal"]
  , yO = ["numParticles", "lifetime", "rate", "rate2", "startAngle", "startAngle2", "lighting", "halfLambert", "intensity", "wrap", "wrapBounds", "depthWrite", "noFog", "sort", "stretch", "alignToMotion", "preWarm", "emitterShape", "animTilesX", "animTilesY", "animStartFrame", "animNumFrames", "animNumAnimations", "animIndex", "randomizeAnimIndex", "animLoop", "colorMap", "localSpace", "screenSpace", "orientation"]
  , vO = ["scaleGraph", "scaleGraph2", "colorGraph", "colorGraph2", "alphaGraph", "alphaGraph2", "velocityGraph", "velocityGraph2", "localVelocityGraph", "localVelocityGraph2", "rotationSpeedGraph", "rotationSpeedGraph2", "radialSpeedGraph", "radialSpeedGraph2"]
  , ud = ["colorMapAsset", "normalMapAsset", "meshAsset", "renderAsset"];
let to;
class rw extends _e {
    constructor(e, t) {
        super(e, t),
        this._requestedDepth = !1,
        this._drawOrder = 0,
        this.on("set_colorMapAsset", this.onSetColorMapAsset, this),
        this.on("set_normalMapAsset", this.onSetNormalMapAsset, this),
        this.on("set_meshAsset", this.onSetMeshAsset, this),
        this.on("set_mesh", this.onSetMesh, this),
        this.on("set_renderAsset", this.onSetRenderAsset, this),
        this.on("set_loop", this.onSetLoop, this),
        this.on("set_blendType", this.onSetBlendType, this),
        this.on("set_depthSoftening", this.onSetDepthSoftening, this),
        this.on("set_layers", this.onSetLayers, this),
        gO.forEach(s => {
            this.on(`set_${s}`, this.onSetSimpleProperty, this)
        }
        ),
        yO.forEach(s => {
            this.on(`set_${s}`, this.onSetComplexProperty, this)
        }
        ),
        vO.forEach(s => {
            this.on(`set_${s}`, this.onSetGraphProperty, this)
        }
        )
    }
    set drawOrder(e) {
        this._drawOrder = e,
        this.emitter && (this.emitter.drawOrder = e)
    }
    get drawOrder() {
        return this._drawOrder
    }
    addMeshInstanceToLayers() {
        if (this.emitter)
            for (let e = 0; e < this.layers.length; e++) {
                const t = this.system.app.scene.layers.getLayerById(this.layers[e]);
                t && (t.addMeshInstances([this.emitter.meshInstance]),
                this.emitter._layer = t)
            }
    }
    removeMeshInstanceFromLayers() {
        if (this.emitter)
            for (let e = 0; e < this.layers.length; e++) {
                const t = this.system.app.scene.layers.getLayerById(this.layers[e]);
                t && t.removeMeshInstances([this.emitter.meshInstance])
            }
    }
    onSetLayers(e, t, s) {
        if (this.emitter) {
            for (let i = 0; i < t.length; i++) {
                const n = this.system.app.scene.layers.getLayerById(t[i]);
                n && n.removeMeshInstances([this.emitter.meshInstance])
            }
            if (!(!this.enabled || !this.entity.enabled))
                for (let i = 0; i < s.length; i++) {
                    const n = this.system.app.scene.layers.getLayerById(s[i]);
                    n && n.addMeshInstances([this.emitter.meshInstance])
                }
        }
    }
    onLayersChanged(e, t) {
        this.addMeshInstanceToLayers(),
        e.off("add", this.onLayerAdded, this),
        e.off("remove", this.onLayerRemoved, this),
        t.on("add", this.onLayerAdded, this),
        t.on("remove", this.onLayerRemoved, this)
    }
    onLayerAdded(e) {
        !this.emitter || this.layers.indexOf(e.id) < 0 || e.addMeshInstances([this.emitter.meshInstance])
    }
    onLayerRemoved(e) {
        !this.emitter || this.layers.indexOf(e.id) < 0 || e.removeMeshInstances([this.emitter.meshInstance])
    }
    _bindColorMapAsset(e) {
        if (e.on("load", this._onColorMapAssetLoad, this),
        e.on("unload", this._onColorMapAssetUnload, this),
        e.on("remove", this._onColorMapAssetRemove, this),
        e.on("change", this._onColorMapAssetChange, this),
        e.resource)
            this._onColorMapAssetLoad(e);
        else {
            if (!this.enabled || !this.entity.enabled)
                return;
            this.system.app.assets.load(e)
        }
    }
    _unbindColorMapAsset(e) {
        e.off("load", this._onColorMapAssetLoad, this),
        e.off("unload", this._onColorMapAssetUnload, this),
        e.off("remove", this._onColorMapAssetRemove, this),
        e.off("change", this._onColorMapAssetChange, this)
    }
    _onColorMapAssetLoad(e) {
        this.colorMap = e.resource
    }
    _onColorMapAssetUnload(e) {
        this.colorMap = null
    }
    _onColorMapAssetRemove(e) {
        this._onColorMapAssetUnload(e)
    }
    _onColorMapAssetChange(e) {}
    onSetColorMapAsset(e, t, s) {
        const i = this.system.app.assets;
        if (t) {
            const n = i.get(t);
            n && this._unbindColorMapAsset(n)
        }
        if (s) {
            s instanceof le && (this.data.colorMapAsset = s.id,
            s = s.id);
            const n = i.get(s);
            n ? this._bindColorMapAsset(n) : i.once("add:" + s, r => {
                this._bindColorMapAsset(r)
            }
            )
        } else
            this.colorMap = null
    }
    _bindNormalMapAsset(e) {
        if (e.on("load", this._onNormalMapAssetLoad, this),
        e.on("unload", this._onNormalMapAssetUnload, this),
        e.on("remove", this._onNormalMapAssetRemove, this),
        e.on("change", this._onNormalMapAssetChange, this),
        e.resource)
            this._onNormalMapAssetLoad(e);
        else {
            if (!this.enabled || !this.entity.enabled)
                return;
            this.system.app.assets.load(e)
        }
    }
    _unbindNormalMapAsset(e) {
        e.off("load", this._onNormalMapAssetLoad, this),
        e.off("unload", this._onNormalMapAssetUnload, this),
        e.off("remove", this._onNormalMapAssetRemove, this),
        e.off("change", this._onNormalMapAssetChange, this)
    }
    _onNormalMapAssetLoad(e) {
        this.normalMap = e.resource
    }
    _onNormalMapAssetUnload(e) {
        this.normalMap = null
    }
    _onNormalMapAssetRemove(e) {
        this._onNormalMapAssetUnload(e)
    }
    _onNormalMapAssetChange(e) {}
    onSetNormalMapAsset(e, t, s) {
        const i = this.system.app.assets;
        if (t) {
            const n = i.get(t);
            n && this._unbindNormalMapAsset(n)
        }
        if (s) {
            s instanceof le && (this.data.normalMapAsset = s.id,
            s = s.id);
            const n = i.get(s);
            n ? this._bindNormalMapAsset(n) : i.once("add:" + s, r => {
                this._bindNormalMapAsset(r)
            }
            )
        } else
            this.normalMap = null
    }
    _bindMeshAsset(e) {
        if (e.on("load", this._onMeshAssetLoad, this),
        e.on("unload", this._onMeshAssetUnload, this),
        e.on("remove", this._onMeshAssetRemove, this),
        e.on("change", this._onMeshAssetChange, this),
        e.resource)
            this._onMeshAssetLoad(e);
        else {
            if (!this.enabled || !this.entity.enabled)
                return;
            this.system.app.assets.load(e)
        }
    }
    _unbindMeshAsset(e) {
        e.off("load", this._onMeshAssetLoad, this),
        e.off("unload", this._onMeshAssetUnload, this),
        e.off("remove", this._onMeshAssetRemove, this),
        e.off("change", this._onMeshAssetChange, this)
    }
    _onMeshAssetLoad(e) {
        this._onMeshChanged(e.resource)
    }
    _onMeshAssetUnload(e) {
        this.mesh = null
    }
    _onMeshAssetRemove(e) {
        this._onMeshAssetUnload(e)
    }
    _onMeshAssetChange(e) {}
    onSetMeshAsset(e, t, s) {
        const i = this.system.app.assets;
        if (t) {
            const n = i.get(t);
            n && this._unbindMeshAsset(n)
        }
        if (s) {
            s instanceof le && (this.data.meshAsset = s.id,
            s = s.id);
            const n = i.get(s);
            n && this._bindMeshAsset(n)
        } else
            this._onMeshChanged(null)
    }
    onSetMesh(e, t, s) {
        !s || s instanceof le || typeof s == "number" ? this.meshAsset = s : this._onMeshChanged(s)
    }
    _onMeshChanged(e) {
        e && !(e instanceof ms) && (e.meshInstances[0] ? e = e.meshInstances[0].mesh : e = null),
        this.data.mesh = e,
        this.emitter && (this.emitter.mesh = e,
        this.emitter.resetMaterial(),
        this.rebuild())
    }
    onSetRenderAsset(e, t, s) {
        const i = this.system.app.assets;
        if (t) {
            const n = i.get(t);
            n && this._unbindRenderAsset(n)
        }
        if (s) {
            s instanceof le && (this.data.renderAsset = s.id,
            s = s.id);
            const n = i.get(s);
            n && this._bindRenderAsset(n)
        } else
            this._onRenderChanged(null)
    }
    _bindRenderAsset(e) {
        if (e.on("load", this._onRenderAssetLoad, this),
        e.on("unload", this._onRenderAssetUnload, this),
        e.on("remove", this._onRenderAssetRemove, this),
        e.resource)
            this._onRenderAssetLoad(e);
        else {
            if (!this.enabled || !this.entity.enabled)
                return;
            this.system.app.assets.load(e)
        }
    }
    _unbindRenderAsset(e) {
        e.off("load", this._onRenderAssetLoad, this),
        e.off("unload", this._onRenderAssetUnload, this),
        e.off("remove", this._onRenderAssetRemove, this),
        e.resource && e.resource.off("set:meshes", this._onRenderSetMeshes, this)
    }
    _onRenderAssetLoad(e) {
        this._onRenderChanged(e.resource)
    }
    _onRenderAssetUnload(e) {
        this._onRenderChanged(null)
    }
    _onRenderAssetRemove(e) {
        this._onRenderAssetUnload(e)
    }
    _onRenderChanged(e) {
        if (!e) {
            this._onMeshChanged(null);
            return
        }
        e.off("set:meshes", this._onRenderSetMeshes, this),
        e.on("set:meshes", this._onRenderSetMeshes, this),
        e.meshes && this._onRenderSetMeshes(e.meshes)
    }
    _onRenderSetMeshes(e) {
        this._onMeshChanged(e && e[0])
    }
    onSetLoop(e, t, s) {
        this.emitter && (this.emitter[e] = s,
        this.emitter.resetTime())
    }
    onSetBlendType(e, t, s) {
        this.emitter && (this.emitter[e] = s,
        this.emitter.material.blendType = s,
        this.emitter.resetMaterial(),
        this.rebuild())
    }
    _requestDepth() {
        this._requestedDepth || (to || (to = this.system.app.scene.layers.getLayerById(hs)),
        to && (to.incrementCounter(),
        this._requestedDepth = !0))
    }
    _releaseDepth() {
        this._requestedDepth && to && (to.decrementCounter(),
        this._requestedDepth = !1)
    }
    onSetDepthSoftening(e, t, s) {
        t !== s && (s ? (this.enabled && this.entity.enabled && this._requestDepth(),
        this.emitter && (this.emitter[e] = s)) : (this.enabled && this.entity.enabled && this._releaseDepth(),
        this.emitter && (this.emitter[e] = s)),
        this.emitter && (this.reset(),
        this.emitter.resetMaterial(),
        this.rebuild()))
    }
    onSetSimpleProperty(e, t, s) {
        this.emitter && (this.emitter[e] = s,
        this.emitter.resetMaterial())
    }
    onSetComplexProperty(e, t, s) {
        this.emitter && (this.emitter[e] = s,
        this.emitter.resetMaterial(),
        this.rebuild(),
        this.reset())
    }
    onSetGraphProperty(e, t, s) {
        this.emitter && (this.emitter[e] = s,
        this.emitter.rebuildGraphs(),
        this.emitter.resetMaterial())
    }
    onEnable() {
        const e = this.data;
        for (let t = 0, s = ud.length; t < s; t++) {
            let i = e[ud[t]];
            if (i) {
                if (!(i instanceof le))
                    if (parseInt(i, 10) >= 0)
                        i = this.system.app.assets.get(i);
                    else
                        continue;
                i && !i.resource && this.system.app.assets.load(i)
            }
        }
        if (!this.system.app.graphicsDevice.disableParticleSystem) {
            if (!this.emitter) {
                let t = e.mesh;
                t instanceof ms || (t = null),
                this.emitter = new RL(this.system.app.graphicsDevice,{
                    numParticles: e.numParticles,
                    emitterExtents: e.emitterExtents,
                    emitterExtentsInner: e.emitterExtentsInner,
                    emitterRadius: e.emitterRadius,
                    emitterRadiusInner: e.emitterRadiusInner,
                    emitterShape: e.emitterShape,
                    initialVelocity: e.initialVelocity,
                    wrap: e.wrap,
                    localSpace: e.localSpace,
                    screenSpace: e.screenSpace,
                    wrapBounds: e.wrapBounds,
                    lifetime: e.lifetime,
                    rate: e.rate,
                    rate2: e.rate2,
                    orientation: e.orientation,
                    particleNormal: e.particleNormal,
                    animTilesX: e.animTilesX,
                    animTilesY: e.animTilesY,
                    animStartFrame: e.animStartFrame,
                    animNumFrames: e.animNumFrames,
                    animNumAnimations: e.animNumAnimations,
                    animIndex: e.animIndex,
                    randomizeAnimIndex: e.randomizeAnimIndex,
                    animSpeed: e.animSpeed,
                    animLoop: e.animLoop,
                    startAngle: e.startAngle,
                    startAngle2: e.startAngle2,
                    scaleGraph: e.scaleGraph,
                    scaleGraph2: e.scaleGraph2,
                    colorGraph: e.colorGraph,
                    colorGraph2: e.colorGraph2,
                    alphaGraph: e.alphaGraph,
                    alphaGraph2: e.alphaGraph2,
                    localVelocityGraph: e.localVelocityGraph,
                    localVelocityGraph2: e.localVelocityGraph2,
                    velocityGraph: e.velocityGraph,
                    velocityGraph2: e.velocityGraph2,
                    rotationSpeedGraph: e.rotationSpeedGraph,
                    rotationSpeedGraph2: e.rotationSpeedGraph2,
                    radialSpeedGraph: e.radialSpeedGraph,
                    radialSpeedGraph2: e.radialSpeedGraph2,
                    colorMap: e.colorMap,
                    normalMap: e.normalMap,
                    loop: e.loop,
                    preWarm: e.preWarm,
                    sort: e.sort,
                    stretch: e.stretch,
                    alignToMotion: e.alignToMotion,
                    lighting: e.lighting,
                    halfLambert: e.halfLambert,
                    intensity: e.intensity,
                    depthSoftening: e.depthSoftening,
                    scene: this.system.app.scene,
                    mesh: t,
                    depthWrite: e.depthWrite,
                    noFog: e.noFog,
                    node: this.entity,
                    blendType: e.blendType
                }),
                this.emitter.meshInstance.node = this.entity,
                this.emitter.drawOrder = this.drawOrder,
                e.autoPlay || (this.pause(),
                this.emitter.meshInstance.visible = !1)
            }
            this.emitter.colorMap && this.addMeshInstanceToLayers(),
            this.system.app.scene.on("set:layers", this.onLayersChanged, this),
            this.system.app.scene.layers && (this.system.app.scene.layers.on("add", this.onLayerAdded, this),
            this.system.app.scene.layers.on("remove", this.onLayerRemoved, this)),
            this.enabled && this.entity.enabled && e.depthSoftening && this._requestDepth()
        }
    }
    onDisable() {
        this.system.app.scene.off("set:layers", this.onLayersChanged, this),
        this.system.app.scene.layers && (this.system.app.scene.layers.off("add", this.onLayerAdded, this),
        this.system.app.scene.layers.off("remove", this.onLayerRemoved, this)),
        this.emitter && (this.removeMeshInstanceFromLayers(),
        this.data.depthSoftening && this._releaseDepth(),
        this.emitter.camera = null)
    }
    onBeforeRemove() {
        this.enabled && (this.enabled = !1),
        this.emitter && (this.emitter.destroy(),
        this.emitter = null);
        for (let e = 0; e < ud.length; e++) {
            const t = ud[e];
            this.data[t] && (this[t] = null)
        }
        this.off()
    }
    reset() {
        this.emitter && this.emitter.reset()
    }
    stop() {
        this.emitter && (this.emitter.loop = !1,
        this.emitter.resetTime(),
        this.emitter.addTime(0, !0))
    }
    pause() {
        this.data.paused = !0
    }
    unpause() {
        this.data.paused = !1
    }
    play() {
        this.data.paused = !1,
        this.emitter && (this.emitter.meshInstance.visible = !0,
        this.emitter.loop = this.data.loop,
        this.emitter.resetTime())
    }
    isPlaying() {
        return this.data.paused ? !1 : this.emitter && this.emitter.loop ? !0 : Date.now() <= this.emitter.endTime
    }
    rebuild() {
        const e = this.enabled;
        this.enabled = !1,
        this.emitter && (this.emitter.rebuild(),
        this.emitter.meshInstance.node = this.entity),
        this.enabled = e
    }
}
class SO {
    constructor() {
        this.numParticles = 1,
        this.rate = 1,
        this.rate2 = null,
        this.startAngle = 0,
        this.startAngle2 = null,
        this.lifetime = 50,
        this.emitterExtents = new y,
        this.emitterExtentsInner = new y,
        this.emitterRadius = 0,
        this.emitterRadiusInner = 0,
        this.emitterShape = di,
        this.initialVelocity = 0,
        this.wrapBounds = new y,
        this.localSpace = !1,
        this.screenSpace = !1,
        this.colorMap = null,
        this.colorMapAsset = null,
        this.normalMap = null,
        this.normalMapAsset = null,
        this.loop = !0,
        this.preWarm = !1,
        this.sort = 0,
        this.mode = tx,
        this.scene = null,
        this.lighting = !1,
        this.halfLambert = !1,
        this.intensity = 1,
        this.stretch = 0,
        this.alignToMotion = !1,
        this.depthSoftening = 0,
        this.meshAsset = null,
        this.mesh = null,
        this.depthWrite = !1,
        this.noFog = !1,
        this.orientation = ih,
        this.particleNormal = new y(0,1,0),
        this.animTilesX = 1,
        this.animTilesY = 1,
        this.animStartFrame = 0,
        this.animNumFrames = 1,
        this.animNumAnimations = 1,
        this.animIndex = 0,
        this.randomizeAnimIndex = !1,
        this.animSpeed = 1,
        this.animLoop = !0,
        this.scaleGraph = null,
        this.scaleGraph2 = null,
        this.colorGraph = null,
        this.colorGraph2 = null,
        this.alphaGraph = null,
        this.alphaGraph2 = null,
        this.localVelocityGraph = null,
        this.localVelocityGraph2 = null,
        this.velocityGraph = null,
        this.velocityGraph2 = null,
        this.rotationSpeedGraph = null,
        this.rotationSpeedGraph2 = null,
        this.radialSpeedGraph = null,
        this.radialSpeedGraph2 = null,
        this.blendType = ps,
        this.enabled = !0,
        this.paused = !1,
        this.autoPlay = !0,
        this.layers = [Bn]
    }
}
const aw = ["enabled", "autoPlay", "numParticles", "lifetime", "rate", "rate2", "startAngle", "startAngle2", "loop", "preWarm", "lighting", "halfLambert", "intensity", "depthWrite", "noFog", "depthSoftening", "sort", "blendType", "stretch", "alignToMotion", "emitterShape", "emitterExtents", "emitterExtentsInner", "emitterRadius", "emitterRadiusInner", "initialVelocity", "wrap", "wrapBounds", "localSpace", "screenSpace", "colorMapAsset", "normalMapAsset", "mesh", "meshAsset", "renderAsset", "orientation", "particleNormal", "localVelocityGraph", "localVelocityGraph2", "velocityGraph", "velocityGraph2", "rotationSpeedGraph", "rotationSpeedGraph2", "radialSpeedGraph", "radialSpeedGraph2", "scaleGraph", "scaleGraph2", "colorGraph", "colorGraph2", "alphaGraph", "alphaGraph2", "colorMap", "normalMap", "animTilesX", "animTilesY", "animStartFrame", "animNumFrames", "animNumAnimations", "animIndex", "randomizeAnimIndex", "animSpeed", "animLoop", "layers"];
class xO extends it {
    constructor(e) {
        super(e),
        this.id = "particlesystem",
        this.ComponentType = rw,
        this.DataType = SO,
        this.schema = aw,
        this.propertyTypes = {
            emitterExtents: "vec3",
            emitterExtentsInner: "vec3",
            particleNormal: "vec3",
            wrapBounds: "vec3",
            localVelocityGraph: "curveset",
            localVelocityGraph2: "curveset",
            velocityGraph: "curveset",
            velocityGraph2: "curveset",
            colorGraph: "curveset",
            colorGraph2: "curveset",
            alphaGraph: "curve",
            alphaGraph2: "curve",
            rotationSpeedGraph: "curve",
            rotationSpeedGraph2: "curve",
            radialSpeedGraph: "curve",
            radialSpeedGraph2: "curve",
            scaleGraph: "curve",
            scaleGraph2: "curve"
        },
        this.on("beforeremove", this.onBeforeRemove, this),
        this.app.systems.on("update", this.onUpdate, this)
    }
    initializeComponentData(e, t, s) {
        const i = {};
        s = [];
        const n = this.propertyTypes;
        (t.mesh instanceof le || typeof t.mesh == "number") && (t.meshAsset = t.mesh,
        delete t.mesh);
        for (const r in t) {
            if (t.hasOwnProperty(r) && (s.push(r),
            i[r] = t[r]),
            n[r] === "vec3")
                Array.isArray(i[r]) && (i[r] = new y(i[r][0],i[r][1],i[r][2]));
            else if (n[r] === "curve") {
                if (!(i[r]instanceof Ot)) {
                    const o = i[r].type;
                    i[r] = new Ot(i[r].keys),
                    i[r].type = o
                }
            } else if (n[r] === "curveset" && !(i[r]instanceof Qt)) {
                const o = i[r].type;
                i[r] = new Qt(i[r].keys),
                i[r].type = o
            }
            i.layers && Array.isArray(i.layers) && (i.layers = i.layers.slice(0))
        }
        super.initializeComponentData(e, i, s)
    }
    cloneComponent(e, t) {
        const s = e.particlesystem.data
          , i = this.schema
          , n = {};
        for (let r = 0, o = i.length; r < o; r++) {
            const l = i[r];
            let c = s[l];
            c instanceof y || c instanceof Ot || c instanceof Qt ? (c = c.clone(),
            n[l] = c) : l === "layers" ? n.layers = s.layers.slice(0) : c != null && (n[l] = c)
        }
        return this.addComponent(t, n)
    }
    onUpdate(e) {
        const t = this.store;
        let s;
        const i = this.app.stats.particles
          , n = this.app.scene.layers;
        for (let r = 0; r < n.layerList.length; r++)
            n.layerList[r].requiresLightCube = !1;
        for (const r in t)
            if (t.hasOwnProperty(r)) {
                const o = t[r]
                  , l = o.entity
                  , c = o.data;
                if (c.enabled && l.enabled) {
                    const d = l.particlesystem.emitter;
                    if (!(d != null && d.meshInstance.visible))
                        continue;
                    if (d.lighting) {
                        const h = c.layers;
                        for (let u = 0; u < h.length; u++) {
                            const f = n.getLayerById(h[u]);
                            f && (f.requiresLightCube = !0)
                        }
                    }
                    if (!c.paused) {
                        if (d.simTime += e,
                        d.simTime > d.fixedTimeStep && (s = Math.floor(d.simTime / d.fixedTimeStep),
                        d.simTime -= s * d.fixedTimeStep),
                        s) {
                            s = Math.min(s, d.maxSubSteps);
                            for (let h = 0; h < s; h++)
                                d.addTime(d.fixedTimeStep, !1);
                            i._updatesPerFrame += s,
                            i._frameTime += d._addTimeTime,
                            d._addTimeTime = 0
                        }
                        d.finishFrame()
                    }
                }
            }
    }
    onBeforeRemove(e, t) {
        t.onBeforeRemove()
    }
    destroy() {
        super.destroy(),
        this.app.systems.off("update", this.onUpdate, this)
    }
}
_e._buildAccessors(rw.prototype, aw);
class wO extends ig {
    constructor(e, t) {
        super(),
        this.skin = e,
        this.skinInstance = t
    }
}
class Vs {
    static createCachedSkinInstance(e, t, s) {
        let i = Vs.getCachedSkinInstance(e, t);
        return i || (i = new gc(e),
        i.resolve(t, s),
        Vs.addCachedSkinInstance(e, t, i)),
        i
    }
    static getCachedSkinInstance(e, t) {
        let s = null;
        const i = Vs._skinInstanceCache.get(t);
        if (i) {
            const n = i.find(r => r.skin === e);
            n && (n.incRefCount(),
            s = n.skinInstance)
        }
        return s
    }
    static addCachedSkinInstance(e, t, s) {
        let i = Vs._skinInstanceCache.get(t);
        i || (i = [],
        Vs._skinInstanceCache.set(t, i));
        let n = i.find(r => r.skin === e);
        n || (n = new wO(e,s),
        i.push(n)),
        n.incRefCount()
    }
    static removeCachedSkinInstance(e) {
        if (e) {
            const t = e.rootBone;
            if (t) {
                const s = Vs._skinInstanceCache.get(t);
                if (s) {
                    const i = s.findIndex(n => n.skinInstance === e);
                    if (i >= 0) {
                        const n = s[i];
                        n.decRefCount(),
                        n.refCount === 0 && (s.splice(i, 1),
                        s.length || Vs._skinInstanceCache.delete(t),
                        e && (e.destroy(),
                        n.skinInstance = null))
                    }
                }
            }
        }
    }
}
Vs._skinInstanceCache = new Map;
class Bh {
    constructor(e, t, s, i, n) {
        this.propertyName = e,
        this.parent = t,
        this._scope = n,
        this._registry = s,
        this.id = null,
        this.url = null,
        this.asset = null,
        this._onAssetLoad = i.load,
        this._onAssetAdd = i.add,
        this._onAssetRemove = i.remove,
        this._onAssetUnload = i.unload
    }
    set id(e) {
        if (this.url)
            throw Error("Can't set id and url");
        this._unbind(),
        this._id = e,
        this.asset = this._registry.get(this._id),
        this._bind()
    }
    get id() {
        return this._id
    }
    set url(e) {
        if (this.id)
            throw Error("Can't set id and url");
        this._unbind(),
        this._url = e,
        this.asset = this._registry.getByUrl(this._url),
        this._bind()
    }
    get url() {
        return this._url
    }
    _bind() {
        this.id && (this._onAssetLoad && this._registry.on("load:" + this.id, this._onLoad, this),
        this._onAssetAdd && this._registry.once("add:" + this.id, this._onAdd, this),
        this._onAssetRemove && this._registry.on("remove:" + this.id, this._onRemove, this),
        this._onAssetUnload && this._registry.on("unload:" + this.id, this._onUnload, this)),
        this.url && (this._onAssetLoad && this._registry.on("load:url:" + this.url, this._onLoad, this),
        this._onAssetAdd && this._registry.once("add:url:" + this.url, this._onAdd, this),
        this._onAssetRemove && this._registry.on("remove:url:" + this.url, this._onRemove, this))
    }
    _unbind() {
        this.id && (this._onAssetLoad && this._registry.off("load:" + this.id, this._onLoad, this),
        this._onAssetAdd && this._registry.off("add:" + this.id, this._onAdd, this),
        this._onAssetRemove && this._registry.off("remove:" + this.id, this._onRemove, this),
        this._onAssetUnload && this._registry.off("unload:" + this.id, this._onUnload, this)),
        this.url && (this._onAssetLoad && this._registry.off("load:" + this.url, this._onLoad, this),
        this._onAssetAdd && this._registry.off("add:" + this.url, this._onAdd, this),
        this._onAssetRemove && this._registry.off("remove:" + this.url, this._onRemove, this))
    }
    _onLoad(e) {
        this._onAssetLoad.call(this._scope, this.propertyName, this.parent, e)
    }
    _onAdd(e) {
        this.asset = e,
        this._onAssetAdd.call(this._scope, this.propertyName, this.parent, e)
    }
    _onRemove(e) {
        this._onAssetRemove.call(this._scope, this.propertyName, this.parent, e),
        this.asset = null
    }
    _onUnload(e) {
        this._onAssetUnload.call(this._scope, this.propertyName, this.parent, e)
    }
}
class ow extends _e {
    constructor(e, t) {
        super(e, t),
        this._type = "asset",
        this._castShadows = !0,
        this._receiveShadows = !0,
        this._castShadowsLightmap = !0,
        this._lightmapped = !1,
        this._lightmapSizeMultiplier = 1,
        this.isStatic = !1,
        this._batchGroupId = -1,
        this._layers = [Bn],
        this._renderStyle = nh,
        this._meshInstances = [],
        this._customAabb = null,
        this._area = null,
        this._assetReference = void 0,
        this._materialReferences = [],
        this._material = void 0,
        this._rootBone = void 0,
        this._rootBone = new Yr(this,"rootBone"),
        this._rootBone.on("set:entity", this._onSetRootBone, this),
        this._assetReference = new Bh("asset",this,e.app.assets,{
            add: this._onRenderAssetAdded,
            load: this._onRenderAssetLoad,
            remove: this._onRenderAssetRemove,
            unload: this._onRenderAssetUnload
        },this),
        this._material = e.defaultMaterial,
        t.on("remove", this.onRemoveChild, this),
        t.on("removehierarchy", this.onRemoveChild, this),
        t.on("insert", this.onInsertChild, this),
        t.on("inserthierarchy", this.onInsertChild, this)
    }
    set renderStyle(e) {
        this._renderStyle !== e && (this._renderStyle = e,
        Fe._prepareRenderStyleForArray(this._meshInstances, e))
    }
    get renderStyle() {
        return this._renderStyle
    }
    set customAabb(e) {
        this._customAabb = e;
        const t = this._meshInstances;
        if (t)
            for (let s = 0; s < t.length; s++)
                t[s].setCustomAabb(this._customAabb)
    }
    get customAabb() {
        return this._customAabb
    }
    set type(e) {
        if (this._type !== e && (this._area = null,
        this._type = e,
        this.destroyMeshInstances(),
        e !== "asset")) {
            let t = this._material;
            (!t || t === this.system.defaultMaterial) && (t = this._materialReferences[0] && this._materialReferences[0].asset && this._materialReferences[0].asset.resource);
            const s = ox(this.system.app.graphicsDevice, e);
            this._area = s.area,
            this.meshInstances = [new Fe(s.mesh,t || this.system.defaultMaterial,this.entity)]
        }
    }
    get type() {
        return this._type
    }
    set meshInstances(e) {
        if (this.destroyMeshInstances(),
        this._meshInstances = e,
        this._meshInstances) {
            const t = this._meshInstances;
            for (let s = 0; s < t.length; s++)
                t[s].node || (t[s].node = this.entity),
                t[s].castShadow = this._castShadows,
                t[s].receiveShadow = this._receiveShadows,
                t[s].renderStyle = this._renderStyle,
                t[s].setLightmapped(this._lightmapped),
                t[s].setCustomAabb(this._customAabb);
            this.enabled && this.entity.enabled && this.addToLayers()
        }
    }
    get meshInstances() {
        return this._meshInstances
    }
    set lightmapped(e) {
        if (e !== this._lightmapped) {
            this._lightmapped = e;
            const t = this._meshInstances;
            if (t)
                for (let s = 0; s < t.length; s++)
                    t[s].setLightmapped(e)
        }
    }
    get lightmapped() {
        return this._lightmapped
    }
    set castShadows(e) {
        if (this._castShadows !== e) {
            const t = this._meshInstances;
            if (t) {
                const s = this.layers
                  , i = this.system.app.scene;
                if (this._castShadows && !e)
                    for (let n = 0; n < s.length; n++) {
                        const r = i.layers.getLayerById(this.layers[n]);
                        r && r.removeShadowCasters(t)
                    }
                for (let n = 0; n < t.length; n++)
                    t[n].castShadow = e;
                if (!this._castShadows && e)
                    for (let n = 0; n < s.length; n++) {
                        const r = i.layers.getLayerById(s[n]);
                        r && r.addShadowCasters(t)
                    }
            }
            this._castShadows = e
        }
    }
    get castShadows() {
        return this._castShadows
    }
    set receiveShadows(e) {
        if (this._receiveShadows !== e) {
            this._receiveShadows = e;
            const t = this._meshInstances;
            if (t)
                for (let s = 0; s < t.length; s++)
                    t[s].receiveShadow = e
        }
    }
    get receiveShadows() {
        return this._receiveShadows
    }
    set castShadowsLightmap(e) {
        this._castShadowsLightmap = e
    }
    get castShadowsLightmap() {
        return this._castShadowsLightmap
    }
    set lightmapSizeMultiplier(e) {
        this._lightmapSizeMultiplier = e
    }
    get lightmapSizeMultiplier() {
        return this._lightmapSizeMultiplier
    }
    set layers(e) {
        const t = this.system.app.scene.layers;
        let s;
        if (this._meshInstances)
            for (let i = 0; i < this._layers.length; i++)
                s = t.getLayerById(this._layers[i]),
                s && s.removeMeshInstances(this._meshInstances);
        this._layers.length = 0;
        for (let i = 0; i < e.length; i++)
            this._layers[i] = e[i];
        if (!(!this.enabled || !this.entity.enabled || !this._meshInstances))
            for (let i = 0; i < this._layers.length; i++)
                s = t.getLayerById(this._layers[i]),
                s && s.addMeshInstances(this._meshInstances)
    }
    get layers() {
        return this._layers
    }
    set batchGroupId(e) {
        if (this._batchGroupId !== e) {
            if (this.entity.enabled && this._batchGroupId >= 0) {
                var t;
                (t = this.system.app.batcher) == null || t.remove(gt.RENDER, this.batchGroupId, this.entity)
            }
            if (this.entity.enabled && e >= 0) {
                var s;
                (s = this.system.app.batcher) == null || s.insert(gt.RENDER, e, this.entity)
            }
            e < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled && this.addToLayers(),
            this._batchGroupId = e
        }
    }
    get batchGroupId() {
        return this._batchGroupId
    }
    set material(e) {
        if (this._material !== e && (this._material = e,
        this._meshInstances && this._type !== "asset"))
            for (let t = 0; t < this._meshInstances.length; t++)
                this._meshInstances[t].material = e
    }
    get material() {
        return this._material
    }
    set materialAssets(e=[]) {
        if (this._materialReferences.length > e.length) {
            for (let t = e.length; t < this._materialReferences.length; t++)
                this._materialReferences[t].id = null;
            this._materialReferences.length = e.length
        }
        for (let t = 0; t < e.length; t++)
            if (this._materialReferences[t] || this._materialReferences.push(new Bh(t,this,this.system.app.assets,{
                add: this._onMaterialAdded,
                load: this._onMaterialLoad,
                remove: this._onMaterialRemove,
                unload: this._onMaterialUnload
            },this)),
            e[t]) {
                const s = e[t]instanceof le ? e[t].id : e[t];
                this._materialReferences[t].id !== s && (this._materialReferences[t].id = s),
                this._materialReferences[t].asset && this._onMaterialAdded(t, this, this._materialReferences[t].asset)
            } else
                this._materialReferences[t].id = null,
                this._meshInstances[t] && (this._meshInstances[t].material = this.system.defaultMaterial)
    }
    get materialAssets() {
        return this._materialReferences.map(function(e) {
            return e.id
        })
    }
    set asset(e) {
        const t = e instanceof le ? e.id : e;
        this._assetReference.id !== t && (this._assetReference.asset && this._assetReference.asset.resource && this._onRenderAssetRemove(),
        this._assetReference.id = t,
        this._assetReference.asset && this._onRenderAssetAdded())
    }
    get asset() {
        return this._assetReference.id
    }
    assignAsset(e) {
        const t = e instanceof le ? e.id : e;
        this._assetReference.id = t
    }
    _onSetRootBone(e) {
        e && this._onRootBoneChanged()
    }
    _onRootBoneChanged() {
        this._clearSkinInstances(),
        this.enabled && this.entity.enabled && this._cloneSkinInstances()
    }
    destroyMeshInstances() {
        const e = this._meshInstances;
        if (e) {
            this.removeFromLayers(),
            this._clearSkinInstances();
            for (let t = 0; t < e.length; t++)
                e[t].destroy();
            this._meshInstances.length = 0
        }
    }
    addToLayers() {
        const e = this.system.app.scene.layers;
        for (let t = 0; t < this._layers.length; t++) {
            const s = e.getLayerById(this._layers[t]);
            s && s.addMeshInstances(this._meshInstances)
        }
    }
    removeFromLayers() {
        if (this._meshInstances && this._meshInstances.length) {
            const e = this.system.app.scene.layers;
            for (let t = 0; t < this._layers.length; t++) {
                const s = e.getLayerById(this._layers[t]);
                s && s.removeMeshInstances(this._meshInstances)
            }
        }
    }
    onRemoveChild() {
        this.removeFromLayers()
    }
    onInsertChild() {
        this._meshInstances && this.enabled && this.entity.enabled && this.addToLayers()
    }
    onRemove() {
        this.destroyMeshInstances(),
        this.asset = null,
        this.materialAsset = null,
        this._assetReference.id = null;
        for (let e = 0; e < this._materialReferences.length; e++)
            this._materialReferences[e].id = null;
        this.entity.off("remove", this.onRemoveChild, this),
        this.entity.off("insert", this.onInsertChild, this)
    }
    onLayersChanged(e, t) {
        this.addToLayers(),
        e.off("add", this.onLayerAdded, this),
        e.off("remove", this.onLayerRemoved, this),
        t.on("add", this.onLayerAdded, this),
        t.on("remove", this.onLayerRemoved, this)
    }
    onLayerAdded(e) {
        this.layers.indexOf(e.id) < 0 || e.addMeshInstances(this._meshInstances)
    }
    onLayerRemoved(e) {
        this.layers.indexOf(e.id) < 0 || e.removeMeshInstances(this._meshInstances)
    }
    onEnable() {
        const e = this.system.app
          , t = e.scene;
        this._rootBone.onParentComponentEnable(),
        this._cloneSkinInstances(),
        t.on("set:layers", this.onLayersChanged, this),
        t.layers && (t.layers.on("add", this.onLayerAdded, this),
        t.layers.on("remove", this.onLayerRemoved, this));
        const s = this._type === "asset";
        this._meshInstances && this._meshInstances.length ? this.addToLayers() : s && this.asset && this._onRenderAssetAdded();
        for (let n = 0; n < this._materialReferences.length; n++)
            this._materialReferences[n].asset && this.system.app.assets.load(this._materialReferences[n].asset);
        if (this._batchGroupId >= 0) {
            var i;
            (i = e.batcher) == null || i.insert(gt.RENDER, this.batchGroupId, this.entity)
        }
    }
    onDisable() {
        const e = this.system.app
          , t = e.scene;
        if (t.off("set:layers", this.onLayersChanged, this),
        t.layers && (t.layers.off("add", this.onLayerAdded, this),
        t.layers.off("remove", this.onLayerRemoved, this)),
        this._batchGroupId >= 0) {
            var s;
            (s = e.batcher) == null || s.remove(gt.RENDER, this.batchGroupId, this.entity)
        }
        this.removeFromLayers()
    }
    hide() {
        if (this._meshInstances)
            for (let e = 0; e < this._meshInstances.length; e++)
                this._meshInstances[e].visible = !1
    }
    show() {
        if (this._meshInstances)
            for (let e = 0; e < this._meshInstances.length; e++)
                this._meshInstances[e].visible = !0
    }
    _onRenderAssetAdded() {
        this._assetReference.asset && (this._assetReference.asset.resource ? this._onRenderAssetLoad() : this.enabled && this.entity.enabled && this.system.app.assets.load(this._assetReference.asset))
    }
    _onRenderAssetLoad() {
        if (this.destroyMeshInstances(),
        this._assetReference.asset) {
            const e = this._assetReference.asset.resource;
            e.off("set:meshes", this._onSetMeshes, this),
            e.on("set:meshes", this._onSetMeshes, this),
            e.meshes && this._onSetMeshes(e.meshes)
        }
    }
    _onSetMeshes(e) {
        this._cloneMeshes(e)
    }
    _clearSkinInstances() {
        for (let e = 0; e < this._meshInstances.length; e++) {
            const t = this._meshInstances[e];
            Vs.removeCachedSkinInstance(t.skinInstance),
            t.skinInstance = null
        }
    }
    _cloneSkinInstances() {
        if (this._meshInstances.length && this._rootBone.entity instanceof yt)
            for (let e = 0; e < this._meshInstances.length; e++) {
                const t = this._meshInstances[e]
                  , s = t.mesh;
                s.skin && !t.skinInstance && (t.skinInstance = Vs.createCachedSkinInstance(s.skin, this._rootBone.entity, this.entity))
            }
    }
    _cloneMeshes(e) {
        if (e && e.length) {
            const t = [];
            for (let s = 0; s < e.length; s++) {
                const i = e[s]
                  , n = this._materialReferences[s] && this._materialReferences[s].asset && this._materialReferences[s].asset.resource
                  , r = new Fe(i,n || this.system.defaultMaterial,this.entity);
                t.push(r),
                i.morph && (r.morphInstance = new Sa(i.morph))
            }
            this.meshInstances = t,
            this._cloneSkinInstances()
        }
    }
    _onRenderAssetUnload() {
        this._type === "asset" && this.destroyMeshInstances()
    }
    _onRenderAssetRemove() {
        this._assetReference.asset && this._assetReference.asset.resource && this._assetReference.asset.resource.off("set:meshes", this._onSetMeshes, this),
        this._onRenderAssetUnload()
    }
    _onMaterialAdded(e, t, s) {
        s.resource ? this._onMaterialLoad(e, t, s) : this.enabled && this.entity.enabled && this.system.app.assets.load(s)
    }
    _updateMainMaterial(e, t) {
        e === 0 && (this.material = t)
    }
    _onMaterialLoad(e, t, s) {
        this._meshInstances[e] && (this._meshInstances[e].material = s.resource),
        this._updateMainMaterial(e, s.resource)
    }
    _onMaterialRemove(e, t, s) {
        this._meshInstances[e] && (this._meshInstances[e].material = this.system.defaultMaterial),
        this._updateMainMaterial(e, this.system.defaultMaterial)
    }
    _onMaterialUnload(e, t, s) {
        this._meshInstances[e] && (this._meshInstances[e].material = this.system.defaultMaterial),
        this._updateMainMaterial(e, this.system.defaultMaterial)
    }
    resolveDuplicatedEntityReferenceProperties(e, t) {
        e.rootBone && t[e.rootBone] && (this.rootBone = t[e.rootBone]),
        this._clearSkinInstances()
    }
}
class bO {
    constructor() {
        this.enabled = !0,
        this.rootBone = null
    }
}
const Km = [{
    name: "rootBone",
    type: "entity"
}, "enabled"]
  , Nr = ["material", "meshInstances", "asset", "materialAssets", "castShadows", "receiveShadows", "castShadowsLightmap", "lightmapped", "lightmapSizeMultiplier", "renderStyle", "type", "layers", "isStatic", "batchGroupId"];
class TO extends it {
    constructor(e) {
        super(e),
        this.id = "render",
        this.ComponentType = ow,
        this.DataType = bO,
        this.schema = Km,
        this.defaultMaterial = _c(e.graphicsDevice),
        this.on("beforeremove", this.onRemove, this)
    }
    initializeComponentData(e, t, s) {
        (t.batchGroupId === null || t.batchGroupId === void 0) && (t.batchGroupId = -1),
        t.layers && t.layers.length && (t.layers = t.layers.slice(0));
        for (let i = 0; i < Nr.length; i++)
            t.hasOwnProperty(Nr[i]) && (e[Nr[i]] = t[Nr[i]]);
        t.aabbCenter && t.aabbHalfExtents && (e.customAabb = new Pe(new y(t.aabbCenter),new y(t.aabbHalfExtents))),
        super.initializeComponentData(e, t, Km)
    }
    cloneComponent(e, t) {
        const s = {};
        for (let o = 0; o < Nr.length; o++)
            s[Nr[o]] = e.render[Nr[o]];
        s.enabled = e.render.enabled,
        delete s.meshInstances;
        const i = this.addComponent(t, s)
          , n = e.render.meshInstances
          , r = n.map(o => o.mesh);
        i._onSetMeshes(r);
        for (let o = 0; o < n.length; o++)
            i.meshInstances[o].material = n[o].material;
        return e.render.customAabb && (i.customAabb = e.render.customAabb.clone()),
        i
    }
    onRemove(e, t) {
        t.onRemove()
    }
}
_e._buildAccessors(ow.prototype, Km);
class Rp {
    constructor(e, t) {
        this._pool = [],
        this._count = 0,
        this._constructor = e,
        this._resize(t)
    }
    _resize(e) {
        if (e > this._pool.length)
            for (let t = this._pool.length; t < e; t++)
                this._pool[t] = new this._constructor
    }
    allocate() {
        return this._count >= this._pool.length && this._resize(this._pool.length * 2),
        this._pool[this._count++]
    }
    freeAll() {
        this._count = 0
    }
}
let li, Ne, hn, fd;
const CO = new ne
  , EO = new ne
  , pd = new y;
class yr extends _e {
    constructor(e, t) {
        super(e, t),
        this._angularDamping = 0,
        this._angularFactor = new y(1,1,1),
        this._angularVelocity = new y,
        this._body = null,
        this._friction = .5,
        this._group = ov,
        this._linearDamping = 0,
        this._linearFactor = new y(1,1,1),
        this._linearVelocity = new y,
        this._mask = Wm,
        this._mass = 1,
        this._restitution = 0,
        this._rollingFriction = 0,
        this._simulationEnabled = !1,
        this._type = Il
    }
    static onLibraryLoaded() {
        typeof Ammo < "u" && (li = new Ammo.btTransform,
        Ne = new Ammo.btVector3,
        hn = new Ammo.btVector3,
        fd = new Ammo.btQuaternion)
    }
    set angularDamping(e) {
        this._angularDamping !== e && (this._angularDamping = e,
        this._body && this._body.setDamping(this._linearDamping, e))
    }
    get angularDamping() {
        return this._angularDamping
    }
    set angularFactor(e) {
        this._angularFactor.equals(e) || (this._angularFactor.copy(e),
        this._body && this._type === ai && (Ne.setValue(e.x, e.y, e.z),
        this._body.setAngularFactor(Ne)))
    }
    get angularFactor() {
        return this._angularFactor
    }
    set angularVelocity(e) {
        this._body && this._type === ai && (this._body.activate(),
        Ne.setValue(e.x, e.y, e.z),
        this._body.setAngularVelocity(Ne),
        this._angularVelocity.copy(e))
    }
    get angularVelocity() {
        if (this._body && this._type === ai) {
            const e = this._body.getAngularVelocity();
            this._angularVelocity.set(e.x(), e.y(), e.z())
        }
        return this._angularVelocity
    }
    set body(e) {
        this._body !== e && (this._body = e,
        e && this._simulationEnabled && e.activate())
    }
    get body() {
        return this._body
    }
    set friction(e) {
        this._friction !== e && (this._friction = e,
        this._body && this._body.setFriction(e))
    }
    get friction() {
        return this._friction
    }
    set group(e) {
        this._group !== e && (this._group = e,
        this.enabled && this.entity.enabled && (this.disableSimulation(),
        this.enableSimulation()))
    }
    get group() {
        return this._group
    }
    set linearDamping(e) {
        this._linearDamping !== e && (this._linearDamping = e,
        this._body && this._body.setDamping(e, this._angularDamping))
    }
    get linearDamping() {
        return this._linearDamping
    }
    set linearFactor(e) {
        this._linearFactor.equals(e) || (this._linearFactor.copy(e),
        this._body && this._type === ai && (Ne.setValue(e.x, e.y, e.z),
        this._body.setLinearFactor(Ne)))
    }
    get linearFactor() {
        return this._linearFactor
    }
    set linearVelocity(e) {
        this._body && this._type === ai && (this._body.activate(),
        Ne.setValue(e.x, e.y, e.z),
        this._body.setLinearVelocity(Ne),
        this._linearVelocity.copy(e))
    }
    get linearVelocity() {
        if (this._body && this._type === ai) {
            const e = this._body.getLinearVelocity();
            this._linearVelocity.set(e.x(), e.y(), e.z())
        }
        return this._linearVelocity
    }
    set mask(e) {
        this._mask !== e && (this._mask = e,
        this.enabled && this.entity.enabled && (this.disableSimulation(),
        this.enableSimulation()))
    }
    get mask() {
        return this._mask
    }
    set mass(e) {
        if (this._mass !== e && (this._mass = e,
        this._body && this._type === ai)) {
            const t = this.enabled && this.entity.enabled;
            t && this.disableSimulation(),
            this._body.getCollisionShape().calculateLocalInertia(e, Ne),
            this._body.setMassProps(e, Ne),
            this._body.updateInertiaTensor(),
            t && this.enableSimulation()
        }
    }
    get mass() {
        return this._mass
    }
    set restitution(e) {
        this._restitution !== e && (this._restitution = e,
        this._body && this._body.setRestitution(e))
    }
    get restitution() {
        return this._restitution
    }
    set rollingFriction(e) {
        this._rollingFriction !== e && (this._rollingFriction = e,
        this._body && this._body.setRollingFriction(e))
    }
    get rollingFriction() {
        return this._rollingFriction
    }
    set type(e) {
        if (this._type !== e) {
            switch (this._type = e,
            this.disableSimulation(),
            e) {
            case ai:
                this._group = g2,
                this._mask = hv;
                break;
            case Ya:
                this._group = y2,
                this._mask = hv;
                break;
            case Il:
            default:
                this._group = ov,
                this._mask = Wm;
                break
            }
            this.createBody()
        }
    }
    get type() {
        return this._type
    }
    createBody() {
        const e = this.entity;
        let t;
        if (e.collision && (t = e.collision.shape,
        e.trigger && (e.trigger.destroy(),
        delete e.trigger)),
        t) {
            this._body && (this.system.removeBody(this._body),
            this.system.destroyBody(this._body),
            this._body = null);
            const s = this._type === ai ? this._mass : 0;
            this._getEntityTransform(li);
            const i = this.system.createBody(s, t, li);
            if (i.setRestitution(this._restitution),
            i.setFriction(this._friction),
            i.setRollingFriction(this._rollingFriction),
            i.setDamping(this._linearDamping, this._angularDamping),
            this._type === ai) {
                const n = this._linearFactor;
                Ne.setValue(n.x, n.y, n.z),
                i.setLinearFactor(Ne);
                const r = this._angularFactor;
                Ne.setValue(r.x, r.y, r.z),
                i.setAngularFactor(Ne)
            } else
                this._type === Ya && (i.setCollisionFlags(i.getCollisionFlags() | _2),
                i.setActivationState(av));
            i.entity = e,
            this.body = i,
            this.enabled && e.enabled && this.enableSimulation()
        }
    }
    isActive() {
        return this._body ? this._body.isActive() : !1
    }
    activate() {
        this._body && this._body.activate()
    }
    enableSimulation() {
        const e = this.entity;
        if (e.collision && e.collision.enabled && !this._simulationEnabled) {
            const t = this._body;
            if (t) {
                switch (this.system.addBody(t, this._group, this._mask),
                this._type) {
                case ai:
                    this.system._dynamic.push(this),
                    t.forceActivationState(Hm),
                    this.syncEntityToBody();
                    break;
                case Ya:
                    this.system._kinematic.push(this),
                    t.forceActivationState(av);
                    break;
                case Il:
                    t.forceActivationState(Hm),
                    this.syncEntityToBody();
                    break
                }
                e.collision.type === "compound" && this.system._compounds.push(e.collision),
                t.activate(),
                this._simulationEnabled = !0
            }
        }
    }
    disableSimulation() {
        const e = this._body;
        if (e && this._simulationEnabled) {
            const t = this.system;
            let s = t._compounds.indexOf(this.entity.collision);
            s > -1 && t._compounds.splice(s, 1),
            s = t._dynamic.indexOf(this),
            s > -1 && t._dynamic.splice(s, 1),
            s = t._kinematic.indexOf(this),
            s > -1 && t._kinematic.splice(s, 1),
            t.removeBody(e),
            e.forceActivationState(Xx),
            this._simulationEnabled = !1
        }
    }
    applyForce(e, t, s, i, n, r) {
        const o = this._body;
        o && (o.activate(),
        e instanceof y ? Ne.setValue(e.x, e.y, e.z) : Ne.setValue(e, t, s),
        t instanceof y ? hn.setValue(t.x, t.y, t.z) : i !== void 0 ? hn.setValue(i, n, r) : hn.setValue(0, 0, 0),
        o.applyForce(Ne, hn))
    }
    applyTorque(e, t, s) {
        const i = this._body;
        i && (i.activate(),
        e instanceof y ? Ne.setValue(e.x, e.y, e.z) : Ne.setValue(e, t, s),
        i.applyTorque(Ne))
    }
    applyImpulse(e, t, s, i, n, r) {
        const o = this._body;
        o && (o.activate(),
        e instanceof y ? Ne.setValue(e.x, e.y, e.z) : Ne.setValue(e, t, s),
        t instanceof y ? hn.setValue(t.x, t.y, t.z) : i !== void 0 ? hn.setValue(i, n, r) : hn.setValue(0, 0, 0),
        o.applyImpulse(Ne, hn))
    }
    applyTorqueImpulse(e, t, s) {
        const i = this._body;
        i && (i.activate(),
        e instanceof y ? Ne.setValue(e.x, e.y, e.z) : Ne.setValue(e, t, s),
        i.applyTorqueImpulse(Ne))
    }
    isStatic() {
        return this._type === Il
    }
    isStaticOrKinematic() {
        return this._type === Il || this._type === Ya
    }
    isKinematic() {
        return this._type === Ya
    }
    _getEntityTransform(e) {
        const t = this.entity
          , s = t.collision;
        if (s) {
            const i = s.getShapePosition()
              , n = s.getShapeRotation();
            Ne.setValue(i.x, i.y, i.z),
            fd.setValue(n.x, n.y, n.z, n.w)
        } else {
            const i = t.getPosition()
              , n = t.getRotation();
            Ne.setValue(i.x, i.y, i.z),
            fd.setValue(n.x, n.y, n.z, n.w)
        }
        e.setOrigin(Ne),
        e.setRotation(fd)
    }
    syncEntityToBody() {
        const e = this._body;
        if (e) {
            if (this._getEntityTransform(li),
            e.setWorldTransform(li),
            this._type === Ya) {
                const t = e.getMotionState();
                t && t.setWorldTransform(li)
            }
            e.activate()
        }
    }
    _updateDynamic() {
        const e = this._body;
        if (e.isActive()) {
            const t = e.getMotionState();
            if (t) {
                const s = this.entity;
                t.getWorldTransform(li);
                const i = li.getOrigin()
                  , n = li.getRotation()
                  , r = s.collision;
                if (r && r._hasOffset) {
                    const o = r.data.linearOffset
                      , l = r.data.angularOffset
                      , c = EO.copy(l).invert()
                      , d = CO.set(n.x(), n.y(), n.z(), n.w()).mul(c);
                    d.transformVector(o, pd),
                    s.setPosition(i.x() - pd.x, i.y() - pd.y, i.z() - pd.z),
                    s.setRotation(d)
                } else
                    s.setPosition(i.x(), i.y(), i.z()),
                    s.setRotation(n.x(), n.y(), n.z(), n.w())
            }
        }
    }
    _updateKinematic() {
        const e = this._body.getMotionState();
        e && (this._getEntityTransform(li),
        e.setWorldTransform(li))
    }
    teleport(e, t, s, i, n, r) {
        e instanceof y ? this.entity.setPosition(e) : this.entity.setPosition(e, t, s),
        t instanceof ne ? this.entity.setRotation(t) : t instanceof y ? this.entity.setEulerAngles(t) : i !== void 0 && this.entity.setEulerAngles(i, n, r),
        this.syncEntityToBody()
    }
    onEnable() {
        this._body || this.createBody(),
        this.enableSimulation()
    }
    onDisable() {
        this.disableSimulation()
    }
}
yr.EVENT_CONTACT = "contact";
yr.EVENT_COLLISIONSTART = "collisionstart";
yr.EVENT_COLLISIONEND = "collisionend";
yr.EVENT_TRIGGERENTER = "triggerenter";
yr.EVENT_TRIGGERLEAVE = "triggerleave";
class AO {
    constructor() {
        this.enabled = !0
    }
}
let Ur, zr;
class yv {
    constructor(e, t, s, i) {
        this.entity = e,
        this.point = t,
        this.normal = s,
        this.hitFraction = i
    }
}
class MO {
    constructor(e, t, s) {
        arguments.length === 0 ? (this.a = null,
        this.b = null,
        this.impulse = 0,
        this.localPointA = new y,
        this.localPointB = new y,
        this.pointA = new y,
        this.pointB = new y,
        this.normal = new y) : (this.a = e,
        this.b = t,
        this.impulse = s.impulse,
        this.localPointA = s.localPoint,
        this.localPointB = s.localPointOther,
        this.pointA = s.point,
        this.pointB = s.pointOther,
        this.normal = s.normal)
    }
}
class PO {
    constructor(e=new y, t=new y, s=new y, i=new y, n=new y, r=0) {
        this.localPoint = e,
        this.localPointOther = t,
        this.point = s,
        this.pointOther = i,
        this.normal = n,
        this.impulse = r
    }
}
class RO {
    constructor(e, t) {
        this.other = e,
        this.contacts = t
    }
}
const lw = ["enabled"];
class Be extends it {
    constructor(e) {
        super(e),
        this.maxSubSteps = 10,
        this.fixedTimeStep = 1 / 60,
        this.gravity = new y(0,-9.81,0),
        this._gravityFloat32 = new Float32Array(3),
        this._dynamic = [],
        this._kinematic = [],
        this._triggers = [],
        this._compounds = [],
        this.id = "rigidbody",
        this._stats = e.stats.frame,
        this.ComponentType = yr,
        this.DataType = AO,
        this.contactPointPool = null,
        this.contactResultPool = null,
        this.singleContactResultPool = null,
        this.schema = lw,
        this.collisions = {},
        this.frameCollisions = {},
        this.on("beforeremove", this.onBeforeRemove, this)
    }
    onLibraryLoaded() {
        if (typeof Ammo < "u") {
            if (this.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration,
            this.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration),
            this.overlappingPairCache = new Ammo.btDbvtBroadphase,
            this.solver = new Ammo.btSequentialImpulseConstraintSolver,
            this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher,this.overlappingPairCache,this.solver,this.collisionConfiguration),
            this.dynamicsWorld.setInternalTickCallback) {
                const e = Ammo.addFunction(this._checkForCollisions.bind(this), "vif");
                this.dynamicsWorld.setInternalTickCallback(e)
            }
            Ur = new Ammo.btVector3,
            zr = new Ammo.btVector3,
            yr.onLibraryLoaded(),
            this.contactPointPool = new Rp(PO,1),
            this.contactResultPool = new Rp(RO,1),
            this.singleContactResultPool = new Rp(MO,1),
            this.app.systems.on("update", this.onUpdate, this)
        } else
            this.app.systems.off("update", this.onUpdate, this)
    }
    initializeComponentData(e, t, s) {
        const i = ["mass", "linearDamping", "angularDamping", "linearFactor", "angularFactor", "friction", "rollingFriction", "restitution", "type", "group", "mask"];
        for (const n of i)
            if (t.hasOwnProperty(n)) {
                const r = t[n];
                Array.isArray(r) ? e[n] = new y(r[0],r[1],r[2]) : e[n] = r
            }
        super.initializeComponentData(e, t, ["enabled"])
    }
    cloneComponent(e, t) {
        const s = e.rigidbody
          , i = {
            enabled: s.enabled,
            mass: s.mass,
            linearDamping: s.linearDamping,
            angularDamping: s.angularDamping,
            linearFactor: [s.linearFactor.x, s.linearFactor.y, s.linearFactor.z],
            angularFactor: [s.angularFactor.x, s.angularFactor.y, s.angularFactor.z],
            friction: s.friction,
            rollingFriction: s.rollingFriction,
            restitution: s.restitution,
            type: s.type,
            group: s.group,
            mask: s.mask
        };
        return this.addComponent(t, i)
    }
    onBeforeRemove(e, t) {
        t.enabled && (t.enabled = !1),
        t.body && (this.destroyBody(t.body),
        t.body = null)
    }
    addBody(e, t, s) {
        t !== void 0 && s !== void 0 ? this.dynamicsWorld.addRigidBody(e, t, s) : this.dynamicsWorld.addRigidBody(e)
    }
    removeBody(e) {
        this.dynamicsWorld.removeRigidBody(e)
    }
    createBody(e, t, s) {
        const i = new Ammo.btVector3(0,0,0);
        e !== 0 && t.calculateLocalInertia(e, i);
        const n = new Ammo.btDefaultMotionState(s)
          , r = new Ammo.btRigidBodyConstructionInfo(e,n,t,i)
          , o = new Ammo.btRigidBody(r);
        return Ammo.destroy(r),
        Ammo.destroy(i),
        o
    }
    destroyBody(e) {
        const t = e.getMotionState();
        t && Ammo.destroy(t),
        Ammo.destroy(e)
    }
    raycastFirst(e, t, s={}) {
        if (s.filterTags || s.filterCallback)
            return s.sort = !0,
            this.raycastAll(e, t, s)[0] || null;
        let i = null;
        Ur.setValue(e.x, e.y, e.z),
        zr.setValue(t.x, t.y, t.z);
        const n = new Ammo.ClosestRayResultCallback(Ur,zr);
        if (typeof s.filterCollisionGroup == "number" && n.set_m_collisionFilterGroup(s.filterCollisionGroup),
        typeof s.filterCollisionMask == "number" && n.set_m_collisionFilterMask(s.filterCollisionMask),
        this.dynamicsWorld.rayTest(Ur, zr, n),
        n.hasHit()) {
            const r = n.get_m_collisionObject()
              , o = Ammo.castObject(r, Ammo.btRigidBody);
            if (o) {
                const l = n.get_m_hitPointWorld()
                  , c = n.get_m_hitNormalWorld();
                i = new yv(o.entity,new y(l.x(),l.y(),l.z()),new y(c.x(),c.y(),c.z()),n.get_m_closestHitFraction())
            }
        }
        return Ammo.destroy(n),
        i
    }
    raycastAll(e, t, s={}) {
        const i = [];
        Ur.setValue(e.x, e.y, e.z),
        zr.setValue(t.x, t.y, t.z);
        const n = new Ammo.AllHitsRayResultCallback(Ur,zr);
        if (typeof s.filterCollisionGroup == "number" && n.set_m_collisionFilterGroup(s.filterCollisionGroup),
        typeof s.filterCollisionMask == "number" && n.set_m_collisionFilterMask(s.filterCollisionMask),
        this.dynamicsWorld.rayTest(Ur, zr, n),
        n.hasHit()) {
            const r = n.get_m_collisionObjects()
              , o = n.get_m_hitPointWorld()
              , l = n.get_m_hitNormalWorld()
              , c = n.get_m_hitFractions()
              , d = r.size();
            for (let h = 0; h < d; h++) {
                const u = Ammo.castObject(r.at(h), Ammo.btRigidBody);
                if (u && u.entity) {
                    if (s.filterTags && !u.entity.tags.has(...s.filterTags) || s.filterCallback && !s.filterCallback(u.entity))
                        continue;
                    const f = o.at(h)
                      , p = l.at(h)
                      , _ = new yv(u.entity,new y(f.x(),f.y(),f.z()),new y(p.x(),p.y(),p.z()),c.at(h));
                    i.push(_)
                }
            }
            s.sort && i.sort( (h, u) => h.hitFraction - u.hitFraction)
        }
        return Ammo.destroy(n),
        i
    }
    _storeCollision(e, t) {
        let s = !1;
        const i = e.getGuid();
        return this.collisions[i] = this.collisions[i] || {
            others: [],
            entity: e
        },
        this.collisions[i].others.indexOf(t) < 0 && (this.collisions[i].others.push(t),
        s = !0),
        this.frameCollisions[i] = this.frameCollisions[i] || {
            others: [],
            entity: e
        },
        this.frameCollisions[i].others.push(t),
        s
    }
    _createContactPointFromAmmo(e) {
        const t = e.get_m_localPointA()
          , s = e.get_m_localPointB()
          , i = e.getPositionWorldOnA()
          , n = e.getPositionWorldOnB()
          , r = e.get_m_normalWorldOnB()
          , o = this.contactPointPool.allocate();
        return o.localPoint.set(t.x(), t.y(), t.z()),
        o.localPointOther.set(s.x(), s.y(), s.z()),
        o.point.set(i.x(), i.y(), i.z()),
        o.pointOther.set(n.x(), n.y(), n.z()),
        o.normal.set(r.x(), r.y(), r.z()),
        o.impulse = e.getAppliedImpulse(),
        o
    }
    _createReverseContactPointFromAmmo(e) {
        const t = e.get_m_localPointA()
          , s = e.get_m_localPointB()
          , i = e.getPositionWorldOnA()
          , n = e.getPositionWorldOnB()
          , r = e.get_m_normalWorldOnB()
          , o = this.contactPointPool.allocate();
        return o.localPointOther.set(t.x(), t.y(), t.z()),
        o.localPoint.set(s.x(), s.y(), s.z()),
        o.pointOther.set(i.x(), i.y(), i.z()),
        o.point.set(n.x(), n.y(), n.z()),
        o.normal.set(r.x(), r.y(), r.z()),
        o.impulse = e.getAppliedImpulse(),
        o
    }
    _createSingleContactResult(e, t, s) {
        const i = this.singleContactResultPool.allocate();
        return i.a = e,
        i.b = t,
        i.localPointA = s.localPoint,
        i.localPointB = s.localPointOther,
        i.pointA = s.point,
        i.pointB = s.pointOther,
        i.normal = s.normal,
        i.impulse = s.impulse,
        i
    }
    _createContactResult(e, t) {
        const s = this.contactResultPool.allocate();
        return s.other = e,
        s.contacts = t,
        s
    }
    _cleanOldCollisions() {
        for (const e in this.collisions)
            if (this.collisions.hasOwnProperty(e)) {
                const t = this.frameCollisions[e]
                  , s = this.collisions[e]
                  , i = s.entity
                  , n = i.collision
                  , r = i.rigidbody
                  , o = s.others;
                let c = o.length;
                for (; c--; ) {
                    const d = o[c];
                    (!t || t.others.indexOf(d) < 0) && (o.splice(c, 1),
                    i.trigger ? (n && n.fire("triggerleave", d),
                    d.rigidbody && d.rigidbody.fire("triggerleave", i)) : d.trigger || (r && r.fire("collisionend", d),
                    n && n.fire("collisionend", d)))
                }
                o.length === 0 && delete this.collisions[e]
            }
    }
    _hasContactEvent(e) {
        const t = e.collision;
        if (t && (t.hasEvent("collisionstart") || t.hasEvent("collisionend") || t.hasEvent("contact")))
            return !0;
        const s = e.rigidbody;
        return s && (s.hasEvent("collisionstart") || s.hasEvent("collisionend") || s.hasEvent("contact"))
    }
    _checkForCollisions(e, t) {
        const i = Ammo.wrapPointer(e, Ammo.btDynamicsWorld).getDispatcher()
          , n = i.getNumManifolds();
        this.frameCollisions = {};
        for (let r = 0; r < n; r++) {
            const o = i.getManifoldByIndexInternal(r)
              , l = o.getBody0()
              , c = o.getBody1()
              , d = Ammo.castObject(l, Ammo.btRigidBody)
              , h = Ammo.castObject(c, Ammo.btRigidBody)
              , u = d.entity
              , f = h.entity;
            if (!u || !f)
                continue;
            const p = d.getCollisionFlags()
              , _ = h.getCollisionFlags()
              , m = o.getNumContacts()
              , g = []
              , v = [];
            let x;
            if (m > 0)
                if (p & Hl || _ & Hl) {
                    const S = u.collision && (u.collision.hasEvent("triggerenter") || u.collision.hasEvent("triggerleave"))
                      , w = f.collision && (f.collision.hasEvent("triggerenter") || f.collision.hasEvent("triggerleave"))
                      , T = u.rigidbody && (u.rigidbody.hasEvent("triggerenter") || u.rigidbody.hasEvent("triggerleave"))
                      , b = f.rigidbody && (f.rigidbody.hasEvent("triggerenter") || f.rigidbody.hasEvent("triggerleave"));
                    S && (x = this._storeCollision(u, f),
                    x && !(_ & Hl) && u.collision.fire("triggerenter", f)),
                    w && (x = this._storeCollision(f, u),
                    x && !(p & Hl) && f.collision.fire("triggerenter", u)),
                    T && (x || (x = this._storeCollision(f, u)),
                    x && u.rigidbody.fire("triggerenter", f)),
                    b && (x || (x = this._storeCollision(u, f)),
                    x && f.rigidbody.fire("triggerenter", u))
                } else {
                    const S = this._hasContactEvent(u)
                      , w = this._hasContactEvent(f)
                      , T = this.hasEvent("contact");
                    if (T || S || w) {
                        for (let b = 0; b < m; b++) {
                            const E = o.getContactPoint(b)
                              , C = this._createContactPointFromAmmo(E);
                            if (S || w) {
                                g.push(C);
                                const R = this._createReverseContactPointFromAmmo(E);
                                v.push(R)
                            }
                            if (T) {
                                const R = this._createSingleContactResult(u, f, C);
                                this.fire("contact", R)
                            }
                        }
                        if (S) {
                            const b = this._createContactResult(f, g);
                            x = this._storeCollision(u, f),
                            u.collision && (u.collision.fire("contact", b),
                            x && u.collision.fire("collisionstart", b)),
                            u.rigidbody && (u.rigidbody.fire("contact", b),
                            x && u.rigidbody.fire("collisionstart", b))
                        }
                        if (w) {
                            const b = this._createContactResult(u, v);
                            x = this._storeCollision(f, u),
                            f.collision && (f.collision.fire("contact", b),
                            x && f.collision.fire("collisionstart", b)),
                            f.rigidbody && (f.rigidbody.fire("contact", b),
                            x && f.rigidbody.fire("collisionstart", b))
                        }
                    }
                }
        }
        this._cleanOldCollisions(),
        this.contactPointPool.freeAll(),
        this.contactResultPool.freeAll(),
        this.singleContactResultPool.freeAll()
    }
    onUpdate(e) {
        let t, s;
        this._gravityFloat32[0] = this.gravity.x,
        this._gravityFloat32[1] = this.gravity.y,
        this._gravityFloat32[2] = this.gravity.z;
        const i = this.dynamicsWorld.getGravity();
        (i.x() !== this._gravityFloat32[0] || i.y() !== this._gravityFloat32[1] || i.z() !== this._gravityFloat32[2]) && (i.setValue(this.gravity.x, this.gravity.y, this.gravity.z),
        this.dynamicsWorld.setGravity(i));
        const n = this._triggers;
        for (t = 0,
        s = n.length; t < s; t++)
            n[t].updateTransform();
        const r = this._compounds;
        for (t = 0,
        s = r.length; t < s; t++)
            r[t]._updateCompound();
        const o = this._kinematic;
        for (t = 0,
        s = o.length; t < s; t++)
            o[t]._updateKinematic();
        this.dynamicsWorld.stepSimulation(e, this.maxSubSteps, this.fixedTimeStep);
        const l = this._dynamic;
        for (t = 0,
        s = l.length; t < s; t++)
            l[t]._updateDynamic();
        this.dynamicsWorld.setInternalTickCallback || this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld), e)
    }
    destroy() {
        super.destroy(),
        this.app.systems.off("update", this.onUpdate, this),
        typeof Ammo < "u" && (Ammo.destroy(this.dynamicsWorld),
        Ammo.destroy(this.solver),
        Ammo.destroy(this.overlappingPairCache),
        Ammo.destroy(this.dispatcher),
        Ammo.destroy(this.collisionConfiguration),
        this.dynamicsWorld = null,
        this.solver = null,
        this.overlappingPairCache = null,
        this.dispatcher = null,
        this.collisionConfiguration = null)
    }
}
Be.EVENT_CONTACT = "contact";
_e._buildAccessors(yr.prototype, lw);
const so = "none"
  , wc = "blend"
  , vv = new ee;
class hw extends _e {
    constructor(e, t) {
        super(e, t),
        this._resolution = new P(640,320),
        this._referenceResolution = new P(640,320),
        this._scaleMode = so,
        this.scale = 1,
        this._scaleBlend = .5,
        this._priority = 0,
        this._screenSpace = !1,
        this.cull = this._screenSpace,
        this._screenMatrix = new ee,
        this._elements = new Set,
        e.app.graphicsDevice.on("resizecanvas", this._onResize, this)
    }
    syncDrawOrder() {
        this.system.queueDrawOrderSync(this.entity.getGuid(), this._processDrawOrderSync, this)
    }
    _recurseDrawOrderSync(e, t) {
        if (!(e instanceof V))
            return t;
        if (e.element) {
            const n = e.element.drawOrder;
            if (e.element.drawOrder = t++,
            e.element._batchGroupId >= 0 && n !== e.element.drawOrder) {
                var s;
                (s = this.system.app.batcher) == null || s.markGroupDirty(e.element._batchGroupId)
            }
        }
        e.particlesystem && (e.particlesystem.drawOrder = t++);
        const i = e.children;
        for (let n = 0; n < i.length; n++)
            t = this._recurseDrawOrderSync(i[n], t);
        return t
    }
    _processDrawOrderSync() {
        this._recurseDrawOrderSync(this.entity, 1),
        this.fire("syncdraworder")
    }
    _calcProjectionMatrix() {
        const e = this._resolution.x / this.scale
          , t = this._resolution.y / this.scale
          , s = 0
          , i = e
          , n = -t;
        this._screenMatrix.setOrtho(s, i, n, 0, 1, -1),
        this._screenSpace || (vv.setScale(.5 * e, .5 * t, 1),
        this._screenMatrix.mul2(vv, this._screenMatrix))
    }
    _updateScale() {
        this.scale = this._calcScale(this._resolution, this.referenceResolution)
    }
    _calcScale(e, t) {
        const s = Math.log2((e.x || 1) / t.x)
          , i = Math.log2((e.y || 1) / t.y);
        return Math.pow(2, s * (1 - this._scaleBlend) + i * this._scaleBlend)
    }
    _onResize(e, t) {
        this._screenSpace && (this._resolution.set(e, t),
        this.resolution = this._resolution)
    }
    _bindElement(e) {
        this._elements.add(e)
    }
    _unbindElement(e) {
        this._elements.delete(e)
    }
    onRemove() {
        this.system.app.graphicsDevice.off("resizecanvas", this._onResize, this),
        this.fire("remove"),
        this._elements.forEach(e => e._onScreenRemove()),
        this._elements.clear(),
        this.off()
    }
    set resolution(e) {
        this._screenSpace ? this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height) : this._resolution.set(e.x, e.y),
        this._updateScale(),
        this._calcProjectionMatrix(),
        this.entity._dirtyLocal || this.entity._dirtifyLocal(),
        this.fire("set:resolution", this._resolution),
        this._elements.forEach(t => t._onScreenResize(this._resolution))
    }
    get resolution() {
        return this._resolution
    }
    set referenceResolution(e) {
        this._referenceResolution.set(e.x, e.y),
        this._updateScale(),
        this._calcProjectionMatrix(),
        this.entity._dirtyLocal || this.entity._dirtifyLocal(),
        this.fire("set:referenceresolution", this._resolution),
        this._elements.forEach(t => t._onScreenResize(this._resolution))
    }
    get referenceResolution() {
        return this._scaleMode === so ? this._resolution : this._referenceResolution
    }
    set screenSpace(e) {
        this._screenSpace = e,
        this._screenSpace && this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height),
        this.resolution = this._resolution,
        this.entity._dirtyLocal || this.entity._dirtifyLocal(),
        this.fire("set:screenspace", this._screenSpace),
        this._elements.forEach(t => t._onScreenSpaceChange())
    }
    get screenSpace() {
        return this._screenSpace
    }
    set scaleMode(e) {
        e !== so && e !== wc && (e = so),
        !this._screenSpace && e !== so && (e = so),
        this._scaleMode = e,
        this.resolution = this._resolution,
        this.fire("set:scalemode", this._scaleMode)
    }
    get scaleMode() {
        return this._scaleMode
    }
    set scaleBlend(e) {
        this._scaleBlend = e,
        this._updateScale(),
        this._calcProjectionMatrix(),
        this.entity._dirtyLocal || this.entity._dirtifyLocal(),
        this.fire("set:scaleblend", this._scaleBlend),
        this._elements.forEach(t => t._onScreenResize(this._resolution))
    }
    get scaleBlend() {
        return this._scaleBlend
    }
    set priority(e) {
        e > 255 && (e = 255),
        this._priority !== e && (this._priority = e,
        this.syncDrawOrder())
    }
    get priority() {
        return this._priority
    }
}
class IO {
    constructor() {
        this.enabled = !0
    }
}
const cw = ["enabled"];
class LO extends it {
    constructor(e) {
        super(e),
        this.id = "screen",
        this.ComponentType = hw,
        this.DataType = IO,
        this.schema = cw,
        this.windowResolution = new P,
        this._drawOrderSyncQueue = new Yb,
        this.app.graphicsDevice.on("resizecanvas", this._onResize, this),
        this.app.systems.on("update", this._onUpdate, this),
        this.on("beforeremove", this.onRemoveComponent, this)
    }
    initializeComponentData(e, t, s) {
        t.priority !== void 0 && (e.priority = t.priority),
        t.screenSpace !== void 0 && (e.screenSpace = t.screenSpace),
        e.cull = e.screenSpace,
        t.scaleMode !== void 0 && (e.scaleMode = t.scaleMode),
        t.scaleBlend !== void 0 && (e.scaleBlend = t.scaleBlend),
        t.resolution !== void 0 && (t.resolution instanceof P ? e._resolution.copy(t.resolution) : e._resolution.set(t.resolution[0], t.resolution[1]),
        e.resolution = e._resolution),
        t.referenceResolution !== void 0 && (t.referenceResolution instanceof P ? e._referenceResolution.copy(t.referenceResolution) : e._referenceResolution.set(t.referenceResolution[0], t.referenceResolution[1]),
        e.referenceResolution = e._referenceResolution),
        e.syncDrawOrder(),
        super.initializeComponentData(e, t, s)
    }
    destroy() {
        super.destroy(),
        this.app.graphicsDevice.off("resizecanvas", this._onResize, this),
        this.app.systems.off("update", this._onUpdate, this)
    }
    _onUpdate(e) {
        const t = this.store;
        for (const s in t)
            t[s].entity.screen.update && t[s].entity.screen.update(e)
    }
    _onResize(e, t) {
        this.windowResolution.x = e,
        this.windowResolution.y = t
    }
    cloneComponent(e, t) {
        const s = e.screen;
        return this.addComponent(t, {
            enabled: s.enabled,
            screenSpace: s.screenSpace,
            scaleMode: s.scaleMode,
            resolution: s.resolution.clone(),
            referenceResolution: s.referenceResolution.clone()
        })
    }
    onRemoveComponent(e, t) {
        t.onRemove()
    }
    processDrawOrderSyncQueue() {
        const e = this._drawOrderSyncQueue.list();
        for (let t = 0; t < e.length; t++) {
            const s = e[t];
            s.callback.call(s.scope)
        }
        this._drawOrderSyncQueue.clear()
    }
    queueDrawOrderSync(e, t, s) {
        this._drawOrderSyncQueue.list().length || this.app.once("prerender", this.processDrawOrderSyncQueue, this),
        this._drawOrderSyncQueue.has(e) || this._drawOrderSyncQueue.push(e, {
            callback: t,
            scope: s
        })
    }
}
_e._buildAccessors(hw.prototype, cw);
class dw extends _e {
    constructor(e, t) {
        super(e, t),
        this.on("set_scripts", this.onSetScripts, this)
    }
    send(e, t) {
        const s = Array.prototype.slice.call(arguments, 2)
          , i = this.entity.script.instances;
        let n;
        if (i && i[e] && (n = i[e].instance[t],
        n))
            return n.apply(i[e].instance, s)
    }
    onEnable() {
        this.data.areScriptsLoaded && !this.system.preloading && (this.data.initialized ? this.system._enableScriptComponent(this) : this.system._initializeScriptComponent(this),
        this.data.postInitialized || this.system._postInitializeScriptComponent(this))
    }
    onDisable() {
        this.system._disableScriptComponent(this)
    }
    onSetScripts(e, t, s) {
        if (!this.system._inTools || this.runInTools) {
            if (this._updateScriptAttributes(t, s))
                return;
            this.enabled && this.system._disableScriptComponent(this),
            this.system._destroyScriptComponent(this),
            this.data.areScriptsLoaded = !1;
            const n = s.map(function(r) {
                return r.url
            });
            if (this._loadFromCache(n))
                return;
            this._loadScripts(n)
        }
    }
    _updateScriptAttributes(e, t) {
        let s = !0;
        if (e.length !== t.length)
            s = !1;
        else
            for (let i = 0, n = t.length; i < n; i++)
                if (e[i].url !== t[i].url) {
                    s = !1;
                    break
                }
        if (s)
            for (const i in this.instances)
                this.instances.hasOwnProperty(i) && this.system._updateAccessors(this.entity, this.instances[i]);
        return s
    }
    _loadFromCache(e) {
        const t = []
          , s = this.system.app._scriptPrefix || ""
          , i = /^http(s)?:\/\//i;
        for (let n = 0, r = e.length; n < r; n++) {
            let o = e[n];
            i.test(o) || (o = ye.join(s, o));
            const l = this.system.app.loader.getFromCache(o, "script");
            if (!l)
                return !1;
            t.push(l)
        }
        for (let n = 0, r = t.length; n < r; n++) {
            const o = t[n];
            if (o !== !0 && o && this.entity.script && !this.entity.script.instances[o._pcScriptName]) {
                const l = new o(this.entity);
                this.system._preRegisterInstance(this.entity, e[n], o._pcScriptName, l)
            }
        }
        return this.data && (this.data.areScriptsLoaded = !0),
        this.system.preloading || (this.system.onInitialize(this.entity),
        this.system.onPostInitialize(this.entity)),
        !0
    }
    _loadScripts(e) {
        let t = e.length;
        const s = this.system.app._scriptPrefix || "";
        e.forEach(i => {
            let n = null
              , r = null;
            i.toLowerCase().startsWith("http://") || i.toLowerCase().startsWith("https://") ? (r = i,
            n = i) : (r = i,
            n = ye.join(s, i)),
            this.system.app.loader.load(n, "script", (o, l) => {
                if (t--,
                o)
                    console.error(o);
                else if (l && this.entity.script && !this.entity.script.instances[l._pcScriptName]) {
                    const c = new l(this.entity);
                    this.system._preRegisterInstance(this.entity, r, l._pcScriptName, c)
                }
                t === 0 && (this.data.areScriptsLoaded = !0,
                this.system.preloading || (this.system.onInitialize(this.entity),
                this.system.onPostInitialize(this.entity)))
            }
            )
        }
        )
    }
}
class DO {
    constructor() {
        this.scripts = [],
        this.enabled = !0,
        this.instances = {},
        this._instances = {},
        this.runInTools = !1,
        this.attributes = {},
        this.initialized = !1,
        this.postInitialized = !1,
        this.areScriptsLoaded = !1
    }
}
const uw = ["enabled", "scripts", "instances", "runInTools"]
  , Ip = "initialize"
  , Lp = "postInitialize"
  , Dp = "update"
  , Op = "postUpdate"
  , Fp = "fixedUpdate"
  , Bp = "toolsUpdate"
  , OO = "onEnable"
  , FO = "onDisable";
class BO extends it {
    constructor(e) {
        super(e),
        this.id = "script",
        this.ComponentType = dw,
        this.DataType = DO,
        this.schema = uw,
        this.preloading = !1,
        this.instancesWithUpdate = [],
        this.instancesWithFixedUpdate = [],
        this.instancesWithPostUpdate = [],
        this.instancesWithToolsUpdate = [],
        this.on("beforeremove", this.onBeforeRemove, this),
        this.app.systems.on(Ip, this.onInitialize, this),
        this.app.systems.on(Lp, this.onPostInitialize, this),
        this.app.systems.on(Dp, this.onUpdate, this),
        this.app.systems.on(Fp, this.onFixedUpdate, this),
        this.app.systems.on(Op, this.onPostUpdate, this),
        this.app.systems.on(Bp, this.onToolsUpdate, this)
    }
    initializeComponentData(e, t, s) {
        s = ["runInTools", "enabled", "scripts"],
        t.scripts && t.scripts.length && t.scripts.forEach(function(i) {
            if (i.attributes && Array.isArray(i.attributes)) {
                const n = {};
                for (let r = 0; r < i.attributes.length; r++)
                    n[i.attributes[r].name] = i.attributes[r];
                i.attributes = n
            }
        }),
        super.initializeComponentData(e, t, s)
    }
    cloneComponent(e, t) {
        const s = this.store[e.getGuid()]
          , i = {
            runInTools: s.data.runInTools,
            scripts: [],
            enabled: s.data.enabled
        }
          , n = s.data.scripts;
        for (let r = 0, o = n.length; r < o; r++) {
            const l = n[r].attributes;
            l && delete n[r].attributes,
            i.scripts.push(or({}, n[r])),
            l && (i.scripts[r].attributes = this._cloneAttributes(l),
            n[r].attributes = l)
        }
        return this.addComponent(t, i)
    }
    onBeforeRemove(e, t) {
        t.enabled && this._disableScriptComponent(t),
        this._destroyScriptComponent(t)
    }
    onInitialize(e) {
        if (this._registerInstances(e),
        e.enabled) {
            e.script && e.script.enabled && this._initializeScriptComponent(e.script);
            const t = e._children;
            for (let s = 0, i = t.length; s < i; s++)
                t[s]instanceof V && this.onInitialize(t[s])
        }
    }
    onPostInitialize(e) {
        if (e.enabled) {
            e.script && e.script.enabled && this._postInitializeScriptComponent(e.script);
            const t = e._children;
            for (let s = 0, i = t.length; s < i; s++)
                t[s]instanceof V && this.onPostInitialize(t[s])
        }
    }
    _callInstancesMethod(e, t) {
        const s = e.data.instances;
        for (const i in s)
            if (s.hasOwnProperty(i)) {
                const n = s[i].instance;
                n[t] && n[t]()
            }
    }
    _initializeScriptComponent(e) {
        this._callInstancesMethod(e, Ip),
        e.data.initialized = !0,
        e.enabled && e.entity.enabled && this._enableScriptComponent(e)
    }
    _enableScriptComponent(e) {
        this._callInstancesMethod(e, OO)
    }
    _disableScriptComponent(e) {
        this._callInstancesMethod(e, FO)
    }
    _destroyScriptComponent(e) {
        const t = e.data.instances;
        for (const s in t)
            if (t.hasOwnProperty(s)) {
                const i = t[s].instance;
                if (i.destroy && i.destroy(),
                i.update) {
                    const n = this.instancesWithUpdate.indexOf(i);
                    n >= 0 && this.instancesWithUpdate.splice(n, 1)
                }
                if (i.fixedUpdate) {
                    const n = this.instancesWithFixedUpdate.indexOf(i);
                    n >= 0 && this.instancesWithFixedUpdate.splice(n, 1)
                }
                if (i.postUpdate) {
                    const n = this.instancesWithPostUpdate.indexOf(i);
                    n >= 0 && this.instancesWithPostUpdate.splice(n, 1)
                }
                if (i.toolsUpdate) {
                    const n = this.instancesWithToolsUpdate.indexOf(i);
                    n >= 0 && this.instancesWithToolsUpdate.splice(n, 1)
                }
                e.instances[s].instance === e[s] && delete e[s],
                delete e.instances[s]
            }
    }
    _postInitializeScriptComponent(e) {
        this._callInstancesMethod(e, Lp),
        e.data.postInitialized = !0
    }
    _updateInstances(e, t, s) {
        for (let i = 0, n = t.length; i < n; i++) {
            const r = t[i];
            r && r.entity && r.entity.enabled && r.entity.script.enabled && r[e](s)
        }
    }
    onUpdate(e) {
        this._updateInstances(Dp, this.instancesWithUpdate, e)
    }
    onFixedUpdate(e) {
        this._updateInstances(Fp, this.instancesWithFixedUpdate, e)
    }
    onPostUpdate(e) {
        this._updateInstances(Op, this.instancesWithPostUpdate, e)
    }
    onToolsUpdate(e) {
        this._updateInstances(Bp, this.instancesWithToolsUpdate, e)
    }
    broadcast(e, t) {
        const s = Array.prototype.slice.call(arguments, 2)
          , i = this.store;
        for (const n in i)
            if (i.hasOwnProperty(n)) {
                const r = i[n].data;
                if (r.instances[e]) {
                    const o = r.instances[e].instance[t];
                    o && o.apply(r.instances[e].instance, s)
                }
            }
    }
    _preRegisterInstance(e, t, s, i) {
        if (e.script) {
            if (e.script.data._instances = e.script.data._instances || {},
            e.script.data._instances[s])
                throw Error(`Script name collision '${s}'. Scripts from '${t}' and '${e.script.data._instances[s].url}' {${e.getGuid()}}`);
            e.script.data._instances[s] = {
                url: t,
                name: s,
                instance: i
            }
        }
    }
    _registerInstances(e) {
        if (e.script && e.script.data._instances) {
            e.script.instances = e.script.data._instances;
            for (const s in e.script.instances) {
                const i = e.script.instances[s]
                  , n = i.instance;
                if (y_.attach(n),
                n.update && this.instancesWithUpdate.push(n),
                n.fixedUpdate && this.instancesWithFixedUpdate.push(n),
                n.postUpdate && this.instancesWithPostUpdate.push(n),
                n.toolsUpdate && this.instancesWithToolsUpdate.push(n),
                e.script.scripts && this._createAccessors(e, i),
                e.script[s])
                    throw Error(`Script with name '${s}' is already attached to Script Component`);
                e.script[s] = n
            }
            delete e.script.data._instances
        }
        const t = e._children;
        for (let s = 0, i = t.length; s < i; s++)
            t[s]instanceof V && this._registerInstances(t[s])
    }
    _cloneAttributes(e) {
        const t = {};
        for (const s in e)
            if (e.hasOwnProperty(s))
                if (e[s].type !== "entity")
                    t[s] = or({}, e[s]);
                else {
                    const i = e[s].value;
                    delete e[s].value,
                    t[s] = or({}, e[s]),
                    t[s].value = i,
                    e[s].value = i
                }
        return t
    }
    _createAccessors(e, t) {
        const s = e.script.scripts.length
          , i = t.url;
        for (let n = 0; n < s; n++) {
            const r = e.script.scripts[n];
            if (r.url === i) {
                const o = r.attributes;
                if (r.name && o) {
                    for (const l in o)
                        o.hasOwnProperty(l) && this._createAccessor(o[l], t);
                    e.script.data.attributes[r.name] = this._cloneAttributes(o)
                }
                break
            }
        }
    }
    _createAccessor(e, t) {
        const s = this;
        e = {
            name: e.name,
            value: e.value,
            type: e.type
        },
        this._convertAttributeValue(e),
        Object.defineProperty(t.instance, e.name, {
            get: function() {
                return e.value
            },
            set: function(i) {
                const n = e.value;
                e.value = i,
                s._convertAttributeValue(e),
                t.instance.fire("set", e.name, n, e.value)
            },
            configurable: !0
        })
    }
    _updateAccessors(e, t) {
        const s = e.script.scripts.length
          , i = t.url;
        for (let n = 0; n < s; n++) {
            const r = e.script
              , o = r.scripts[n];
            if (o.url === i) {
                const l = o.name
                  , c = o.attributes;
                if (l) {
                    if (c)
                        for (const h in c)
                            c.hasOwnProperty(h) && this._createAccessor(c[h], t);
                    const d = r.data.attributes[l];
                    if (d)
                        for (const h in d) {
                            const u = d[h];
                            h in c ? c[h].value !== u.value && t.instance.onAttributeChanged && t.instance.onAttributeChanged(u.name, u.value, c[h].value) : delete t.instance[u.name]
                        }
                    c ? r.data.attributes[l] = this._cloneAttributes(c) : delete r.data.attributes[l]
                }
                break
            }
        }
    }
    _convertAttributeValue(e) {
        if (e.type === "rgb" || e.type === "rgba")
            Array.isArray(e.value) && (e.value = e.value.length === 3 ? new z(e.value[0],e.value[1],e.value[2]) : new z(e.value[0],e.value[1],e.value[2],e.value[3]));
        else if (e.type === "vec2")
            Array.isArray(e.value) && (e.value = new P(e.value[0],e.value[1]));
        else if (e.type === "vec3" || e.type === "vector")
            Array.isArray(e.value) && (e.value = new y(e.value[0],e.value[1],e.value[2]));
        else if (e.type === "vec4")
            Array.isArray(e.value) && (e.value = new M(e.value[0],e.value[1],e.value[2],e.value[3]));
        else if (e.type === "entity")
            e.value !== null && typeof e.value == "string" && (e.value = this.app.root.findByGuid(e.value));
        else if (e.type === "curve" || e.type === "colorcurve") {
            const t = e.value.keys[0]instanceof Array ? Qt : Ot;
            e.value = new t(e.value.keys),
            e.value.type = e.value.type
        }
    }
    destroy() {
        super.destroy(),
        this.app.systems.off(Ip, this.onInitialize, this),
        this.app.systems.off(Lp, this.onPostInitialize, this),
        this.app.systems.off(Dp, this.onUpdate, this),
        this.app.systems.off(Fp, this.onFixedUpdate, this),
        this.app.systems.off(Op, this.onPostUpdate, this),
        this.app.systems.off(Bp, this.onToolsUpdate, this)
    }
}
_e._buildAccessors(dw.prototype, uw);
const Yn = new P
  , Sv = new y
  , Vr = new cr
  , xv = new rT
  , wv = new y
  , Ll = new y
  , kO = new ne
  , NO = {
    x: "y",
    y: "x"
};
class bc extends fe {
    constructor(e, t) {
        if (super(),
        !e || !(e instanceof ts))
            throw new Error("Element was null or not an ElementComponent");
        if (t && t !== "x" && t !== "y")
            throw new Error("Unrecognized axis: " + t);
        this._element = e,
        this._app = e.system.app,
        this._axis = t || null,
        this._enabled = !0,
        this._dragScale = new y,
        this._dragStartMousePosition = new y,
        this._dragStartHandlePosition = new y,
        this._deltaMousePosition = new y,
        this._deltaHandlePosition = new y,
        this._isDragging = !1,
        this._toggleLifecycleListeners("on")
    }
    _toggleLifecycleListeners(e) {
        this._element[e]("mousedown", this._onMouseDownOrTouchStart, this),
        this._element[e]("touchstart", this._onMouseDownOrTouchStart, this),
        this._element[e]("selectstart", this._onMouseDownOrTouchStart, this)
    }
    _toggleDragListeners(e) {
        const t = e === "on";
        this._hasDragListeners && t || (this._app.mouse && (this._element[e]("mousemove", this._onMove, this),
        this._element[e]("mouseup", this._onMouseUpOrTouchEnd, this)),
        Le.touch && (this._element[e]("touchmove", this._onMove, this),
        this._element[e]("touchend", this._onMouseUpOrTouchEnd, this),
        this._element[e]("touchcancel", this._onMouseUpOrTouchEnd, this)),
        this._element[e]("selectmove", this._onMove, this),
        this._element[e]("selectend", this._onMouseUpOrTouchEnd, this),
        this._hasDragListeners = t)
    }
    _onMouseDownOrTouchStart(e) {
        if (this._element && !this._isDragging && this.enabled) {
            this._dragCamera = e.camera,
            this._calculateDragScale();
            const t = this._screenToLocal(e);
            t && (this._toggleDragListeners("on"),
            this._isDragging = !0,
            this._dragStartMousePosition.copy(t),
            this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition()),
            this.fire("drag:start"))
        }
    }
    _onMouseUpOrTouchEnd() {
        this._isDragging && (this._isDragging = !1,
        this._toggleDragListeners("off"),
        this.fire("drag:end"))
    }
    _screenToLocal(e) {
        return e.inputSource ? Vr.set(e.inputSource.getOrigin(), e.inputSource.getDirection()) : (this._determineInputPosition(e),
        this._chooseRayOriginAndDirection()),
        wv.copy(this._element.entity.forward).mulScalar(-1),
        xv.setFromPointNormal(this._element.entity.getPosition(), wv),
        xv.intersectsRay(Vr, Ll) ? (kO.copy(this._element.entity.getRotation()).invert().transformVector(Ll, Ll),
        Ll.mul(this._dragScale),
        Ll) : null
    }
    _determineInputPosition(e) {
        const t = this._app.graphicsDevice.maxPixelRatio;
        typeof e.x < "u" && typeof e.y < "u" ? (Yn.x = e.x * t,
        Yn.y = e.y * t) : e.changedTouches ? (Yn.x = e.changedTouches[0].x * t,
        Yn.y = e.changedTouches[0].y * t) : console.warn("Could not determine position from input event")
    }
    _chooseRayOriginAndDirection() {
        this._element.screen && this._element.screen.screen.screenSpace ? (Vr.origin.set(Yn.x, -Yn.y, 0),
        Vr.direction.copy(y.FORWARD)) : (Sv.copy(this._dragCamera.screenToWorld(Yn.x, Yn.y, 1)),
        Vr.origin.copy(this._dragCamera.entity.getPosition()),
        Vr.direction.copy(Sv).sub(Vr.origin).normalize())
    }
    _calculateDragScale() {
        let e = this._element.entity.parent;
        const t = this._element.screen && this._element.screen.screen
          , s = t && t.screenSpace
          , i = s ? t.scale : 1
          , n = this._dragScale;
        for (n.set(i, i, i); e && (n.mul(e.getLocalScale()),
        e = e.parent,
        !(s && e.screen)); )
            ;
        n.x = 1 / n.x,
        n.y = 1 / n.y,
        n.z = 0
    }
    _onMove(e) {
        const {_element: t, _deltaMousePosition: s, _deltaHandlePosition: i, _axis: n} = this;
        if (t && this._isDragging && this.enabled && t.enabled && t.entity.enabled) {
            const r = this._screenToLocal(e);
            if (r) {
                if (s.sub2(r, this._dragStartMousePosition),
                i.add2(this._dragStartHandlePosition, s),
                n) {
                    const o = t.entity.getLocalPosition()
                      , l = NO[n];
                    i[l] = o[l]
                }
                t.entity.setLocalPosition(i),
                this.fire("drag:move", i)
            }
        }
    }
    destroy() {
        this._toggleLifecycleListeners("off"),
        this._toggleDragListeners("off")
    }
    set enabled(e) {
        this._enabled = e
    }
    get enabled() {
        return this._enabled
    }
    get isDragging() {
        return this._isDragging
    }
}
bc.EVENT_DRAGSTART = "drag:start";
bc.EVENT_DRAGEND = "drag:end";
bc.EVENT_DRAGMOVE = "drag:move";
const UO = 0
  , yu = 1
  , zO = 2
  , VO = 0
  , _g = 1
  , Dl = new P;
class gg extends _e {
    constructor(e, t) {
        super(e, t),
        this._viewportReference = new Yr(this,"viewportEntity",{
            "element#gain": this._onViewportElementGain,
            "element#resize": this._onSetContentOrViewportSize
        }),
        this._contentReference = new Yr(this,"contentEntity",{
            "element#gain": this._onContentElementGain,
            "element#lose": this._onContentElementLose,
            "element#resize": this._onSetContentOrViewportSize
        }),
        this._scrollbarUpdateFlags = {},
        this._scrollbarReferences = {},
        this._scrollbarReferences[Se] = new Yr(this,"horizontalScrollbarEntity",{
            "scrollbar#set:value": this._onSetHorizontalScrollbarValue,
            "scrollbar#gain": this._onHorizontalScrollbarGain
        }),
        this._scrollbarReferences[Re] = new Yr(this,"verticalScrollbarEntity",{
            "scrollbar#set:value": this._onSetVerticalScrollbarValue,
            "scrollbar#gain": this._onVerticalScrollbarGain
        }),
        this._prevContentSizes = {},
        this._prevContentSizes[Se] = null,
        this._prevContentSizes[Re] = null,
        this._scroll = new P,
        this._velocity = new y,
        this._dragStartPosition = new y,
        this._disabledContentInput = !1,
        this._disabledContentInputEntities = [],
        this._toggleLifecycleListeners("on", e),
        this._toggleElementListeners("on")
    }
    _toggleLifecycleListeners(e, t) {
        this[e]("set_horizontal", this._onSetHorizontalScrollingEnabled, this),
        this[e]("set_vertical", this._onSetVerticalScrollingEnabled, this),
        t.app.systems.element[e]("add", this._onElementComponentAdd, this),
        t.app.systems.element[e]("beforeremove", this._onElementComponentRemove, this)
    }
    _toggleElementListeners(e) {
        if (this.entity.element) {
            if (e === "on" && this._hasElementListeners)
                return;
            this.entity.element[e]("resize", this._onSetContentOrViewportSize, this),
            this.entity.element[e](bh, this._onMouseWheel, this),
            this._hasElementListeners = e === "on"
        }
    }
    _onElementComponentAdd(e) {
        this.entity === e && this._toggleElementListeners("on")
    }
    _onElementComponentRemove(e) {
        this.entity === e && this._toggleElementListeners("off")
    }
    _onViewportElementGain() {
        this._syncAll()
    }
    _onContentElementGain() {
        this._destroyDragHelper(),
        this._contentDragHelper = new bc(this._contentReference.entity.element),
        this._contentDragHelper.on("drag:start", this._onContentDragStart, this),
        this._contentDragHelper.on("drag:end", this._onContentDragEnd, this),
        this._contentDragHelper.on("drag:move", this._onContentDragMove, this),
        this._prevContentSizes[Se] = null,
        this._prevContentSizes[Re] = null,
        this._syncAll()
    }
    _onContentElementLose() {
        this._destroyDragHelper()
    }
    _onContentDragStart() {
        this._contentReference.entity && this.enabled && this.entity.enabled && this._dragStartPosition.copy(this._contentReference.entity.getLocalPosition())
    }
    _onContentDragEnd() {
        this._prevContentDragPosition = null,
        this._enableContentInput()
    }
    _onContentDragMove(e) {
        if (this._contentReference.entity && this.enabled && this.entity.enabled && (this._wasDragged = !0,
        this._setScrollFromContentPosition(e),
        this._setVelocityFromContentPositionDelta(e),
        !this._disabledContentInput)) {
            const t = e.x - this._dragStartPosition.x
              , s = e.y - this._dragStartPosition.y;
            (Math.abs(t) > this.dragThreshold || Math.abs(s) > this.dragThreshold) && this._disableContentInput()
        }
    }
    _onSetContentOrViewportSize() {
        this._syncAll()
    }
    _onSetHorizontalScrollbarValue(e) {
        !this._scrollbarUpdateFlags[Se] && this.enabled && this.entity.enabled && this._onSetScroll(e, null)
    }
    _onSetVerticalScrollbarValue(e) {
        !this._scrollbarUpdateFlags[Re] && this.enabled && this.entity.enabled && this._onSetScroll(null, e)
    }
    _onSetHorizontalScrollingEnabled() {
        this._syncScrollbarEnabledState(Se)
    }
    _onSetVerticalScrollingEnabled() {
        this._syncScrollbarEnabledState(Re)
    }
    _onHorizontalScrollbarGain() {
        this._syncScrollbarEnabledState(Se),
        this._syncScrollbarPosition(Se)
    }
    _onVerticalScrollbarGain() {
        this._syncScrollbarEnabledState(Re),
        this._syncScrollbarPosition(Re)
    }
    _onSetScroll(e, t, s) {
        s !== !1 && this._velocity.set(0, 0, 0);
        const i = this._updateAxis(e, "x", Se)
          , n = this._updateAxis(t, "y", Re);
        (i || n) && this.fire("set:scroll", this._scroll)
    }
    _updateAxis(e, t, s) {
        const i = e !== null && Math.abs(e - this._scroll[t]) > 1e-5;
        return (i || this._isDragging() || e === 0) && (this._scroll[t] = this._determineNewScrollValue(e, t, s),
        this._syncContentPosition(s),
        this._syncScrollbarPosition(s)),
        i
    }
    _determineNewScrollValue(e, t, s) {
        if (!this._getScrollingEnabled(s))
            return this._scroll[t];
        switch (this.scrollMode) {
        case UO:
            return W.clamp(e, 0, this._getMaxScrollValue(s));
        case yu:
            return this._setVelocityFromOvershoot(e, t, s),
            e;
        case zO:
            return e;
        default:
            return console.warn("Unhandled scroll mode:" + this.scrollMode),
            e
        }
    }
    _syncAll() {
        this._syncContentPosition(Se),
        this._syncContentPosition(Re),
        this._syncScrollbarPosition(Se),
        this._syncScrollbarPosition(Re),
        this._syncScrollbarEnabledState(Se),
        this._syncScrollbarEnabledState(Re)
    }
    _syncContentPosition(e) {
        const t = this._getAxis(e)
          , s = this._getSign(e)
          , i = this._contentReference.entity;
        if (i) {
            const n = this._prevContentSizes[e]
              , r = this._getContentSize(e);
            if (n !== null && Math.abs(n - r) > 1e-4) {
                const c = this._getMaxOffset(e, n)
                  , d = this._getMaxOffset(e, r);
                d === 0 ? this._scroll[t] = 1 : this._scroll[t] = W.clamp(this._scroll[t] * c / d, 0, 1)
            }
            const o = this._scroll[t] * this._getMaxOffset(e)
              , l = i.getLocalPosition();
            l[t] = o * s,
            i.setLocalPosition(l),
            this._prevContentSizes[e] = r
        }
    }
    _syncScrollbarPosition(e) {
        const t = this._getAxis(e)
          , s = this._scrollbarReferences[e].entity;
        s && s.scrollbar && (this._scrollbarUpdateFlags[e] = !0,
        s.scrollbar.value = this._scroll[t],
        s.scrollbar.handleSize = this._getScrollbarHandleSize(t, e),
        this._scrollbarUpdateFlags[e] = !1)
    }
    _syncScrollbarEnabledState(e) {
        const t = this._scrollbarReferences[e].entity;
        if (t) {
            const s = this._getScrollingEnabled(e)
              , i = this._getScrollbarVisibility(e);
            switch (i) {
            case VO:
                t.enabled = s;
                return;
            case _g:
                t.enabled = s && this._contentIsLargerThanViewport(e);
                return;
            default:
                console.warn("Unhandled scrollbar visibility:" + i),
                t.enabled = s
            }
        }
    }
    _contentIsLargerThanViewport(e) {
        return this._getContentSize(e) > this._getViewportSize(e)
    }
    _contentPositionToScrollValue(e) {
        const t = this._getMaxOffset(Se)
          , s = this._getMaxOffset(Re);
        return t === 0 ? Dl.x = 0 : Dl.x = e.x / t,
        s === 0 ? Dl.y = 0 : Dl.y = e.y / -s,
        Dl
    }
    _getMaxOffset(e, t) {
        t = t === void 0 ? this._getContentSize(e) : t;
        const s = this._getViewportSize(e);
        return t < s ? -this._getViewportSize(e) : s - t
    }
    _getMaxScrollValue(e) {
        return this._contentIsLargerThanViewport(e) ? 1 : 0
    }
    _getScrollbarHandleSize(e, t) {
        const s = this._getViewportSize(t)
          , i = this._getContentSize(t);
        if (Math.abs(i) < .001)
            return 1;
        const n = Math.min(s / i, 1)
          , r = this._toOvershoot(this._scroll[e], t);
        return r === 0 ? n : n / (1 + Math.abs(r))
    }
    _getViewportSize(e) {
        return this._getSize(e, this._viewportReference)
    }
    _getContentSize(e) {
        return this._getSize(e, this._contentReference)
    }
    _getSize(e, t) {
        return t.entity && t.entity.element ? t.entity.element[this._getCalculatedDimension(e)] : 0
    }
    _getScrollingEnabled(e) {
        if (e === Se)
            return this.horizontal;
        if (e === Re)
            return this.vertical
    }
    _getScrollbarVisibility(e) {
        if (e === Se)
            return this.horizontalScrollbarVisibility;
        if (e === Re)
            return this.verticalScrollbarVisibility
    }
    _getSign(e) {
        return e === Se ? 1 : -1
    }
    _getAxis(e) {
        return e === Se ? "x" : "y"
    }
    _getCalculatedDimension(e) {
        return e === Se ? "calculatedWidth" : "calculatedHeight"
    }
    _destroyDragHelper() {
        this._contentDragHelper && this._contentDragHelper.destroy()
    }
    onUpdate() {
        this._contentReference.entity && (this._updateVelocity(),
        this._syncScrollbarEnabledState(Se),
        this._syncScrollbarEnabledState(Re))
    }
    _updateVelocity() {
        if (!this._isDragging()) {
            if (this.scrollMode === yu && (this._hasOvershoot("x", Se) && this._setVelocityFromOvershoot(this.scroll.x, "x", Se),
            this._hasOvershoot("y", Re) && this._setVelocityFromOvershoot(this.scroll.y, "y", Re)),
            Math.abs(this._velocity.x) > 1e-4 || Math.abs(this._velocity.y) > 1e-4) {
                const e = this._contentReference.entity.getLocalPosition();
                e.x += this._velocity.x,
                e.y += this._velocity.y,
                this._contentReference.entity.setLocalPosition(e),
                this._setScrollFromContentPosition(e)
            }
            this._velocity.x *= 1 - this.friction,
            this._velocity.y *= 1 - this.friction
        }
    }
    _hasOvershoot(e, t) {
        return Math.abs(this._toOvershoot(this.scroll[e], t)) > .001
    }
    _toOvershoot(e, t) {
        const s = this._getMaxScrollValue(t);
        return e < 0 ? e : e > s ? e - s : 0
    }
    _setVelocityFromOvershoot(e, t, s) {
        const n = this._toOvershoot(e, s) * this._getMaxOffset(s) * this._getSign(s);
        Math.abs(n) > 0 && (this._velocity[t] = -n / (this.bounceAmount * 50 + 1))
    }
    _setVelocityFromContentPositionDelta(e) {
        this._prevContentDragPosition ? (this._velocity.sub2(e, this._prevContentDragPosition),
        this._prevContentDragPosition.copy(e)) : (this._velocity.set(0, 0, 0),
        this._prevContentDragPosition = e.clone())
    }
    _setScrollFromContentPosition(e) {
        let t = this._contentPositionToScrollValue(e);
        this._isDragging() && (t = this._applyScrollValueTension(t)),
        this._onSetScroll(t.x, t.y, !1)
    }
    _applyScrollValueTension(e) {
        let s = this._getMaxScrollValue(Se)
          , i = this._toOvershoot(e.x, Se);
        return i > 0 ? e.x = s + 1 * Math.log10(1 + i) : i < 0 && (e.x = -1 * Math.log10(1 - i)),
        s = this._getMaxScrollValue(Re),
        i = this._toOvershoot(e.y, Re),
        i > 0 ? e.y = s + 1 * Math.log10(1 + i) : i < 0 && (e.y = -1 * Math.log10(1 - i)),
        e
    }
    _isDragging() {
        return this._contentDragHelper && this._contentDragHelper.isDragging
    }
    _setScrollbarComponentsEnabled(e) {
        this._scrollbarReferences[Se].hasComponent("scrollbar") && (this._scrollbarReferences[Se].entity.scrollbar.enabled = e),
        this._scrollbarReferences[Re].hasComponent("scrollbar") && (this._scrollbarReferences[Re].entity.scrollbar.enabled = e)
    }
    _setContentDraggingEnabled(e) {
        this._contentDragHelper && (this._contentDragHelper.enabled = e)
    }
    _onMouseWheel(e) {
        if (this.useMouseWheel) {
            const t = e.event
              , s = t.deltaX / this._contentReference.entity.element.calculatedWidth * this.mouseWheelSensitivity.x
              , i = t.deltaY / this._contentReference.entity.element.calculatedHeight * this.mouseWheelSensitivity.y
              , n = W.clamp(this._scroll.x + s, 0, this._getMaxScrollValue(Se))
              , r = W.clamp(this._scroll.y + i, 0, this._getMaxScrollValue(Re));
            this.scroll = new P(n,r)
        }
    }
    _enableContentInput() {
        for (; this._disabledContentInputEntities.length; ) {
            const e = this._disabledContentInputEntities.pop();
            e.element && (e.element.useInput = !0)
        }
        this._disabledContentInput = !1
    }
    _disableContentInput() {
        const e = s => {
            s.element && s.element.useInput && (this._disabledContentInputEntities.push(s),
            s.element.useInput = !1);
            const i = s.children;
            for (let n = 0, r = i.length; n < r; n++)
                e(i[n])
        }
          , t = this._contentReference.entity;
        if (t) {
            const s = t.children;
            for (let i = 0, n = s.length; i < n; i++)
                e(s[i])
        }
        this._disabledContentInput = !0
    }
    onEnable() {
        this._viewportReference.onParentComponentEnable(),
        this._contentReference.onParentComponentEnable(),
        this._scrollbarReferences[Se].onParentComponentEnable(),
        this._scrollbarReferences[Re].onParentComponentEnable(),
        this._setScrollbarComponentsEnabled(!0),
        this._setContentDraggingEnabled(!0),
        this._syncAll()
    }
    onDisable() {
        this._setScrollbarComponentsEnabled(!1),
        this._setContentDraggingEnabled(!1)
    }
    onRemove() {
        this._toggleLifecycleListeners("off", this.system),
        this._toggleElementListeners("off"),
        this._destroyDragHelper()
    }
    set scroll(e) {
        this._onSetScroll(e.x, e.y)
    }
    get scroll() {
        return this._scroll
    }
}
gg.EVENT_SETSCROLL = "set:scroll";
class GO {
    constructor() {
        this.enabled = !0
    }
}
const Zm = [{
    name: "enabled",
    type: "boolean"
}, {
    name: "horizontal",
    type: "boolean"
}, {
    name: "vertical",
    type: "boolean"
}, {
    name: "scrollMode",
    type: "number"
}, {
    name: "bounceAmount",
    type: "number"
}, {
    name: "friction",
    type: "number"
}, {
    name: "dragThreshold",
    type: "number"
}, {
    name: "useMouseWheel",
    type: "boolean"
}, {
    name: "mouseWheelSensitivity",
    type: "vec2"
}, {
    name: "horizontalScrollbarVisibility",
    type: "number"
}, {
    name: "verticalScrollbarVisibility",
    type: "number"
}, {
    name: "viewportEntity",
    type: "entity"
}, {
    name: "contentEntity",
    type: "entity"
}, {
    name: "horizontalScrollbarEntity",
    type: "entity"
}, {
    name: "verticalScrollbarEntity",
    type: "entity"
}]
  , HO = 10;
class WO extends it {
    constructor(e) {
        super(e),
        this.id = "scrollview",
        this.ComponentType = gg,
        this.DataType = GO,
        this.schema = Zm,
        this.on("beforeremove", this._onRemoveComponent, this),
        this.app.systems.on("update", this.onUpdate, this)
    }
    initializeComponentData(e, t, s) {
        t.dragThreshold === void 0 && (t.dragThreshold = HO),
        t.useMouseWheel === void 0 && (t.useMouseWheel = !0),
        t.mouseWheelSensitivity === void 0 && (t.mouseWheelSensitivity = new P(1,1)),
        super.initializeComponentData(e, t, Zm)
    }
    onUpdate(e) {
        const t = this.store;
        for (const s in t) {
            const i = t[s].entity
              , n = i.scrollview;
            n.enabled && i.enabled && n.onUpdate()
        }
    }
    _onRemoveComponent(e, t) {
        t.onRemove()
    }
    destroy() {
        super.destroy(),
        this.app.systems.off("update", this.onUpdate, this)
    }
}
_e._buildAccessors(gg.prototype, Zm);
class yg extends _e {
    constructor(e, t) {
        super(e, t),
        this._handleReference = new Yr(this,"handleEntity",{
            "element#gain": this._onHandleElementGain,
            "element#lose": this._onHandleElementLose,
            "element#set:anchor": this._onSetHandleAlignment,
            "element#set:margin": this._onSetHandleAlignment,
            "element#set:pivot": this._onSetHandleAlignment
        }),
        this._toggleLifecycleListeners("on")
    }
    _toggleLifecycleListeners(e) {
        this[e]("set_value", this._onSetValue, this),
        this[e]("set_handleSize", this._onSetHandleSize, this),
        this[e]("set_orientation", this._onSetOrientation, this)
    }
    _onHandleElementGain() {
        this._destroyDragHelper(),
        this._handleDragHelper = new bc(this._handleReference.entity.element,this._getAxis()),
        this._handleDragHelper.on("drag:move", this._onHandleDrag, this),
        this._updateHandlePositionAndSize()
    }
    _onHandleElementLose() {
        this._destroyDragHelper()
    }
    _onHandleDrag(e) {
        this._handleReference.entity && this.enabled && this.entity.enabled && (this.value = this._handlePositionToScrollValue(e[this._getAxis()]))
    }
    _onSetValue(e, t, s) {
        Math.abs(s - t) > 1e-5 && (this.data.value = W.clamp(s, 0, 1),
        this._updateHandlePositionAndSize(),
        this.fire("set:value", this.data.value))
    }
    _onSetHandleSize(e, t, s) {
        Math.abs(s - t) > 1e-5 && (this.data.handleSize = W.clamp(s, 0, 1),
        this._updateHandlePositionAndSize())
    }
    _onSetHandleAlignment() {
        this._updateHandlePositionAndSize()
    }
    _onSetOrientation(e, t, s) {
        s !== t && this._handleReference.hasComponent("element") && (this._handleReference.entity.element[this._getOppositeDimension()] = 0)
    }
    _updateHandlePositionAndSize() {
        const e = this._handleReference.entity
          , t = e && e.element;
        if (e) {
            const s = e.getLocalPosition();
            s[this._getAxis()] = this._getHandlePosition(),
            this._handleReference.entity.setLocalPosition(s)
        }
        t && (t[this._getDimension()] = this._getHandleLength())
    }
    _handlePositionToScrollValue(e) {
        return e * this._getSign() / this._getUsableTrackLength()
    }
    _scrollValueToHandlePosition(e) {
        return e * this._getSign() * this._getUsableTrackLength()
    }
    _getUsableTrackLength() {
        return Math.max(this._getTrackLength() - this._getHandleLength(), .001)
    }
    _getTrackLength() {
        return this.entity.element ? this.orientation === Se ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight : 0
    }
    _getHandleLength() {
        return this._getTrackLength() * this.handleSize
    }
    _getHandlePosition() {
        return this._scrollValueToHandlePosition(this.value)
    }
    _getSign() {
        return this.orientation === Se ? 1 : -1
    }
    _getAxis() {
        return this.orientation === Se ? "x" : "y"
    }
    _getDimension() {
        return this.orientation === Se ? "width" : "height"
    }
    _getOppositeDimension() {
        return this.orientation === Se ? "height" : "width"
    }
    _destroyDragHelper() {
        this._handleDragHelper && this._handleDragHelper.destroy()
    }
    _setHandleDraggingEnabled(e) {
        this._handleDragHelper && (this._handleDragHelper.enabled = e)
    }
    onEnable() {
        this._handleReference.onParentComponentEnable(),
        this._setHandleDraggingEnabled(!0)
    }
    onDisable() {
        this._setHandleDraggingEnabled(!1)
    }
    onRemove() {
        this._destroyDragHelper(),
        this._toggleLifecycleListeners("off")
    }
}
yg.EVENT_SETVALUE = "set:value";
class XO {
    constructor() {
        this.enabled = !0
    }
}
const Qm = [{
    name: "enabled",
    type: "boolean"
}, {
    name: "orientation",
    type: "number"
}, {
    name: "value",
    type: "number"
}, {
    name: "handleSize",
    type: "number"
}, {
    name: "handleEntity",
    type: "entity"
}];
class jO extends it {
    constructor(e) {
        super(e),
        this.id = "scrollbar",
        this.ComponentType = yg,
        this.DataType = XO,
        this.schema = Qm,
        this.on("beforeremove", this._onRemoveComponent, this)
    }
    initializeComponentData(e, t, s) {
        super.initializeComponentData(e, t, Qm)
    }
    _onRemoveComponent(e, t) {
        t.onRemove()
    }
}
_e._buildAccessors(yg.prototype, Qm);
const $O = {
    volume: 0,
    pitch: 0,
    loop: !1,
    startTime: 0,
    duration: 0,
    position: new y,
    maxDistance: 0,
    refDistance: 0,
    rollOffFactor: 0,
    distanceModel: 0,
    onPlay: null,
    onPause: null,
    onResume: null,
    onStop: null,
    onEnd: null
};
class lr extends fe {
    constructor(e, t="Untitled", s={}) {
        super(),
        this.name = void 0,
        this.instances = [],
        this._component = e,
        this._assets = e.system.app.assets,
        this._manager = e.system.manager,
        this.name = t,
        this._volume = s.volume !== void 0 ? W.clamp(Number(s.volume) || 0, 0, 1) : 1,
        this._pitch = s.pitch !== void 0 ? Math.max(.01, Number(s.pitch) || 0) : 1,
        this._loop = !!(s.loop !== void 0 && s.loop),
        this._duration = s.duration > 0 ? s.duration : null,
        this._startTime = Math.max(0, Number(s.startTime) || 0),
        this._overlap = !!s.overlap,
        this._autoPlay = !!s.autoPlay,
        this._firstNode = null,
        this._lastNode = null,
        this._asset = s.asset,
        this._asset instanceof le && (this._asset = this._asset.id),
        this._onInstancePlayHandler = this._onInstancePlay.bind(this),
        this._onInstancePauseHandler = this._onInstancePause.bind(this),
        this._onInstanceResumeHandler = this._onInstanceResume.bind(this),
        this._onInstanceStopHandler = this._onInstanceStop.bind(this),
        this._onInstanceEndHandler = this._onInstanceEnd.bind(this)
    }
    play() {
        if (this.overlap || this.stop(),
        !this.isLoaded && !this._hasAsset())
            return;
        const e = this._createInstance();
        if (this.instances.push(e),
        this.isLoaded)
            e.play();
        else {
            const t = function(i) {
                const n = e._playWhenLoaded;
                e.sound = i,
                n && e.play()
            };
            this.off("load", t),
            this.once("load", t),
            this.load()
        }
        return e
    }
    pause() {
        let e = !1;
        const t = this.instances;
        for (let s = 0, i = t.length; s < i; s++)
            t[s].pause() && (e = !0);
        return e
    }
    resume() {
        let e = !1;
        const t = this.instances;
        for (let s = 0, i = t.length; s < i; s++)
            t[s].resume() && (e = !0);
        return e
    }
    stop() {
        let e = !1;
        const t = this.instances;
        let s = t.length;
        for (; s--; )
            t[s].stop(),
            e = !0;
        return t.length = 0,
        e
    }
    load() {
        if (!this._hasAsset())
            return;
        const e = this._assets.get(this._asset);
        if (!e) {
            this._assets.off("add:" + this._asset, this._onAssetAdd, this),
            this._assets.once("add:" + this._asset, this._onAssetAdd, this);
            return
        }
        if (e.off("remove", this._onAssetRemoved, this),
        e.on("remove", this._onAssetRemoved, this),
        !e.resource) {
            e.off("load", this._onAssetLoad, this),
            e.once("load", this._onAssetLoad, this),
            this._assets.load(e);
            return
        }
        this.fire("load", e.resource)
    }
    setExternalNodes(e, t) {
        if (!e) {
            console.error("The firstNode must have a valid AudioNode");
            return
        }
        if (t || (t = e),
        this._firstNode = e,
        this._lastNode = t,
        !this._overlap) {
            const s = this.instances;
            for (let i = 0, n = s.length; i < n; i++)
                s[i].setExternalNodes(e, t)
        }
    }
    clearExternalNodes() {
        if (this._firstNode = null,
        this._lastNode = null,
        !this._overlap) {
            const e = this.instances;
            for (let t = 0, s = e.length; t < s; t++)
                e[t].clearExternalNodes()
        }
    }
    getExternalNodes() {
        return [this._firstNode, this._lastNode]
    }
    _hasAsset() {
        return this._asset != null
    }
    _createInstance() {
        let e = null;
        const t = this._component;
        let s = null;
        if (this._hasAsset()) {
            const n = this._assets.get(this._asset);
            n && (s = n.resource)
        }
        const i = $O;
        return i.volume = this._volume * t.volume,
        i.pitch = this._pitch * t.pitch,
        i.loop = this._loop,
        i.startTime = this._startTime,
        i.duration = this._duration,
        i.onPlay = this._onInstancePlayHandler,
        i.onPause = this._onInstancePauseHandler,
        i.onResume = this._onInstanceResumeHandler,
        i.onStop = this._onInstanceStopHandler,
        i.onEnd = this._onInstanceEndHandler,
        t.positional ? (i.position.copy(t.entity.getPosition()),
        i.maxDistance = t.maxDistance,
        i.refDistance = t.refDistance,
        i.rollOffFactor = t.rollOffFactor,
        i.distanceModel = t.distanceModel,
        e = new co(this._manager,s,i)) : e = new Xs(this._manager,s,i),
        this._firstNode && e.setExternalNodes(this._firstNode, this._lastNode),
        e
    }
    _onInstancePlay(e) {
        this.fire("play", e),
        this._component.fire("play", this, e)
    }
    _onInstancePause(e) {
        this.fire("pause", e),
        this._component.fire("pause", this, e)
    }
    _onInstanceResume(e) {
        this.fire("resume", e),
        this._component.fire("resume", this, e)
    }
    _onInstanceStop(e) {
        const t = this.instances.indexOf(e);
        t !== -1 && this.instances.splice(t, 1),
        this.fire("stop", e),
        this._component.fire("stop", this, e)
    }
    _onInstanceEnd(e) {
        const t = this.instances.indexOf(e);
        t !== -1 && this.instances.splice(t, 1),
        this.fire("end", e),
        this._component.fire("end", this, e)
    }
    _onAssetAdd(e) {
        this.load()
    }
    _onAssetLoad(e) {
        this.load()
    }
    _onAssetRemoved(e) {
        e.off("remove", this._onAssetRemoved, this),
        this._assets.off("add:" + e.id, this._onAssetAdd, this),
        this.stop()
    }
    updatePosition(e) {
        const t = this.instances;
        for (let s = 0, i = t.length; s < i; s++)
            t[s].position = e
    }
    set asset(e) {
        const t = this._asset;
        if (t) {
            this._assets.off("add:" + t, this._onAssetAdd, this);
            const s = this._assets.get(t);
            s && s.off("remove", this._onAssetRemoved, this)
        }
        this._asset = e,
        this._asset instanceof le && (this._asset = this._asset.id),
        this._hasAsset() && this._component.enabled && this._component.entity.enabled && this.load()
    }
    get asset() {
        return this._asset
    }
    set autoPlay(e) {
        this._autoPlay = !!e
    }
    get autoPlay() {
        return this._autoPlay
    }
    set duration(e) {
        if (this._duration = Math.max(0, Number(e) || 0) || null,
        !this._overlap) {
            const t = this.instances;
            for (let s = 0, i = t.length; s < i; s++)
                t[s].duration = this._duration
        }
    }
    get duration() {
        let e = 0;
        if (this._hasAsset()) {
            const t = this._assets.get(this._asset);
            e = t != null && t.resource ? t.resource.duration : 0
        }
        return this._duration != null ? this._duration % (e || 1) : e
    }
    get isLoaded() {
        if (this._hasAsset()) {
            const e = this._assets.get(this._asset);
            if (e)
                return !!e.resource
        }
        return !1
    }
    get isPaused() {
        const e = this.instances
          , t = e.length;
        if (t === 0)
            return !1;
        for (let s = 0; s < t; s++)
            if (!e[s].isPaused)
                return !1;
        return !0
    }
    get isPlaying() {
        const e = this.instances;
        for (let t = 0, s = e.length; t < s; t++)
            if (e[t].isPlaying)
                return !0;
        return !1
    }
    get isStopped() {
        const e = this.instances;
        for (let t = 0, s = e.length; t < s; t++)
            if (!e[t].isStopped)
                return !1;
        return !0
    }
    set loop(e) {
        this._loop = !!e;
        const t = this.instances;
        for (let s = 0, i = t.length; s < i; s++)
            t[s].loop = this._loop
    }
    get loop() {
        return this._loop
    }
    set overlap(e) {
        this._overlap = !!e
    }
    get overlap() {
        return this._overlap
    }
    set pitch(e) {
        if (this._pitch = Math.max(Number(e) || 0, .01),
        !this._overlap) {
            const t = this.instances;
            for (let s = 0, i = t.length; s < i; s++)
                t[s].pitch = this.pitch * this._component.pitch
        }
    }
    get pitch() {
        return this._pitch
    }
    set startTime(e) {
        if (this._startTime = Math.max(0, Number(e) || 0),
        !this._overlap) {
            const t = this.instances;
            for (let s = 0, i = t.length; s < i; s++)
                t[s].startTime = this._startTime
        }
    }
    get startTime() {
        return this._startTime
    }
    set volume(e) {
        if (this._volume = W.clamp(Number(e) || 0, 0, 1),
        !this._overlap) {
            const t = this.instances;
            for (let s = 0, i = t.length; s < i; s++)
                t[s].volume = this._volume * this._component.volume
        }
    }
    get volume() {
        return this._volume
    }
}
lr.EVENT_PLAY = "play";
lr.EVENT_PAUSE = "pause";
lr.EVENT_RESUME = "resume";
lr.EVENT_STOP = "stop";
lr.EVENT_LOAD = "load";
class Ia extends _e {
    constructor(e, t) {
        super(e, t),
        this._volume = 1,
        this._pitch = 1,
        this._positional = !0,
        this._refDistance = 1,
        this._maxDistance = 1e4,
        this._rollOffFactor = 1,
        this._distanceModel = Du,
        this._slots = {},
        this._playingBeforeDisable = {}
    }
    _updateSoundInstances(e, t, s) {
        const i = this._slots;
        for (const n in i) {
            const r = i[n];
            if (!r.overlap) {
                const o = r.instances;
                for (let l = 0, c = o.length; l < c; l++)
                    o[l][e] = s ? r[e] * t : t
            }
        }
    }
    set distanceModel(e) {
        this._distanceModel = e,
        this._updateSoundInstances("distanceModel", e, !1)
    }
    get distanceModel() {
        return this._distanceModel
    }
    set maxDistance(e) {
        this._maxDistance = e,
        this._updateSoundInstances("maxDistance", e, !1)
    }
    get maxDistance() {
        return this._maxDistance
    }
    set refDistance(e) {
        this._refDistance = e,
        this._updateSoundInstances("refDistance", e, !1)
    }
    get refDistance() {
        return this._refDistance
    }
    set rollOffFactor(e) {
        this._rollOffFactor = e,
        this._updateSoundInstances("rollOffFactor", e, !1)
    }
    get rollOffFactor() {
        return this._rollOffFactor
    }
    set pitch(e) {
        this._pitch = e,
        this._updateSoundInstances("pitch", e, !0)
    }
    get pitch() {
        return this._pitch
    }
    set volume(e) {
        this._volume = e,
        this._updateSoundInstances("volume", e, !0)
    }
    get volume() {
        return this._volume
    }
    set positional(e) {
        this._positional = e;
        const t = this._slots;
        for (const s in t) {
            const i = t[s];
            if (!i.overlap) {
                const n = i.instances
                  , r = n.length;
                for (let o = r - 1; o >= 0; o--) {
                    const l = n[o].isPlaying || n[o].isSuspended
                      , c = n[o].currentTime;
                    l && n[o].stop();
                    const d = i._createInstance();
                    l && (d.play(),
                    d.currentTime = c),
                    n.push(d)
                }
            }
        }
    }
    get positional() {
        return this._positional
    }
    set slots(e) {
        const t = this._slots;
        if (t)
            for (const i in t)
                t[i].stop();
        const s = {};
        for (const i in e)
            e[i]instanceof lr ? s[e[i].name] = e[i] : e[i].name && (s[e[i].name] = new lr(this,e[i].name,e[i]));
        this._slots = s,
        this.enabled && this.entity.enabled && this.onEnable()
    }
    get slots() {
        return this._slots
    }
    onEnable() {
        if (this.system._inTools)
            return;
        const e = this._slots
          , t = this._playingBeforeDisable;
        for (const s in e) {
            const i = e[s];
            i.autoPlay && i.isStopped ? i.play() : t[s] ? i.resume() : i.isLoaded || i.load()
        }
    }
    onDisable() {
        const e = this._slots
          , t = {};
        for (const s in e)
            e[s].overlap || e[s].isPlaying && (e[s].pause(),
            t[s] = !0);
        this._playingBeforeDisable = t
    }
    onRemove() {
        this.off()
    }
    addSlot(e, t) {
        const s = this._slots;
        if (s[e])
            return null;
        const i = new lr(this,e,t);
        return s[e] = i,
        i.autoPlay && this.enabled && this.entity.enabled && i.play(),
        i
    }
    removeSlot(e) {
        const t = this._slots;
        t[e] && (t[e].stop(),
        delete t[e])
    }
    slot(e) {
        return this._slots[e]
    }
    _getSlotProperty(e, t) {
        if (!this.enabled || !this.entity.enabled)
            return;
        const s = this._slots[e];
        if (s)
            return s[t]
    }
    isPlaying(e) {
        return this._getSlotProperty(e, "isPlaying") || !1
    }
    isLoaded(e) {
        return this._getSlotProperty(e, "isLoaded") || !1
    }
    isPaused(e) {
        return this._getSlotProperty(e, "isPaused") || !1
    }
    isStopped(e) {
        return this._getSlotProperty(e, "isStopped") || !1
    }
    play(e) {
        if (!this.enabled || !this.entity.enabled)
            return null;
        const t = this._slots[e];
        return t ? t.play() : null
    }
    pause(e) {
        const t = this._slots;
        if (e) {
            const s = t[e];
            if (!s)
                return;
            s.pause()
        } else
            for (const s in t)
                t[s].pause()
    }
    resume(e) {
        const t = this._slots;
        if (e) {
            const s = t[e];
            if (!s)
                return;
            s.isPaused && s.resume()
        } else
            for (const s in t)
                t[s].resume()
    }
    stop(e) {
        const t = this._slots;
        if (e) {
            const s = t[e];
            if (!s)
                return;
            s.stop()
        } else
            for (const s in t)
                t[s].stop()
    }
}
Ia.EVENT_PLAY = "play";
Ia.EVENT_PAUSE = "pause";
Ia.EVENT_RESUME = "resume";
Ia.EVENT_STOP = "stop";
Ia.EVENT_END = "end";
class qO {
    constructor() {
        this.enabled = !0
    }
}
const fw = ["enabled"];
class YO extends it {
    constructor(e) {
        super(e),
        this.id = "sound",
        this.ComponentType = Ia,
        this.DataType = qO,
        this.schema = fw,
        this.manager = e.soundManager,
        this.app.systems.on("update", this.onUpdate, this),
        this.on("beforeremove", this.onBeforeRemove, this)
    }
    set volume(e) {
        this.manager.volume = e
    }
    get volume() {
        return this.manager.volume
    }
    get context() {
        return Fn() ? this.manager.context : null
    }
    initializeComponentData(e, t, s) {
        s = ["volume", "pitch", "positional", "refDistance", "maxDistance", "rollOffFactor", "distanceModel", "slots"];
        for (let i = 0; i < s.length; i++)
            t.hasOwnProperty(s[i]) && (e[s[i]] = t[s[i]]);
        super.initializeComponentData(e, t, ["enabled"])
    }
    cloneComponent(e, t) {
        const s = e.sound
          , i = s.slots
          , n = {};
        for (const o in i) {
            const l = i[o];
            n[o] = {
                name: l.name,
                volume: l.volume,
                pitch: l.pitch,
                loop: l.loop,
                duration: l.duration,
                startTime: l.startTime,
                overlap: l.overlap,
                autoPlay: l.autoPlay,
                asset: l.asset
            }
        }
        const r = {
            distanceModel: s.distanceModel,
            enabled: s.enabled,
            maxDistance: s.maxDistance,
            pitch: s.pitch,
            positional: s.positional,
            refDistance: s.refDistance,
            rollOffFactor: s.rollOffFactor,
            slots: n,
            volume: s.volume
        };
        return this.addComponent(t, r)
    }
    onUpdate(e) {
        const t = this.store;
        for (const s in t)
            if (t.hasOwnProperty(s)) {
                const n = t[s].entity;
                if (n.enabled) {
                    const r = n.sound;
                    if (r.enabled && r.positional) {
                        const o = n.getPosition()
                          , l = r.slots;
                        for (const c in l)
                            l[c].updatePosition(o)
                    }
                }
            }
    }
    onBeforeRemove(e, t) {
        const s = t.slots;
        for (const i in s)
            s[i].overlap || s[i].stop();
        t.onRemove()
    }
    destroy() {
        super.destroy(),
        this.app.systems.off("update", this.onUpdate, this)
    }
}
_e._buildAccessors(Ia.prototype, fw);
const bv = "simple"
  , Tv = "animated";
class Cn extends fe {
    constructor(e, t) {
        super(),
        this._component = e,
        this._frame = 0,
        this._sprite = null,
        this._spriteAsset = null,
        this.spriteAsset = t.spriteAsset,
        this.name = t.name,
        this.fps = t.fps || 0,
        this.loop = t.loop || !1,
        this._playing = !1,
        this._paused = !1,
        this._time = 0
    }
    get duration() {
        if (this._sprite) {
            const e = this.fps || Number.MIN_VALUE;
            return this._sprite.frameKeys.length / Math.abs(e)
        }
        return 0
    }
    set frame(e) {
        this._setFrame(e);
        const t = this.fps || Number.MIN_VALUE;
        this._setTime(this._frame / t)
    }
    get frame() {
        return this._frame
    }
    get isPaused() {
        return this._paused
    }
    get isPlaying() {
        return this._playing
    }
    set sprite(e) {
        if (this._sprite && (this._sprite.off("set:meshes", this._onSpriteMeshesChange, this),
        this._sprite.off("set:pixelsPerUnit", this._onSpritePpuChanged, this),
        this._sprite.off("set:atlas", this._onSpriteMeshesChange, this),
        this._sprite.atlas && this._sprite.atlas.off("set:texture", this._onSpriteMeshesChange, this)),
        this._sprite = e,
        this._sprite && (this._sprite.on("set:meshes", this._onSpriteMeshesChange, this),
        this._sprite.on("set:pixelsPerUnit", this._onSpritePpuChanged, this),
        this._sprite.on("set:atlas", this._onSpriteMeshesChange, this),
        this._sprite.atlas && this._sprite.atlas.on("set:texture", this._onSpriteMeshesChange, this)),
        this._component.currentClip === this) {
            let t;
            !e || !e.atlas ? (t = this._component._meshInstance,
            t && (t.deleteParameter("texture_emissiveMap"),
            t.deleteParameter("texture_opacityMap")),
            this._component._hideModel()) : (e.atlas.texture && (t = this._component._meshInstance,
            t && (t.setParameter("texture_emissiveMap", e.atlas.texture),
            t.setParameter("texture_opacityMap", e.atlas.texture)),
            this._component.enabled && this._component.entity.enabled && this._component._showModel()),
            this.time && this.fps ? this.time = this.time : this.frame = this.frame)
        }
    }
    get sprite() {
        return this._sprite
    }
    set spriteAsset(e) {
        const t = this._component.system.app.assets;
        let s = e;
        if (e instanceof le && (s = e.id),
        this._spriteAsset !== s) {
            if (this._spriteAsset) {
                const i = t.get(this._spriteAsset);
                i && this._unbindSpriteAsset(i)
            }
            if (this._spriteAsset = s,
            this._spriteAsset) {
                const i = t.get(this._spriteAsset);
                i ? this._bindSpriteAsset(i) : (this.sprite = null,
                t.on("add:" + this._spriteAsset, this._onSpriteAssetAdded, this))
            } else
                this.sprite = null
        }
    }
    get spriteAsset() {
        return this._spriteAsset
    }
    set time(e) {
        this._setTime(e),
        this._sprite ? this.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps))) : this.frame = 0
    }
    get time() {
        return this._time
    }
    _onSpriteAssetAdded(e) {
        this._component.system.app.assets.off("add:" + e.id, this._onSpriteAssetAdded, this),
        this._spriteAsset === e.id && this._bindSpriteAsset(e)
    }
    _bindSpriteAsset(e) {
        e.on("load", this._onSpriteAssetLoad, this),
        e.on("remove", this._onSpriteAssetRemove, this),
        e.resource ? this._onSpriteAssetLoad(e) : this._component.system.app.assets.load(e)
    }
    _unbindSpriteAsset(e) {
        e && (e.off("load", this._onSpriteAssetLoad, this),
        e.off("remove", this._onSpriteAssetRemove, this),
        e.resource && !e.resource.atlas && this._component.system.app.assets.off("load:" + e.data.textureAtlasAsset, this._onTextureAtlasLoad, this))
    }
    _onSpriteAssetLoad(e) {
        if (!e.resource)
            this.sprite = null;
        else if (e.resource.atlas)
            this.sprite = e.resource;
        else {
            const t = e.data.textureAtlasAsset
              , s = this._component.system.app.assets;
            s.off("load:" + t, this._onTextureAtlasLoad, this),
            s.once("load:" + t, this._onTextureAtlasLoad, this)
        }
    }
    _onTextureAtlasLoad(e) {
        const t = this._spriteAsset;
        t instanceof le ? this._onSpriteAssetLoad(t) : this._onSpriteAssetLoad(this._component.system.app.assets.get(t))
    }
    _onSpriteAssetRemove(e) {
        this.sprite = null
    }
    _onSpriteMeshesChange() {
        this._component.currentClip === this && this._component._showFrame(this.frame)
    }
    _onSpritePpuChanged() {
        this._component.currentClip === this && this.sprite.renderMode !== gn && this._component._showFrame(this.frame)
    }
    _update(e) {
        if (this.fps === 0 || !this._playing || this._paused || !this._sprite)
            return;
        const t = this.fps < 0 ? -1 : 1
          , s = this._time + e * this._component.speed * t
          , i = this.duration
          , n = s > i || s < 0;
        this._setTime(s);
        let r = this.frame;
        this._sprite ? r = Math.floor(this._sprite.frameKeys.length * this._time / i) : r = 0,
        r !== this._frame && this._setFrame(r),
        n && (this.loop ? (this.fire("loop"),
        this._component.fire("loop", this)) : (this._playing = !1,
        this._paused = !1,
        this.fire("end"),
        this._component.fire("end", this)))
    }
    _setTime(e) {
        this._time = e;
        const t = this.duration;
        this._time < 0 ? this.loop ? this._time = this._time % t + t : this._time = 0 : this._time > t && (this.loop ? this._time %= t : this._time = t)
    }
    _setFrame(e) {
        this._sprite ? this._frame = W.clamp(e, 0, this._sprite.frameKeys.length - 1) : this._frame = e,
        this._component.currentClip === this && this._component._showFrame(this._frame)
    }
    _destroy() {
        if (this._spriteAsset) {
            const e = this._component.system.app.assets;
            this._unbindSpriteAsset(e.get(this._spriteAsset))
        }
        this._sprite && (this.sprite = null),
        this._spriteAsset && (this.spriteAsset = null)
    }
    play() {
        this._playing || (this._playing = !0,
        this._paused = !1,
        this.frame = 0,
        this.fire("play"),
        this._component.fire("play", this))
    }
    pause() {
        !this._playing || this._paused || (this._paused = !0,
        this.fire("pause"),
        this._component.fire("pause", this))
    }
    resume() {
        this._paused && (this._paused = !1,
        this.fire("resume"),
        this._component.fire("resume", this))
    }
    stop() {
        this._playing && (this._playing = !1,
        this._paused = !1,
        this._time = 0,
        this.frame = 0,
        this.fire("stop"),
        this._component.fire("stop", this))
    }
}
Cn.EVENT_PLAY = "play";
Cn.EVENT_PAUSE = "pause";
Cn.EVENT_RESUME = "resume";
Cn.EVENT_STOP = "stop";
Cn.EVENT_END = "end";
Cn.EVENT_LOOP = "loop";
const Cv = "texture_emissiveMap"
  , Ev = "texture_opacityMap"
  , Av = "material_emissive"
  , Mv = "material_opacity"
  , KO = "innerOffset"
  , ZO = "outerScale"
  , QO = "atlasRect";
class Mr extends _e {
    constructor(e, t) {
        super(e, t),
        this._type = bv,
        this._material = e.defaultMaterial,
        this._color = new z(1,1,1,1),
        this._colorUniform = new Float32Array(3),
        this._speed = 1,
        this._flipX = !1,
        this._flipY = !1,
        this._width = 1,
        this._height = 1,
        this._drawOrder = 0,
        this._layers = [Bn],
        this._outerScale = new P(1,1),
        this._outerScaleUniform = new Float32Array(2),
        this._innerOffset = new M,
        this._innerOffsetUniform = new Float32Array(4),
        this._atlasRect = new M,
        this._atlasRectUniform = new Float32Array(4),
        this._batchGroupId = -1,
        this._batchGroup = null,
        this._node = new yt,
        this._model = new kn,
        this._model.graph = this._node,
        this._meshInstance = null,
        t.addChild(this._model.graph),
        this._model._entity = t,
        this._updateAabbFunc = this._updateAabb.bind(this),
        this._addedModel = !1,
        this._autoPlayClip = null,
        this._clips = {},
        this._defaultClip = new Cn(this,{
            name: this.entity.name,
            fps: 0,
            loop: !1,
            spriteAsset: null
        }),
        this._currentClip = this._defaultClip
    }
    set type(e) {
        this._type !== e && (this._type = e,
        this._type === bv ? (this.stop(),
        this._currentClip = this._defaultClip,
        this.enabled && this.entity.enabled && (this._currentClip.frame = this.frame,
        this._currentClip.sprite ? this._showModel() : this._hideModel())) : this._type === Tv && (this.stop(),
        this._autoPlayClip && this._tryAutoPlay(),
        this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled ? this._showModel() : this._hideModel()))
    }
    get type() {
        return this._type
    }
    set frame(e) {
        this._currentClip.frame = e
    }
    get frame() {
        return this._currentClip.frame
    }
    set spriteAsset(e) {
        this._defaultClip.spriteAsset = e
    }
    get spriteAsset() {
        return this._defaultClip._spriteAsset
    }
    set sprite(e) {
        this._currentClip.sprite = e
    }
    get sprite() {
        return this._currentClip.sprite
    }
    set material(e) {
        this._material = e,
        this._meshInstance && (this._meshInstance.material = e)
    }
    get material() {
        return this._material
    }
    set color(e) {
        this._color.r = e.r,
        this._color.g = e.g,
        this._color.b = e.b,
        this._meshInstance && (this._colorUniform[0] = this._color.r,
        this._colorUniform[1] = this._color.g,
        this._colorUniform[2] = this._color.b,
        this._meshInstance.setParameter(Av, this._colorUniform))
    }
    get color() {
        return this._color
    }
    set opacity(e) {
        this._color.a = e,
        this._meshInstance && this._meshInstance.setParameter(Mv, e)
    }
    get opacity() {
        return this._color.a
    }
    set clips(e) {
        if (!e) {
            for (const t in this._clips)
                this.removeClip(t);
            return
        }
        for (const t in this._clips) {
            let s = !1;
            for (const i in e)
                if (e[i].name === t) {
                    s = !0,
                    this._clips[t].fps = e[i].fps,
                    this._clips[t].loop = e[i].loop,
                    e[i].hasOwnProperty("sprite") ? this._clips[t].sprite = e[i].sprite : e[i].hasOwnProperty("spriteAsset") && (this._clips[t].spriteAsset = e[i].spriteAsset);
                    break
                }
            s || this.removeClip(t)
        }
        for (const t in e)
            this._clips[e[t].name] || this.addClip(e[t]);
        this._autoPlayClip && this._tryAutoPlay(),
        (!this._currentClip || !this._currentClip.sprite) && this._hideModel()
    }
    get clips() {
        return this._clips
    }
    get currentClip() {
        return this._currentClip
    }
    set speed(e) {
        this._speed = e
    }
    get speed() {
        return this._speed
    }
    set flipX(e) {
        this._flipX !== e && (this._flipX = e,
        this._updateTransform())
    }
    get flipX() {
        return this._flipX
    }
    set flipY(e) {
        this._flipY !== e && (this._flipY = e,
        this._updateTransform())
    }
    get flipY() {
        return this._flipY
    }
    set width(e) {
        e !== this._width && (this._width = e,
        this._outerScale.x = this._width,
        this.sprite && (this.sprite.renderMode === _t || this.sprite.renderMode === xt) && this._updateTransform())
    }
    get width() {
        return this._width
    }
    set height(e) {
        e !== this._height && (this._height = e,
        this._outerScale.y = this.height,
        this.sprite && (this.sprite.renderMode === _t || this.sprite.renderMode === xt) && this._updateTransform())
    }
    get height() {
        return this._height
    }
    set batchGroupId(e) {
        if (this._batchGroupId === e)
            return;
        const t = this._batchGroupId;
        if (this._batchGroupId = e,
        this.entity.enabled && t >= 0) {
            var s;
            (s = this.system.app.batcher) == null || s.remove(gt.SPRITE, t, this.entity)
        }
        if (this.entity.enabled && e >= 0) {
            var i;
            (i = this.system.app.batcher) == null || i.insert(gt.SPRITE, e, this.entity)
        } else
            t >= 0 && this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled && this._showModel()
    }
    get batchGroupId() {
        return this._batchGroupId
    }
    set autoPlayClip(e) {
        this._autoPlayClip = e instanceof Cn ? e.name : e,
        this._tryAutoPlay()
    }
    get autoPlayClip() {
        return this._autoPlayClip
    }
    set drawOrder(e) {
        this._drawOrder = e,
        this._meshInstance && (this._meshInstance.drawOrder = e)
    }
    get drawOrder() {
        return this._drawOrder
    }
    set layers(e) {
        this._addedModel && this._hideModel(),
        this._layers = e,
        this._meshInstance && this.enabled && this.entity.enabled && this._showModel()
    }
    get layers() {
        return this._layers
    }
    get aabb() {
        return this._meshInstance ? this._meshInstance.aabb : null
    }
    onEnable() {
        const e = this.system.app
          , t = e.scene;
        if (t.on("set:layers", this._onLayersChanged, this),
        t.layers && (t.layers.on("add", this._onLayerAdded, this),
        t.layers.on("remove", this._onLayerRemoved, this)),
        this._showModel(),
        this._autoPlayClip && this._tryAutoPlay(),
        this._batchGroupId >= 0) {
            var s;
            (s = e.batcher) == null || s.insert(gt.SPRITE, this._batchGroupId, this.entity)
        }
    }
    onDisable() {
        const e = this.system.app
          , t = e.scene;
        if (t.off("set:layers", this._onLayersChanged, this),
        t.layers && (t.layers.off("add", this._onLayerAdded, this),
        t.layers.off("remove", this._onLayerRemoved, this)),
        this.stop(),
        this._hideModel(),
        this._batchGroupId >= 0) {
            var s;
            (s = e.batcher) == null || s.remove(gt.SPRITE, this._batchGroupId, this.entity)
        }
    }
    onDestroy() {
        var e;
        this._currentClip = null,
        this._defaultClip && (this._defaultClip._destroy(),
        this._defaultClip = null);
        for (const t in this._clips)
            this._clips[t]._destroy();
        this._clips = null,
        this._hideModel(),
        this._model = null,
        (e = this._node) == null || e.remove(),
        this._node = null,
        this._meshInstance && (this._meshInstance.material = null,
        this._meshInstance.mesh = null,
        this._meshInstance = null)
    }
    _showModel() {
        if (this._addedModel || !this._meshInstance)
            return;
        const e = [this._meshInstance];
        for (let t = 0, s = this._layers.length; t < s; t++) {
            const i = this.system.app.scene.layers.getLayerById(this._layers[t]);
            i && i.addMeshInstances(e)
        }
        this._addedModel = !0
    }
    _hideModel() {
        if (!this._addedModel || !this._meshInstance)
            return;
        const e = [this._meshInstance];
        for (let t = 0, s = this._layers.length; t < s; t++) {
            const i = this.system.app.scene.layers.getLayerById(this._layers[t]);
            i && i.removeMeshInstances(e)
        }
        this._addedModel = !1
    }
    _showFrame(e) {
        if (!this.sprite)
            return;
        const t = this.sprite.meshes[e];
        if (!t) {
            this._meshInstance && (this._meshInstance.mesh = null,
            this._meshInstance.visible = !1);
            return
        }
        let s;
        if (this.sprite.renderMode === xt ? s = this.system.default9SlicedMaterialSlicedMode : this.sprite.renderMode === _t ? s = this.system.default9SlicedMaterialTiledMode : s = this.system.defaultMaterial,
        this._meshInstance || (this._meshInstance = new Fe(t,this._material,this._node),
        this._meshInstance.castShadow = !1,
        this._meshInstance.receiveShadow = !1,
        this._meshInstance.drawOrder = this._drawOrder,
        this._model.meshInstances.push(this._meshInstance),
        this._colorUniform[0] = this._color.r,
        this._colorUniform[1] = this._color.g,
        this._colorUniform[2] = this._color.b,
        this._meshInstance.setParameter(Av, this._colorUniform),
        this._meshInstance.setParameter(Mv, this._color.a),
        this.enabled && this.entity.enabled && this._showModel()),
        this._meshInstance.material !== s && (this._meshInstance.material = s),
        this._meshInstance.mesh !== t && (this._meshInstance.mesh = t,
        this._meshInstance.visible = !0,
        this._meshInstance._aabbVer = -1),
        this.sprite.atlas && this.sprite.atlas.texture ? (this._meshInstance.setParameter(Cv, this.sprite.atlas.texture),
        this._meshInstance.setParameter(Ev, this.sprite.atlas.texture)) : (this._meshInstance.deleteParameter(Cv),
        this._meshInstance.deleteParameter(Ev)),
        this.sprite.atlas && (this.sprite.renderMode === xt || this.sprite.renderMode === _t)) {
            this._meshInstance._updateAabbFunc = this._updateAabbFunc;
            const i = this.sprite.atlas.frames[this.sprite.frameKeys[e]];
            if (i) {
                const n = 2 / i.rect.z
                  , r = 2 / i.rect.w;
                this._innerOffset.set(i.border.x * n, i.border.y * r, i.border.z * n, i.border.w * r);
                const o = this.sprite.atlas.texture;
                this._atlasRect.set(i.rect.x / o.width, i.rect.y / o.height, i.rect.z / o.width, i.rect.w / o.height)
            } else
                this._innerOffset.set(0, 0, 0, 0);
            this._innerOffsetUniform[0] = this._innerOffset.x,
            this._innerOffsetUniform[1] = this._innerOffset.y,
            this._innerOffsetUniform[2] = this._innerOffset.z,
            this._innerOffsetUniform[3] = this._innerOffset.w,
            this._meshInstance.setParameter(KO, this._innerOffsetUniform),
            this._atlasRectUniform[0] = this._atlasRect.x,
            this._atlasRectUniform[1] = this._atlasRect.y,
            this._atlasRectUniform[2] = this._atlasRect.z,
            this._atlasRectUniform[3] = this._atlasRect.w,
            this._meshInstance.setParameter(QO, this._atlasRectUniform)
        } else
            this._meshInstance._updateAabbFunc = null;
        this._updateTransform()
    }
    _updateTransform() {
        let e = this.flipX ? -1 : 1
          , t = this.flipY ? -1 : 1
          , s = 0
          , i = 0;
        if (this.sprite && (this.sprite.renderMode === xt || this.sprite.renderMode === _t)) {
            let n = 1
              , r = 1;
            if (this.sprite.atlas) {
                const c = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];
                c && (n = c.rect.z,
                r = c.rect.w,
                s = (.5 - c.pivot.x) * this._width,
                i = (.5 - c.pivot.y) * this._height)
            }
            const o = n / this.sprite.pixelsPerUnit
              , l = r / this.sprite.pixelsPerUnit;
            this._outerScale.set(Math.max(this._width, this._innerOffset.x * o), Math.max(this._height, this._innerOffset.y * l)),
            e *= o,
            t *= l,
            this._outerScale.x /= o,
            this._outerScale.y /= l,
            e *= W.clamp(this._width / (this._innerOffset.x * o), 1e-4, 1),
            t *= W.clamp(this._height / (this._innerOffset.y * l), 1e-4, 1),
            this._meshInstance && (this._outerScaleUniform[0] = this._outerScale.x,
            this._outerScaleUniform[1] = this._outerScale.y,
            this._meshInstance.setParameter(ZO, this._outerScaleUniform))
        }
        this._node.setLocalScale(e, t, 1),
        this._node.setLocalPosition(s, i, 0)
    }
    _updateAabb(e) {
        return e.center.set(0, 0, 0),
        e.halfExtents.set(this._outerScale.x * .5, this._outerScale.y * .5, .001),
        e.setFromTransformedAabb(e, this._node.getWorldTransform()),
        e
    }
    _tryAutoPlay() {
        if (!this._autoPlayClip || this.type !== Tv)
            return;
        const e = this._clips[this._autoPlayClip];
        e && !e.isPlaying && (!this._currentClip || !this._currentClip.isPlaying) && this.enabled && this.entity.enabled && this.play(e.name)
    }
    _onLayersChanged(e, t) {
        e.off("add", this.onLayerAdded, this),
        e.off("remove", this.onLayerRemoved, this),
        t.on("add", this.onLayerAdded, this),
        t.on("remove", this.onLayerRemoved, this),
        this.enabled && this.entity.enabled && this._showModel()
    }
    _onLayerAdded(e) {
        this.layers.indexOf(e.id) < 0 || this._addedModel && this.enabled && this.entity.enabled && this._meshInstance && e.addMeshInstances([this._meshInstance])
    }
    _onLayerRemoved(e) {
        !this._meshInstance || this.layers.indexOf(e.id) < 0 || e.removeMeshInstances([this._meshInstance])
    }
    removeModelFromLayers() {
        for (let e = 0; e < this.layers.length; e++) {
            const t = this.system.app.scene.layers.getLayerById(this.layers[e]);
            t && t.removeMeshInstances([this._meshInstance])
        }
    }
    addClip(e) {
        const t = new Cn(this,{
            name: e.name,
            fps: e.fps,
            loop: e.loop,
            spriteAsset: e.spriteAsset
        });
        return this._clips[e.name] = t,
        t.name && t.name === this._autoPlayClip && this._tryAutoPlay(),
        t
    }
    removeClip(e) {
        delete this._clips[e]
    }
    clip(e) {
        return this._clips[e]
    }
    play(e) {
        const t = this._clips[e]
          , s = this._currentClip;
        return s && s !== t && (s._playing = !1),
        this._currentClip = t,
        this._currentClip && (this._currentClip = t,
        this._currentClip.play()),
        t
    }
    pause() {
        this._currentClip !== this._defaultClip && this._currentClip.isPlaying && this._currentClip.pause()
    }
    resume() {
        this._currentClip !== this._defaultClip && this._currentClip.isPaused && this._currentClip.resume()
    }
    stop() {
        this._currentClip !== this._defaultClip && this._currentClip.stop()
    }
}
Mr.EVENT_PLAY = "play";
Mr.EVENT_PAUSE = "pause";
Mr.EVENT_RESUME = "resume";
Mr.EVENT_STOP = "stop";
Mr.EVENT_END = "end";
Mr.EVENT_LOOP = "loop";
class JO {
    constructor() {
        this.enabled = !0
    }
}
const pw = ["enabled"];
class eF extends it {
    constructor(e) {
        super(e),
        this.id = "sprite",
        this.ComponentType = Mr,
        this.DataType = JO,
        this.schema = pw,
        this._defaultTexture = null,
        this._defaultMaterial = null,
        this._default9SlicedMaterialSlicedMode = null,
        this._default9SlicedMaterialTiledMode = null,
        this.app.systems.on("update", this.onUpdate, this),
        this.on("beforeremove", this.onBeforeRemove, this)
    }
    set defaultMaterial(e) {
        this._defaultMaterial = e
    }
    get defaultMaterial() {
        if (!this._defaultMaterial) {
            const e = new ge(this.app.graphicsDevice,{
                width: 1,
                height: 1,
                format: ve,
                name: "sprite"
            })
              , t = new Uint8Array(e.lock());
            t[0] = t[1] = t[2] = t[3] = 255,
            e.unlock();
            const s = new at;
            s.diffuse.set(0, 0, 0),
            s.emissive.set(.5, .5, .5),
            s.emissiveMap = e,
            s.emissiveTint = !0,
            s.opacityMap = e,
            s.opacityMapChannel = "a",
            s.opacityTint = !0,
            s.opacity = 0,
            s.useLighting = !1,
            s.useGammaTonemap = !1,
            s.useFog = !1,
            s.useSkybox = !1,
            s.blendType = _a,
            s.depthWrite = !1,
            s.pixelSnap = !1,
            s.cull = bt,
            s.update(),
            this._defaultTexture = e,
            this._defaultMaterial = s
        }
        return this._defaultMaterial
    }
    set default9SlicedMaterialSlicedMode(e) {
        this._default9SlicedMaterialSlicedMode = e
    }
    get default9SlicedMaterialSlicedMode() {
        if (!this._default9SlicedMaterialSlicedMode) {
            const e = this.defaultMaterial.clone();
            e.nineSlicedMode = xt,
            e.update(),
            this._default9SlicedMaterialSlicedMode = e
        }
        return this._default9SlicedMaterialSlicedMode
    }
    set default9SlicedMaterialTiledMode(e) {
        this._default9SlicedMaterialTiledMode = e
    }
    get default9SlicedMaterialTiledMode() {
        if (!this._default9SlicedMaterialTiledMode) {
            const e = this.defaultMaterial.clone();
            e.nineSlicedMode = _t,
            e.update(),
            this._default9SlicedMaterialTiledMode = e
        }
        return this._default9SlicedMaterialTiledMode
    }
    destroy() {
        super.destroy(),
        this.app.systems.off("update", this.onUpdate, this),
        this._defaultTexture && (this._defaultTexture.destroy(),
        this._defaultTexture = null)
    }
    initializeComponentData(e, t, s) {
        if (t.enabled !== void 0 && (e.enabled = t.enabled),
        e.type = t.type,
        t.layers && Array.isArray(t.layers) && (e.layers = t.layers.slice(0)),
        t.drawOrder !== void 0 && (e.drawOrder = t.drawOrder),
        t.color !== void 0) {
            if (t.color instanceof z) {
                var i;
                e.color.set(t.color.r, t.color.g, t.color.b, (i = t.opacity) != null ? i : 1)
            } else {
                var n;
                e.color.set(t.color[0], t.color[1], t.color[2], (n = t.opacity) != null ? n : 1)
            }
            e.color = e.color
        }
        if (t.opacity !== void 0 && (e.opacity = t.opacity),
        t.flipX !== void 0 && (e.flipX = t.flipX),
        t.flipY !== void 0 && (e.flipY = t.flipY),
        t.width !== void 0 && (e.width = t.width),
        t.height !== void 0 && (e.height = t.height),
        t.spriteAsset !== void 0 && (e.spriteAsset = t.spriteAsset),
        t.sprite && (e.sprite = t.sprite),
        t.frame !== void 0 && (e.frame = t.frame),
        t.clips)
            for (const r in t.clips)
                e.addClip(t.clips[r]);
        t.speed !== void 0 && (e.speed = t.speed),
        t.autoPlayClip && (e.autoPlayClip = t.autoPlayClip),
        e.batchGroupId = t.batchGroupId === void 0 || t.batchGroupId === null ? -1 : t.batchGroupId,
        super.initializeComponentData(e, t, s)
    }
    cloneComponent(e, t) {
        const s = e.sprite;
        return this.addComponent(t, {
            enabled: s.enabled,
            type: s.type,
            spriteAsset: s.spriteAsset,
            sprite: s.sprite,
            width: s.width,
            height: s.height,
            frame: s.frame,
            color: s.color.clone(),
            opacity: s.opacity,
            flipX: s.flipX,
            flipY: s.flipY,
            speed: s.speed,
            clips: s.clips,
            autoPlayClip: s.autoPlayClip,
            batchGroupId: s.batchGroupId,
            drawOrder: s.drawOrder,
            layers: s.layers.slice(0)
        })
    }
    onUpdate(e) {
        const t = this.store;
        for (const s in t)
            if (t.hasOwnProperty(s)) {
                const i = t[s];
                if (i.data.enabled && i.entity.enabled) {
                    const n = i.entity.sprite;
                    n._currentClip && n._currentClip._update(e)
                }
            }
    }
    onBeforeRemove(e, t) {
        t.onDestroy()
    }
}
_e._buildAccessors(Mr.prototype, pw);
class ol extends _e {
    constructor(e, t) {
        super(e, t),
        this._oldState = !0,
        this._size = new y,
        this.on("set_enabled", this._onSetEnabled, this)
    }
    set size(e) {
        e instanceof y ? this._size.copy(e) : e instanceof Array && e.length >= 3 && this.size.set(e[0], e[1], e[2])
    }
    get size() {
        return this._size
    }
    onEnable() {
        this._checkState()
    }
    onDisable() {
        this._checkState()
    }
    _onSetEnabled(e, t, s) {
        this._checkState()
    }
    _checkState() {
        const e = this.enabled && this.entity.enabled;
        e !== this._oldState && (this._oldState = e,
        this.fire("enable"),
        this.fire("state", this.enabled))
    }
    _onBeforeRemove() {
        this.fire("remove")
    }
}
ol.EVENT_ENABLE = "enable";
ol.EVENT_DISABLE = "disable";
ol.EVENT_STATE = "state";
ol.EVENT_REMOVE = "remove";
class tF {
    constructor() {
        this.enabled = !0
    }
}
const mw = ["enabled"];
class sF extends it {
    constructor(e) {
        super(e),
        this.id = "zone",
        this.ComponentType = ol,
        this.DataType = tF,
        this.schema = mw,
        this.on("beforeremove", this._onBeforeRemove, this)
    }
    initializeComponentData(e, t, s) {
        e.enabled = t.hasOwnProperty("enabled") ? !!t.enabled : !0,
        t.size && (t.size instanceof y ? e.size.copy(t.size) : t.size instanceof Array && t.size.length >= 3 && e.size.set(t.size[0], t.size[1], t.size[2]))
    }
    cloneComponent(e, t) {
        const s = {
            size: e.zone.size
        };
        return this.addComponent(t, s)
    }
    _onBeforeRemove(e, t) {
        t._onBeforeRemove()
    }
}
_e._buildAccessors(ol.prototype, mw);
class iF {
    constructor(e, t) {
        this.effect = e,
        this.inputTarget = t,
        this.outputTarget = null,
        this.name = e.constructor.name
    }
}
class nF {
    constructor(e, t) {
        this.app = e,
        this.camera = t,
        this.destinationRenderTarget = null,
        this.effects = [],
        this.enabled = !1,
        this.depthTarget = null,
        t.on("set:rect", this.onCameraRectChanged, this)
    }
    _allocateColorBuffer(e, t) {
        var s, i;
        const n = this.camera.rect
          , r = this.destinationRenderTarget
          , o = this.app.graphicsDevice
          , l = Math.floor(n.z * ((s = r == null ? void 0 : r.width) != null ? s : o.width))
          , c = Math.floor(n.w * ((i = r == null ? void 0 : r.height) != null ? i : o.height));
        return new ge(o,{
            name: t,
            format: e,
            width: l,
            height: c,
            mipmaps: !1,
            minFilter: be,
            magFilter: be,
            addressU: oe,
            addressV: oe
        })
    }
    _createOffscreenTarget(e, t) {
        const s = this.app.graphicsDevice
          , i = t && s.getRenderableHdrFormat([Tt, lt], !0) || ve
          , n = this.camera.entity.name + "-posteffect-" + this.effects.length
          , r = this._allocateColorBuffer(i, n);
        return new It({
            colorBuffer: r,
            depth: e,
            stencil: e && this.app.graphicsDevice.supportsStencil,
            samples: e ? s.samples : 1
        })
    }
    _resizeOffscreenTarget(e) {
        const t = e.colorBuffer.format
          , s = e.colorBuffer.name;
        e.destroyFrameBuffers(),
        e.destroyTextureBuffers(),
        e._colorBuffer = this._allocateColorBuffer(t, s),
        e._colorBuffers = [e._colorBuffer]
    }
    _destroyOffscreenTarget(e) {
        e.destroyTextureBuffers(),
        e.destroy()
    }
    addEffect(e) {
        const t = this.effects
          , s = t.length === 0
          , i = this._createOffscreenTarget(s, e.hdr)
          , n = new iF(e,i);
        t.push(n),
        this._sourceTarget = n.inputTarget,
        t.length > 1 && (t[t.length - 2].outputTarget = n.inputTarget),
        this._newPostEffect = e,
        e.needsDepthBuffer && this._requestDepthMap(),
        this.enable(),
        this._newPostEffect = void 0
    }
    removeEffect(e) {
        let t = -1;
        for (let s = 0, i = this.effects.length; s < i; s++)
            if (this.effects[s].effect === e) {
                t = s;
                break
            }
        t >= 0 && (t > 0 ? this.effects[t - 1].outputTarget = t + 1 < this.effects.length ? this.effects[t + 1].inputTarget : null : this.effects.length > 1 && (this.effects[1].inputTarget._depth || (this._destroyOffscreenTarget(this.effects[1].inputTarget),
        this.effects[1].inputTarget = this._createOffscreenTarget(!0, this.effects[1].hdr),
        this._sourceTarget = this.effects[1].inputTarget),
        this.camera.renderTarget = this.effects[1].inputTarget),
        this._destroyOffscreenTarget(this.effects[t].inputTarget),
        this.effects.splice(t, 1)),
        this.enabled && e.needsDepthBuffer && this._releaseDepthMap(),
        this.effects.length === 0 && this.disable()
    }
    _requestDepthMaps() {
        for (let e = 0, t = this.effects.length; e < t; e++) {
            const s = this.effects[e].effect;
            this._newPostEffect !== s && s.needsDepthBuffer && this._requestDepthMap()
        }
    }
    _releaseDepthMaps() {
        for (let e = 0, t = this.effects.length; e < t; e++)
            this.effects[e].effect.needsDepthBuffer && this._releaseDepthMap()
    }
    _requestDepthMap() {
        const e = this.app.scene.layers.getLayerById(hs);
        e && (e.incrementCounter(),
        this.camera.requestSceneDepthMap(!0))
    }
    _releaseDepthMap() {
        const e = this.app.scene.layers.getLayerById(hs);
        e && (e.decrementCounter(),
        this.camera.requestSceneDepthMap(!1))
    }
    destroy() {
        for (let e = 0, t = this.effects.length; e < t; e++)
            this.effects[e].inputTarget.destroy();
        this.effects.length = 0,
        this.disable()
    }
    enable() {
        !this.enabled && this.effects.length && (this.enabled = !0,
        this._requestDepthMaps(),
        this.app.graphicsDevice.on("resizecanvas", this._onCanvasResized, this),
        this.destinationRenderTarget = this.camera.renderTarget,
        this.camera.renderTarget = this.effects[0].inputTarget,
        this.camera.onPostprocessing = () => {
            if (this.enabled) {
                let e = null;
                const t = this.effects.length;
                if (t)
                    for (let s = 0; s < t; s++) {
                        const i = this.effects[s];
                        let n = i.outputTarget;
                        s === t - 1 && (e = this.camera.rect,
                        this.destinationRenderTarget && (n = this.destinationRenderTarget)),
                        i.effect.render(i.inputTarget, n, e)
                    }
            }
        }
        )
    }
    disable() {
        this.enabled && (this.enabled = !1,
        this.app.graphicsDevice.off("resizecanvas", this._onCanvasResized, this),
        this._releaseDepthMaps(),
        this._destroyOffscreenTarget(this._sourceTarget),
        this.camera.renderTarget = null,
        this.camera.onPostprocessing = null)
    }
    _onCanvasResized(e, t) {
        var s, i;
        const n = this.camera.rect
          , r = this.destinationRenderTarget;
        e = (s = r == null ? void 0 : r.width) != null ? s : e,
        t = (i = r == null ? void 0 : r.height) != null ? i : t,
        this.camera.camera.aspectRatio = e * n.z / (t * n.w),
        this.resizeRenderTargets()
    }
    resizeRenderTargets() {
        var e, t;
        const s = this.app.graphicsDevice
          , i = this.destinationRenderTarget
          , n = (e = i == null ? void 0 : i.width) != null ? e : s.width
          , r = (t = i == null ? void 0 : i.height) != null ? t : s.height
          , o = this.camera.rect
          , l = Math.floor(o.z * n)
          , c = Math.floor(o.w * r)
          , d = this.effects;
        for (let h = 0, u = d.length; h < u; h++) {
            const f = d[h];
            (f.inputTarget.width !== l || f.inputTarget.height !== c) && this._resizeOffscreenTarget(f.inputTarget)
        }
    }
    onCameraRectChanged(e, t, s) {
        this.enabled && this.resizeRenderTargets()
    }
}
class _w extends _e {
    constructor(e, t) {
        super(e, t),
        this.onPostprocessing = null,
        this.onPreRender = null,
        this.onPostRender = null,
        this._renderSceneDepthMap = 0,
        this._renderSceneColorMap = 0,
        this._sceneDepthMapRequested = !1,
        this._sceneColorMapRequested = !1,
        this._priority = 0,
        this._disablePostEffectsLayer = Cf,
        this._camera = new rg,
        this._camera.node = t,
        this._postEffects = new nF(e.app,this)
    }
    setShaderPass(e) {
        const t = wi.get(this.system.app.graphicsDevice)
          , s = e ? t.allocate(e, {
            isForward: !0
        }) : null;
        return this._camera.shaderPassInfo = s,
        s.index
    }
    getShaderPass() {
        var e;
        return (e = this._camera.shaderPassInfo) == null ? void 0 : e.name
    }
    set renderPasses(e) {
        this._camera.renderPasses = e
    }
    get renderPasses() {
        return this._camera.renderPasses
    }
    set aperture(e) {
        this._camera.aperture = e
    }
    get aperture() {
        return this._camera.aperture
    }
    set aspectRatio(e) {
        this._camera.aspectRatio = e
    }
    get aspectRatio() {
        return this._camera.aspectRatio
    }
    set aspectRatioMode(e) {
        this._camera.aspectRatioMode = e
    }
    get aspectRatioMode() {
        return this._camera.aspectRatioMode
    }
    set calculateProjection(e) {
        this._camera.calculateProjection = e
    }
    get calculateProjection() {
        return this._camera.calculateProjection
    }
    set calculateTransform(e) {
        this._camera.calculateTransform = e
    }
    get calculateTransform() {
        return this._camera.calculateTransform
    }
    get camera() {
        return this._camera
    }
    set clearColor(e) {
        this._camera.clearColor = e
    }
    get clearColor() {
        return this._camera.clearColor
    }
    set clearColorBuffer(e) {
        this._camera.clearColorBuffer = e,
        this.dirtyLayerCompositionCameras()
    }
    get clearColorBuffer() {
        return this._camera.clearColorBuffer
    }
    set clearDepthBuffer(e) {
        this._camera.clearDepthBuffer = e,
        this.dirtyLayerCompositionCameras()
    }
    get clearDepthBuffer() {
        return this._camera.clearDepthBuffer
    }
    set clearStencilBuffer(e) {
        this._camera.clearStencilBuffer = e,
        this.dirtyLayerCompositionCameras()
    }
    get clearStencilBuffer() {
        return this._camera.clearStencilBuffer
    }
    set cullFaces(e) {
        this._camera.cullFaces = e
    }
    get cullFaces() {
        return this._camera.cullFaces
    }
    set disablePostEffectsLayer(e) {
        this._disablePostEffectsLayer = e,
        this.dirtyLayerCompositionCameras()
    }
    get disablePostEffectsLayer() {
        return this._disablePostEffectsLayer
    }
    set farClip(e) {
        this._camera.farClip = e
    }
    get farClip() {
        return this._camera.farClip
    }
    set flipFaces(e) {
        this._camera.flipFaces = e
    }
    get flipFaces() {
        return this._camera.flipFaces
    }
    set fov(e) {
        this._camera.fov = e
    }
    get fov() {
        return this._camera.fov
    }
    get frustum() {
        return this._camera.frustum
    }
    set frustumCulling(e) {
        this._camera.frustumCulling = e
    }
    get frustumCulling() {
        return this._camera.frustumCulling
    }
    set horizontalFov(e) {
        this._camera.horizontalFov = e
    }
    get horizontalFov() {
        return this._camera.horizontalFov
    }
    set layers(e) {
        const t = this._camera.layers;
        for (let s = 0; s < t.length; s++) {
            const i = this.system.app.scene.layers.getLayerById(t[s]);
            i && i.removeCamera(this)
        }
        if (this._camera.layers = e,
        !(!this.enabled || !this.entity.enabled))
            for (let s = 0; s < e.length; s++) {
                const i = this.system.app.scene.layers.getLayerById(e[s]);
                i && i.addCamera(this)
            }
    }
    get layers() {
        return this._camera.layers
    }
    get layersSet() {
        return this._camera.layersSet
    }
    set jitter(e) {
        this._camera.jitter = e
    }
    get jitter() {
        return this._camera.jitter
    }
    set nearClip(e) {
        this._camera.nearClip = e
    }
    get nearClip() {
        return this._camera.nearClip
    }
    set orthoHeight(e) {
        this._camera.orthoHeight = e
    }
    get orthoHeight() {
        return this._camera.orthoHeight
    }
    get postEffects() {
        return this._postEffects
    }
    get postEffectsEnabled() {
        return this._postEffects.enabled
    }
    set priority(e) {
        this._priority = e,
        this.dirtyLayerCompositionCameras()
    }
    get priority() {
        return this._priority
    }
    set projection(e) {
        this._camera.projection = e
    }
    get projection() {
        return this._camera.projection
    }
    get projectionMatrix() {
        return this._camera.projectionMatrix
    }
    set rect(e) {
        this._camera.rect = e,
        this.fire("set:rect", this._camera.rect)
    }
    get rect() {
        return this._camera.rect
    }
    set renderSceneColorMap(e) {
        e && !this._sceneColorMapRequested ? (this.requestSceneColorMap(!0),
        this._sceneColorMapRequested = !0) : this._sceneColorMapRequested && (this.requestSceneColorMap(!1),
        this._sceneColorMapRequested = !1)
    }
    get renderSceneColorMap() {
        return this._renderSceneColorMap > 0
    }
    set renderSceneDepthMap(e) {
        e && !this._sceneDepthMapRequested ? (this.requestSceneDepthMap(!0),
        this._sceneDepthMapRequested = !0) : this._sceneDepthMapRequested && (this.requestSceneDepthMap(!1),
        this._sceneDepthMapRequested = !1)
    }
    get renderSceneDepthMap() {
        return this._renderSceneDepthMap > 0
    }
    set renderTarget(e) {
        this._camera.renderTarget = e,
        this.dirtyLayerCompositionCameras()
    }
    get renderTarget() {
        return this._camera.renderTarget
    }
    set scissorRect(e) {
        this._camera.scissorRect = e
    }
    get scissorRect() {
        return this._camera.scissorRect
    }
    set sensitivity(e) {
        this._camera.sensitivity = e
    }
    get sensitivity() {
        return this._camera.sensitivity
    }
    set shutter(e) {
        this._camera.shutter = e
    }
    get shutter() {
        return this._camera.shutter
    }
    get viewMatrix() {
        return this._camera.viewMatrix
    }
    _enableDepthLayer(e) {
        if (this.layers.find(s => s === hs)) {
            const s = this.system.app.scene.layers.getLayerById(hs);
            e ? s == null || s.incrementCounter() : s == null || s.decrementCounter()
        } else if (e)
            return !1;
        return !0
    }
    requestSceneColorMap(e) {
        this._renderSceneColorMap += e ? 1 : -1,
        this._enableDepthLayer(e),
        this.camera._enableRenderPassColorGrab(this.system.app.graphicsDevice, this.renderSceneColorMap)
    }
    requestSceneDepthMap(e) {
        this._renderSceneDepthMap += e ? 1 : -1,
        this._enableDepthLayer(e),
        this.camera._enableRenderPassDepthGrab(this.system.app.graphicsDevice, this.system.app.renderer, this.renderSceneDepthMap)
    }
    dirtyLayerCompositionCameras() {
        const e = this.system.app.scene.layers;
        e._dirty = !0
    }
    screenToWorld(e, t, s, i) {
        const n = this.system.app.graphicsDevice
          , r = n.clientRect.width
          , o = n.clientRect.height;
        return this._camera.screenToWorld(e, t, s, r, o, i)
    }
    worldToScreen(e, t) {
        const s = this.system.app.graphicsDevice
          , i = s.clientRect.width
          , n = s.clientRect.height;
        return this._camera.worldToScreen(e, i, n, t)
    }
    onAppPrerender() {
        this._camera._viewMatDirty = !0,
        this._camera._viewProjMatDirty = !0
    }
    addCameraToLayers() {
        const e = this.layers;
        for (let t = 0; t < e.length; t++) {
            const s = this.system.app.scene.layers.getLayerById(e[t]);
            s && s.addCamera(this)
        }
    }
    removeCameraFromLayers() {
        const e = this.layers;
        for (let t = 0; t < e.length; t++) {
            const s = this.system.app.scene.layers.getLayerById(e[t]);
            s && s.removeCamera(this)
        }
    }
    onLayersChanged(e, t) {
        this.addCameraToLayers(),
        e.off("add", this.onLayerAdded, this),
        e.off("remove", this.onLayerRemoved, this),
        t.on("add", this.onLayerAdded, this),
        t.on("remove", this.onLayerRemoved, this)
    }
    onLayerAdded(e) {
        this.layers.indexOf(e.id) < 0 || e.addCamera(this)
    }
    onLayerRemoved(e) {
        this.layers.indexOf(e.id) < 0 || e.removeCamera(this)
    }
    onEnable() {
        const e = this.system
          , t = e.app.scene
          , s = t.layers;
        e.addCamera(this),
        t.on("set:layers", this.onLayersChanged, this),
        s && (s.on("add", this.onLayerAdded, this),
        s.on("remove", this.onLayerRemoved, this)),
        this.enabled && this.entity.enabled && this.addCameraToLayers(),
        this.postEffects.enable()
    }
    onDisable() {
        const e = this.system
          , t = e.app.scene
          , s = t.layers;
        this.postEffects.disable(),
        this.removeCameraFromLayers(),
        t.off("set:layers", this.onLayersChanged, this),
        s && (s.off("add", this.onLayerAdded, this),
        s.off("remove", this.onLayerRemoved, this)),
        e.removeCamera(this)
    }
    onRemove() {
        this.onDisable(),
        this.off(),
        this.camera.destroy()
    }
    calculateAspectRatio(e) {
        const t = this.system.app.graphicsDevice
          , s = e ? e.width : t.width
          , i = e ? e.height : t.height;
        return s * this.rect.z / (i * this.rect.w)
    }
    frameUpdate(e) {
        this.aspectRatioMode === sg && (this.aspectRatio = this.calculateAspectRatio(e))
    }
    startXr(e, t, s) {
        this.system.app.xr.start(this, e, t, s)
    }
    endXr(e) {
        if (!this._camera.xr) {
            e && e(new Error("Camera is not in XR"));
            return
        }
        this._camera.xr.end(e)
    }
    copy(e) {
        this.aperture = e.aperture,
        this.aspectRatio = e.aspectRatio,
        this.aspectRatioMode = e.aspectRatioMode,
        this.calculateProjection = e.calculateProjection,
        this.calculateTransform = e.calculateTransform,
        this.clearColor = e.clearColor,
        this.clearColorBuffer = e.clearColorBuffer,
        this.clearDepthBuffer = e.clearDepthBuffer,
        this.clearStencilBuffer = e.clearStencilBuffer,
        this.cullFaces = e.cullFaces,
        this.disablePostEffectsLayer = e.disablePostEffectsLayer,
        this.farClip = e.farClip,
        this.flipFaces = e.flipFaces,
        this.fov = e.fov,
        this.frustumCulling = e.frustumCulling,
        this.horizontalFov = e.horizontalFov,
        this.layers = e.layers,
        this.nearClip = e.nearClip,
        this.orthoHeight = e.orthoHeight,
        this.priority = e.priority,
        this.projection = e.projection,
        this.rect = e.rect,
        this.renderTarget = e.renderTarget,
        this.scissorRect = e.scissorRect,
        this.sensitivity = e.sensitivity,
        this.shutter = e.shutter
    }
}
class rF {
    constructor() {
        this.enabled = !0
    }
}
const gw = ["enabled"];
class aF extends it {
    constructor(e) {
        super(e),
        this.cameras = [],
        this.id = "camera",
        this.ComponentType = _w,
        this.DataType = rF,
        this.schema = gw,
        this.on("beforeremove", this.onBeforeRemove, this),
        this.app.on("prerender", this.onAppPrerender, this),
        this.app.systems.on("update", this.onUpdate, this)
    }
    initializeComponentData(e, t, s) {
        s = ["aspectRatio", "aspectRatioMode", "calculateProjection", "calculateTransform", "clearColor", "clearColorBuffer", "clearDepthBuffer", "clearStencilBuffer", "renderSceneColorMap", "renderSceneDepthMap", "cullFaces", "farClip", "flipFaces", "fov", "frustumCulling", "horizontalFov", "layers", "renderTarget", "nearClip", "orthoHeight", "projection", "priority", "rect", "scissorRect", "aperture", "shutter", "sensitivity"];
        for (let i = 0; i < s.length; i++) {
            const n = s[i];
            if (t.hasOwnProperty(n)) {
                const r = t[n];
                switch (n) {
                case "rect":
                case "scissorRect":
                    Array.isArray(r) ? e[n] = new M(r[0],r[1],r[2],r[3]) : e[n] = r;
                    break;
                case "clearColor":
                    Array.isArray(r) ? e[n] = new z(r[0],r[1],r[2],r[3]) : e[n] = r;
                    break;
                default:
                    e[n] = r;
                    break
                }
            }
        }
        super.initializeComponentData(e, t, ["enabled"])
    }
    cloneComponent(e, t) {
        const s = e.camera;
        return this.addComponent(t, {
            aspectRatio: s.aspectRatio,
            aspectRatioMode: s.aspectRatioMode,
            calculateProjection: s.calculateProjection,
            calculateTransform: s.calculateTransform,
            clearColor: s.clearColor,
            clearColorBuffer: s.clearColorBuffer,
            clearDepthBuffer: s.clearDepthBuffer,
            clearStencilBuffer: s.clearStencilBuffer,
            renderSceneDepthMap: s.renderSceneDepthMap,
            renderSceneColorMap: s.renderSceneColorMap,
            cullFaces: s.cullFaces,
            enabled: s.enabled,
            farClip: s.farClip,
            flipFaces: s.flipFaces,
            fov: s.fov,
            frustumCulling: s.frustumCulling,
            horizontalFov: s.horizontalFov,
            layers: s.layers,
            renderTarget: s.renderTarget,
            nearClip: s.nearClip,
            orthoHeight: s.orthoHeight,
            projection: s.projection,
            priority: s.priority,
            rect: s.rect,
            scissorRect: s.scissorRect,
            aperture: s.aperture,
            sensitivity: s.sensitivity,
            shutter: s.shutter
        })
    }
    onBeforeRemove(e, t) {
        this.removeCamera(t),
        t.onRemove()
    }
    onUpdate(e) {}
    onAppPrerender() {
        for (let e = 0, t = this.cameras.length; e < t; e++)
            this.cameras[e].onAppPrerender()
    }
    addCamera(e) {
        this.cameras.push(e),
        Lh(this.cameras)
    }
    removeCamera(e) {
        const t = this.cameras.indexOf(e);
        t >= 0 && (this.cameras.splice(t, 1),
        Lh(this.cameras))
    }
    destroy() {
        super.destroy(),
        this.app.systems.off("update", this.onUpdate, this)
    }
}
_e._buildAccessors(_w.prototype, gw);
const xa = []
  , vg = [];
class yw extends _e {
    constructor(e, t) {
        super(e, t),
        this._cookieAsset = null,
        this._cookieAssetId = null,
        this._cookieAssetAdd = !1,
        this._cookieMatrix = null
    }
    addLightToLayers() {
        for (let e = 0; e < this.layers.length; e++) {
            const t = this.system.app.scene.layers.getLayerById(this.layers[e]);
            t && (t.addLight(this),
            this.light.addLayer(t))
        }
    }
    removeLightFromLayers() {
        for (let e = 0; e < this.layers.length; e++) {
            const t = this.system.app.scene.layers.getLayerById(this.layers[e]);
            t && (t.removeLight(this),
            this.light.removeLayer(t))
        }
    }
    onLayersChanged(e, t) {
        this.enabled && this.entity.enabled && this.addLightToLayers(),
        e.off("add", this.onLayerAdded, this),
        e.off("remove", this.onLayerRemoved, this),
        t.on("add", this.onLayerAdded, this),
        t.on("remove", this.onLayerRemoved, this)
    }
    onLayerAdded(e) {
        this.layers.indexOf(e.id) >= 0 && this.enabled && this.entity.enabled && (e.addLight(this),
        this.light.addLayer(e))
    }
    onLayerRemoved(e) {
        this.layers.indexOf(e.id) >= 0 && (e.removeLight(this),
        this.light.removeLayer(e))
    }
    refreshProperties() {
        for (let e = 0; e < xa.length; e++) {
            const t = xa[e];
            this[t] = this[t]
        }
        this.enabled && this.entity.enabled && this.onEnable()
    }
    onCookieAssetSet() {
        let e = !1;
        this._cookieAsset.type === "cubemap" && !this._cookieAsset.loadFaces && (this._cookieAsset.loadFaces = !0,
        e = !0),
        (!this._cookieAsset.resource || e) && this.system.app.assets.load(this._cookieAsset),
        this._cookieAsset.resource && this.onCookieAssetLoad()
    }
    onCookieAssetAdd(e) {
        this._cookieAssetId === e.id && (this._cookieAsset = e,
        this.light.enabled && this.onCookieAssetSet(),
        this._cookieAsset.on("load", this.onCookieAssetLoad, this),
        this._cookieAsset.on("remove", this.onCookieAssetRemove, this))
    }
    onCookieAssetLoad() {
        !this._cookieAsset || !this._cookieAsset.resource || (this.cookie = this._cookieAsset.resource)
    }
    onCookieAssetRemove() {
        this._cookieAssetId && (this._cookieAssetAdd && (this.system.app.assets.off("add:" + this._cookieAssetId, this.onCookieAssetAdd, this),
        this._cookieAssetAdd = !1),
        this._cookieAsset && (this._cookieAsset.off("load", this.onCookieAssetLoad, this),
        this._cookieAsset.off("remove", this.onCookieAssetRemove, this),
        this._cookieAsset = null),
        this.cookie = null)
    }
    onEnable() {
        this.light.enabled = !0,
        this.system.app.scene.on("set:layers", this.onLayersChanged, this),
        this.system.app.scene.layers && (this.system.app.scene.layers.on("add", this.onLayerAdded, this),
        this.system.app.scene.layers.on("remove", this.onLayerRemoved, this)),
        this.enabled && this.entity.enabled && this.addLightToLayers(),
        this._cookieAsset && !this.cookie && this.onCookieAssetSet()
    }
    onDisable() {
        this.light.enabled = !1,
        this.system.app.scene.off("set:layers", this.onLayersChanged, this),
        this.system.app.scene.layers && (this.system.app.scene.layers.off("add", this.onLayerAdded, this),
        this.system.app.scene.layers.off("remove", this.onLayerRemoved, this)),
        this.removeLightFromLayers()
    }
    onRemove() {
        this.onDisable(),
        this.light.destroy(),
        this.cookieAsset = null
    }
    set shadowUpdateOverrides(e) {
        this.light.shadowUpdateOverrides = e
    }
    get shadowUpdateOverrides() {
        return this.light.shadowUpdateOverrides
    }
    set penumbraSize(e) {
        this.light.penumbraSize = e
    }
    get penumbraSize() {
        return this.light.penumbraSize
    }
}
function xe(a, e, t, s) {
    const i = yw.prototype;
    xa.push(a),
    vg.push(e),
    Object.defineProperty(i, a, {
        get: function() {
            return this.data[a]
        },
        set: function(n) {
            const r = this.data
              , o = r[a];
            !s && o === n || (r[a] = n,
            t && t.call(this, n, o))
        },
        configurable: !0
    })
}
function oF() {
    xe("enabled", !0, function(a, e) {
        this.onSetEnabled(null, e, a)
    }),
    xe("light", null),
    xe("type", "directional", function(a, e) {
        this.system.changeType(this, e, a),
        this.refreshProperties()
    }),
    xe("color", new z(1,1,1), function(a, e) {
        this.light.setColor(a)
    }, !0),
    xe("intensity", 1, function(a, e) {
        this.light.intensity = a
    }),
    xe("luminance", 0, function(a, e) {
        this.light.luminance = a
    }),
    xe("shape", Nt, function(a, e) {
        this.light.shape = a
    }),
    xe("affectSpecularity", !0, function(a, e) {
        this.light.affectSpecularity = a
    }),
    xe("castShadows", !1, function(a, e) {
        this.light.castShadows = a
    }),
    xe("shadowDistance", 40, function(a, e) {
        this.light.shadowDistance = a
    }),
    xe("shadowIntensity", 1, function(a, e) {
        this.light.shadowIntensity = a
    }),
    xe("shadowResolution", 1024, function(a, e) {
        this.light.shadowResolution = a
    }),
    xe("shadowBias", .05, function(a, e) {
        this.light.shadowBias = -.01 * W.clamp(a, 0, 1)
    }),
    xe("numCascades", 1, function(a, e) {
        this.light.numCascades = W.clamp(Math.floor(a), 1, 4)
    }),
    xe("bakeNumSamples", 1, function(a, e) {
        this.light.bakeNumSamples = W.clamp(Math.floor(a), 1, 255)
    }),
    xe("bakeArea", 0, function(a, e) {
        this.light.bakeArea = W.clamp(a, 0, 180)
    }),
    xe("cascadeDistribution", .5, function(a, e) {
        this.light.cascadeDistribution = W.clamp(a, 0, 1)
    }),
    xe("normalOffsetBias", 0, function(a, e) {
        this.light.normalOffsetBias = W.clamp(a, 0, 1)
    }),
    xe("range", 10, function(a, e) {
        this.light.attenuationEnd = a
    }),
    xe("innerConeAngle", 40, function(a, e) {
        this.light.innerConeAngle = a
    }),
    xe("outerConeAngle", 45, function(a, e) {
        this.light.outerConeAngle = a
    }),
    xe("falloffMode", q_, function(a, e) {
        this.light.falloffMode = a
    }),
    xe("shadowType", St, function(a, e) {
        this.light.shadowType = a
    }),
    xe("vsmBlurSize", 11, function(a, e) {
        this.light.vsmBlurSize = a
    }),
    xe("vsmBlurMode", Y_, function(a, e) {
        this.light.vsmBlurMode = a
    }),
    xe("vsmBias", .01 * .25, function(a, e) {
        this.light.vsmBias = W.clamp(a, 0, 1)
    }),
    xe("cookieAsset", null, function(a, e) {
        if (!(this._cookieAssetId && (a instanceof le && a.id === this._cookieAssetId || a === this._cookieAssetId))) {
            if (this.onCookieAssetRemove(),
            this._cookieAssetId = null,
            a instanceof le)
                this.data.cookieAsset = a.id,
                this._cookieAssetId = a.id,
                this.onCookieAssetAdd(a);
            else if (typeof a == "number") {
                this._cookieAssetId = a;
                const t = this.system.app.assets.get(a);
                t ? this.onCookieAssetAdd(t) : (this._cookieAssetAdd = !0,
                this.system.app.assets.on("add:" + this._cookieAssetId, this.onCookieAssetAdd, this))
            }
        }
    }),
    xe("cookie", null, function(a, e) {
        this.light.cookie = a
    }),
    xe("cookieIntensity", 1, function(a, e) {
        this.light.cookieIntensity = W.clamp(a, 0, 1)
    }),
    xe("cookieFalloff", !0, function(a, e) {
        this.light.cookieFalloff = a
    }),
    xe("cookieChannel", "rgb", function(a, e) {
        this.light.cookieChannel = a
    }),
    xe("cookieAngle", 0, function(a, e) {
        if (a !== 0 || this.cookieScale !== null) {
            this._cookieMatrix || (this._cookieMatrix = new M);
            let t = 1
              , s = 1;
            this.cookieScale && (t = this.cookieScale.x,
            s = this.cookieScale.y);
            const i = Math.cos(a * W.DEG_TO_RAD)
              , n = Math.sin(a * W.DEG_TO_RAD);
            this._cookieMatrix.set(i / t, -n / t, n / s, i / s),
            this.light.cookieTransform = this._cookieMatrix
        } else
            this.light.cookieTransform = null
    }),
    xe("cookieScale", null, function(a, e) {
        if (a !== null || this.cookieAngle !== 0) {
            this._cookieMatrix || (this._cookieMatrix = new M);
            const t = a.x
              , s = a.y
              , i = Math.cos(this.cookieAngle * W.DEG_TO_RAD)
              , n = Math.sin(this.cookieAngle * W.DEG_TO_RAD);
            this._cookieMatrix.set(i / t, -n / t, n / s, i / s),
            this.light.cookieTransform = this._cookieMatrix
        } else
            this.light.cookieTransform = null
    }, !0),
    xe("cookieOffset", null, function(a, e) {
        this.light.cookieOffset = a
    }, !0),
    xe("shadowUpdateMode", tg, function(a, e) {
        this.light.shadowUpdateMode = a
    }, !0),
    xe("mask", 1, function(a, e) {
        this.light.mask = a
    }),
    xe("affectDynamic", !0, function(a, e) {
        a ? this.light.mask |= Rs : this.light.mask &= ~Rs,
        this.light.layersDirty()
    }),
    xe("affectLightmapped", !1, function(a, e) {
        a ? (this.light.mask |= Ui,
        this.bake && (this.light.mask &= ~zi)) : (this.light.mask &= ~Ui,
        this.bake && (this.light.mask |= zi))
    }),
    xe("bake", !1, function(a, e) {
        a ? (this.light.mask |= zi,
        this.affectLightmapped && (this.light.mask &= ~Ui)) : (this.light.mask &= ~zi,
        this.affectLightmapped && (this.light.mask |= Ui)),
        this.light.layersDirty()
    }),
    xe("bakeDir", !0, function(a, e) {
        this.light.bakeDir = a
    }),
    xe("isStatic", !1, function(a, e) {
        this.light.isStatic = a
    }),
    xe("layers", [Bn], function(a, e) {
        for (let t = 0; t < e.length; t++) {
            const s = this.system.app.scene.layers.getLayerById(e[t]);
            s && (s.removeLight(this),
            this.light.removeLayer(s))
        }
        for (let t = 0; t < a.length; t++) {
            const s = this.system.app.scene.layers.getLayerById(a[t]);
            s && this.enabled && this.entity.enabled && (s.addLight(this),
            this.light.addLayer(s))
        }
    }),
    xa.push("penumbraSize"),
    vg.push(1)
}
oF();
class lF {
    constructor() {
        const e = xa
          , t = vg;
        for (let s = 0; s < e.length; s++) {
            const i = t[s];
            i && i.clone ? this[e[s]] = i.clone() : this[e[s]] = i
        }
    }
}
class hF extends it {
    constructor(e) {
        super(e),
        this.id = "light",
        this.ComponentType = yw,
        this.DataType = lF,
        this.on("beforeremove", this._onRemoveComponent, this)
    }
    initializeComponentData(e, t) {
        const s = xa
          , i = {};
        for (let r = 0, o = s.length; r < o; r++) {
            const l = s[r];
            i[l] = t[l]
        }
        i.type || (i.type = e.data.type),
        e.data.type = i.type,
        i.layers && Array.isArray(i.layers) && (i.layers = i.layers.slice(0)),
        i.color && Array.isArray(i.color) && (i.color = new z(i.color[0],i.color[1],i.color[2])),
        i.cookieOffset && i.cookieOffset instanceof Array && (i.cookieOffset = new P(i.cookieOffset[0],i.cookieOffset[1])),
        i.cookieScale && i.cookieScale instanceof Array && (i.cookieScale = new P(i.cookieScale[0],i.cookieScale[1])),
        i.enable && (console.warn("WARNING: enable: Property is deprecated. Set enabled property instead."),
        i.enabled = i.enable),
        i.shape || (i.shape = Nt);
        const n = new Sx(this.app.graphicsDevice,this.app.scene.clusteredLightingEnabled);
        n.type = Im[i.type],
        n._node = e.entity,
        e.data.light = n,
        super.initializeComponentData(e, i, s)
    }
    _onRemoveComponent(e, t) {
        t.onRemove()
    }
    cloneComponent(e, t) {
        const s = e.light
          , i = [];
        let n;
        const r = xa;
        for (let o = 0; o < r.length; o++)
            n = r[o],
            n !== "light" && (s[n] && s[n].clone ? i[n] = s[n].clone() : i[n] = s[n]);
        return this.addComponent(t, i)
    }
    changeType(e, t, s) {
        t !== s && (e.light.type = Im[s])
    }
}
const cF = ["x", "y", "z", "w"]
  , dF = [void 0, void 0, P, y, M];
function vu(a, e, t, s) {
    switch (e.type) {
    case "boolean":
        return !!t;
    case "number":
        if (typeof t == "number")
            return t;
        if (typeof t == "string") {
            const i = parseInt(t, 10);
            return isNaN(i) ? null : i
        } else if (typeof t == "boolean")
            return 0 + t;
        return null;
    case "json":
        {
            const i = {};
            if (Array.isArray(e.schema)) {
                (!t || typeof t != "object") && (t = {});
                for (let n = 0; n < e.schema.length; n++) {
                    const r = e.schema[n];
                    if (r.name)
                        if (r.array) {
                            i[r.name] = [];
                            const o = Array.isArray(t[r.name]) ? t[r.name] : [];
                            for (let l = 0; l < o.length; l++)
                                i[r.name].push(vu(a, r, o[l]))
                        } else {
                            const o = t.hasOwnProperty(r.name) ? t[r.name] : r.default;
                            i[r.name] = vu(a, r, o)
                        }
                }
            }
            return i
        }
    case "asset":
        return t instanceof le ? t : typeof t == "number" ? a.assets.get(t) || null : typeof t == "string" && a.assets.get(parseInt(t, 10)) || null;
    case "entity":
        return t instanceof yt ? t : typeof t == "string" ? a.getEntityFromIndex(t) : null;
    case "rgb":
    case "rgba":
        if (t instanceof z)
            return s instanceof z ? (s.copy(t),
            s) : t.clone();
        if (t instanceof Array && t.length >= 3 && t.length <= 4) {
            for (let i = 0; i < t.length; i++)
                if (typeof t[i] != "number")
                    return null;
            return s || (s = new z),
            s.r = t[0],
            s.g = t[1],
            s.b = t[2],
            s.a = t.length === 3 ? 1 : t[3],
            s
        } else if (typeof t == "string" && /#([0-9abcdef]{2}){3,4}/i.test(t))
            return s || (s = new z),
            s.fromString(t),
            s;
        return null;
    case "vec2":
    case "vec3":
    case "vec4":
        {
            const i = parseInt(e.type.slice(3), 10)
              , n = dF[i];
            if (t instanceof n)
                return s instanceof n ? (s.copy(t),
                s) : t.clone();
            if (t instanceof Array && t.length === i) {
                for (let r = 0; r < t.length; r++)
                    if (typeof t[r] != "number")
                        return null;
                s || (s = new n);
                for (let r = 0; r < i; r++)
                    s[cF[r]] = t[r];
                return s
            }
            return null
        }
    case "curve":
        if (t) {
            let i;
            if (t instanceof Ot || t instanceof Qt)
                i = t.clone();
            else {
                const n = t.keys[0]instanceof Array ? Qt : Ot;
                i = new n(t.keys),
                i.type = t.type
            }
            return i
        }
        break
    }
    return t
}
class Pn {
    constructor(e) {
        this.scriptType = e,
        this.index = {}
    }
    add(e, t) {
        this.index[e] || Pn.reservedNames.has(e) || (this.index[e] = t,
        Object.defineProperty(this.scriptType.prototype, e, {
            get: function() {
                return this.__attributes[e]
            },
            set: function(s) {
                const i = "attr"
                  , n = "attr:" + e
                  , r = this.__attributes[e];
                let o = r;
                if (r && t.type !== "json" && t.type !== "entity" && r.clone && (this.hasEvent(i) || this.hasEvent(n)) && (o = r.clone()),
                t.array) {
                    if (this.__attributes[e] = [],
                    s)
                        for (let l = 0, c = s.length; l < c; l++)
                            this.__attributes[e].push(vu(this.app, t, s[l], r ? r[l] : null))
                } else
                    this.__attributes[e] = vu(this.app, t, s, r);
                this.fire(i, e, this.__attributes[e], o),
                this.fire(n, this.__attributes[e], o)
            }
        }))
    }
    remove(e) {
        return this.index[e] ? (delete this.index[e],
        delete this.scriptType.prototype[e],
        !0) : !1
    }
    has(e) {
        return !!this.index[e]
    }
    get(e) {
        return this.index[e] || null
    }
}
Pn.reservedNames = new Set(["app", "entity", "enabled", "_enabled", "_enabledOld", "_destroyed", "__attributes", "__attributesRaw", "__scriptType", "__executionOrder", "_callbacks", "_callbackActive", "has", "get", "on", "off", "fire", "once", "hasEvent"]);
const Jm = "initialize"
  , e_ = "postInitialize"
  , uF = "update"
  , fF = "postUpdate"
  , pF = "swap";
class Un extends _e {
    constructor(e, t) {
        super(e, t),
        this._scripts = [],
        this._updateList = new qd({
            sortBy: "__executionOrder"
        }),
        this._postUpdateList = new qd({
            sortBy: "__executionOrder"
        }),
        this._scriptsIndex = {},
        this._destroyedScripts = [],
        this._destroyed = !1,
        this._scriptsData = null,
        this._oldState = !0,
        this._enabled = !0,
        this._beingEnabled = !1,
        this._isLoopingThroughScripts = !1,
        this._executionOrder = -1,
        this.on("set_enabled", this._onSetEnabled, this)
    }
    set scripts(e) {
        this._scriptsData = e;
        for (const t in e) {
            if (!e.hasOwnProperty(t))
                continue;
            const s = this._scriptsIndex[t];
            if (s) {
                if (typeof e[t].enabled == "boolean" && (s.enabled = !!e[t].enabled),
                typeof e[t].attributes == "object") {
                    for (const i in e[t].attributes)
                        if (!Pn.reservedNames.has(i)) {
                            if (!s.__attributes.hasOwnProperty(i)) {
                                const n = this.system.app.scripts.get(t);
                                n && n.attributes.add(i, {})
                            }
                            s[i] = e[t].attributes[i]
                        }
                }
            } else
                console.log(this.order)
        }
    }
    get scripts() {
        return this._scripts
    }
    set enabled(e) {
        const t = this._enabled;
        this._enabled = e,
        this.fire("set", "enabled", t, e)
    }
    get enabled() {
        return this._enabled
    }
    onEnable() {
        this._beingEnabled = !0,
        this._checkState(),
        this.entity._beingEnabled || this.onPostStateChange(),
        this._beingEnabled = !1
    }
    onDisable() {
        this._checkState()
    }
    onPostStateChange() {
        const e = this._beginLooping();
        for (let t = 0, s = this.scripts.length; t < s; t++) {
            const i = this.scripts[t];
            i._initialized && !i._postInitialized && i.enabled && (i._postInitialized = !0,
            i.postInitialize && this._scriptMethod(i, e_))
        }
        this._endLooping(e)
    }
    _beginLooping() {
        const e = this._isLoopingThroughScripts;
        return this._isLoopingThroughScripts = !0,
        e
    }
    _endLooping(e) {
        this._isLoopingThroughScripts = e,
        this._isLoopingThroughScripts || this._removeDestroyedScripts()
    }
    _onSetEnabled(e, t, s) {
        this._beingEnabled = !0,
        this._checkState(),
        this._beingEnabled = !1
    }
    _checkState() {
        const e = this.enabled && this.entity.enabled;
        if (e === this._oldState)
            return;
        this._oldState = e,
        this.fire(e ? "enable" : "disable"),
        this.fire("state", e),
        e ? this.system._addComponentToEnabled(this) : this.system._removeComponentFromEnabled(this);
        const t = this._beginLooping();
        for (let s = 0, i = this.scripts.length; s < i; s++) {
            const n = this.scripts[s];
            n.enabled = n._enabled
        }
        this._endLooping(t)
    }
    _onBeforeRemove() {
        this.fire("remove");
        const e = this._beginLooping();
        for (let t = 0; t < this.scripts.length; t++) {
            const s = this.scripts[t];
            s && this.destroy(s.__scriptType.__name)
        }
        this._endLooping(e)
    }
    _removeDestroyedScripts() {
        const e = this._destroyedScripts.length;
        if (e) {
            for (let t = 0; t < e; t++) {
                const s = this._destroyedScripts[t];
                this._removeScriptInstance(s)
            }
            this._destroyedScripts.length = 0,
            this._resetExecutionOrder(0, this._scripts.length)
        }
    }
    _onInitializeAttributes() {
        for (let e = 0, t = this.scripts.length; e < t; e++)
            this.scripts[e].__initializeAttributes()
    }
    _scriptMethod(e, t, s) {
        e[t](s)
    }
    _onInitialize() {
        const e = this._scripts
          , t = this._beginLooping();
        for (let s = 0, i = e.length; s < i; s++) {
            const n = e[s];
            !n._initialized && n.enabled && (n._initialized = !0,
            n.initialize && this._scriptMethod(n, Jm))
        }
        this._endLooping(t)
    }
    _onPostInitialize() {
        this.onPostStateChange()
    }
    _onUpdate(e) {
        const t = this._updateList;
        if (!t.length)
            return;
        const s = this._beginLooping();
        for (t.loopIndex = 0; t.loopIndex < t.length; t.loopIndex++) {
            const i = t.items[t.loopIndex];
            i.enabled && this._scriptMethod(i, uF, e)
        }
        this._endLooping(s)
    }
    _onPostUpdate(e) {
        const t = this._postUpdateList;
        if (!t.length)
            return;
        const s = this._beginLooping();
        for (t.loopIndex = 0; t.loopIndex < t.length; t.loopIndex++) {
            const i = t.items[t.loopIndex];
            i.enabled && this._scriptMethod(i, fF, e)
        }
        this._endLooping(s)
    }
    _insertScriptInstance(e, t, s) {
        t === -1 ? (this._scripts.push(e),
        e.__executionOrder = s,
        e.update && this._updateList.append(e),
        e.postUpdate && this._postUpdateList.append(e)) : (this._scripts.splice(t, 0, e),
        e.__executionOrder = t,
        this._resetExecutionOrder(t + 1, s + 1),
        e.update && this._updateList.insert(e),
        e.postUpdate && this._postUpdateList.insert(e))
    }
    _removeScriptInstance(e) {
        const t = this._scripts.indexOf(e);
        return t === -1 || (this._scripts.splice(t, 1),
        e.update && this._updateList.remove(e),
        e.postUpdate && this._postUpdateList.remove(e)),
        t
    }
    _resetExecutionOrder(e, t) {
        for (let s = e; s < t; s++)
            this._scripts[s].__executionOrder = s
    }
    _resolveEntityScriptAttribute(e, t, s, i, n, r) {
        if (e.array) {
            const o = s.length;
            if (!o)
                return;
            const l = s.slice();
            for (let c = 0; c < o; c++) {
                const d = l[c]instanceof V ? l[c].getGuid() : l[c];
                r[d] && (l[c] = i ? r[d].getGuid() : r[d])
            }
            n[t] = l
        } else {
            if (s instanceof V)
                s = s.getGuid();
            else if (typeof s != "string")
                return;
            r[s] && (n[t] = r[s])
        }
    }
    has(e) {
        if (typeof e == "string")
            return !!this._scriptsIndex[e];
        if (!e)
            return !1;
        const t = e
          , s = t.__name
          , i = this._scriptsIndex[s];
        return (i && i.instance)instanceof t
    }
    get(e) {
        if (typeof e == "string") {
            const r = this._scriptsIndex[e];
            return r ? r.instance : null
        }
        if (!e)
            return null;
        const t = e
          , s = t.__name
          , i = this._scriptsIndex[s]
          , n = i && i.instance;
        return n instanceof t ? n : null
    }
    create(e, t={}) {
        const s = this;
        let i = e
          , n = e;
        if (typeof i == "string" ? i = this.system.app.scripts.get(i) : i && (n = i.__name),
        i) {
            if (!this._scriptsIndex[n] || !this._scriptsIndex[n].instance) {
                const r = new i({
                    app: this.system.app,
                    entity: this.entity,
                    enabled: t.hasOwnProperty("enabled") ? t.enabled : !0,
                    attributes: t.attributes
                })
                  , o = this._scripts.length;
                let l = -1;
                return typeof t.ind == "number" && t.ind !== -1 && o > t.ind && (l = t.ind),
                this._insertScriptInstance(r, l, o),
                this._scriptsIndex[n] = {
                    instance: r,
                    onSwap: function() {
                        s.swap(n)
                    }
                },
                this[n] = r,
                t.preloading || r.__initializeAttributes(),
                this.fire("create", n, r),
                this.fire("create:" + n, r),
                this.system.app.scripts.on("swap:" + n, this._scriptsIndex[n].onSwap),
                t.preloading || (r.enabled && !r._initialized && (r._initialized = !0,
                r.initialize && this._scriptMethod(r, Jm)),
                r.enabled && !r._postInitialized && (r._postInitialized = !0,
                r.postInitialize && this._scriptMethod(r, e_))),
                r
            }
        } else
            this._scriptsIndex[n] = {
                awaiting: !0,
                ind: this._scripts.length
            };
        return null
    }
    destroy(e) {
        let t = e
          , s = e;
        typeof s == "string" ? s = this.system.app.scripts.get(s) : s && (t = s.__name);
        const i = this._scriptsIndex[t];
        if (delete this._scriptsIndex[t],
        !i)
            return !1;
        const n = i.instance;
        if (n && !n._destroyed)
            if (n.enabled = !1,
            n._destroyed = !0,
            this._isLoopingThroughScripts)
                this._destroyedScripts.push(n);
            else {
                const r = this._removeScriptInstance(n);
                r >= 0 && this._resetExecutionOrder(r, this._scripts.length)
            }
        return this.system.app.scripts.off("swap:" + t, i.onSwap),
        delete this[t],
        this.fire("destroy", t, n || null),
        this.fire("destroy:" + t, n || null),
        n && n.fire("destroy"),
        !0
    }
    swap(e) {
        let t = e
          , s = e;
        typeof s == "string" ? s = this.system.app.scripts.get(s) : s && (t = s.__name);
        const i = this._scriptsIndex[t];
        if (!i || !i.instance)
            return !1;
        const n = i.instance
          , r = this._scripts.indexOf(n)
          , o = new s({
            app: this.system.app,
            entity: this.entity,
            enabled: n.enabled,
            attributes: n.__attributes
        });
        return o.swap ? (o.__initializeAttributes(),
        this._scripts[r] = o,
        this._scriptsIndex[t].instance = o,
        this[t] = o,
        o.__executionOrder = r,
        n.update && this._updateList.remove(n),
        n.postUpdate && this._postUpdateList.remove(n),
        o.update && this._updateList.insert(o),
        o.postUpdate && this._postUpdateList.insert(o),
        this._scriptMethod(o, pF, n),
        this.fire("swap", t, o),
        this.fire("swap:" + t, o),
        !0) : !1
    }
    resolveDuplicatedEntityReferenceProperties(e, t) {
        const s = this.entity.script;
        for (const i in e._scriptsIndex) {
            const n = this.system.app.scripts.get(i);
            if (!n)
                continue;
            const r = e._scriptsIndex[i];
            if (!r || !r.instance)
                continue;
            const o = s[i].__attributesRaw
              , l = s[i].__attributes;
            if (!o && !l)
                continue;
            const c = !!o
              , d = r.instance.__attributes;
            for (const h in d) {
                if (!d[h])
                    continue;
                const u = n.attributes.get(h);
                if (u) {
                    if (u.type === "entity")
                        this._resolveEntityScriptAttribute(u, h, d[h], c, o || l, t);
                    else if (u.type === "json" && Array.isArray(u.schema)) {
                        const f = d[h]
                          , p = o ? o[h] : l[h];
                        for (let _ = 0; _ < u.schema.length; _++) {
                            const m = u.schema[_];
                            if (m.type === "entity")
                                if (u.array)
                                    for (let g = 0; g < f.length; g++)
                                        this._resolveEntityScriptAttribute(m, m.name, f[g][m.name], c, p[g], t);
                                else
                                    this._resolveEntityScriptAttribute(m, m.name, f[m.name], c, p, t)
                        }
                    }
                }
            }
        }
    }
    move(e, t) {
        const s = this._scripts.length;
        if (t >= s || t < 0)
            return !1;
        let i = e
          , n = e;
        typeof n != "string" ? n = e.__name : i = null;
        const r = this._scriptsIndex[n];
        if (!r || !r.instance)
            return !1;
        const o = r.instance;
        if (i && !(o instanceof i))
            return !1;
        const l = this._scripts.indexOf(o);
        return l === -1 || l === t ? !1 : (this._scripts.splice(t, 0, this._scripts.splice(l, 1)[0]),
        this._resetExecutionOrder(0, s),
        this._updateList.sort(),
        this._postUpdateList.sort(),
        this.fire("move", n, o, t, l),
        this.fire("move:" + n, o, t, l),
        !0)
    }
}
Un.EVENT_CREATE = "create";
Un.EVENT_DESTROY = "destroy";
Un.EVENT_ENABLE = "enable";
Un.EVENT_DISABLE = "disable";
Un.EVENT_REMOVE = "remove";
Un.EVENT_STATE = "state";
Un.EVENT_MOVE = "move";
Un.EVENT_ERROR = "error";
class mF {
    constructor() {
        this.enabled = !0
    }
}
const _F = "_onInitializeAttributes"
  , gF = "_onInitialize"
  , yF = "_onPostInitialize"
  , vF = "_onUpdate"
  , SF = "_onPostUpdate";
let md = 0;
class xF extends it {
    constructor(e) {
        super(e),
        this.id = "script",
        this.ComponentType = Un,
        this.DataType = mF,
        this._components = new qd({
            sortBy: "_executionOrder"
        }),
        this._enabledComponents = new qd({
            sortBy: "_executionOrder"
        }),
        this.preloading = !0,
        this.on("beforeremove", this._onBeforeRemove, this),
        this.app.systems.on("initialize", this._onInitialize, this),
        this.app.systems.on("postInitialize", this._onPostInitialize, this),
        this.app.systems.on("update", this._onUpdate, this),
        this.app.systems.on("postUpdate", this._onPostUpdate, this)
    }
    initializeComponentData(e, t) {
        if (e._executionOrder = md++,
        this._components.append(e),
        md > Number.MAX_SAFE_INTEGER && this._resetExecutionOrder(),
        e.enabled = t.hasOwnProperty("enabled") ? !!t.enabled : !0,
        e.enabled && e.entity.enabled && this._enabledComponents.append(e),
        t.hasOwnProperty("order") && t.hasOwnProperty("scripts")) {
            e._scriptsData = t.scripts;
            for (let s = 0; s < t.order.length; s++)
                e.create(t.order[s], {
                    enabled: t.scripts[t.order[s]].enabled,
                    attributes: t.scripts[t.order[s]].attributes,
                    preloading: this.preloading
                })
        }
    }
    cloneComponent(e, t) {
        const s = []
          , i = {};
        for (let r = 0; r < e.script._scripts.length; r++) {
            const o = e.script._scripts[r]
              , l = o.__scriptType.__name;
            s.push(l);
            const c = {};
            for (const d in o.__attributes)
                c[d] = o.__attributes[d];
            i[l] = {
                enabled: o._enabled,
                attributes: c
            }
        }
        for (const r in e.script._scriptsIndex)
            r.awaiting && s.splice(r.ind, 0, r);
        const n = {
            enabled: e.script.enabled,
            order: s,
            scripts: i
        };
        return this.addComponent(t, n)
    }
    _resetExecutionOrder() {
        md = 0;
        for (let e = 0, t = this._components.length; e < t; e++)
            this._components.items[e]._executionOrder = md++
    }
    _callComponentMethod(e, t, s) {
        for (e.loopIndex = 0; e.loopIndex < e.length; e.loopIndex++)
            e.items[e.loopIndex][t](s)
    }
    _onInitialize() {
        this.preloading = !1,
        this._callComponentMethod(this._components, _F),
        this._callComponentMethod(this._enabledComponents, gF)
    }
    _onPostInitialize() {
        this._callComponentMethod(this._enabledComponents, yF)
    }
    _onUpdate(e) {
        this._callComponentMethod(this._enabledComponents, vF, e)
    }
    _onPostUpdate(e) {
        this._callComponentMethod(this._enabledComponents, SF, e)
    }
    _addComponentToEnabled(e) {
        this._enabledComponents.insert(e)
    }
    _removeComponentFromEnabled(e) {
        this._enabledComponents.remove(e)
    }
    _onBeforeRemove(e, t) {
        this._components.items.indexOf(t) >= 0 && t._onBeforeRemove(),
        this._removeComponentFromEnabled(t),
        this._components.remove(t)
    }
    destroy() {
        super.destroy(),
        this.app.systems.off("initialize", this._onInitialize, this),
        this.app.systems.off("postInitialize", this._onPostInitialize, this),
        this.app.systems.off("update", this._onUpdate, this),
        this.app.systems.off("postUpdate", this._onPostUpdate, this)
    }
}
class vw extends _e {
    constructor(e, t) {
        super(e, t),
        this._layers = [Bn],
        this._instance = null,
        this._customAabb = null,
        this._assetReference = void 0,
        this._materialOptions = null,
        this._assetReference = new Bh("asset",this,e.app.assets,{
            add: this._onGSplatAssetAdded,
            load: this._onGSplatAssetLoad,
            remove: this._onGSplatAssetRemove,
            unload: this._onGSplatAssetUnload
        },this),
        t.on("remove", this.onRemoveChild, this),
        t.on("removehierarchy", this.onRemoveChild, this),
        t.on("insert", this.onInsertChild, this),
        t.on("inserthierarchy", this.onInsertChild, this)
    }
    set customAabb(e) {
        var t;
        this._customAabb = e,
        (t = this._instance) == null || t.meshInstance.setCustomAabb(this._customAabb)
    }
    get customAabb() {
        return this._customAabb
    }
    set instance(e) {
        if (this.destroyInstance(),
        this._instance = e,
        this._instance) {
            const t = this._instance.meshInstance;
            t.node || (t.node = this.entity),
            t.setCustomAabb(this._customAabb),
            this._materialOptions && this._instance.createMaterial(this._materialOptions),
            this.enabled && this.entity.enabled && this.addToLayers()
        }
    }
    get instance() {
        return this._instance
    }
    set materialOptions(e) {
        this._materialOptions = Object.assign({}, e),
        this._instance && this._instance.createMaterial(this._materialOptions)
    }
    get materialOptions() {
        return this._materialOptions
    }
    get material() {
        var e;
        return (e = this._instance) == null ? void 0 : e.material
    }
    set layers(e) {
        this.removeFromLayers(),
        this._layers.length = 0;
        for (let t = 0; t < e.length; t++)
            this._layers[t] = e[t];
        !this.enabled || !this.entity.enabled || this.addToLayers()
    }
    get layers() {
        return this._layers
    }
    set asset(e) {
        const t = e instanceof le ? e.id : e;
        this._assetReference.id !== t && (this._assetReference.asset && this._assetReference.asset.resource && this._onGSplatAssetRemove(),
        this._assetReference.id = t,
        this._assetReference.asset && this._onGSplatAssetAdded())
    }
    get asset() {
        return this._assetReference.id
    }
    assignAsset(e) {
        const t = e instanceof le ? e.id : e;
        this._assetReference.id = t
    }
    destroyInstance() {
        if (this._instance) {
            var e;
            this.removeFromLayers(),
            (e = this._instance) == null || e.destroy(),
            this._instance = null
        }
    }
    addToLayers() {
        var e;
        const t = (e = this.instance) == null ? void 0 : e.meshInstance;
        if (t) {
            const i = this.system.app.scene.layers;
            for (let n = 0; n < this._layers.length; n++) {
                var s;
                (s = i.getLayerById(this._layers[n])) == null || s.addMeshInstances([t])
            }
        }
    }
    removeFromLayers() {
        var e;
        const t = (e = this.instance) == null ? void 0 : e.meshInstance;
        if (t) {
            const i = this.system.app.scene.layers;
            for (let n = 0; n < this._layers.length; n++) {
                var s;
                (s = i.getLayerById(this._layers[n])) == null || s.removeMeshInstances([t])
            }
        }
    }
    onRemoveChild() {
        this.removeFromLayers()
    }
    onInsertChild() {
        this._instance && this.enabled && this.entity.enabled && this.addToLayers()
    }
    onRemove() {
        this.destroyInstance(),
        this.asset = null,
        this._assetReference.id = null,
        this.entity.off("remove", this.onRemoveChild, this),
        this.entity.off("insert", this.onInsertChild, this)
    }
    onLayersChanged(e, t) {
        this.addToLayers(),
        e.off("add", this.onLayerAdded, this),
        e.off("remove", this.onLayerRemoved, this),
        t.on("add", this.onLayerAdded, this),
        t.on("remove", this.onLayerRemoved, this)
    }
    onLayerAdded(e) {
        this.layers.indexOf(e.id) < 0 || this._instance && e.addMeshInstances(this._instance.meshInstance)
    }
    onLayerRemoved(e) {
        this.layers.indexOf(e.id) < 0 || this._instance && e.removeMeshInstances(this._instance.meshInstance)
    }
    onEnable() {
        const e = this.system.app.scene;
        e.on("set:layers", this.onLayersChanged, this),
        e.layers && (e.layers.on("add", this.onLayerAdded, this),
        e.layers.on("remove", this.onLayerRemoved, this)),
        this._instance ? this.addToLayers() : this.asset && this._onGSplatAssetAdded()
    }
    onDisable() {
        const e = this.system.app.scene;
        e.off("set:layers", this.onLayersChanged, this),
        e.layers && (e.layers.off("add", this.onLayerAdded, this),
        e.layers.off("remove", this.onLayerRemoved, this)),
        this.removeFromLayers()
    }
    hide() {
        this._instance && (this._instance.meshInstance.visible = !1)
    }
    show() {
        this._instance && (this._instance.meshInstance.visible = !0)
    }
    _onGSplatAssetAdded() {
        this._assetReference.asset && (this._assetReference.asset.resource ? this._onGSplatAssetLoad() : this.enabled && this.entity.enabled && this.system.app.assets.load(this._assetReference.asset))
    }
    _onGSplatAssetLoad() {
        this.destroyInstance();
        const e = this._assetReference.asset;
        e && (this.instance = e.resource.createInstance())
    }
    _onGSplatAssetUnload() {
        this.destroyInstance()
    }
    _onGSplatAssetRemove() {
        this._onGSplatAssetUnload()
    }
}
class wF {
    constructor() {
        this.enabled = !0
    }
}
const t_ = ["enabled"]
  , Gr = ["instance", "asset", "layers"];
class bF extends it {
    constructor(e) {
        super(e),
        this.id = "gsplat",
        this.ComponentType = vw,
        this.DataType = wF,
        this.schema = t_,
        this.on("beforeremove", this.onRemove, this)
    }
    initializeComponentData(e, t, s) {
        t.layers && t.layers.length && (t.layers = t.layers.slice(0));
        for (let i = 0; i < Gr.length; i++)
            t.hasOwnProperty(Gr[i]) && (e[Gr[i]] = t[Gr[i]]);
        t.aabbCenter && t.aabbHalfExtents && (e.customAabb = new Pe(new y(t.aabbCenter),new y(t.aabbHalfExtents))),
        super.initializeComponentData(e, t, t_)
    }
    cloneComponent(e, t) {
        const s = e.gsplat
          , i = {};
        for (let r = 0; r < Gr.length; r++)
            i[Gr[r]] = s[Gr[r]];
        i.enabled = s.enabled,
        delete i.instance;
        const n = this.addComponent(t, i);
        return n.instance = s.instance.clone(),
        s.customAabb && (n.customAabb = s.customAabb.clone()),
        n
    }
    onRemove(e, t) {
        t.onRemove()
    }
}
_e._buildAccessors(vw.prototype, t_);
class Sg extends fe {
    constructor() {
        super(),
        this._meshes = null
    }
    set meshes(e) {
        this.decRefMeshes(),
        this._meshes = e,
        this.incRefMeshes(),
        this.fire("set:meshes", e)
    }
    get meshes() {
        return this._meshes
    }
    destroy() {
        this.meshes = null
    }
    decRefMeshes() {
        if (this._meshes) {
            const e = this._meshes.length;
            for (let t = 0; t < e; t++) {
                const s = this._meshes[t];
                s && (s.decRefCount(),
                s.refCount < 1 && (s.destroy(),
                this._meshes[t] = null))
            }
        }
    }
    incRefMeshes() {
        if (this._meshes) {
            const e = this._meshes.length;
            for (let t = 0; t < e; t++)
                this._meshes[t] && this._meshes[t].incRefCount()
        }
    }
}
Sg.EVENT_SETMESHES = "set:meshes";
function Vd(a) {
    const e = this;
    if (!e.resource)
        return;
    const t = a.resource
      , s = t.renders && t.renders[e.data.renderIndex];
    s && (e.resource.meshes = s.resource.meshes)
}
function Pv(a) {
    const e = this;
    e.registry.off("load:" + a.id, Vd, e),
    e.registry.on("load:" + a.id, Vd, e),
    e.registry.off("remove:" + a.id, Rv, e),
    e.registry.once("remove:" + a.id, Rv, e),
    a.resource ? Vd.call(e, a) : e.registry.load(a)
}
function Rv(a) {
    const e = this;
    e.registry.off("load:" + a.id, Vd, e),
    e.resource && e.resource.destroy()
}
class TF {
    constructor(e) {
        this.handlerType = "render",
        this._registry = e.assets
    }
    load(e, t, s) {}
    open(e, t) {
        return new Sg
    }
    patch(e, t) {
        if (!e.data.containerAsset)
            return;
        const s = t.get(e.data.containerAsset);
        if (!s) {
            t.once("add:" + e.data.containerAsset, Pv, e);
            return
        }
        Pv.call(e, s)
    }
}
class Sw {
    constructor(e, t, s, i) {
        this._paths = e,
        this._input = t,
        this._output = s,
        this._interpolation = i
    }
    get paths() {
        return this._paths
    }
    get input() {
        return this._input
    }
    get output() {
        return this._output
    }
    get interpolation() {
        return this._interpolation
    }
}
class Su {
    constructor(e, t) {
        this._components = e,
        this._data = t
    }
    get components() {
        return this._components
    }
    get data() {
        return this._data
    }
}
function CF(a, e) {
    let t;
    const n = (f, p) => {
        switch (p) {
        case t.DT_INT8:
            return new Int8Array(f.buffer,f.byteOffset,f.byteLength);
        case t.DT_INT16:
            return new Int16Array(f.buffer,f.byteOffset,f.byteLength / 2);
        case t.DT_INT32:
            return new Int32Array(f.buffer,f.byteOffset,f.byteLength / 4);
        case t.DT_UINT8:
            return new Uint8Array(f.buffer,f.byteOffset,f.byteLength);
        case t.DT_UINT16:
            return new Uint16Array(f.buffer,f.byteOffset,f.byteLength / 2);
        case t.DT_UINT32:
            return new Uint32Array(f.buffer,f.byteOffset,f.byteLength / 4);
        case t.DT_FLOAT32:
            return new Float32Array(f.buffer,f.byteOffset,f.byteLength / 4)
        }
        return null
    }
      , r = f => {
        switch (f) {
        case t.DT_INT8:
            return 1;
        case t.DT_INT16:
            return 2;
        case t.DT_INT32:
            return 4;
        case t.DT_UINT8:
            return 1;
        case t.DT_UINT16:
            return 2;
        case t.DT_UINT32:
            return 4;
        case t.DT_FLOAT32:
            return 4
        }
        return 1
    }
      , o = f => f.num_components() * r(f.data_type())
      , l = {
        0: 0,
        1: 1,
        5: 2,
        2: 3,
        7: 4,
        8: 5,
        4: 6,
        3: 7
    }
      , c = (f, p) => {
        const _ = (L, U, I) => {
            L[0] = U[0] - I[0],
            L[1] = U[1] - I[1],
            L[2] = U[2] - I[2]
        }
          , m = (L, U, I) => {
            L[0] = U[1] * I[2] - I[1] * U[2],
            L[1] = U[2] * I[0] - I[2] * U[0],
            L[2] = U[0] * I[1] - I[0] * U[1]
        }
          , g = (L, U) => {
            const I = L[U + 0]
              , O = L[U + 1]
              , D = L[U + 2]
              , A = 1 / Math.sqrt(I * I + O * O + D * D);
            L[U + 0] *= A,
            L[U + 1] *= A,
            L[U + 2] *= A
        }
          , v = (L, U, I) => {
            for (let O = 0; O < 3; ++O)
                L[O] = U[I + O]
        }
          , x = p.length / 3
          , S = f.length / 3
          , w = new Float32Array(f.length)
          , T = [0, 0, 0]
          , b = [0, 0, 0]
          , E = [0, 0, 0]
          , C = [0, 0, 0]
          , R = [0, 0, 0]
          , F = [0, 0, 0];
        for (let L = 0; L < x; ++L) {
            const U = p[L * 3 + 0] * 3
              , I = p[L * 3 + 1] * 3
              , O = p[L * 3 + 2] * 3;
            v(T, f, U),
            v(b, f, I),
            v(E, f, O),
            _(C, b, T),
            _(R, E, T),
            m(F, C, R),
            g(F, 0);
            for (let D = 0; D < 3; ++D)
                w[U + D] += F[D],
                w[I + D] += F[D],
                w[O + D] += F[D]
        }
        for (let L = 0; L < S; ++L)
            g(w, L * 3);
        return new Uint8Array(w.buffer)
    }
      , d = f => {
        const p = {}
          , _ = new t.DecoderBuffer;
        _.Init(f, f.length);
        const m = new t.Decoder;
        if (m.GetEncodedGeometryType(_) !== t.TRIANGULAR_MESH)
            return p.error = "Failed to decode draco mesh: not a mesh",
            p;
        const g = new t.Mesh
          , v = m.DecodeBufferToMesh(_, g);
        if (!v || !v.ok() || g.ptr === 0)
            return p.error = "Failed to decode draco asset",
            p;
        const x = g.num_faces() * 3
          , S = g.num_points() <= 65535
          , w = x * (S ? 2 : 4)
          , T = t._malloc(w);
        S ? (m.GetTrianglesUInt16Array(g, w, T),
        p.indices = new Uint16Array(t.HEAPU16.buffer,T,x).slice().buffer) : (m.GetTrianglesUInt32Array(g, w, T),
        p.indices = new Uint32Array(t.HEAPU32.buffer,T,x).slice().buffer),
        t._free(T);
        const b = [];
        for (let U = 0; U < g.num_attributes(); ++U)
            b.push(m.GetAttribute(g, U));
        b.sort( (U, I) => {
            var O, D;
            return ((O = l[U.attribute_type()]) != null ? O : l.length) - ((D = l[I.attribute_type()]) != null ? D : l.length)
        }
        ),
        p.attributes = b.map(U => U.unique_id());
        let E = 0;
        const C = b.map(U => {
            const I = E;
            return E += Math.ceil(o(U) / 4) * 4,
            I
        }
        )
          , R = b.some(U => U.attribute_type() === 1)
          , F = C[1];
        if (!R) {
            for (let U = 1; U < C.length; ++U)
                C[U] += 12;
            E += 12
        }
        p.vertices = new ArrayBuffer(g.num_points() * E);
        const L = new Uint8Array(p.vertices);
        for (let U = 0; U < g.num_attributes(); ++U) {
            const I = b[U]
              , O = o(I)
              , D = g.num_points() * O
              , A = t._malloc(D);
            m.GetAttributeDataArrayForAllPoints(g, I, I.data_type(), D, A);
            const k = new Uint8Array(t.HEAPU8.buffer,A,D);
            for (let N = 0; N < g.num_points(); ++N)
                for (let H = 0; H < O; ++H)
                    L[N * E + C[U] + H] = k[N * O + H];
            if (!R && I.attribute_type() === 0) {
                const N = c(n(k, I.data_type()), S ? new Uint16Array(p.indices) : new Uint32Array(p.indices));
                for (let H = 0; H < g.num_points(); ++H)
                    for (let K = 0; K < 12; ++K)
                        L[H * E + F + K] = N[H * 12 + K]
            }
            t._free(A)
        }
        return t.destroy(g),
        t.destroy(m),
        t.destroy(_),
        p
    }
      , h = f => {
        const p = d(new Uint8Array(f.buffer));
        self.postMessage({
            jobId: f.jobId,
            error: p.error,
            indices: p.indices,
            vertices: p.vertices,
            attributes: p.attributes
        }, [p.indices, p.vertices].filter(_ => _ != null))
    }
      , u = [];
    self.onmessage = f => {
        const p = f.data;
        switch (p.type) {
        case "init":
            self.DracoDecoderModule({
                instantiateWasm: (_, m) => (WebAssembly.instantiate(p.module, _).then(g => m(g)).catch(g => console.error("instantiate failed + " + g)),
                {})
            }).then(_ => {
                t = _,
                u.forEach(m => h(m))
            }
            );
            break;
        case "decodeMesh":
            t ? h(p) : u.push(p);
            break
        }
    }
}
const Iv = 3;
class EF {
    constructor() {
        this.workers = [[], [], []],
        this.jobId = 0,
        this.jobQueue = [],
        this.jobCallbacks = new Map,
        this.run = (e, t) => {
            e.postMessage({
                type: "decodeMesh",
                jobId: t.jobId,
                buffer: t.buffer
            }, [t.buffer])
        }
    }
    init(e) {
        for (e.forEach(t => {
            t.addEventListener("message", s => {
                const i = s.data
                  , n = this.jobCallbacks.get(i.jobId);
                if (n && n(i.error, {
                    indices: i.indices,
                    vertices: i.vertices,
                    attributes: i.attributes
                }),
                this.jobCallbacks.delete(i.jobId),
                this.jobQueue.length > 0) {
                    const r = this.jobQueue.shift();
                    this.run(t, r)
                } else {
                    const r = this.workers[2].indexOf(t);
                    if (r !== -1)
                        this.workers[2].splice(r, 1),
                        this.workers[1].push(t);
                    else {
                        const o = this.workers[1].indexOf(t);
                        o !== -1 && (this.workers[1].splice(o, 1),
                        this.workers[0].push(t))
                    }
                }
            }
            )
        }
        ),
        this.workers[0] = e; this.jobQueue.length && (this.workers[0].length || this.workers[1].length); ) {
            const t = this.jobQueue.shift();
            if (this.workers[0].length > 0) {
                const s = this.workers[0].shift();
                this.workers[1].push(s),
                this.run(s, t)
            } else {
                const s = this.workers[1].shift();
                this.workers[2].push(s),
                this.run(s, t)
            }
        }
    }
    enqueueJob(e, t) {
        const s = {
            jobId: this.jobId++,
            buffer: e
        };
        if (this.jobCallbacks.set(s.jobId, t),
        this.workers[0].length > 0) {
            const i = this.workers[0].shift();
            this.workers[1].push(i),
            this.run(i, s)
        } else if (this.workers[1].length > 0) {
            const i = this.workers[1].shift();
            this.workers[2].push(i),
            this.run(i, s)
        } else
            this.jobQueue.push(s)
    }
}
const AF = a => new Promise( (e, t) => {
    const s = {
        cache: !0,
        responseType: "text",
        retry: Iv > 0,
        maxRetries: Iv
    };
    st.get(a, s, (i, n) => {
        i ? t(i) : e(n)
    }
    )
}
)
  , MF = a => {
    const e = () => fetch(a).then(s => s.arrayBuffer()).then(s => WebAssembly.compile(s))
      , t = () => WebAssembly.compileStreaming(fetch(a)).catch(s => e());
    return WebAssembly.compileStreaming ? t() : e()
}
  , Lv = 1;
let Gd;
const PF = a => {
    if (Gd)
        return !0;
    if (!a) {
        const e = TS.getConfig("DracoDecoderModule");
        e ? a = {
            jsUrl: e.glueUrl,
            wasmUrl: e.wasmUrl,
            numWorkers: e.numWorkers
        } : a = {
            jsUrl: "draco.wasm.js",
            wasmUrl: "draco.wasm.wasm",
            numWorkers: Lv
        }
    }
    return !a.jsUrl || !a.wasmUrl ? !1 : (Gd = new EF,
    Promise.all([AF(a.jsUrl), MF(a.wasmUrl)]).then( ([e,t]) => {
        const s = ["/* draco */", e, "/* worker */", `(
${CF.toString()}
)()

`].join(`
`)
          , i = new Blob([s],{
            type: "application/javascript"
        })
          , n = URL.createObjectURL(i)
          , r = Math.max(1, Math.min(16, a.numWorkers || Lv))
          , o = [];
        for (let l = 0; l < r; ++l) {
            const c = new Worker(n);
            c.postMessage({
                type: "init",
                module: t
            }),
            o.push(c)
        }
        Gd.init(o)
    }
    ),
    !0)
}
  , RF = (a, e) => PF() ? (Gd.enqueueJob(a, e),
!0) : !1;
class IF {
    constructor() {
        this.gltf = void 0,
        this.nodes = void 0,
        this.scenes = void 0,
        this.animations = void 0,
        this.textures = void 0,
        this.materials = void 0,
        this.variants = void 0,
        this.meshVariants = void 0,
        this.meshDefaultMaterials = void 0,
        this.renders = void 0,
        this.skins = void 0,
        this.lights = void 0,
        this.cameras = void 0
    }
    destroy() {
        this.renders && this.renders.forEach(e => {
            e.meshes = null
        }
        )
    }
}
const xw = a => /^data:.*,.*$/i.test(a)
  , LF = a => a.substring(a.indexOf(":") + 1, a.indexOf(";"))
  , kh = a => {
    switch (a) {
    case "SCALAR":
        return 1;
    case "VEC2":
        return 2;
    case "VEC3":
        return 3;
    case "VEC4":
        return 4;
    case "MAT2":
        return 4;
    case "MAT3":
        return 9;
    case "MAT4":
        return 16;
    default:
        return 3
    }
}
  , Rf = a => {
    switch (a) {
    case 5120:
        return Ca;
    case 5121:
        return Wi;
    case 5122:
        return Ea;
    case 5123:
        return wr;
    case 5124:
        return nc;
    case 5125:
        return il;
    case 5126:
        return Me;
    default:
        return 0
    }
}
  , DF = a => {
    switch (a) {
    case 5120:
        return 1;
    case 5121:
        return 1;
    case 5122:
        return 2;
    case 5123:
        return 2;
    case 5124:
        return 4;
    case 5125:
        return 4;
    case 5126:
        return 4;
    default:
        return 0
    }
}
  , OF = a => {
    switch (a) {
    case 5120:
        return Int8Array;
    case 5121:
        return Uint8Array;
    case 5122:
        return Int16Array;
    case 5123:
        return Uint16Array;
    case 5124:
        return Int32Array;
    case 5125:
        return Uint32Array;
    case 5126:
        return Float32Array;
    default:
        return null
    }
}
  , xu = {
    POSITION: ut,
    NORMAL: Is,
    TANGENT: Qi,
    COLOR_0: jt,
    JOINTS_0: Ps,
    WEIGHTS_0: Ji,
    TEXCOORD_0: Ls,
    TEXCOORD_1: xr,
    TEXCOORD_2: Kh,
    TEXCOORD_3: Zh,
    TEXCOORD_4: Qh,
    TEXCOORD_5: Jh,
    TEXCOORD_6: ec,
    TEXCOORD_7: tc
}
  , Dv = {
    [ut]: 0,
    [Is]: 1,
    [Qi]: 2,
    [jt]: 3,
    [Ps]: 4,
    [Ji]: 5,
    [Ls]: 6,
    [xr]: 7,
    [Kh]: 8,
    [Zh]: 9,
    [Qh]: 10,
    [Jh]: 11,
    [ec]: 12,
    [tc]: 13
}
  , FF = a => {
    switch (a) {
    case Ca:
        return e => Math.max(e / 127, -1);
    case Wi:
        return e => e / 255;
    case Ea:
        return e => Math.max(e / 32767, -1);
    case wr:
        return e => e / 65535;
    default:
        return e => e
    }
}
  , s_ = (a, e, t) => {
    const s = FF(t)
      , i = e.length;
    for (let n = 0; n < i; ++n)
        a[n] = s(e[n]);
    return a
}
  , aa = (a, e, t=!1) => {
    const s = kh(a.type)
      , i = OF(a.componentType);
    if (!i)
        return null;
    let n;
    if (a.sparse) {
        const r = a.sparse
          , o = {
            count: r.count,
            type: "SCALAR"
        }
          , l = aa(Object.assign(o, r.indices), e, !0)
          , c = {
            count: r.count,
            type: a.type,
            componentType: a.componentType
        }
          , d = aa(Object.assign(c, r.values), e, !0);
        if (a.hasOwnProperty("bufferView")) {
            const h = {
                bufferView: a.bufferView,
                byteOffset: a.byteOffset,
                componentType: a.componentType,
                count: a.count,
                type: a.type
            };
            n = aa(h, e, !0).slice()
        } else
            n = new i(a.count * s);
        for (let h = 0; h < r.count; ++h) {
            const u = l[h];
            for (let f = 0; f < s; ++f)
                n[u * s + f] = d[h * s + f]
        }
    } else if (a.hasOwnProperty("bufferView")) {
        const r = e[a.bufferView];
        if (t && r.hasOwnProperty("byteStride")) {
            const o = s * i.BYTES_PER_ELEMENT
              , l = new ArrayBuffer(a.count * o)
              , c = new Uint8Array(l);
            let d = 0;
            for (let h = 0; h < a.count; ++h) {
                let u = (a.byteOffset || 0) + h * r.byteStride;
                for (let f = 0; f < o; ++f)
                    c[d++] = r[u++]
            }
            n = new i(l)
        } else
            n = new i(r.buffer,r.byteOffset + (a.byteOffset || 0),a.count * s)
    } else
        n = new i(a.count * s);
    return n
}
  , i_ = (a, e) => {
    const t = aa(a, e, !0);
    if (t instanceof Float32Array || !a.normalized)
        return t;
    const s = new Float32Array(t.length);
    return s_(s, t, Rf(a.componentType)),
    s
}
  , n_ = a => {
    let e = a.min
      , t = a.max;
    if (!e || !t)
        return null;
    if (a.normalized) {
        const s = Rf(a.componentType);
        e = s_([], e, s),
        t = s_([], t, s)
    }
    return new Pe(new y((t[0] + e[0]) * .5,(t[1] + e[1]) * .5,(t[2] + e[2]) * .5),new y((t[0] - e[0]) * .5,(t[1] - e[1]) * .5,(t[2] - e[2]) * .5))
}
  , ww = a => {
    if (!a.hasOwnProperty("mode"))
        return xn;
    switch (a.mode) {
    case 0:
        return af;
    case 1:
        return of;
    case 2:
        return RS;
    case 3:
        return IS;
    case 4:
        return xn;
    case 5:
        return Ks;
    case 6:
        return Zr;
    default:
        return xn
    }
}
  , BF = a => {
    const e = new Uint16Array(a);
    for (let t = 0; t < a; t++)
        e[t] = t;
    return e
}
  , kF = (a, e) => {
    const t = a[ut];
    if (!t || t.components !== 3)
        return;
    let s;
    if (t.size !== t.stride) {
        const o = t.stride / th[t.type]
          , l = new bo[t.type](t.buffer,t.offset,t.count * o);
        s = new bo[t.type](t.count * 3);
        for (let c = 0; c < t.count; ++c)
            s[c * 3 + 0] = l[c * o + 0],
            s[c * 3 + 1] = l[c * o + 1],
            s[c * 3 + 2] = l[c * o + 2]
    } else
        s = new bo[t.type](t.buffer,t.offset,t.count * 3);
    const i = t.count;
    e || (e = BF(i));
    const n = SA(s, e)
      , r = new Float32Array(n.length);
    r.set(n),
    a[Is] = {
        buffer: r.buffer,
        size: 12,
        offset: 0,
        stride: 12,
        count: i,
        components: 3,
        type: Me
    }
}
  , NF = a => {
    let e, t;
    const s = []
      , i = []
      , n = [];
    for (e = 0; e < a.format.elements.length; ++e) {
        const o = a.format.elements[e];
        if (o.name === Ls || o.name === xr)
            switch (o.dataType) {
            case Me:
                s.push({
                    offset: o.offset / 4 + 1,
                    stride: o.stride / 4
                });
                break;
            case wr:
                i.push({
                    offset: o.offset / 2 + 1,
                    stride: o.stride / 2
                });
                break;
            case Wi:
                n.push({
                    offset: o.offset + 1,
                    stride: o.stride
                });
                break
            }
    }
    const r = (o, l, c) => {
        const d = new l(a.storage);
        for (e = 0; e < o.length; ++e) {
            let h = o[e].offset;
            const u = o[e].stride;
            for (t = 0; t < a.numVertices; ++t)
                d[h] = c - d[h],
                h += u
        }
    }
    ;
    s.length > 0 && r(s, Float32Array, 1),
    i.length > 0 && r(i, Uint16Array, 65535),
    n.length > 0 && r(n, Uint8Array, 255)
}
  , UF = a => {
    const e = s => {
        const i = [];
        for (let n = 0; n < s._levels.length; ++n) {
            let r = [];
            if (s.cubemap)
                for (let o = 0; o < 6; ++o)
                    r.push(s._levels[n][o]);
            else
                r = s._levels[n];
            i.push(r)
        }
        return i
    }
      , t = new ge(a.device,a);
    return t._levels = e(a),
    t
}
  , zF = a => {
    const e = new le(a.name + "_clone",a.type,a.file,a.data,a.options);
    return e.loaded = !0,
    e.resource = UF(a.resource),
    a.registry.add(e),
    e
}
  , VF = (a, e, t) => {
    const s = e[ut];
    if (!s)
        return null;
    const i = s.count
      , n = [];
    for (const v in e)
        if (e.hasOwnProperty(v)) {
            const x = {
                semantic: v,
                components: e[v].components,
                type: e[v].type,
                normalize: !!e[v].normalize
            };
            fs.isElementValid(a, x) || x.components++,
            n.push(x)
        }
    n.sort( (v, x) => Dv[v.semantic] - Dv[x.semantic]);
    let r, o, l, c, d, h;
    const u = new fs(a,n);
    let f = !0;
    for (r = 0; r < u.elements.length; ++r)
        if (d = u.elements[r],
        c = e[d.name],
        h = c.offset - s.offset,
        c.buffer !== s.buffer || c.stride !== d.stride || c.size !== d.size || h !== d.offset) {
            f = !1;
            break
        }
    const p = new xi(a,u,i,es)
      , _ = p.lock()
      , m = new Uint32Array(_);
    let g;
    if (f)
        g = new Uint32Array(s.buffer,s.offset,i * p.format.size / 4),
        m.set(g);
    else {
        let v, x;
        for (r = 0; r < p.format.elements.length; ++r) {
            d = p.format.elements[r],
            v = d.stride / 4,
            c = e[d.name],
            x = c.stride / 4,
            g = new Uint32Array(c.buffer,c.offset,(c.count - 1) * x + (c.size + 3) / 4);
            let S = 0
              , w = d.offset / 4;
            const T = Math.floor((c.size + 3) / 4);
            for (o = 0; o < i; ++o) {
                for (l = 0; l < T; ++l)
                    m[w + l] = g[S + l];
                S += x,
                w += v
            }
        }
    }
    return t && NF(p),
    p.unlock(),
    p
}
  , GF = (a, e, t, s, i, n, r) => {
    const o = {}
      , l = [];
    for (const h in e)
        e.hasOwnProperty(h) && xu.hasOwnProperty(h) && (o[h] = e[h],
        l.push(h + ":" + e[h]));
    l.sort();
    const c = l.join();
    let d = r[c];
    if (!d) {
        const h = {};
        for (const u in o) {
            const f = s[e[u]]
              , p = aa(f, i)
              , _ = i[f.bufferView]
              , m = xu[u]
              , g = kh(f.type) * DF(f.componentType)
              , v = _ && _.hasOwnProperty("byteStride") ? _.byteStride : g;
            h[m] = {
                buffer: p.buffer,
                size: g,
                offset: p.byteOffset,
                stride: v,
                count: f.count,
                components: kh(f.type),
                type: Rf(f.componentType),
                normalize: f.normalized
            }
        }
        h.hasOwnProperty(Is) || kF(h, t),
        d = VF(a, h, n),
        r[c] = d
    }
    return d
}
  , HF = (a, e, t, s, i, n) => {
    let r, o, l;
    const c = e.joints
      , d = c.length
      , h = [];
    if (e.hasOwnProperty("inverseBindMatrices")) {
        const _ = e.inverseBindMatrices
          , m = aa(t[_], s, !0)
          , g = [];
        for (r = 0; r < d; r++) {
            for (o = 0; o < 16; o++)
                g[o] = m[r * 16 + o];
            l = new ee,
            l.set(g),
            h.push(l)
        }
    } else
        for (r = 0; r < d; r++)
            l = new ee,
            h.push(l);
    const u = [];
    for (r = 0; r < d; r++)
        u[r] = i[c[r]].name;
    const f = u.join("#");
    let p = n.get(f);
    return p || (p = new Tx(a,h,u),
    n.set(f, p)),
    p
}
  , WF = (a, e, t, s, i, n, r) => {
    var o;
    const l = new ms(a);
    l.aabb = n_(t[e.attributes.POSITION]);
    const c = [];
    for (const [h,u] of Object.entries(e.attributes)) {
        var d;
        const f = t[u]
          , p = xu[h]
          , _ = Rf(f.componentType);
        c.push({
            semantic: p,
            components: kh(f.type),
            type: _,
            normalize: (d = f.normalized) != null ? d : p === jt && (_ === Wi || _ === wr)
        })
    }
    if (r.push(new Promise( (h, u) => {
        const f = e.extensions.KHR_draco_mesh_compression;
        RF(s[f.bufferView].slice().buffer, (p, _) => {
            if (p)
                console.log(p),
                u(p);
            else {
                var m;
                const g = {};
                for (const [E,C] of Object.entries(f.attributes))
                    g[xu[E]] = _.attributes.indexOf(C);
                c.sort( (E, C) => g[E.semantic] - g[C.semantic]),
                (m = e.attributes) != null && m.NORMAL || c.splice(1, 0, {
                    semantic: "NORMAL",
                    components: 3,
                    type: Me
                });
                const v = new fs(a,c)
                  , x = _.vertices.byteLength / v.size
                  , S = x <= 65535 ? js : fr
                  , w = _.indices.byteLength / (x <= 65535 ? 2 : 4)
                  , T = new xi(a,v,x,es,_.vertices)
                  , b = new _r(a,S,w,es,_.indices);
                l.vertexBuffer = T,
                l.indexBuffer[0] = b,
                l.primitive[0].type = ww(e),
                l.primitive[0].base = 0,
                l.primitive[0].count = b ? w : x,
                l.primitive[0].indexed = !!b,
                h()
            }
        }
        )
    }
    )),
    e != null && (o = e.extensions) != null && o.KHR_materials_variants) {
        const h = e.extensions.KHR_materials_variants
          , u = {};
        h.mappings.forEach(f => {
            f.variants.forEach(p => {
                u[p] = f.material
            }
            )
        }
        ),
        i[l.id] = u
    }
    return n[l.id] = e.material,
    l
}
  , XF = (a, e, t, s, i, n, r, o, l, c) => {
    const d = [];
    return e.primitives.forEach(h => {
        var u;
        if ((u = h.extensions) != null && u.KHR_draco_mesh_compression)
            d.push(WF(a, h, t, s, r, o, c));
        else {
            let f = h.hasOwnProperty("indices") ? aa(t[h.indices], s, !0) : null;
            const p = GF(a, h.attributes, f, t, s, i, n)
              , _ = ww(h)
              , m = new ms(a);
            if (m.vertexBuffer = p,
            m.primitive[0].type = _,
            m.primitive[0].base = 0,
            m.primitive[0].indexed = f !== null,
            f !== null) {
                let v;
                f instanceof Uint8Array ? v = dm : f instanceof Uint16Array ? v = js : v = fr,
                v === fr && !a.extUintElement && (v = js,
                f = new Uint16Array(f)),
                v === dm && a.isWebGPU && (v = js,
                f = new Uint16Array(f));
                const x = new _r(a,v,f.length,es,f);
                m.indexBuffer[0] = x,
                m.primitive[0].count = f.length
            } else
                m.primitive[0].count = p.numVertices;
            if (h.hasOwnProperty("extensions") && h.extensions.hasOwnProperty("KHR_materials_variants")) {
                const v = h.extensions.KHR_materials_variants
                  , x = {};
                v.mappings.forEach(S => {
                    S.variants.forEach(w => {
                        x[w] = S.material
                    }
                    )
                }
                ),
                r[m.id] = x
            }
            o[m.id] = h.material;
            let g = t[h.attributes.POSITION];
            if (m.aabb = n_(g),
            h.hasOwnProperty("targets")) {
                const v = [];
                h.targets.forEach( (x, S) => {
                    const w = {};
                    x.hasOwnProperty("POSITION") && (g = t[x.POSITION],
                    w.deltaPositions = i_(g, s),
                    w.deltaPositionsType = Me,
                    w.aabb = n_(g)),
                    x.hasOwnProperty("NORMAL") && (g = t[x.NORMAL],
                    w.deltaNormals = i_(g, s),
                    w.deltaNormalsType = Me),
                    e.hasOwnProperty("extras") && e.extras.hasOwnProperty("targetNames") ? w.name = e.extras.targetNames[S] : w.name = S.toString(10),
                    e.hasOwnProperty("weights") && (w.defaultWeight = e.weights[S]),
                    w.preserveData = l.morphPreserveData,
                    v.push(new Pf(w))
                }
                ),
                m.morph = new wx(v,a,{
                    preferHighPrecision: l.morphPreferHighPrecision
                })
            }
            d.push(m)
        }
    }
    ),
    d
}
  , Dt = (a, e, t) => {
    var s;
    let i;
    const n = a.texCoord;
    if (n)
        for (i = 0; i < t.length; ++i)
            e[t[i] + "MapUv"] = n;
    const r = [0, 0]
      , o = [1, 1]
      , l = (s = a.extensions) == null ? void 0 : s.KHR_texture_transform;
    if (l) {
        const c = l.offset || r
          , d = l.scale || o
          , h = l.rotation ? -l.rotation * W.RAD_TO_DEG : 0
          , u = new P(d[0],d[1])
          , f = new P(c[0],1 - d[1] - c[1]);
        for (i = 0; i < t.length; ++i)
            e[`${t[i]}MapTiling`] = u,
            e[`${t[i]}MapOffset`] = f,
            e[`${t[i]}MapRotation`] = h
    }
}
  , jF = (a, e, t) => {
    let s, i;
    if (a.hasOwnProperty("diffuseFactor") ? (s = a.diffuseFactor,
    e.diffuse.set(Math.pow(s[0], 1 / 2.2), Math.pow(s[1], 1 / 2.2), Math.pow(s[2], 1 / 2.2)),
    e.opacity = s[3]) : (e.diffuse.set(1, 1, 1),
    e.opacity = 1),
    a.hasOwnProperty("diffuseTexture")) {
        const n = a.diffuseTexture;
        i = t[n.index],
        e.diffuseMap = i,
        e.diffuseMapChannel = "rgb",
        e.opacityMap = i,
        e.opacityMapChannel = "a",
        Dt(n, e, ["diffuse", "opacity"])
    }
    if (e.useMetalness = !1,
    a.hasOwnProperty("specularFactor") ? (s = a.specularFactor,
    e.specular.set(Math.pow(s[0], 1 / 2.2), Math.pow(s[1], 1 / 2.2), Math.pow(s[2], 1 / 2.2))) : e.specular.set(1, 1, 1),
    a.hasOwnProperty("glossinessFactor") ? e.gloss = a.glossinessFactor : e.gloss = 1,
    a.hasOwnProperty("specularGlossinessTexture")) {
        const n = a.specularGlossinessTexture;
        e.specularEncoding = "srgb",
        e.specularMap = e.glossMap = t[n.index],
        e.specularMapChannel = "rgb",
        e.glossMapChannel = "a",
        Dt(n, e, ["gloss", "metalness"])
    }
}
  , $F = (a, e, t) => {
    if (a.hasOwnProperty("clearcoatFactor") ? e.clearCoat = a.clearcoatFactor * .25 : e.clearCoat = 0,
    a.hasOwnProperty("clearcoatTexture")) {
        const s = a.clearcoatTexture;
        e.clearCoatMap = t[s.index],
        e.clearCoatMapChannel = "r",
        Dt(s, e, ["clearCoat"])
    }
    if (a.hasOwnProperty("clearcoatRoughnessFactor") ? e.clearCoatGloss = a.clearcoatRoughnessFactor : e.clearCoatGloss = 0,
    a.hasOwnProperty("clearcoatRoughnessTexture")) {
        const s = a.clearcoatRoughnessTexture;
        e.clearCoatGlossMap = t[s.index],
        e.clearCoatGlossMapChannel = "g",
        Dt(s, e, ["clearCoatGloss"])
    }
    if (a.hasOwnProperty("clearcoatNormalTexture")) {
        const s = a.clearcoatNormalTexture;
        e.clearCoatNormalMap = t[s.index],
        Dt(s, e, ["clearCoatNormal"]),
        s.hasOwnProperty("scale") && (e.clearCoatBumpiness = s.scale)
    }
    e.clearCoatGlossInvert = !0
}
  , qF = (a, e, t) => {
    e.useLighting = !1,
    e.emissive.copy(e.diffuse),
    e.emissiveTint = e.diffuseTint,
    e.emissiveMap = e.diffuseMap,
    e.emissiveMapUv = e.diffuseMapUv,
    e.emissiveMapTiling.copy(e.diffuseMapTiling),
    e.emissiveMapOffset.copy(e.diffuseMapOffset),
    e.emissiveMapRotation = e.diffuseMapRotation,
    e.emissiveMapChannel = e.diffuseMapChannel,
    e.emissiveVertexColor = e.diffuseVertexColor,
    e.emissiveVertexColorChannel = e.diffuseVertexColorChannel,
    e.useLighting = !1,
    e.useSkybox = !1,
    e.diffuse.set(0, 0, 0),
    e.diffuseTint = !1,
    e.diffuseMap = null,
    e.diffuseVertexColor = !1
}
  , YF = (a, e, t) => {
    if (e.useMetalnessSpecularColor = !0,
    a.hasOwnProperty("specularColorTexture") && (e.specularEncoding = "srgb",
    e.specularMap = t[a.specularColorTexture.index],
    e.specularMapChannel = "rgb",
    Dt(a.specularColorTexture, e, ["specular"])),
    a.hasOwnProperty("specularColorFactor")) {
        const s = a.specularColorFactor;
        e.specular.set(Math.pow(s[0], 1 / 2.2), Math.pow(s[1], 1 / 2.2), Math.pow(s[2], 1 / 2.2))
    } else
        e.specular.set(1, 1, 1);
    a.hasOwnProperty("specularFactor") ? e.specularityFactor = a.specularFactor : e.specularityFactor = 1,
    a.hasOwnProperty("specularTexture") && (e.specularityFactorMapChannel = "a",
    e.specularityFactorMap = t[a.specularTexture.index],
    Dt(a.specularTexture, e, ["specularityFactor"]))
}
  , KF = (a, e, t) => {
    a.hasOwnProperty("ior") && (e.refractionIndex = 1 / a.ior)
}
  , ZF = (a, e, t) => {
    e.blendType = ps,
    e.useDynamicRefraction = !0,
    a.hasOwnProperty("transmissionFactor") && (e.refraction = a.transmissionFactor),
    a.hasOwnProperty("transmissionTexture") && (e.refractionMapChannel = "r",
    e.refractionMap = t[a.transmissionTexture.index],
    Dt(a.transmissionTexture, e, ["refraction"]))
}
  , QF = (a, e, t) => {
    if (e.useSheen = !0,
    a.hasOwnProperty("sheenColorFactor")) {
        const s = a.sheenColorFactor;
        e.sheen.set(Math.pow(s[0], 1 / 2.2), Math.pow(s[1], 1 / 2.2), Math.pow(s[2], 1 / 2.2))
    } else
        e.sheen.set(1, 1, 1);
    a.hasOwnProperty("sheenColorTexture") && (e.sheenMap = t[a.sheenColorTexture.index],
    e.sheenEncoding = "srgb",
    Dt(a.sheenColorTexture, e, ["sheen"])),
    a.hasOwnProperty("sheenRoughnessFactor") ? e.sheenGloss = a.sheenRoughnessFactor : e.sheenGloss = 0,
    a.hasOwnProperty("sheenRoughnessTexture") && (e.sheenGlossMap = t[a.sheenRoughnessTexture.index],
    e.sheenGlossMapChannel = "a",
    Dt(a.sheenRoughnessTexture, e, ["sheenGloss"])),
    e.sheenGlossInvert = !0
}
  , JF = (a, e, t) => {
    if (e.blendType = ps,
    e.useDynamicRefraction = !0,
    a.hasOwnProperty("thicknessFactor") && (e.thickness = a.thicknessFactor),
    a.hasOwnProperty("thicknessTexture") && (e.thicknessMap = t[a.thicknessTexture.index],
    e.thicknessMapChannel = "g",
    Dt(a.thicknessTexture, e, ["thickness"])),
    a.hasOwnProperty("attenuationDistance") && (e.attenuationDistance = a.attenuationDistance),
    a.hasOwnProperty("attenuationColor")) {
        const s = a.attenuationColor;
        e.attenuation.set(Math.pow(s[0], 1 / 2.2), Math.pow(s[1], 1 / 2.2), Math.pow(s[2], 1 / 2.2))
    }
}
  , eB = (a, e, t) => {
    a.hasOwnProperty("emissiveStrength") && (e.emissiveIntensity = a.emissiveStrength)
}
  , tB = (a, e, t) => {
    e.useIridescence = !0,
    a.hasOwnProperty("iridescenceFactor") && (e.iridescence = a.iridescenceFactor),
    a.hasOwnProperty("iridescenceTexture") && (e.iridescenceMapChannel = "r",
    e.iridescenceMap = t[a.iridescenceTexture.index],
    Dt(a.iridescenceTexture, e, ["iridescence"])),
    a.hasOwnProperty("iridescenceIor") && (e.iridescenceRefractionIndex = a.iridescenceIor),
    a.hasOwnProperty("iridescenceThicknessMinimum") && (e.iridescenceThicknessMin = a.iridescenceThicknessMinimum),
    a.hasOwnProperty("iridescenceThicknessMaximum") && (e.iridescenceThicknessMax = a.iridescenceThicknessMaximum),
    a.hasOwnProperty("iridescenceThicknessTexture") && (e.iridescenceThicknessMapChannel = "g",
    e.iridescenceThicknessMap = t[a.iridescenceThicknessTexture.index],
    Dt(a.iridescenceThicknessTexture, e, ["iridescenceThickness"]))
}
  , bw = (a, e, t) => {
    const s = new at;
    s.occludeSpecular = Th,
    s.diffuseTint = !0,
    s.diffuseVertexColor = !0,
    s.specularTint = !0,
    s.specularVertexColor = !0,
    a.hasOwnProperty("name") && (s.name = a.name);
    let i, n;
    if (a.hasOwnProperty("pbrMetallicRoughness")) {
        const o = a.pbrMetallicRoughness;
        if (o.hasOwnProperty("baseColorFactor") ? (i = o.baseColorFactor,
        s.diffuse.set(Math.pow(i[0], 1 / 2.2), Math.pow(i[1], 1 / 2.2), Math.pow(i[2], 1 / 2.2)),
        s.opacity = i[3]) : (s.diffuse.set(1, 1, 1),
        s.opacity = 1),
        o.hasOwnProperty("baseColorTexture")) {
            const l = o.baseColorTexture;
            n = e[l.index],
            s.diffuseMap = n,
            s.diffuseMapChannel = "rgb",
            s.opacityMap = n,
            s.opacityMapChannel = "a",
            Dt(l, s, ["diffuse", "opacity"])
        }
        if (s.useMetalness = !0,
        s.specular.set(1, 1, 1),
        o.hasOwnProperty("metallicFactor") ? s.metalness = o.metallicFactor : s.metalness = 1,
        o.hasOwnProperty("roughnessFactor") ? s.gloss = o.roughnessFactor : s.gloss = 1,
        s.glossInvert = !0,
        o.hasOwnProperty("metallicRoughnessTexture")) {
            const l = o.metallicRoughnessTexture;
            s.metalnessMap = s.glossMap = e[l.index],
            s.metalnessMapChannel = "b",
            s.glossMapChannel = "g",
            Dt(l, s, ["gloss", "metalness"])
        }
    }
    if (a.hasOwnProperty("normalTexture")) {
        const o = a.normalTexture;
        s.normalMap = e[o.index],
        Dt(o, s, ["normal"]),
        o.hasOwnProperty("scale") && (s.bumpiness = o.scale)
    }
    if (a.hasOwnProperty("occlusionTexture")) {
        const o = a.occlusionTexture;
        s.aoMap = e[o.index],
        s.aoMapChannel = "r",
        Dt(o, s, ["ao"])
    }
    if (a.hasOwnProperty("emissiveFactor") ? (i = a.emissiveFactor,
    s.emissive.set(Math.pow(i[0], 1 / 2.2), Math.pow(i[1], 1 / 2.2), Math.pow(i[2], 1 / 2.2)),
    s.emissiveTint = !0) : (s.emissive.set(0, 0, 0),
    s.emissiveTint = !1),
    a.hasOwnProperty("emissiveTexture")) {
        const o = a.emissiveTexture;
        s.emissiveMap = e[o.index],
        Dt(o, s, ["emissive"])
    }
    if (a.hasOwnProperty("alphaMode"))
        switch (a.alphaMode) {
        case "MASK":
            s.blendType = ls,
            a.hasOwnProperty("alphaCutoff") ? s.alphaTest = a.alphaCutoff : s.alphaTest = .5;
            break;
        case "BLEND":
            s.blendType = ps,
            s.depthWrite = !1;
            break;
        default:
        case "OPAQUE":
            s.blendType = ls;
            break
        }
    else
        s.blendType = ls;
    a.hasOwnProperty("doubleSided") ? (s.twoSidedLighting = a.doubleSided,
    s.cull = a.doubleSided ? bt : dr) : (s.twoSidedLighting = !1,
    s.cull = dr);
    const r = {
        KHR_materials_clearcoat: $F,
        KHR_materials_emissive_strength: eB,
        KHR_materials_ior: KF,
        KHR_materials_iridescence: tB,
        KHR_materials_pbrSpecularGlossiness: jF,
        KHR_materials_sheen: QF,
        KHR_materials_specular: YF,
        KHR_materials_transmission: ZF,
        KHR_materials_unlit: qF,
        KHR_materials_volume: JF
    };
    if (a.hasOwnProperty("extensions"))
        for (const o in a.extensions) {
            const l = r[o];
            l !== void 0 && l(a.extensions[o], s, e)
        }
    return s.update(),
    s
}
  , sB = (a, e, t, s, i, n, r) => {
    const o = E => new Su(kh(E.type),i_(E, s))
      , l = {
        STEP: Dx,
        LINEAR: Bm,
        CUBICSPLINE: km
    }
      , c = {}
      , d = {}
      , h = {};
    let u = 1, f;
    for (f = 0; f < a.samplers.length; ++f) {
        const E = a.samplers[f];
        c.hasOwnProperty(E.input) || (c[E.input] = o(t[E.input])),
        d.hasOwnProperty(E.output) || (d[E.output] = o(t[E.output]));
        const C = E.hasOwnProperty("interpolation") && l.hasOwnProperty(E.interpolation) ? l[E.interpolation] : Bm
          , R = {
            paths: [],
            input: E.input,
            output: E.output,
            interpolation: C
        };
        h[f] = R
    }
    const p = []
      , _ = {
        translation: "localPosition",
        rotation: "localRotation",
        scale: "localScale"
    }
      , m = E => {
        const C = [];
        for (; E; )
            C.unshift(E.name),
            E = E.parent;
        return C
    }
      , g = (E, C, R) => {
        const F = d[E.output];
        if (!F)
            return;
        let L;
        if (n && n[C.mesh]) {
            const N = n[C.mesh];
            N.hasOwnProperty("extras") && N.extras.hasOwnProperty("targetNames") && (L = N.extras.targetNames)
        }
        const U = F.data
          , I = U.length / c[E.input].data.length
          , O = U.length / I
          , D = O * 4
          , A = new ArrayBuffer(D * I);
        for (let N = 0; N < I; N++) {
            var k;
            const H = new Float32Array(A,D * N,O);
            for (let ie = 0; ie < O; ie++)
                H[ie] = U[ie * I + N];
            const K = new Su(1,H)
              , q = (k = L) != null && k[N] ? `name.${L[N]}` : N;
            d[-u] = K;
            const se = {
                paths: [{
                    entityPath: R,
                    component: "graph",
                    propertyPath: [`weight.${q}`]
                }],
                input: E.input,
                output: -u,
                interpolation: E.interpolation
            };
            u++,
            h[`morphCurve-${f}-${N}`] = se
        }
    }
    ;
    for (f = 0; f < a.channels.length; ++f) {
        const E = a.channels[f]
          , C = E.target
          , R = h[E.sampler]
          , F = i[C.node]
          , L = r[C.node]
          , U = m(F);
        C.path.startsWith("weights") ? (g(R, L, U),
        h[E.sampler].morphCurve = !0) : R.paths.push({
            entityPath: U,
            component: "graph",
            propertyPath: [_[C.path]]
        })
    }
    const v = []
      , x = []
      , S = [];
    for (const E in c)
        v.push(c[E]),
        c[E] = v.length - 1;
    for (const E in d)
        x.push(d[E]),
        d[E] = x.length - 1;
    for (const E in h) {
        const C = h[E];
        C.morphCurve || (S.push(new Sw(C.paths,c[C.input],d[C.output],C.interpolation)),
        C.paths.length > 0 && C.paths[0].propertyPath[0] === "localRotation" && C.interpolation !== km && p.push(S[S.length - 1].output))
    }
    p.sort();
    let w = null, T;
    for (f = 0; f < p.length; ++f) {
        const E = p[f];
        if (f === 0 || E !== w) {
            if (T = x[E],
            T.components === 4) {
                const C = T.data
                  , R = C.length - 4;
                for (let F = 0; F < R; F += 4)
                    C[F + 0] * C[F + 4] + C[F + 1] * C[F + 5] + C[F + 2] * C[F + 6] + C[F + 3] * C[F + 7] < 0 && (C[F + 4] *= -1,
                    C[F + 5] *= -1,
                    C[F + 6] *= -1,
                    C[F + 7] *= -1)
            }
            w = E
        }
    }
    let b = 0;
    for (f = 0; f < v.length; f++)
        T = v[f]._data,
        b = Math.max(b, T.length === 0 ? 0 : T[T.length - 1]);
    return new Nn(a.hasOwnProperty("name") ? a.name : "animation_" + e,b,v,x,S)
}
  , _d = new ee
  , io = new y
  , iB = (a, e) => {
    const t = new yt;
    if (a.hasOwnProperty("name") && a.name.length > 0 ? t.name = a.name : t.name = "node_" + e,
    a.hasOwnProperty("matrix") && (_d.data.set(a.matrix),
    _d.getTranslation(io),
    t.setLocalPosition(io),
    _d.getEulerAngles(io),
    t.setLocalEulerAngles(io),
    _d.getScale(io),
    t.setLocalScale(io)),
    a.hasOwnProperty("rotation")) {
        const s = a.rotation;
        t.setLocalRotation(s[0], s[1], s[2], s[3])
    }
    if (a.hasOwnProperty("translation")) {
        const s = a.translation;
        t.setLocalPosition(s[0], s[1], s[2])
    }
    if (a.hasOwnProperty("scale")) {
        const s = a.scale;
        t.setLocalScale(s[0], s[1], s[2])
    }
    return t
}
  , nB = (a, e) => {
    const t = a.type === "orthographic" ? Co : Di
      , s = t === Co ? a.orthographic : a.perspective
      , i = {
        enabled: !1,
        projection: t,
        nearClip: s.znear,
        aspectRatioMode: sg
    };
    s.zfar && (i.farClip = s.zfar),
    t === Co ? (i.orthoHeight = .5 * s.ymag,
    s.ymag && (i.aspectRatioMode = Am,
    i.aspectRatio = s.xmag / s.ymag)) : (i.fov = s.yfov * W.RAD_TO_DEG,
    s.aspectRatio && (i.aspectRatioMode = Am,
    i.aspectRatio = s.aspectRatio));
    const n = new V(a.name);
    return n.addComponent("camera", i),
    n
}
  , rB = (a, e) => {
    const t = {
        enabled: !1,
        type: a.type === "point" ? "omni" : a.type,
        color: a.hasOwnProperty("color") ? new z(a.color) : z.WHITE,
        range: a.hasOwnProperty("range") ? a.range : 9999,
        falloffMode: iA,
        intensity: a.hasOwnProperty("intensity") ? W.clamp(a.intensity, 0, 2) : 1
    };
    a.hasOwnProperty("spot") && (t.innerConeAngle = a.spot.hasOwnProperty("innerConeAngle") ? a.spot.innerConeAngle * W.RAD_TO_DEG : 0,
    t.outerConeAngle = a.spot.hasOwnProperty("outerConeAngle") ? a.spot.outerConeAngle * W.RAD_TO_DEG : Math.PI / 4),
    a.hasOwnProperty("intensity") && (t.luminance = a.intensity * Sx.getLightUnitConversion(Im[t.type], t.outerConeAngle, t.innerConeAngle));
    const s = new V(e.name);
    return s.rotateLocal(90, 0, 0),
    s.addComponent("light", t),
    s
}
  , aB = (a, e, t, s) => {
    if (!e.hasOwnProperty("skins") || e.skins.length === 0)
        return [];
    const i = new Map;
    return e.skins.map(n => HF(a, n, e.accessors, s, t, i))
}
  , oB = (a, e, t, s, i) => {
    var n, r, o;
    const l = {}
      , c = {}
      , d = {}
      , h = [];
    return {
        meshes: !i.skipMeshes && (e == null || (n = e.meshes) == null ? void 0 : n.length) && (e == null || (r = e.accessors) == null ? void 0 : r.length) && (e == null || (o = e.bufferViews) == null ? void 0 : o.length) ? e.meshes.map(p => XF(a, p, e.accessors, t, s, l, c, d, i, h)) : [],
        meshVariants: c,
        meshDefaultMaterials: d,
        promises: h
    }
}
  , lB = (a, e, t, s) => {
    var i, n, r, o;
    if (!a.hasOwnProperty("materials") || a.materials.length === 0)
        return [];
    const l = t == null || (i = t.material) == null ? void 0 : i.preprocess
      , c = (n = t == null || (r = t.material) == null ? void 0 : r.process) != null ? n : bw
      , d = t == null || (o = t.material) == null ? void 0 : o.postprocess;
    return a.materials.map(h => {
        l && l(h);
        const u = c(h, e, s);
        return d && d(h, u),
        u
    }
    )
}
  , hB = a => {
    if (!a.hasOwnProperty("extensions") || !a.extensions.hasOwnProperty("KHR_materials_variants"))
        return null;
    const e = a.extensions.KHR_materials_variants.variants
      , t = {};
    for (let s = 0; s < e.length; s++)
        t[e[s].name] = s;
    return t
}
  , cB = (a, e, t, s) => {
    var i, n;
    if (!a.hasOwnProperty("animations") || a.animations.length === 0)
        return [];
    const r = s == null || (i = s.animation) == null ? void 0 : i.preprocess
      , o = s == null || (n = s.animation) == null ? void 0 : n.postprocess;
    return a.animations.map( (l, c) => {
        r && r(l);
        const d = sB(l, c, a.accessors, t, e, a.meshes, a.nodes);
        return o && o(l, d),
        d
    }
    )
}
  , dB = (a, e) => {
    var t, s, i, n;
    if (!a.hasOwnProperty("nodes") || a.nodes.length === 0)
        return [];
    const r = e == null || (t = e.node) == null ? void 0 : t.preprocess
      , o = (s = e == null || (i = e.node) == null ? void 0 : i.process) != null ? s : iB
      , l = e == null || (n = e.node) == null ? void 0 : n.postprocess
      , c = a.nodes.map( (d, h) => {
        r && r(d);
        const u = o(d, h);
        return l && l(d, u),
        u
    }
    );
    for (let d = 0; d < a.nodes.length; ++d) {
        const h = a.nodes[d];
        if (h.hasOwnProperty("children")) {
            const u = c[d]
              , f = {};
            for (let p = 0; p < h.children.length; ++p) {
                const _ = c[h.children[p]];
                _.parent || (f.hasOwnProperty(_.name) ? _.name += f[_.name]++ : f[_.name] = 1,
                u.addChild(_))
            }
        }
    }
    return c
}
  , uB = (a, e) => {
    var t;
    const s = []
      , i = a.scenes.length;
    if (i === 1 && ((t = a.scenes[0].nodes) == null ? void 0 : t.length) === 1) {
        const n = a.scenes[0].nodes[0];
        s.push(e[n])
    } else
        for (let n = 0; n < i; n++) {
            const r = a.scenes[n];
            if (r.nodes) {
                const o = new yt(r.name);
                for (let l = 0; l < r.nodes.length; l++) {
                    const c = e[r.nodes[l]];
                    o.addChild(c)
                }
                s.push(o)
            }
        }
    return s
}
  , fB = (a, e, t) => {
    let s = null;
    if (a.hasOwnProperty("nodes") && a.hasOwnProperty("cameras") && a.cameras.length > 0) {
        var i, n, r, o;
        const l = t == null || (i = t.camera) == null ? void 0 : i.preprocess
          , c = (n = t == null || (r = t.camera) == null ? void 0 : r.process) != null ? n : nB
          , d = t == null || (o = t.camera) == null ? void 0 : o.postprocess;
        a.nodes.forEach( (h, u) => {
            if (h.hasOwnProperty("camera")) {
                const f = a.cameras[h.camera];
                if (f) {
                    l && l(f);
                    const p = c(f, e[u]);
                    d && d(f, p),
                    p && (s || (s = new Map),
                    s.set(h, p))
                }
            }
        }
        )
    }
    return s
}
  , pB = (a, e, t) => {
    let s = null;
    if (a.hasOwnProperty("nodes") && a.hasOwnProperty("extensions") && a.extensions.hasOwnProperty("KHR_lights_punctual") && a.extensions.KHR_lights_punctual.hasOwnProperty("lights")) {
        const l = a.extensions.KHR_lights_punctual.lights;
        if (l.length) {
            var i, n, r, o;
            const c = t == null || (i = t.light) == null ? void 0 : i.preprocess
              , d = (n = t == null || (r = t.light) == null ? void 0 : r.process) != null ? n : rB
              , h = t == null || (o = t.light) == null ? void 0 : o.postprocess;
            a.nodes.forEach( (u, f) => {
                if (u.hasOwnProperty("extensions") && u.extensions.hasOwnProperty("KHR_lights_punctual") && u.extensions.KHR_lights_punctual.hasOwnProperty("light")) {
                    const p = u.extensions.KHR_lights_punctual.light
                      , _ = l[p];
                    if (_) {
                        c && c(_);
                        const m = d(_, e[f]);
                        h && h(_, m),
                        m && (s || (s = new Map),
                        s.set(u, m))
                    }
                }
            }
            )
        }
    }
    return s
}
  , mB = (a, e, t) => {
    a.nodes.forEach(s => {
        s.hasOwnProperty("mesh") && s.hasOwnProperty("skin") && e[s.mesh].meshes.forEach(n => {
            n.skin = t[s.skin]
        }
        )
    }
    )
}
  , _B = async (a, e, t, s, i) => {
    var n, r;
    const o = i == null || (n = i.global) == null ? void 0 : n.preprocess
      , l = i == null || (r = i.global) == null ? void 0 : r.postprocess;
    o && o(e);
    const c = e.asset && e.asset.generator === "PlayCanvas"
      , d = dB(e, i)
      , h = uB(e, d)
      , u = pB(e, d, i)
      , f = fB(e, d, i)
      , p = hB(e)
      , _ = await Promise.all(t)
      , {meshes: m, meshVariants: g, meshDefaultMaterials: v, promises: x} = oB(a, e, _, c, i)
      , S = cB(e, d, _, i)
      , w = await Promise.all(s)
      , T = w.map(F => F.resource)
      , b = lB(e, T, i, c)
      , E = aB(a, e, d, _)
      , C = [];
    for (let F = 0; F < m.length; F++)
        C[F] = new Sg,
        C[F].meshes = m[F];
    mB(e, C, E);
    const R = new IF;
    return R.gltf = e,
    R.nodes = d,
    R.scenes = h,
    R.animations = S,
    R.textures = w,
    R.materials = b,
    R.variants = p,
    R.meshVariants = g,
    R.meshDefaultMaterials = v,
    R.renders = C,
    R.skins = E,
    R.lights = u,
    R.cameras = f,
    l && l(e, R),
    await Promise.all(x),
    R
}
  , gB = (a, e) => {
    const t = (n, r) => {
        switch (n) {
        case 9728:
            return be;
        case 9729:
            return ot;
        case 9984:
            return Vh;
        case 9985:
            return Hh;
        case 9986:
            return Gh;
        case 9987:
            return ur;
        default:
            return r
        }
    }
      , s = (n, r) => {
        switch (n) {
        case 33071:
            return oe;
        case 33648:
            return Fu;
        case 10497:
            return wt;
        default:
            return r
        }
    }
    ;
    if (a) {
        var i;
        e = (i = e) != null ? i : {},
        a.minFilter = t(e.minFilter, ur),
        a.magFilter = t(e.magFilter, ot),
        a.addressU = s(e.wrapS, wt),
        a.addressV = s(e.wrapT, wt)
    }
}
;
let yB = 0;
const vB = (a, e, t, s, i) => {
    var n, r, o;
    if (!a.images || a.images.length === 0)
        return [];
    const l = i == null || (n = i.image) == null ? void 0 : n.preprocess
      , c = i == null || (r = i.image) == null ? void 0 : r.processAsync
      , d = i == null || (o = i.image) == null ? void 0 : o.postprocess
      , h = {
        "image/png": "png",
        "image/jpeg": "jpg",
        "image/basis": "basis",
        "image/ktx": "ktx",
        "image/ktx2": "ktx2",
        "image/vnd-ms.dds": "dds"
    }
      , u = (f, p, _, m, g) => new Promise( (v, x) => {
        const S = w => {
            const T = (f.name || "gltf-texture") + "-" + yB++
              , b = {
                url: p || T
            };
            if (w && (b.contents = w.slice(0).buffer),
            m) {
                const C = h[m];
                C && (b.filename = b.url + "." + C)
            }
            const E = new le(T,"texture",b,null,g);
            E.on("load", C => v(C)),
            E.on("error", C => x(C)),
            s.add(E),
            s.load(E)
        }
        ;
        _ ? _.then(w => S(w)) : S(null)
    }
    );
    return a.images.map( (f, p) => {
        l && l(f);
        let _;
        return c ? _ = new Promise( (m, g) => {
            c(f, (v, x) => {
                v ? g(v) : m(x)
            }
            )
        }
        ) : _ = new Promise(m => {
            m(null)
        }
        ),
        _ = _.then(m => m || (f.hasOwnProperty("uri") ? xw(f.uri) ? u(f, f.uri, null, LF(f.uri), null) : u(f, Ko.test(f.uri) ? f.uri : ye.join(t, f.uri), null, null, {
            crossOrigin: "anonymous"
        }) : f.hasOwnProperty("bufferView") && f.hasOwnProperty("mimeType") ? u(f, null, e[f.bufferView], f.mimeType, null) : Promise.reject(new Error(`Invalid image found in gltf (neither uri or bufferView found). index=${p}`)))),
        d && (_ = _.then(m => (d(f, m),
        m))),
        _
    }
    )
}
  , SB = (a, e, t) => {
    var s, i, n, r, o;
    if (!(a != null && (s = a.images) != null && s.length) || !(a != null && (i = a.textures) != null && i.length))
        return [];
    const l = t == null || (n = t.texture) == null ? void 0 : n.preprocess
      , c = t == null || (r = t.texture) == null ? void 0 : r.processAsync
      , d = t == null || (o = t.texture) == null ? void 0 : o.postprocess
      , h = new Set;
    return a.textures.map(u => {
        l && l(u);
        let f;
        return c ? f = new Promise( (p, _) => {
            c(u, a.images, (m, g) => {
                m ? _(m) : p(g)
            }
            )
        }
        ) : f = new Promise(p => {
            p(null)
        }
        ),
        f = f.then(p => {
            var _, m, g, v, x;
            p = (_ = (m = (g = p) != null ? g : u == null || (v = u.extensions) == null || (v = v.KHR_texture_basisu) == null ? void 0 : v.source) != null ? m : u == null || (x = u.extensions) == null || (x = x.EXT_texture_webp) == null ? void 0 : x.source) != null ? _ : u.source;
            const S = h.has(p);
            return h.add(p),
            e[p].then(w => {
                var T;
                const b = S ? zF(w) : w;
                return gB(b.resource, ((T = a.samplers) != null ? T : [])[u.sampler]),
                b
            }
            )
        }
        ),
        d && (f = f.then(p => (d(u, p),
        p))),
        f
    }
    )
}
  , xB = (a, e, t, s) => {
    var i, n, r;
    if (!a.buffers || a.buffers.length === 0)
        return [];
    const o = s == null || (i = s.buffer) == null ? void 0 : i.preprocess
      , l = s == null || (n = s.buffer) == null ? void 0 : n.processAsync
      , c = s == null || (r = s.buffer) == null ? void 0 : r.postprocess;
    return a.buffers.map( (d, h) => {
        o && o(d);
        let u;
        return l ? u = new Promise( (f, p) => {
            l(d, (_, m) => {
                _ ? p(_) : f(m)
            }
            )
        }
        ) : u = new Promise(f => {
            f(null)
        }
        ),
        u = u.then(f => {
            if (f)
                return f;
            if (d.hasOwnProperty("uri")) {
                if (xw(d.uri)) {
                    const p = atob(d.uri.split(",")[1])
                      , _ = new Uint8Array(p.length);
                    for (let m = 0; m < p.length; m++)
                        _[m] = p.charCodeAt(m);
                    return _
                }
                return new Promise( (p, _) => {
                    st.get(Ko.test(d.uri) ? d.uri : ye.join(t, d.uri), {
                        cache: !0,
                        responseType: "arraybuffer",
                        retry: !1
                    }, (m, g) => {
                        m ? _(m) : p(new Uint8Array(g))
                    }
                    )
                }
                )
            }
            return e
        }
        ),
        c && (u = u.then(f => (c(a.buffers[h], f),
        f))),
        u
    }
    )
}
  , wB = (a, e) => {
    const s = JSON.parse((i => {
        if (typeof TextDecoder < "u")
            return new TextDecoder().decode(i);
        let n = "";
        for (let r = 0; r < i.length; r++)
            n += String.fromCharCode(i[r]);
        return decodeURIComponent(escape(n))
    }
    )(a));
    if (s.asset && s.asset.version && parseFloat(s.asset.version) < 2) {
        e(`Invalid gltf version. Expected version 2.0 or above but found version '${s.asset.version}'.`);
        return
    }
    e(null, s)
}
  , bB = (a, e) => {
    const t = a instanceof ArrayBuffer ? new DataView(a) : new DataView(a.buffer,a.byteOffset,a.byteLength)
      , s = t.getUint32(0, !0)
      , i = t.getUint32(4, !0)
      , n = t.getUint32(8, !0);
    if (s !== 1179937895) {
        e("Invalid magic number found in glb header. Expected 0x46546C67, found 0x" + s.toString(16));
        return
    }
    if (i !== 2) {
        e("Invalid version number found in glb header. Expected 2, found " + i);
        return
    }
    if (n <= 0 || n > t.byteLength) {
        e("Invalid length found in glb header. Found " + n);
        return
    }
    const r = [];
    let o = 12;
    for (; o < n; ) {
        const l = t.getUint32(o, !0);
        o + l + 8 > t.byteLength && e(`Invalid chunk length found in glb. Found ${l}`);
        const c = t.getUint32(o + 4, !0)
          , d = new Uint8Array(t.buffer,t.byteOffset + o + 8,l);
        r.push({
            length: l,
            type: c,
            data: d
        }),
        o += l + 8
    }
    if (r.length !== 1 && r.length !== 2) {
        e("Invalid number of chunks found in glb file.");
        return
    }
    if (r[0].type !== 1313821514) {
        e(`Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x${r[0].type.toString(16)}`);
        return
    }
    if (r.length > 1 && r[1].type !== 5130562) {
        e(`Invalid chunk type found in glb file. Expected 0x004E4942, found 0x${r[1].type.toString(16)}`);
        return
    }
    e(null, {
        gltfChunk: r[0].data,
        binaryChunk: r.length === 2 ? r[1].data : null
    })
}
  , TB = (a, e, t) => {
    const s = () => {
        const i = new Uint8Array(e);
        return i[0] === 103 && i[1] === 108 && i[2] === 84 && i[3] === 70
    }
    ;
    a && a.toLowerCase().endsWith(".glb") || s() ? bB(e, t) : t(null, {
        gltfChunk: e,
        binaryChunk: null
    })
}
  , CB = (a, e, t) => {
    var s, i, n, r;
    const o = []
      , l = t == null || (s = t.bufferView) == null ? void 0 : s.preprocess
      , c = t == null || (i = t.bufferView) == null ? void 0 : i.processAsync
      , d = t == null || (n = t.bufferView) == null ? void 0 : n.postprocess;
    if (!((r = a.bufferViews) != null && r.length))
        return o;
    for (let h = 0; h < a.bufferViews.length; ++h) {
        const u = a.bufferViews[h];
        l && l(u);
        let f;
        c ? f = new Promise( (p, _) => {
            c(u, e, (m, g) => {
                m ? _(m) : p(g)
            }
            )
        }
        ) : f = new Promise(p => {
            p(null)
        }
        ),
        f = f.then(p => p || e[u.buffer].then(_ => new Uint8Array(_.buffer,_.byteOffset + (u.byteOffset || 0),u.byteLength))),
        u.hasOwnProperty("byteStride") && (f = f.then(p => (p.byteStride = u.byteStride,
        p))),
        d && (f = f.then(p => (d(u, p),
        p))),
        o.push(f)
    }
    return o
}
;
class wu {
    static parse(e, t, s, i, n, r, o) {
        TB(e, s, (l, c) => {
            if (l) {
                o(l);
                return
            }
            wB(c.gltfChunk, (d, h) => {
                if (d) {
                    o(d);
                    return
                }
                const u = xB(h, c.binaryChunk, t, r)
                  , f = CB(h, u, r)
                  , p = vB(h, f, t, n, r)
                  , _ = SB(h, p, r);
                _B(i, h, f, _, r).then(m => o(null, m)).catch(m => o(m))
            }
            )
        }
        )
    }
    static createDefaultMaterial() {
        return bw({
            name: "defaultGlbMaterial"
        }, [])
    }
}
class EB {
    constructor(e) {
        this.handlerType = "animation",
        this.device = e.graphicsDevice,
        this.assets = e.assets,
        this.maxRetries = 0
    }
    load(e, t, s) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        });
        const i = {
            retry: this.maxRetries > 0,
            maxRetries: this.maxRetries
        };
        (e.load.startsWith("blob:") || e.load.startsWith("data:")) && (ye.getExtension(e.original).toLowerCase() === ".glb" ? i.responseType = we.ResponseType.ARRAY_BUFFER : i.responseType = we.ResponseType.JSON),
        st.get(e.load, i, (n, r) => {
            if (n)
                t(`Error loading animation resource: ${e.original} [${n}]`);
            else if (ye.getExtension(e.original).toLowerCase() === ".glb") {
                var o;
                wu.parse("filename.glb", "", r, this.device, this.assets, (o = s == null ? void 0 : s.options) != null ? o : {}, (l, c) => {
                    if (l)
                        t(l);
                    else {
                        var d;
                        const h = c.animations;
                        if (s != null && (d = s.data) != null && d.events)
                            for (let u = 0; u < h.length; u++)
                                h[u].events = new kx(Object.values(s.data.events));
                        c.destroy(),
                        t(null, h)
                    }
                }
                )
            } else
                t(null, this["_parseAnimationV" + r.animation.version](r))
        }
        )
    }
    open(e, t, s) {
        return t
    }
    patch(e, t) {}
    _parseAnimationV3(e) {
        const t = e.animation
          , s = new N0;
        s.name = t.name,
        s.duration = t.duration;
        for (let i = 0; i < t.nodes.length; i++) {
            const n = new k0
              , r = t.nodes[i];
            n._name = r.name;
            for (let o = 0; o < r.keys.length; o++) {
                const l = r.keys[o]
                  , c = l.time
                  , d = l.pos
                  , h = l.rot
                  , u = l.scale
                  , f = new y(d[0],d[1],d[2])
                  , p = new ne().setFromEulerAngles(h[0], h[1], h[2])
                  , _ = new y(u[0],u[1],u[2])
                  , m = new B0(c,f,p,_);
                n._keys.push(m)
            }
            s.addNode(n)
        }
        return s
    }
    _parseAnimationV4(e) {
        const t = e.animation
          , s = new N0;
        s.name = t.name,
        s.duration = t.duration;
        for (let i = 0; i < t.nodes.length; i++) {
            const n = new k0
              , r = t.nodes[i];
            n._name = r.name;
            const o = r.defaults.p
              , l = r.defaults.r
              , c = r.defaults.s;
            for (let d = 0; d < r.keys.length; d++) {
                const h = r.keys[d]
                  , u = h.t
                  , f = o || h.p
                  , p = l || h.r
                  , _ = c || h.s
                  , m = new y(f[0],f[1],f[2])
                  , g = new ne().setFromEulerAngles(p[0], p[1], p[2])
                  , v = new y(_[0],_[1],_[2])
                  , x = new B0(u,m,g,v);
                n._keys.push(x)
            }
            s.addNode(n)
        }
        return s
    }
}
class AB {
    constructor(e) {
        this.handlerType = "animclip",
        this.maxRetries = 0
    }
    load(e, t) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        });
        const s = {
            retry: this.maxRetries > 0,
            maxRetries: this.maxRetries
        };
        e.load.startsWith("blob:") && (s.responseType = we.ResponseType.JSON),
        st.get(e.load, s, function(i, n) {
            i ? t(`Error loading animation clip resource: ${e.original} [${i}]`) : t(null, n)
        })
    }
    open(e, t) {
        const s = t.name
          , i = t.duration
          , n = t.inputs.map(function(l) {
            return new Su(1,l)
        })
          , r = t.outputs.map(function(l) {
            return new Su(l.components,l.data)
        })
          , o = t.curves.map(function(l) {
            return new Sw([l.path],l.inputIndex,l.outputIndex,l.interpolation)
        });
        return new Nn(s,i,n,r,o)
    }
    patch(e, t) {}
}
class MB {
    constructor(e) {
        this.handlerType = "animstategraph",
        this.maxRetries = 0
    }
    load(e, t) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        });
        const s = {
            retry: this.maxRetries > 0,
            maxRetries: this.maxRetries
        };
        e.load.startsWith("blob:") && (s.responseType = we.ResponseType.JSON),
        st.get(e.load, s, function(i, n) {
            i ? t(`Error loading animation state graph resource: ${e.original} [${i}]`) : t(null, n)
        })
    }
    open(e, t) {
        return new Ud(t)
    }
    patch(e, t) {}
}
const kp = function() {
    if (typeof window > "u")
        return !1;
    const a = window.navigator.userAgent
      , e = a.indexOf("MSIE ");
    if (e > 0)
        return parseInt(a.substring(e + 5, a.indexOf(".", e)), 10);
    if (a.indexOf("Trident/") > 0) {
        const s = a.indexOf("rv:");
        return parseInt(a.substring(s + 3, a.indexOf(".", s)), 10)
    }
    return !1
}()
  , PB = [".ogg", ".mp3", ".wav", ".mp4a", ".m4a", ".mp4", ".aac", ".opus"];
class RB {
    constructor(e) {
        this.handlerType = "audio",
        this.manager = e.soundManager,
        this.maxRetries = 0
    }
    _isSupported(e) {
        const t = ye.getExtension(e);
        return PB.indexOf(t) > -1
    }
    load(e, t) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        });
        const s = function(r) {
            t(null, new YE(r))
        }
          , i = function(r) {
            let o = "Error loading audio url: " + e.original;
            r && (o += ": " + (r.message || r)),
            console.warn(o),
            t(o)
        };
        if (this._createSound) {
            if (!this._isSupported(e.original)) {
                i(`Audio format for ${e.original} not supported`);
                return
            }
            this._createSound(e.load, s, i)
        } else
            i(null)
    }
    open(e, t) {
        return t
    }
    patch(e, t) {}
    _createSound(e, t, s) {
        if (Fn()) {
            const i = this.manager;
            if (!i.context) {
                s("Audio manager has no audio context");
                return
            }
            const n = {
                retry: this.maxRetries > 0,
                maxRetries: this.maxRetries
            };
            (e.startsWith("blob:") || e.startsWith("data:")) && (n.responseType = we.ResponseType.ARRAY_BUFFER),
            st.get(e, n, function(r, o) {
                if (r) {
                    s(r);
                    return
                }
                i.context.decodeAudioData(o, t, s)
            })
        } else {
            let i = null;
            try {
                i = new Audio
            } catch {
                s("No support for Audio element");
                return
            }
            kp && document.body.appendChild(i);
            const n = function r() {
                i.removeEventListener("canplaythrough", r),
                kp && document.body.removeChild(i),
                t(i)
            };
            i.onerror = function() {
                i.onerror = null,
                kp && document.body.removeChild(i),
                s()
            }
            ,
            i.addEventListener("canplaythrough", n),
            i.src = e
        }
    }
}
class IB {
    constructor(e) {
        this.handlerType = "binary",
        this.maxRetries = 0
    }
    load(e, t) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        }),
        st.get(e.load, {
            responseType: we.ResponseType.ARRAY_BUFFER,
            retry: this.maxRetries > 0,
            maxRetries: this.maxRetries
        }, function(s, i) {
            s ? t(`Error loading binary resource: ${e.original} [${s}]`) : t(null, i)
        })
    }
    open(e, t) {
        return t
    }
    patch(e, t) {}
}
class ir {
    constructor(e, t, s, i) {
        const n = function(d, h, u) {
            const f = ir.createAsset(t.name, d, h, u);
            return s.add(f),
            f
        }
          , r = [];
        for (let c = 0; c < e.renders.length; ++c)
            r.push(n("render", e.renders[c], c));
        const o = [];
        for (let c = 0; c < e.materials.length; ++c)
            o.push(n("material", e.materials[c], c));
        const l = [];
        for (let c = 0; c < e.animations.length; ++c)
            l.push(n("animation", e.animations[c], c));
        this.data = e,
        this._model = null,
        this._assetName = t.name,
        this._assets = s,
        this._defaultMaterial = i,
        this.renders = r,
        this.materials = o,
        this.textures = e.textures,
        this.animations = l
    }
    get model() {
        if (!this._model) {
            const e = ir.createModel(this.data, this._defaultMaterial)
              , t = ir.createAsset(this._assetName, "model", e, 0);
            this._assets.add(t),
            this._model = t
        }
        return this._model
    }
    static createAsset(e, t, s, i) {
        const n = new le(e + "/" + t + "/" + i,t,{
            url: ""
        });
        return n.resource = s,
        n.loaded = !0,
        n
    }
    instantiateModelEntity(e) {
        const t = new V;
        return t.addComponent("model", Object.assign({
            type: "asset",
            asset: this.model
        }, e)),
        t
    }
    instantiateRenderEntity(e) {
        const t = this._defaultMaterial
          , s = []
          , i = function(l, c, d, h, u, f, p) {
            const _ = u[d.id]
              , m = _ === void 0 ? t : h[_]
              , g = new Fe(d,m);
            return d.morph && (g.morphInstance = new Sa(d.morph)),
            p.hasOwnProperty("skin") && s.push({
                meshInstance: g,
                rootBone: l,
                entity: c
            }),
            g
        }
          , n = (o, l, c) => {
            const d = new V;
            l._cloneInternal(d),
            o || (o = d);
            let h = null
              , u = null;
            for (let p = 0; p < c.nodes.length; p++)
                if (c.nodes[p] === l) {
                    const m = c.gltf.nodes[p];
                    if (m.hasOwnProperty("mesh")) {
                        const g = c.renders[m.mesh].meshes;
                        u = this.renders[m.mesh];
                        for (let v = 0; v < g.length; v++) {
                            const x = g[v];
                            if (x) {
                                const S = i(o, d, x, c.materials, c.meshDefaultMaterials, c.skins, m);
                                h || (h = []),
                                h.push(S)
                            }
                        }
                    }
                    if (c.lights) {
                        const g = c.lights.get(m);
                        g && d.addChild(g.clone())
                    }
                    if (c.cameras) {
                        const g = c.cameras.get(m);
                        g && g.camera.system.cloneComponent(g, d)
                    }
                }
            h && (d.addComponent("render", Object.assign({
                type: "asset",
                meshInstances: h,
                rootBone: o
            }, e)),
            d.render.assignAsset(u));
            const f = l.children;
            for (let p = 0; p < f.length; p++) {
                const _ = n(o, f[p], c);
                d.addChild(_)
            }
            return d
        }
          , r = [];
        for (const o of this.data.scenes)
            r.push(n(null, o, this.data));
        return s.forEach(o => {
            o.meshInstance.skinInstance = Vs.createCachedSkinInstance(o.meshInstance.mesh.skin, o.rootBone, o.entity)
        }
        ),
        ir.createSceneHierarchy(r, "Entity")
    }
    getMaterialVariants() {
        return this.data.variants ? Object.keys(this.data.variants) : []
    }
    applyMaterialVariant(e, t) {
        const s = t ? this.data.variants[t] : null;
        if (s === void 0)
            return;
        const i = e.findComponents("render");
        for (let n = 0; n < i.length; n++) {
            const r = i[n];
            this._applyMaterialVariant(s, r.meshInstances)
        }
    }
    applyMaterialVariantInstances(e, t) {
        const s = t ? this.data.variants[t] : null;
        s !== void 0 && this._applyMaterialVariant(s, e)
    }
    _applyMaterialVariant(e, t) {
        t.forEach(s => {
            if (e === null)
                s.material = this._defaultMaterial;
            else {
                const i = this.data.meshVariants[s.mesh.id];
                i && (s.material = this.data.materials[i[e]])
            }
        }
        )
    }
    static createSceneHierarchy(e, t) {
        let s = null;
        if (e.length === 1)
            s = e[0];
        else {
            s = new t("SceneGroup");
            for (const i of e)
                s.addChild(i)
        }
        return s
    }
    static createModel(e, t) {
        const s = function(o, l, c, d, h, u, f) {
            const p = e.meshDefaultMaterials[l.id]
              , _ = p === void 0 ? t : h[p]
              , m = new Fe(l,_,u);
            if (l.morph) {
                const g = new Sa(l.morph);
                m.morphInstance = g,
                o.morphInstances.push(g)
            }
            if (f.hasOwnProperty("skin")) {
                const g = f.skin
                  , v = c[g];
                l.skin = v;
                const x = d[g];
                m.skinInstance = x,
                o.skinInstances.push(x)
            }
            o.meshInstances.push(m)
        }
          , i = new kn
          , n = [];
        for (const r of e.skins) {
            const o = new gc(r);
            o.bones = r.bones,
            n.push(o)
        }
        i.graph = ir.createSceneHierarchy(e.scenes, "GraphNode");
        for (let r = 0; r < e.nodes.length; r++) {
            const o = e.nodes[r];
            if (o.root === i.graph) {
                const l = e.gltf.nodes[r];
                if (l.hasOwnProperty("mesh")) {
                    const c = e.renders[l.mesh].meshes;
                    for (let d = 0; d < c.length; d++) {
                        const h = c[d];
                        h && s(i, h, e.skins, n, e.materials, o, l)
                    }
                }
            }
        }
        return i
    }
    destroy() {
        const e = this._assets
          , t = function(n) {
            e.remove(n),
            n.unload()
        }
          , s = function(n) {
            n.forEach(function(r) {
                t(r)
            })
        };
        this.animations && (s(this.animations),
        this.animations = null),
        this.textures && (s(this.textures),
        this.textures = null),
        this.materials && (s(this.materials),
        this.materials = null),
        this.renders && (s(this.renders),
        this.renders = null),
        this._model && (t(this._model),
        this._model = null),
        this.data = null,
        this.assets = null
    }
}
class LB {
    constructor(e, t, s) {
        this._device = e,
        this._assets = t,
        this._defaultMaterial = wu.createDefaultMaterial(),
        this.maxRetries = s
    }
    _getUrlWithoutParams(e) {
        return e.indexOf("?") >= 0 ? e.split("?")[0] : e
    }
    load(e, t, s) {
        le.fetchArrayBuffer(e.load, (i, n) => {
            i ? t(i) : wu.parse(this._getUrlWithoutParams(e.original), ye.extractPath(e.load), n, this._device, s.registry, s.options, (r, o) => {
                r ? t(r) : t(null, new ir(o,s,this._assets,this._defaultMaterial))
            }
            )
        }
        , s, this.maxRetries)
    }
    open(e, t, s) {
        return t
    }
    patch(e, t) {}
}
class DB {
    constructor(e) {
        this.handlerType = "container",
        this.glbContainerParser = new LB(e.graphicsDevice,e.assets,0),
        this.parsers = {}
    }
    set maxRetries(e) {
        this.glbContainerParser.maxRetries = e;
        for (const t in this.parsers)
            this.parsers.hasOwnProperty(t) && (this.parsers[t].maxRetries = e)
    }
    get maxRetries() {
        return this.glbContainerParser.maxRetries
    }
    _getUrlWithoutParams(e) {
        return e.indexOf("?") >= 0 ? e.split("?")[0] : e
    }
    _getParser(e) {
        const t = e ? ye.getExtension(this._getUrlWithoutParams(e)).toLowerCase().replace(".", "") : null;
        return this.parsers[t] || this.glbContainerParser
    }
    load(e, t, s) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        }),
        this._getParser(e.original).load(e, t, s)
    }
    open(e, t, s) {
        return this._getParser(e).open(e, t, s)
    }
    patch(e, t) {}
}
class OB {
    constructor(e) {
        this.handlerType = "css",
        this.maxRetries = 0
    }
    load(e, t) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        }),
        st.get(e.load, {
            retry: this.maxRetries > 0,
            maxRetries: this.maxRetries
        }, function(s, i) {
            s ? t(`Error loading css resource: ${e.original} [${s}]`) : t(null, i)
        })
    }
    open(e, t) {
        return t
    }
    patch(e, t) {}
}
class FB {
    constructor(e) {
        this.handlerType = "cubemap",
        this._device = e.graphicsDevice,
        this._registry = e.assets,
        this._loader = e.loader
    }
    load(e, t, s) {
        this.loadAssets(s, t)
    }
    open(e, t, s) {
        return s ? s.resource : null
    }
    patch(e, t) {
        this.loadAssets(e, function(s, i) {
            s && (t.fire("error", e),
            t.fire("error:" + e.id, s, e),
            e.fire("error", e))
        })
    }
    getAssetIds(e) {
        const t = [];
        if (t[0] = e.file,
        (e.loadFaces || !e.file) && e.data && e.data.textures)
            for (let s = 0; s < 6; ++s)
                t[s + 1] = e.data.textures[s];
        else
            t[1] = t[2] = t[3] = t[4] = t[5] = t[6] = null;
        return t
    }
    compareAssetIds(e, t) {
        return e && t ? parseInt(e, 10) === e || typeof e == "string" ? e === t : e.url === t.url : e !== null == (t !== null)
    }
    update(e, t, s) {
        const i = e.data || {}
          , n = e._handlerState.assets
          , r = e._resources;
        let o, l, c;
        const d = [null, null, null, null, null, null, null]
          , h = function() {
            return i.hasOwnProperty("type") ? i.type : i.hasOwnProperty("rgbm") ? i.rgbm ? pr : $s : null
        };
        if (!e.loaded || s[0] !== n[0]) {
            if (s[0])
                if (o = s[0].resource,
                o.cubemap)
                    for (c = 0; c < 6; ++c)
                        d[c + 1] = new ge(this._device,{
                            name: e.name + "_prelitCubemap" + (o.width >> c),
                            cubemap: !0,
                            type: h() || o.type,
                            width: o.width >> c,
                            height: o.height >> c,
                            format: o.format,
                            levels: [o._levels[c]],
                            fixCubemapSeams: !0,
                            addressU: oe,
                            addressV: oe,
                            mipmaps: c === 0
                        });
                else
                    o.type = Bo,
                    o.addressU = oe,
                    o.addressV = oe,
                    o.mipmaps = !1,
                    d[1] = o
        } else
            d[1] = r[1] || null,
            d[2] = r[2] || null,
            d[3] = r[3] || null,
            d[4] = r[4] || null,
            d[5] = r[5] || null,
            d[6] = r[6] || null;
        const u = s.slice(1);
        if (!e.loaded || !this.cmpArrays(u, n.slice(1))) {
            if (u.indexOf(null) === -1) {
                var f;
                const p = u.map(function(v) {
                    return v.resource
                })
                  , _ = [];
                for (l = 0; l < p[0]._levels.length; ++l)
                    _.push(p.map(function(v) {
                        return v._levels[l]
                    }));
                const m = p[0].format
                  , g = new ge(this._device,{
                    name: e.name + "_faces",
                    cubemap: !0,
                    type: h() || p[0].type,
                    width: p[0].width,
                    height: p[0].height,
                    format: m === Ln ? ve : m,
                    mipmaps: (f = i.mipmaps) != null ? f : !0,
                    levels: _,
                    minFilter: i.hasOwnProperty("minFilter") ? i.minFilter : p[0].minFilter,
                    magFilter: i.hasOwnProperty("magFilter") ? i.magFilter : p[0].magFilter,
                    anisotropy: i.hasOwnProperty("anisotropy") ? i.anisotropy : 1,
                    addressU: oe,
                    addressV: oe,
                    fixCubemapSeams: !!s[0]
                });
                d[0] = g
            }
        } else
            d[0] = r[0] || null;
        if (!this.cmpArrays(d, r))
            for (e.resources = d,
            e._handlerState.assetIds = t,
            e._handlerState.assets = s,
            c = 0; c < r.length; ++c)
                r[c] !== null && d.indexOf(r[c]) === -1 && r[c].destroy();
        for (c = 0; c < n.length; ++c)
            n[c] !== null && s.indexOf(n[c]) === -1 && n[c].unload()
    }
    cmpArrays(e, t) {
        if (e.length !== t.length)
            return !1;
        for (let s = 0; s < e.length; ++s)
            if (e[s] !== t[s])
                return !1;
        return !0
    }
    resolveId(e) {
        const t = parseInt(e, 10);
        return t === e || t.toString() === e ? t : e
    }
    loadAssets(e, t) {
        e.hasOwnProperty("_handlerState") || (e._handlerState = {
            assetIds: [null, null, null, null, null, null, null],
            assets: [null, null, null, null, null, null, null]
        });
        const s = this
          , i = s.getAssetIds(e)
          , n = [null, null, null, null, null, null, null]
          , r = e._handlerState.assetIds
          , o = e._handlerState.assets
          , l = s._registry;
        let c = 7;
        const d = function(_, m) {
            n[_] = m,
            c--,
            c === 0 && (s.update(e, i, n),
            t(null, e.resources))
        }
          , h = function(_, m, g) {
            t(m)
        }
          , u = function(_, m) {
            m.loaded ? d(_, m) : (l.once("load:" + m.id, d.bind(s, _)),
            l.once("error:" + m.id, h.bind(s, _)),
            m.loading || l.load(m))
        };
        let f;
        for (let p = 0; p < 7; ++p) {
            const _ = this.resolveId(i[p]);
            if (!_)
                d(p, null);
            else if (s.compareAssetIds(_, r[p]))
                d(p, o[p]);
            else if (parseInt(_, 10) === _)
                f = l.get(_),
                f ? u(p, f) : setTimeout((function(m, g) {
                    const v = l.get(g);
                    v ? u(m, v) : h(m, "failed to find dependent cubemap asset=" + g)
                }
                ).bind(null, p, _));
            else {
                const m = typeof _ == "string" ? {
                    url: _,
                    filename: _
                } : _;
                f = new le(e.name + "_part_" + p,"texture",m),
                l.add(f),
                l.once("load:" + f.id, d.bind(s, p)),
                l.once("error:" + f.id, h.bind(s, p)),
                l.load(f)
            }
        }
    }
}
class BB {
    constructor() {
        this.handlerType = "folder"
    }
    load(e, t) {
        t(null, null)
    }
    open(e, t) {
        return t
    }
}
class Ov {
    constructor(e, t) {
        this.type = t && t.type || _u,
        this.em = 1,
        this.textures = e,
        this.intensity = 0,
        this._data = null,
        this.data = t
    }
    set data(e) {
        if (this._data = e,
        !!e && (this._data.intensity !== void 0 && (this.intensity = this._data.intensity),
        this._data.info || (this._data.info = {}),
        (!this._data.version || this._data.version < 2) && (this._data.info.maps = [{
            width: this._data.info.width,
            height: this._data.info.height
        }],
        this._data.chars)))
            for (const t in this._data.chars)
                this._data.chars[t].map = 0
    }
    get data() {
        return this._data
    }
}
function Np(a) {
    return a.version < 3 && (a.version < 2 && (a.info.maps = a.info.maps || [{
        width: a.info.width,
        height: a.info.height
    }]),
    a.chars = Object.keys(a.chars || {}).reduce(function(e, t) {
        const s = a.chars[t]
          , i = s.letter !== void 0 ? s.letter : Rd.fromCodePoint(t);
        return a.version < 2 && (s.map = s.map || 0),
        e[i] = s,
        e
    }, {}),
    a.version = 3),
    a
}
class kB {
    constructor(e) {
        this.handlerType = "font",
        this._loader = e.loader,
        this.maxRetries = 0
    }
    load(e, t, s) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        });
        const i = this;
        ye.getExtension(e.original) === ".json" ? st.get(e.load, {
            retry: this.maxRetries > 0,
            maxRetries: this.maxRetries
        }, function(n, r) {
            if (n)
                t(`Error loading font resource: ${e.original} [${n}]`);
            else {
                const o = Np(r);
                i._loadTextures(e.load.replace(".json", ".png"), o, function(l, c) {
                    l ? t(l) : t(null, {
                        data: o,
                        textures: c
                    })
                })
            }
        }) : (s && s.data && (s.data = Np(s.data)),
        this._loadTextures(e.load, s && s.data, t))
    }
    _loadTextures(e, t, s) {
        const i = t.info.maps.length;
        let n = 0
          , r = null;
        const o = new Array(i)
          , l = this._loader
          , c = function(h) {
            const u = function(p, _) {
                if (!r) {
                    if (p) {
                        r = p,
                        s(p);
                        return
                    }
                    _.upload(),
                    o[h] = _,
                    n++,
                    n === i && s(null, o)
                }
            };
            h === 0 ? l.load(e, "texture", u) : l.load(e.replace(".png", h + ".png"), "texture", u)
        };
        for (let d = 0; d < i; d++)
            c(d)
    }
    open(e, t, s) {
        let i;
        return t.textures ? i = new Ov(t.textures,t.data) : i = new Ov(t,null),
        i
    }
    patch(e, t) {
        const s = e.resource;
        !s.data && e.data ? s.data = e.data : !e.data && s.data && (e.data = s.data),
        e.data && (e.data = Np(e.data))
    }
}
class NB {
    constructor(e, t) {
        this.device = void 0,
        this.splatData = void 0,
        this.splat = null,
        this.device = e,
        this.splatData = t.isCompressed ? t.decompress() : t
    }
    destroy() {
        var e;
        this.device = null,
        this.splatData = null,
        (e = this.splat) == null || e.destroy(),
        this.splat = null
    }
    createSplat() {
        if (!this.splat) {
            const e = this.splatData
              , t = new Pe;
            this.splatData.calcAabb(t);
            const s = new qL(this.device,e.numSplats,t);
            this.splat = s,
            s.updateColorData(e.getProp("f_dc_0"), e.getProp("f_dc_1"), e.getProp("f_dc_2"), e.getProp("opacity")),
            s.updateScaleData(e.getProp("scale_0"), e.getProp("scale_1"), e.getProp("scale_2")),
            s.updateRotationData(e.getProp("rot_0"), e.getProp("rot_1"), e.getProp("rot_2"), e.getProp("rot_3")),
            s.updateCenterData(e.getProp("x"), e.getProp("y"), e.getProp("z"));
            const i = e.getProp("x")
              , n = e.getProp("y")
              , r = e.getProp("z")
              , o = new Float32Array(this.splatData.numSplats * 3);
            for (let l = 0; l < this.splatData.numSplats; ++l)
                o[l * 3 + 0] = i[l],
                o[l * 3 + 1] = n[l],
                o[l * 3 + 2] = r[l];
            s.centers = o
        }
        return this.splat
    }
    instantiate(e={}) {
        const t = this.createInstance(e)
          , s = new V
          , i = s.addComponent("gsplat", {
            instance: t
        });
        return i.customAabb = t.splat.aabb.clone(),
        s
    }
    createInstance(e={}) {
        const t = this.createSplat();
        return new dg(t,e)
    }
}
const Fv = new Uint8Array([112, 108, 121, 10])
  , Bv = new Uint8Array([10, 101, 110, 100, 95, 104, 101, 97, 100, 101, 114, 10])
  , kv = new Map([["char", Int8Array], ["uchar", Uint8Array], ["short", Int16Array], ["ushort", Uint16Array], ["int", Int32Array], ["uint", Uint32Array], ["float", Float32Array], ["double", Float64Array]])
  , UB = async (a, e=null) => {
    const t = (f, p) => {
        const _ = new Uint8Array(f.byteLength + p.byteLength);
        return _.set(f),
        _.set(p, f.byteLength),
        _
    }
      , s = (f, p) => {
        const _ = f.length - p.length;
        let m, g;
        for (m = 0; m <= _; ++m) {
            for (g = 0; g < p.length && f[m + g] === p[g]; ++g)
                ;
            if (g === p.length)
                return m
        }
        return -1
    }
      , i = (f, p) => {
        if (f.length < p.length)
            return !1;
        for (let _ = 0; _ < p.length; ++_)
            if (f[_] !== p[_])
                return !1;
        return !0
    }
    ;
    let n, r;
    for (; ; ) {
        const {value: f, done: p} = await a.read();
        if (p)
            throw new Error("Stream finished before end of header");
        if (n = n ? t(n, f) : f,
        n.length >= Fv.length && !i(n, Fv))
            throw new Error("Invalid ply header");
        if (r = s(n, Bv),
        r !== -1)
            break
    }
    const l = new TextDecoder("ascii").decode(n.slice(0, r)).split(`
`).filter(f => !f.startsWith("comment "))
      , c = [];
    for (let f = 1; f < l.length; ++f) {
        const p = l[f].split(" ");
        switch (p[0]) {
        case "format":
            if (p[1] !== "binary_little_endian")
                throw new Error("Unsupported ply format");
            break;
        case "element":
            c.push({
                name: p[1],
                count: parseInt(p[2], 10),
                properties: []
            });
            break;
        case "property":
            {
                if (!kv.has(p[1]))
                    throw new Error(`Unrecognized property data type '${p[1]}' in ply header`);
                const _ = c[c.length - 1]
                  , m = kv.get(p[1])
                  , g = !e || e(p[2]) ? new m(_.count) : null;
                _.properties.push({
                    type: p[1],
                    name: p[2],
                    storage: g,
                    byteSize: m.BYTES_PER_ELEMENT
                });
                break
            }
        default:
            throw new Error(`Unrecognized header value '${p[0]}' in ply header`)
        }
    }
    let d = r + Bv.length
      , h = n.length - d
      , u = new DataView(n.buffer);
    for (let f = 0; f < c.length; ++f) {
        const p = c[f];
        for (let _ = 0; _ < p.count; ++_)
            for (let m = 0; m < p.properties.length; ++m) {
                const g = p.properties[m];
                for (; h < g.byteSize; ) {
                    const {value: v, done: x} = await a.read();
                    if (x)
                        throw new Error("Stream finished before end of data");
                    const S = new Uint8Array(h + v.byteLength);
                    S.set(n.slice(d)),
                    S.set(v, h),
                    n = S,
                    u = new DataView(n.buffer),
                    d = 0,
                    h = n.length
                }
                if (g.storage)
                    switch (g.type) {
                    case "char":
                        g.storage[_] = u.getInt8(d);
                        break;
                    case "uchar":
                        g.storage[_] = u.getUint8(d);
                        break;
                    case "short":
                        g.storage[_] = u.getInt16(d, !0);
                        break;
                    case "ushort":
                        g.storage[_] = u.getUint16(d, !0);
                        break;
                    case "int":
                        g.storage[_] = u.getInt32(d, !0);
                        break;
                    case "uint":
                        g.storage[_] = u.getUint32(d, !0);
                        break;
                    case "float":
                        g.storage[_] = u.getFloat32(d, !0);
                        break;
                    case "double":
                        g.storage[_] = u.getFloat64(d, !0);
                        break
                    }
                d += g.byteSize,
                h -= g.byteSize
            }
    }
    return c
}
  , zB = ["x", "y", "z", "f_dc_0", "f_dc_1", "f_dc_2", "opacity", "rot_0", "rot_1", "rot_2", "rot_3", "scale_0", "scale_1", "scale_2", "min_x", "min_y", "min_z", "max_x", "max_y", "max_z", "min_scale_x", "min_scale_y", "min_scale_z", "max_scale_x", "max_scale_y", "max_scale_z", "packed_position", "packed_rotation", "packed_scale", "packed_color"]
  , VB = new Set(zB)
  , GB = a => VB.has(a);
class HB {
    constructor(e, t, s) {
        this.device = void 0,
        this.assets = void 0,
        this.maxRetries = void 0,
        this.device = e,
        this.assets = t,
        this.maxRetries = s
    }
    async load(e, t, s) {
        const i = await fetch(e.load);
        if (!i || !i.body)
            t("Error loading resource", null);
        else {
            var n;
            UB(i.body.getReader(), (n = s.data.elementFilter) != null ? n : GB).then(r => {
                t(null, new NB(this.device,new ah(r)))
            }
            ).catch(r => {
                t(r, null)
            }
            )
        }
    }
    open(e, t) {
        return t
    }
}
class WB {
    constructor(e) {
        this.handlerType = "gsplat",
        this.parser = new HB(e.graphicsDevice,e.assets,3)
    }
    load(e, t, s) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        }),
        this.parser.load(e, t, s)
    }
    open(e, t, s) {
        return this.parser.open(e, t, s)
    }
    patch(e, t) {}
}
class r_ {
    static setCompressedPRS(e, t, s) {
        const i = s.singleVecs;
        let n, r;
        const o = t.___1;
        o || (n = s.tripleVecs,
        r = t.___2);
        let l = o ? o[0] : n[r];
        e.setLocalPosition(i[l], i[l + 1], i[l + 2]),
        l = o ? o[1] : n[r + 1],
        e.setLocalEulerAngles(i[l], i[l + 1], i[l + 2]),
        l = o ? o[2] : n[r + 2],
        e.setLocalScale(i[l], i[l + 1], i[l + 2])
    }
    static oneCharToKey(e, t) {
        const s = e.charCodeAt(0) - t.fieldFirstCode;
        return t.fieldArray[s]
    }
    static multCharToKey(e, t) {
        let s = 0;
        for (let i = 0; i < e.length; i++)
            s = s * t.fieldCodeBase + e.charCodeAt(i) - t.fieldFirstCode;
        return t.fieldArray[s]
    }
}
class bu {
    constructor(e, t) {
        this._node = e,
        this._data = t
    }
    run() {
        const e = Object.prototype.toString.call(this._node);
        return e === "[object Object]" ? this._handleMap() : e === "[object Array]" ? this._handleArray() : this._result = this._node,
        this._result
    }
    _handleMap() {
        this._result = {},
        Object.keys(this._node).forEach(this._handleKey, this)
    }
    _handleKey(e) {
        let t = e;
        const s = e.length;
        s === 1 ? t = r_.oneCharToKey(e, this._data) : s === 2 && (t = r_.multCharToKey(e, this._data)),
        this._result[t] = new bu(this._node[e],this._data).run()
    }
    _handleArray() {
        this._result = [],
        this._node.forEach(this._handleArElt, this)
    }
    _handleArElt(e) {
        const t = new bu(e,this._data).run();
        this._result.push(t)
    }
}
class xg {
    constructor(e, t) {
        this._app = e,
        this._isTemplate = t
    }
    parse(e) {
        const t = {};
        let s = null;
        const i = e.compressedFormat;
        i && !e.entDecompressed && (e.entDecompressed = !0,
        e.entities = new bu(e.entities,i).run());
        for (const n in e.entities) {
            const r = e.entities[n]
              , o = this._createEntity(r, i);
            t[n] = o,
            r.parent === null && (s = o)
        }
        for (const n in e.entities) {
            const r = t[n]
              , o = e.entities[n].children
              , l = o.length;
            for (let c = 0; c < l; c++) {
                const d = t[o[c]];
                d && r.addChild(d)
            }
        }
        return this._openComponentData(s, e.entities),
        s
    }
    _createEntity(e, t) {
        var s;
        const i = new V(e.name,this._app);
        if (i.setGuid(e.resource_id),
        this._setPosRotScale(i, e, t),
        i._enabled = (s = e.enabled) != null ? s : !0,
        this._isTemplate ? i._template = !0 : i._enabledInHierarchy = i._enabled,
        i.template = e.template,
        e.tags)
            for (let n = 0; n < e.tags.length; n++)
                i.tags.add(e.tags[n]);
        return e.labels && e.labels.forEach(function(n) {
            i.addLabel(n)
        }),
        i
    }
    _setPosRotScale(e, t, s) {
        if (s)
            r_.setCompressedPRS(e, t, s);
        else {
            const i = t.position
              , n = t.rotation
              , r = t.scale;
            e.setLocalPosition(i[0], i[1], i[2]),
            e.setLocalEulerAngles(n[0], n[1], n[2]),
            e.setLocalScale(r[0], r[1], r[2])
        }
    }
    _openComponentData(e, t) {
        const s = this._app.systems.list;
        let i = s.length;
        const n = t[e.getGuid()];
        for (let o = 0; o < i; o++) {
            const l = s[o]
              , c = n.components[l.id];
            c && l.addComponent(e, c)
        }
        i = n.children.length;
        const r = e._children;
        for (let o = 0; o < i; o++)
            r[o] && (r[o] = this._openComponentData(r[o], t));
        return e
    }
}
class Tw {
    static load(e, t, s) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        }),
        st.get(e.load, {
            retry: t > 0,
            maxRetries: t
        }, function(i, n) {
            if (!i)
                s(i, n);
            else {
                let r = "Error while loading scene JSON " + e.original;
                i.message ? (r += ": " + i.message,
                i.stack && (r += `
` + i.stack)) : r += ": " + i,
                s(r)
            }
        })
    }
}
class XB {
    constructor(e) {
        this.handlerType = "hierarchy",
        this._app = e,
        this.maxRetries = 0
    }
    load(e, t) {
        Tw.load(e, this.maxRetries, t)
    }
    open(e, t) {
        this._app.systems.script.preloading = !0;
        const i = new xg(this._app,!1).parse(t);
        return this._app.systems.script.preloading = !1,
        i
    }
}
class jB {
    constructor(e) {
        this.handlerType = "html",
        this.maxRetries = 0
    }
    load(e, t) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        }),
        st.get(e.load, {
            retry: this.maxRetries > 0,
            maxRetries: this.maxRetries
        }, function(s, i) {
            s ? t(`Error loading html resource: ${e.original} [${s}]`) : t(null, i)
        })
    }
    open(e, t) {
        return t
    }
    patch(e, t) {}
}
class $B {
    constructor(e) {
        this.handlerType = "json",
        this.maxRetries = 0
    }
    load(e, t) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        });
        const s = {
            retry: this.maxRetries > 0,
            maxRetries: this.maxRetries
        };
        e.load.startsWith("blob:") && (s.responseType = we.ResponseType.JSON),
        st.get(e.load, s, function(i, n) {
            i ? t(`Error loading JSON resource: ${e.original} [${i}]`) : t(null, n)
        })
    }
    open(e, t) {
        return t
    }
    patch(e, t) {}
}
class qB {
    constructor() {
        this.removeInvalid = !0,
        this.valid = !0,
        this.enumValidators = {
            occludeSpecular: this._createEnumValidator([dA, Th, Cm]),
            cull: this._createEnumValidator([bt, dr, Zl, fT]),
            blendType: this._createEnumValidator([KS, hc, ps, ls, _a, H_, fi, ZS, QS, JS, ex]),
            depthFunc: this._createEnumValidator([pT, A_, Yd, cm, mT, _T, gT, Mn]),
            shadingModel: this._createEnumValidator([ji, cc])
        }
    }
    setInvalid(e, t) {
        this.valid = !1,
        this.removeInvalid && delete t[e]
    }
    validate(e) {
        const t = Yo
          , s = YI
          , i = e.mappingFormat === "path";
        for (const n in e) {
            const r = t[n];
            if (!r) {
                s[n] ? delete e[n] : this.valid = !1;
                continue
            }
            if (r.startsWith("enum")) {
                const o = r.split(":")[1];
                this.enumValidators[o] && (this.enumValidators[o](e[n]) || this.setInvalid(n, e))
            } else if (r === "number")
                typeof e[n] != "number" && this.setInvalid(n, e);
            else if (r === "boolean")
                typeof e[n] != "boolean" && this.setInvalid(n, e);
            else if (r === "string")
                typeof e[n] != "string" && this.setInvalid(n, e);
            else if (r === "vec2")
                e[n]instanceof Array && e[n].length === 2 || this.setInvalid(n, e);
            else if (r === "rgb")
                e[n]instanceof Array && e[n].length === 3 || this.setInvalid(n, e);
            else if (r === "texture")
                i ? typeof e[n] == "string" || e[n] === null || e[n]instanceof ge || this.setInvalid(n, e) : typeof e[n] == "number" || e[n] === null || e[n]instanceof ge || this.setInvalid(n, e);
            else if (r === "boundingbox")
                e[n].center && e[n].center instanceof Array && e[n].center.length === 3 || this.setInvalid(n, e),
                e[n].halfExtents && e[n].halfExtents instanceof Array && e[n].halfExtents.length === 3 || this.setInvalid(n, e);
            else if (r === "cubemap")
                typeof e[n] == "number" || e[n] === null || e[n] === void 0 || e[n]instanceof ge && e[n].cubemap || this.setInvalid(n, e);
            else if (r === "chunks") {
                const o = Object.keys(e[n]);
                for (let l = 0; l < o.length; l++)
                    typeof e[n][o[l]] != "string" && this.setInvalid(o[l], e[n])
            } else
                console.error("Unknown material type: " + r)
        }
        return e.validated = !0,
        this.valid
    }
    _createEnumValidator(e) {
        return function(t) {
            return e.indexOf(t) >= 0
        }
    }
}
class YB {
    constructor() {
        this._validator = null
    }
    parse(e) {
        const t = this.migrate(e)
          , s = this._validate(t)
          , i = new at;
        return this.initialize(i, s),
        i
    }
    initialize(e, t) {
        t.validated || (t = this._validate(t)),
        t.chunks && (e.chunks = Bt({}, t.chunks));
        for (const s in t) {
            const i = Yo[s]
              , n = t[s];
            if (i === "vec2")
                e[s] = new P(n[0],n[1]);
            else if (i === "rgb")
                e[s] = new z(n[0],n[1],n[2]);
            else if (i === "texture")
                n instanceof ge ? e[s] = n : e[s]instanceof ge && typeof n == "number" && n > 0 || (e[s] = null);
            else if (i === "cubemap")
                n instanceof ge ? e[s] = n : e[s]instanceof ge && typeof n == "number" && n > 0 || (e[s] = null),
                s === "cubeMap" && !n && (e.prefilteredCubemaps = null);
            else if (i === "boundingbox") {
                const r = new y(n.center[0],n.center[1],n.center[2])
                  , o = new y(n.halfExtents[0],n.halfExtents[1],n.halfExtents[2]);
                e[s] = new Pe(r,o)
            } else
                e[s] = t[s]
        }
        e.update()
    }
    migrate(e) {
        e.shadingModel === void 0 && (e.shader === "blinn" ? e.shadingModel = cc : e.shadingModel = ji),
        e.shader && delete e.shader,
        e.mapping_format && (e.mappingFormat = e.mapping_format,
        delete e.mapping_format);
        let t;
        const s = [["bumpMapFactor", "bumpiness"], ["aoUvSet", "aoMapUv"], ["aoMapVertexColor", "aoVertexColor"], ["diffuseMapVertexColor", "diffuseVertexColor"], ["emissiveMapVertexColor", "emissiveVertexColor"], ["specularMapVertexColor", "specularVertexColor"], ["metalnessMapVertexColor", "metalnessVertexColor"], ["opacityMapVertexColor", "opacityVertexColor"], ["glossMapVertexColor", "glossVertexColor"], ["lightMapVertexColor", "lightVertexColor"], ["diffuseMapTint", "diffuseTint"], ["specularMapTint", "specularTint"], ["emissiveMapTint", "emissiveTint"], ["metalnessMapTint", "metalnessTint"], ["clearCoatGlossiness", "clearCoatGloss"]];
        for (t = 0; t < s.length; t++) {
            const n = s[t][0]
              , r = s[t][1];
            e[n] !== void 0 && (e[r] === void 0 && (e[r] = e[n]),
            delete e[n])
        }
        const i = ["fresnelFactor", "shadowSampleType"];
        for (t = 0; t < i.length; t++) {
            const n = i[t];
            e.hasOwnProperty(n) && delete e[n]
        }
        return e
    }
    _validate(e) {
        return e.validated || (this._validator || (this._validator = new qB),
        this._validator.validate(e)),
        e
    }
}
const KB = {
    aoMap: "white",
    diffuseMap: "gray",
    specularMap: "gray",
    specularityFactorMap: "white",
    metalnessMap: "black",
    glossMap: "gray",
    sheenMap: "black",
    sheenGlossinessMap: "gray",
    clearCoatMap: "black",
    clearCoatGlossMap: "gray",
    clearCoatNormalMap: "normal",
    refractionMap: "white",
    emissiveMap: "gray",
    normalMap: "normal",
    heightMap: "gray",
    opacityMap: "gray",
    sphereMap: "gray",
    lightMap: "white"
};
class ZB {
    constructor(e) {
        this.handlerType = "material",
        this._assets = e.assets,
        this._device = e.graphicsDevice,
        this._placeholderTextures = null,
        this._parser = new YB,
        this.maxRetries = 0
    }
    load(e, t) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        }),
        st.get(e.load, {
            retry: this.maxRetries > 0,
            maxRetries: this.maxRetries
        }, function(s, i) {
            s ? t && t(`Error loading material: ${e.original} [${s}]`) : t && (i._engine = !0,
            t(null, i))
        })
    }
    open(e, t) {
        const s = this._parser.parse(t);
        return t._engine && (s._data = t,
        delete t._engine),
        s
    }
    _createPlaceholders() {
        this._placeholderTextures = {};
        const e = {
            white: [255, 255, 255, 255],
            gray: [128, 128, 128, 255],
            black: [0, 0, 0, 255],
            normal: [128, 128, 255, 255]
        };
        for (const t in e) {
            if (!e.hasOwnProperty(t))
                continue;
            this._placeholderTextures[t] = new ge(this._device,{
                width: 2,
                height: 2,
                format: ve,
                name: "material_placeholder"
            });
            const s = this._placeholderTextures[t].lock();
            for (let i = 0; i < 4; i++)
                for (let n = 0; n < 4; n++)
                    s[i * 4 + n] = e[t][n];
            this._placeholderTextures[t].unlock()
        }
    }
    patch(e, t) {
        e.resource._data && (e._data = e.resource._data,
        delete e.resource._data),
        e.data.name = e.name,
        e.resource.name = e.name,
        this._bindAndAssignAssets(e, t),
        e.off("unload", this._onAssetUnload, this),
        e.on("unload", this._onAssetUnload, this)
    }
    _onAssetUnload(e) {
        delete e.data.parameters,
        delete e.data.chunks,
        delete e.data.name
    }
    _assignTexture(e, t, s) {
        t.resource[e] = s
    }
    _getPlaceholderTexture(e) {
        this._placeholderTextures || this._createPlaceholders();
        const t = KB[e];
        return this._placeholderTextures[t]
    }
    _assignPlaceholderTexture(e, t) {
        t.resource[e] = this._getPlaceholderTexture(e)
    }
    _onTextureLoad(e, t, s) {
        this._assignTexture(e, t, s.resource),
        t.resource.update()
    }
    _onTextureAdd(e, t, s) {
        this._assets.load(s)
    }
    _onTextureRemoveOrUnload(e, t, s) {
        const i = t.resource;
        i && t.resource[e] === s.resource && (this._assignPlaceholderTexture(e, t),
        i.update())
    }
    _assignCubemap(e, t, s) {
        if (t.resource[e] = s[0],
        e === "cubeMap") {
            const i = s.slice(1);
            i.every(n => n) ? t.resource.prefilteredCubemaps = i : i[0] && (t.resource.envAtlas = i[0])
        }
    }
    _onCubemapLoad(e, t, s) {
        this._assignCubemap(e, t, s.resources),
        this._parser.initialize(t.resource, t.data)
    }
    _onCubemapAdd(e, t, s) {
        t.data.shadingModel === ji && (t.loadFaces = !0),
        this._assets.load(s)
    }
    _onCubemapRemoveOrUnload(e, t, s) {
        const i = t.resource;
        t.data.prefilteredCubeMap128 === s.resources[1] && (this._assignCubemap(e, t, [null, null, null, null, null, null, null]),
        i.update())
    }
    _bindAndAssignAssets(e, t) {
        const s = this._parser.migrate(e.data)
          , i = e.resource
          , n = s.mappingFormat === "path"
          , r = Af;
        let o, l, c;
        for (o = 0; o < r.length; o++) {
            l = r[o],
            c = i._assetReferences[l];
            const h = s[l]
              , u = i[l]
              , f = u === this._getPlaceholderTexture(l)
              , p = s.validated;
            h && (!u || !p || f) ? (c || (c = new Bh(l,e,t,{
                load: this._onTextureLoad,
                add: this._onTextureAdd,
                remove: this._onTextureRemoveOrUnload,
                unload: this._onTextureRemoveOrUnload
            },this),
            i._assetReferences[l] = c),
            n ? c.url = e.getAbsoluteUrl(h) : c.id = h,
            c.asset && (c.asset.resource ? this._assignTexture(l, e, c.asset.resource) : this._assignPlaceholderTexture(l, e),
            t.load(c.asset))) : c && (n ? c.url = null : c.id = null)
        }
        const d = lg;
        for (o = 0; o < d.length; o++)
            l = d[o],
            c = i._assetReferences[l],
            s[l] && !e.data.prefilteredCubeMap128 && (c || (c = new Bh(l,e,t,{
                load: this._onCubemapLoad,
                add: this._onCubemapAdd,
                remove: this._onCubemapRemoveOrUnload,
                unload: this._onCubemapRemoveOrUnload
            },this),
            i._assetReferences[l] = c),
            n ? c.url = s[l] : c.id = s[l],
            c.asset && (c.asset.loaded && this._assignCubemap(l, e, c.asset.resources),
            t.load(c.asset)));
        this._parser.initialize(i, s)
    }
}
class QB {
    constructor(e) {
        this._device = e.device,
        this._defaultMaterial = e.defaultMaterial,
        this._assets = e.assets
    }
    parse(e, t, s) {
        var i;
        wu.parse("filename.glb", "", e, this._device, this._assets, (i = s == null ? void 0 : s.options) != null ? i : {}, (n, r) => {
            if (n)
                t(n);
            else {
                const o = ir.createModel(r, this._defaultMaterial);
                r.destroy(),
                t(null, o)
            }
        }
        )
    }
}
class JB {
    constructor() {
        this.index = 0,
        this.boneIndices = [0, 0, 0, 0]
    }
}
class ek {
    constructor() {
        this.partition = 0,
        this.vertexStart = 0,
        this.vertexCount = 0,
        this.indexStart = 0,
        this.indexCount = 0,
        this.boneIndices = [],
        this.vertices = [],
        this.indices = [],
        this.indexMap = {},
        this.originalMesh = null
    }
    addVertex(e, t, s) {
        let i = -1;
        if (this.indexMap[t] !== void 0)
            i = this.indexMap[t],
            this.indices.push(i);
        else {
            for (let n = 0; n < 4; n++) {
                if (s.blendWeight.data[t * 4 + n] === 0)
                    continue;
                const r = s.blendIndices.data[e.index * 4 + n];
                e.boneIndices[n] = this.getBoneRemap(r)
            }
            i = this.vertices.length,
            this.indices.push(i),
            this.vertices.push(e),
            this.indexMap[t] = i
        }
    }
    addPrimitive(e, t, s, i) {
        const n = [];
        let r = 0;
        const o = e.length;
        for (let l = 0; l < o; l++) {
            const d = e[l].index;
            for (let h = 0; h < 4; h++)
                if (s.blendWeight.data[d * 4 + h] > 0) {
                    const u = s.blendIndices.data[d * 4 + h];
                    let f = !0;
                    for (let p = 0; p < r; p++)
                        if (n[p] === u) {
                            f = !1;
                            break
                        }
                    if (f) {
                        n[r] = u;
                        const p = this.getBoneRemap(u);
                        r += p === -1 ? 1 : 0
                    }
                }
        }
        if (this.boneIndices.length + r > i)
            return !1;
        for (let l = 0; l < r; l++)
            this.boneIndices.push(n[l]);
        for (let l = 0; l < o; l++)
            this.addVertex(e[l], t[l], s);
        return !0
    }
    getBoneRemap(e) {
        for (let t = 0; t < this.boneIndices.length; t++)
            if (this.boneIndices[t] === e)
                return t;
        return -1
    }
}
function tk(a) {
    const e = a.vertices
      , t = a.skins
      , s = a.meshes
      , i = a.meshInstances;
    for (let n = 0; n < s.length; n++)
        s[n].vertices = e[s[n].vertices],
        s[n].skin !== void 0 && (s[n].skin = t[s[n].skin]);
    for (let n = 0; n < i.length; n++)
        i[n].mesh = s[i[n].mesh]
}
function sk(a) {
    const e = a.vertices
      , t = a.skins
      , s = a.meshes
      , i = a.meshInstances;
    for (let n = 0; n < s.length; n++)
        s[n].vertices = e.indexOf(s[n].vertices),
        s[n].skin !== void 0 && (s[n].skin = t.indexOf(s[n].skin));
    for (let n = 0; n < i.length; n++)
        i[n].mesh = s.indexOf(i[n].mesh)
}
function ik(a, e, t) {
    let s, i, n, r;
    tk(a);
    const o = a.vertices
      , l = a.skins;
    let c;
    const d = a.meshes
      , h = a.meshInstances
      , u = function(p) {
        const _ = new JB;
        return _.index = p,
        _
    };
    for (s = l.length - 1; s >= 0; s--)
        if (l[s].boneNames.length > t) {
            const f = l.splice(s, 1)[0]
              , p = [];
            for (i = 0; i < d.length; i++)
                d[i].skin === f && p.push(d[i]);
            for (i = 0; i < p.length; i++)
                r = d.indexOf(p[i]),
                r !== -1 && d.splice(r, 1);
            if (p.length === 0)
                throw new Error("partitionSkin: There should be at least one mesh that references a skin");
            const _ = p[0].vertices;
            for (i = 1; i < p.length; i++)
                if (p[i].vertices !== _)
                    throw new Error("partitionSkin: All meshes that share a skin should also share the same vertex buffer");
            let m;
            const g = []
              , v = []
              , x = [];
            let S = 0;
            for (i = 0; i < p.length; i++) {
                c = p[i];
                const U = c.indices;
                for (let I = c.base; I < c.base + c.count; ) {
                    r = U[I++],
                    v[0] = u(r),
                    x[0] = r,
                    r = U[I++],
                    v[1] = u(r),
                    x[1] = r,
                    r = U[I++],
                    v[2] = u(r),
                    x[2] = r;
                    let O = !1;
                    for (let D = S; D < g.length; D++)
                        if (m = g[D],
                        m.addPrimitive(v, x, _, t)) {
                            O = !0;
                            break
                        }
                    O || (m = new ek,
                    m.originalMesh = c,
                    m.addPrimitive(v, x, _, t),
                    g.push(m))
                }
                S = g.length
            }
            const w = []
              , T = [];
            for (i = 0; i < g.length; i++)
                if (m = g[i],
                m.vertices.length && m.indices.length) {
                    const U = w.length
                      , I = m.vertices.length
                      , O = T.length
                      , D = m.indices.length;
                    m.partition = i,
                    m.vertexStart = U,
                    m.vertexCount = I,
                    m.indexStart = O,
                    m.indexCount = D;
                    let A, k;
                    for (A = 0,
                    k = U; A < I; )
                        w[k++] = m.vertices[A++];
                    for (A = 0,
                    k = O; A < D; )
                        T[k++] = m.indices[A++] + U
                }
            const b = [];
            for (i = 0; i < g.length; i++) {
                m = g[i];
                const U = []
                  , I = [];
                for (n = 0; n < m.boneIndices.length; n++)
                    U.push(f.inverseBindMatrices[m.boneIndices[n]]),
                    I.push(f.boneNames[m.boneIndices[n]]);
                const O = {
                    inverseBindMatrices: U,
                    boneNames: I
                };
                b.push(O),
                l.push(O)
            }
            let E, C, R, F;
            const L = {};
            for (C in _)
                L[C] = {
                    components: _[C].components,
                    data: [],
                    type: _[C].type
                };
            for (C in _)
                if (C === "blendIndices") {
                    const U = L[C].data;
                    for (i = 0; i < w.length; i++) {
                        const I = w[i].boneIndices;
                        U.push(I[0], I[1], I[2], I[3])
                    }
                } else
                    for (E = _[C],
                    R = E.data,
                    F = E.components,
                    i = 0; i < w.length; i++)
                        for (r = w[i].index,
                        n = 0; n < F; n++)
                            L[C].data.push(R[r * F + n]);
            for (o[o.indexOf(_)] = L,
            i = 0; i < g.length; i++)
                for (m = g[i],
                c = {
                    aabb: {
                        min: [0, 0, 0],
                        max: [0, 0, 0]
                    },
                    vertices: L,
                    skin: b[i],
                    indices: T.splice(0, m.indexCount),
                    type: "triangles",
                    base: 0,
                    count: m.indexCount
                },
                d.push(c),
                n = h.length - 1; n >= 0; n--)
                    h[n].mesh === m.originalMesh && (h.push({
                        mesh: c,
                        node: h[n].node
                    }),
                    e && e.push({
                        material: e[n].material,
                        path: e[n].path
                    }));
            for (i = 0; i < g.length; i++)
                for (m = g[i],
                n = h.length - 1; n >= 0; n--)
                    h[n].mesh === m.originalMesh && (h.splice(n, 1),
                    e && e.splice(n, 1))
        }
    sk(a)
}
const nk = {
    points: af,
    lines: of,
    lineloop: RS,
    linestrip: IS,
    triangles: xn,
    trianglestrip: Ks,
    trianglefan: Zr
}
  , rk = {
    int8: Ca,
    uint8: Wi,
    int16: Ea,
    uint16: wr,
    int32: nc,
    uint32: il,
    float32: Me
};
class ak {
    constructor(e) {
        this._device = e.device,
        this._defaultMaterial = e.defaultMaterial
    }
    parse(e, t) {
        const s = e.model;
        if (!s) {
            t(null, null);
            return
        }
        if (s.version <= 1) {
            t("JsonModelParser#parse: Trying to parse unsupported model format.");
            return
        }
        const i = this._parseNodes(e)
          , n = this._parseSkins(e, i)
          , r = this._parseVertexBuffers(e)
          , o = this._parseIndexBuffers(e, r)
          , l = this._parseMorphs(e, i, r)
          , c = this._parseMeshes(e, n.skins, l.morphs, r, o.buffer, o.data)
          , d = this._parseMeshInstances(e, i, c, n.skins, n.instances, l.morphs, l.instances)
          , h = new kn;
        h.graph = i[0],
        h.meshInstances = d,
        h.skinInstances = n.instances,
        h.morphInstances = l.instances,
        h.getGraph().syncHierarchy(),
        t(null, h)
    }
    _parseNodes(e) {
        const t = e.model
          , s = [];
        let i;
        for (i = 0; i < t.nodes.length; i++) {
            const n = t.nodes[i]
              , r = new yt(n.name);
            r.setLocalPosition(n.position[0], n.position[1], n.position[2]),
            r.setLocalEulerAngles(n.rotation[0], n.rotation[1], n.rotation[2]),
            r.setLocalScale(n.scale[0], n.scale[1], n.scale[2]),
            r.scaleCompensation = !!n.scaleCompensation,
            s.push(r)
        }
        for (i = 1; i < t.parents.length; i++)
            s[t.parents[i]].addChild(s[i]);
        return s
    }
    _parseSkins(e, t) {
        const s = e.model
          , i = []
          , n = [];
        let r, o;
        if (!this._device.supportsBoneTextures && s.skins.length > 0) {
            const l = this._device.getBoneLimit();
            ik(s, null, l)
        }
        for (r = 0; r < s.skins.length; r++) {
            const l = s.skins[r]
              , c = [];
            for (o = 0; o < l.inverseBindMatrices.length; o++) {
                const f = l.inverseBindMatrices[o];
                c[o] = new ee().set(f)
            }
            const d = new Tx(this._device,c,l.boneNames);
            i.push(d);
            const h = new gc(d)
              , u = [];
            for (o = 0; o < d.boneNames.length; o++) {
                const f = d.boneNames[o]
                  , p = t[0].findByName(f);
                u.push(p)
            }
            h.bones = u,
            n.push(h)
        }
        return {
            skins: i,
            instances: n
        }
    }
    _getMorphVertexCount(e, t, s) {
        for (let i = 0; i < e.meshes.length; i++) {
            const n = e.meshes[i];
            if (n.morph === t)
                return s[n.vertices].numVertices
        }
    }
    _parseMorphs(e, t, s) {
        const i = e.model
          , n = []
          , r = [];
        let o, l, c, d, h, u;
        if (i.morphs) {
            const f = function(_, m, g) {
                const v = new Float32Array(g * 3);
                for (let x = 0; x < m.length; x++) {
                    const S = m[x] * 3;
                    v[S] = _[x * 3],
                    v[S + 1] = _[x * 3 + 1],
                    v[S + 2] = _[x * 3 + 2]
                }
                return v
            };
            for (o = 0; o < i.morphs.length; o++) {
                for (d = i.morphs[o].targets,
                u = [],
                c = this._getMorphVertexCount(i, o, s),
                l = 0; l < d.length; l++) {
                    const m = d[l].aabb
                      , g = m.min
                      , v = m.max
                      , x = new Pe(new y((v[0] + g[0]) * .5,(v[1] + g[1]) * .5,(v[2] + g[2]) * .5),new y((v[0] - g[0]) * .5,(v[1] - g[1]) * .5,(v[2] - g[2]) * .5))
                      , S = d[l].indices;
                    let w = d[l].deltaPositions
                      , T = d[l].deltaNormals;
                    S && (w = f(w, S, c),
                    T = f(T, S, c)),
                    h = new Pf({
                        deltaPositions: w,
                        deltaNormals: T,
                        name: d[l].name,
                        aabb: x
                    }),
                    u.push(h)
                }
                const p = new wx(u,this._device);
                n.push(p);
                const _ = new Sa(p);
                r.push(_)
            }
        }
        return {
            morphs: n,
            instances: r
        }
    }
    _parseVertexBuffers(e) {
        const t = e.model
          , s = []
          , i = {
            position: ut,
            normal: Is,
            tangent: Qi,
            blendWeight: Ji,
            blendIndices: Ps,
            color: jt,
            texCoord0: Ls,
            texCoord1: xr,
            texCoord2: Kh,
            texCoord3: Zh,
            texCoord4: Qh,
            texCoord5: Jh,
            texCoord6: ec,
            texCoord7: tc
        };
        for (let n = 0; n < t.vertices.length; n++) {
            const r = t.vertices[n]
              , o = [];
            for (const u in r) {
                const f = r[u];
                o.push({
                    semantic: i[u],
                    components: f.components,
                    type: rk[f.type],
                    normalize: i[u] === jt
                })
            }
            const l = new fs(this._device,o)
              , c = r.position.data.length / r.position.components
              , d = new xi(this._device,l,c)
              , h = new sh(d);
            for (let u = 0; u < c; u++) {
                for (const f in r) {
                    const p = r[f];
                    switch (p.components) {
                    case 1:
                        h.element[i[f]].set(p.data[u]);
                        break;
                    case 2:
                        h.element[i[f]].set(p.data[u * 2], 1 - p.data[u * 2 + 1]);
                        break;
                    case 3:
                        h.element[i[f]].set(p.data[u * 3], p.data[u * 3 + 1], p.data[u * 3 + 2]);
                        break;
                    case 4:
                        h.element[i[f]].set(p.data[u * 4], p.data[u * 4 + 1], p.data[u * 4 + 2], p.data[u * 4 + 3]);
                        break
                    }
                }
                h.next()
            }
            h.end(),
            s.push(d)
        }
        return s
    }
    _parseIndexBuffers(e, t) {
        const s = e.model;
        let i = null, n = null, r, o = 0;
        for (r = 0; r < s.meshes.length; r++) {
            const c = s.meshes[r];
            c.indices !== void 0 && (o += c.indices.length)
        }
        let l = 0;
        for (r = 0; r < t.length; r++)
            l = Math.max(l, t[r].numVertices);
        return o > 0 && (l > 65535 && this._device.extUintElement ? (i = new _r(this._device,fr,o),
        n = new Uint32Array(i.lock())) : (i = new _r(this._device,js,o),
        n = new Uint16Array(i.lock()))),
        {
            buffer: i,
            data: n
        }
    }
    _parseMeshes(e, t, s, i, n, r) {
        const o = e.model
          , l = [];
        let c = 0;
        for (let d = 0; d < o.meshes.length; d++) {
            const h = o.meshes[d]
              , u = h.aabb
              , f = u.min
              , p = u.max
              , _ = new Pe(new y((p[0] + f[0]) * .5,(p[1] + f[1]) * .5,(p[2] + f[2]) * .5),new y((p[0] - f[0]) * .5,(p[1] - f[1]) * .5,(p[2] - f[2]) * .5))
              , m = h.indices !== void 0
              , g = new ms(this._device);
            g.vertexBuffer = i[h.vertices],
            g.indexBuffer[0] = m ? n : null,
            g.primitive[0].type = nk[h.type],
            g.primitive[0].base = m ? h.base + c : h.base,
            g.primitive[0].count = h.count,
            g.primitive[0].indexed = m,
            g.skin = h.skin !== void 0 ? t[h.skin] : null,
            g.morph = h.morph !== void 0 ? s[h.morph] : null,
            g.aabb = _,
            m && (r.set(h.indices, c),
            c += h.indices.length),
            l.push(g)
        }
        return n !== null && n.unlock(),
        l
    }
    _parseMeshInstances(e, t, s, i, n, r, o) {
        const l = e.model
          , c = [];
        let d;
        for (d = 0; d < l.meshInstances.length; d++) {
            const h = l.meshInstances[d]
              , u = t[h.node]
              , f = s[h.mesh]
              , p = new Fe(f,this._defaultMaterial,u);
            if (f.skin) {
                const _ = i.indexOf(f.skin);
                p.skinInstance = n[_]
            }
            if (f.morph) {
                const _ = r.indexOf(f.morph);
                p.morphInstance = o[_]
            }
            c.push(p)
        }
        return c
    }
}
class ok {
    constructor(e) {
        this.handlerType = "model",
        this._parsers = [],
        this.device = e.graphicsDevice,
        this.assets = e.assets,
        this.defaultMaterial = _c(this.device),
        this.maxRetries = 0,
        this.addParser(new ak(this), function(t, s) {
            return ye.getExtension(t) === ".json"
        }),
        this.addParser(new QB(this), function(t, s) {
            return ye.getExtension(t) === ".glb"
        })
    }
    load(e, t, s) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        });
        const i = {
            retry: this.maxRetries > 0,
            maxRetries: this.maxRetries
        };
        (e.load.startsWith("blob:") || e.load.startsWith("data:")) && (ye.getExtension(e.original).toLowerCase() === ".glb" ? i.responseType = we.ResponseType.ARRAY_BUFFER : i.responseType = we.ResponseType.JSON),
        st.get(e.load, i, (n, r) => {
            if (t)
                if (n)
                    t(`Error loading model: ${e.original} [${n}]`);
                else {
                    for (let o = 0; o < this._parsers.length; o++) {
                        const l = this._parsers[o];
                        if (l.decider(e.original, r)) {
                            l.parser.parse(r, (c, d) => {
                                c ? t(c) : t(null, d)
                            }
                            , s);
                            return
                        }
                    }
                    t("No parsers found")
                }
        }
        )
    }
    open(e, t) {
        return t
    }
    patch(e, t) {
        if (!e.resource)
            return;
        const s = e.data
          , i = this;
        e.resource.meshInstances.forEach(function(n, r) {
            if (s.mapping) {
                const o = function h(u) {
                    u.resource ? n.material = u.resource : (u.once("load", h),
                    t.load(u)),
                    u.once("remove", function(f) {
                        n.material === f.resource && (n.material = i.defaultMaterial)
                    })
                };
                if (!s.mapping[r]) {
                    n.material = i.defaultMaterial;
                    return
                }
                const l = s.mapping[r].material
                  , c = s.mapping[r].path;
                let d;
                if (l !== void 0)
                    l ? (d = t.get(l),
                    d ? o(d) : t.once("add:" + l, o)) : n.material = i.defaultMaterial;
                else if (c) {
                    const h = e.getAbsoluteUrl(s.mapping[r].path);
                    d = t.getByUrl(h),
                    d ? o(d) : t.once("add:url:" + h, o)
                }
            }
        })
    }
    addParser(e, t) {
        this._parsers.push({
            parser: e,
            decider: t
        })
    }
}
class lk {
    constructor(e) {
        this.handlerType = "scene",
        this._app = e,
        this.maxRetries = 0
    }
    load(e, t) {
        Tw.load(e, this.maxRetries, t)
    }
    open(e, t) {
        this._app.systems.script.preloading = !0;
        const i = new xg(this._app,!1).parse(t)
          , n = this._app.scene;
        return n.root = i,
        this._app.applySceneSettings(t.settings),
        this._app.systems.script.preloading = !1,
        n
    }
    patch(e, t) {}
}
const hk = new RegExp("^\\s*function(?:\\s|\\s*\\/\\*.*\\*\\/\\s*)+([^\\(\\s\\/]*)\\s*");
class Jt extends fe {
    constructor(e) {
        super(),
        this.app = void 0,
        this.entity = void 0,
        this._enabled = void 0,
        this._enabledOld = void 0,
        this._initialized = void 0,
        this._postInitialized = void 0,
        this.__destroyed = void 0,
        this.__attributes = void 0,
        this.__attributesRaw = void 0,
        this.__scriptType = void 0,
        this.__executionOrder = void 0,
        this.initScriptType(e)
    }
    set enabled(e) {
        this._enabled = !!e,
        this.enabled !== this._enabledOld && (this._enabledOld = this.enabled,
        this.fire(this.enabled ? "enable" : "disable"),
        this.fire("state", this.enabled),
        !this._initialized && this.enabled && (this._initialized = !0,
        this.__initializeAttributes(!0),
        this.initialize && this.entity.script._scriptMethod(this, Jm)),
        this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled && (this._postInitialized = !0,
        this.postInitialize && this.entity.script._scriptMethod(this, e_)))
    }
    get enabled() {
        return this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled
    }
    initScriptType(e) {
        const t = this.constructor;
        this.app = e.app,
        this.entity = e.entity,
        this._enabled = typeof e.enabled == "boolean" ? e.enabled : !0,
        this._enabledOld = this.enabled,
        this.__destroyed = !1,
        this.__attributes = {},
        this.__attributesRaw = e.attributes || {},
        this.__scriptType = t,
        this.__executionOrder = -1
    }
    static __getScriptName(e) {
        if (typeof e != "function")
            return;
        if ("name"in Function.prototype)
            return e.name;
        if (e === Function || e === Function.prototype.constructor)
            return "Function";
        const t = ("" + e).match(hk);
        return t ? t[1] : void 0
    }
    static get scriptName() {
        return this.__name
    }
    static get attributes() {
        return this.hasOwnProperty("__attributes") || (this.__attributes = new Pn(this)),
        this.__attributes
    }
    __initializeAttributes(e) {
        if (!(!e && !this.__attributesRaw)) {
            for (const t in this.__scriptType.attributes.index)
                this.__attributesRaw && this.__attributesRaw.hasOwnProperty(t) ? this[t] = this.__attributesRaw[t] : this.__attributes.hasOwnProperty(t) || (this.__scriptType.attributes.index[t].hasOwnProperty("default") ? this[t] = this.__scriptType.attributes.index[t].default : this[t] = null);
            this.__attributesRaw = null
        }
    }
    static extend(e) {
        for (const t in e)
            e.hasOwnProperty(t) && (this.prototype[t] = e[t])
    }
}
Jt.EVENT_ENABLE = "enable";
Jt.EVENT_DISABLE = "disable";
Jt.EVENT_STATE = "state";
Jt.EVENT_DESTROY = "destroy";
Jt.EVENT_ATTR = "attr";
Jt.EVENT_ERROR = "error";
Jt.__name = null;
const Cw = new Set(["system", "entity", "create", "destroy", "swap", "move", "data", "scripts", "_scripts", "_scriptsIndex", "_scriptsData", "enabled", "_oldState", "onEnable", "onDisable", "onPostStateChange", "_onSetEnabled", "_checkState", "_onBeforeRemove", "_onInitializeAttributes", "_onInitialize", "_onPostInitialize", "_onUpdate", "_onPostUpdate", "_callbacks", "_callbackActive", "has", "get", "on", "off", "fire", "once", "hasEvent"]);
function oh(a, e) {
    if (Xt.legacy)
        return null;
    if (Cw.has(a))
        throw new Error(`Script name '${a}' is reserved, please rename the script`);
    const t = function(i) {
        fe.prototype.initEventHandler.call(this),
        Jt.prototype.initScriptType.call(this, i)
    };
    return t.prototype = Object.create(Jt.prototype),
    t.prototype.constructor = t,
    t.extend = Jt.extend,
    t.attributes = new Pn(t),
    wg(t, a, e),
    t
}
const Ew = {};
Pn.reservedNames.forEach( (a, e, t) => {
    Ew[a] = 1
}
);
oh.reservedAttributes = Ew;
function wg(a, e, t) {
    if (a.legacy)
        return;
    if (typeof a != "function")
        throw new Error(`script class: '${a}' must be a constructor function (i.e. class).`);
    if (!(a.prototype instanceof Jt))
        throw new Error(`script class: '${Jt.__getScriptName(a)}' does not extend pc.ScriptType.`);
    if (e = e || a.__name || Jt.__getScriptName(a),
    Cw.has(e))
        throw new Error(`script name: '${e}' is reserved, please change script name`);
    a.__name = e,
    (t ? t.scripts : ar.getApplication().scripts).add(a),
    Ws.push(a, a.legacy)
}
class ck {
    constructor(e) {
        this.handlerType = "script",
        this._app = e,
        this._scripts = {},
        this._cache = {}
    }
    clearCache() {
        for (const e in this._cache) {
            const t = this._cache[e]
              , s = t.parentNode;
            s && s.removeChild(t)
        }
        this._cache = {}
    }
    load(e, t) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        });
        const s = this;
        Xt.app = this._app;
        const i = (e.load,
        (l, c, d) => {
            if (l)
                t(l);
            else if (Xt.legacy) {
                let h = null;
                Ws._types.length && (h = Ws._types.pop()),
                h ? this._scripts[c] = h : h = null,
                t(null, h, d)
            } else {
                const h = {};
                for (let u = 0; u < Ws._types.length; u++)
                    h[Ws._types[u].name] = Ws._types[u];
                Ws._types.length = 0,
                t(null, h, d),
                delete s._loader._cache[Ao.makeKey(c, "script")]
            }
        }
        )
          , [n,r] = e.load.split("?");
        if (n.endsWith(".mjs")) {
            let l = e.load;
            l.startsWith(this._app.assets.prefix) && (l = l.replace(this._app.assets.prefix, ""));
            const c = this._app.assets.getByUrl(l).file.hash
              , d = new URLSearchParams(r);
            d.set("hash", c);
            const h = `${n}?${d.toString()}`;
            this._loadModule(h, i)
        } else
            this._loadScript(e.load, i)
    }
    open(e, t) {
        return t
    }
    patch(e, t) {}
    _loadScript(e, t) {
        const s = document.head
          , i = document.createElement("script");
        this._cache[e] = i,
        i.async = !1,
        i.addEventListener("error", function(r) {
            t(`Script: ${r.target.src} failed to load`)
        }, !1);
        let n = !1;
        i.onload = i.onreadystatechange = function() {
            !n && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") && (n = !0,
            t(null, e, i))
        }
        ,
        i.src = e,
        s.appendChild(i)
    }
    _loadModule(e, t) {
        const s = Le.browser ? window.location.origin : import.meta.url
          , i = new URL(e,s);
        vm( () => import(i.toString()), __vite__mapDeps([]), import.meta.url).then(n => {
            for (const r in n) {
                const o = n[r];
                if (o.prototype instanceof Jt) {
                    if (Xt.attributesDefinition)
                        for (const c in Xt.attributesDefinition)
                            o.attributes.add(c, Xt.attributesDefinition[c]);
                    wg(o, o.name)
                }
            }
            t(null, e, null)
        }
        ).catch(n => {
            t(n)
        }
        )
    }
}
class dk {
    constructor(e) {
        this.handlerType = "shader",
        this.maxRetries = 0
    }
    load(e, t) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        }),
        st.get(e.load, {
            retry: this.maxRetries > 0,
            maxRetries: this.maxRetries
        }, function(s, i) {
            s ? t(`Error loading shader resource: ${e.original} [${s}]`) : t(null, i)
        })
    }
    open(e, t) {
        return t
    }
    patch(e, t) {}
}
function Up(a) {
    const e = this;
    e.resource && (e.resource.atlas = a.resource)
}
function zp(a) {
    this.registry.load(a)
}
class uk {
    constructor(e) {
        this.handlerType = "sprite",
        this._assets = e.assets,
        this._device = e.graphicsDevice,
        this.maxRetries = 0
    }
    load(e, t) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        }),
        ye.getExtension(e.original) === ".json" && st.get(e.load, {
            retry: this.maxRetries > 0,
            maxRetries: this.maxRetries
        }, function(s, i) {
            s ? t(s) : t(null, i)
        })
    }
    open(e, t) {
        const s = new Cx(this._device);
        return e && (s.__data = t),
        s
    }
    patch(e, t) {
        const s = e.resource;
        if (s.__data && (e.data.pixelsPerUnit = s.__data.pixelsPerUnit,
        e.data.renderMode = s.__data.renderMode,
        e.data.frameKeys = s.__data.frameKeys,
        s.__data.textureAtlasAsset)) {
            const i = t.getByUrl(s.__data.textureAtlasAsset);
            i ? e.data.textureAtlasAsset = i.id : console.warn("Could not find textureatlas with url: " + s.__data.textureAtlasAsset)
        }
        s.startUpdate(),
        s.renderMode = e.data.renderMode,
        s.pixelsPerUnit = e.data.pixelsPerUnit,
        s.frameKeys = e.data.frameKeys,
        this._updateAtlas(e),
        s.endUpdate(),
        e.off("change", this._onAssetChange, this),
        e.on("change", this._onAssetChange, this)
    }
    _updateAtlas(e) {
        const t = e.resource;
        if (!e.data.textureAtlasAsset) {
            t.atlas = null;
            return
        }
        this._assets.off("load:" + e.data.textureAtlasAsset, Up, e),
        this._assets.on("load:" + e.data.textureAtlasAsset, Up, e);
        const s = this._assets.get(e.data.textureAtlasAsset);
        s && s.resource ? t.atlas = s.resource : s ? this._assets.load(s) : (this._assets.off("add:" + e.data.textureAtlasAsset, zp, e),
        this._assets.on("add:" + e.data.textureAtlasAsset, zp, e))
    }
    _onAssetChange(e, t, s, i) {
        t === "data" && s && s.textureAtlasAsset && i && s.textureAtlasAsset !== i.textureAtlasAsset && (this._assets.off("load:" + i.textureAtlasAsset, Up, e),
        this._assets.off("add:" + i.textureAtlasAsset, zp, e))
    }
}
class fk {
    constructor(e, t) {
        this._app = void 0,
        this._data = void 0,
        this._templateRoot = null,
        this._app = e,
        this._data = t
    }
    instantiate() {
        return this._templateRoot || this._parseTemplate(),
        this._templateRoot.clone()
    }
    _parseTemplate() {
        const e = new xg(this._app,!0);
        this._templateRoot = e.parse(this._data)
    }
}
class pk {
    constructor(e) {
        this.handlerType = "template",
        this._app = e,
        this.maxRetries = 0
    }
    load(e, t) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        });
        const s = {
            retry: this.maxRetries > 0,
            maxRetries: this.maxRetries
        };
        st.get(e.load, s, function(i, n) {
            i ? t("Error requesting template: " + e.original) : t(i, n)
        })
    }
    open(e, t) {
        return new fk(this._app,t)
    }
}
class mk {
    constructor(e) {
        this.handlerType = "text",
        this.maxRetries = 0
    }
    load(e, t) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        }),
        st.get(e.load, {
            retry: this.maxRetries > 0,
            maxRetries: this.maxRetries
        }, function(s, i) {
            s ? t(`Error loading text resource: ${e.original} [${s}]`) : t(null, i)
        })
    }
    open(e, t) {
        return t
    }
    patch(e, t) {}
}
const gd = {
    repeat: wt,
    clamp: oe,
    mirror: Fu
}
  , yd = {
    nearest: be,
    linear: ot,
    nearest_mip_nearest: Vh,
    linear_mip_nearest: Hh,
    nearest_mip_linear: Gh,
    linear_mip_linear: ur
}
  , _k = /^data\.frames\.(\d+)$/;
class gk {
    constructor(e) {
        this.handlerType = "textureatlas",
        this._loader = e.loader,
        this.maxRetries = 0
    }
    load(e, t) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        });
        const s = this
          , i = this._loader.getHandler("texture");
        ye.getExtension(e.original) === ".json" ? st.get(e.load, {
            retry: this.maxRetries > 0,
            maxRetries: this.maxRetries
        }, function(n, r) {
            if (n)
                t(n);
            else {
                const o = e.original.replace(".json", ".png");
                s._loader.load(o, "texture", function(l, c) {
                    l ? t(l) : t(null, {
                        data: r,
                        texture: c
                    })
                })
            }
        }) : i.load(e, t)
    }
    open(e, t) {
        const s = new Ex;
        if (t.texture && t.data)
            s.texture = t.texture,
            s.__data = t.data;
        else {
            const n = this._loader.getHandler("texture").open(e, t);
            if (!n)
                return null;
            s.texture = n
        }
        return s
    }
    patch(e, t) {
        if (!e.resource)
            return;
        e.resource.__data && (e.resource.__data.minfilter !== void 0 && (e.data.minfilter = e.resource.__data.minfilter),
        e.resource.__data.magfilter !== void 0 && (e.data.magfilter = e.resource.__data.magfilter),
        e.resource.__data.addressu !== void 0 && (e.data.addressu = e.resource.__data.addressu),
        e.resource.__data.addressv !== void 0 && (e.data.addressv = e.resource.__data.addressv),
        e.resource.__data.mipmaps !== void 0 && (e.data.mipmaps = e.resource.__data.mipmaps),
        e.resource.__data.anisotropy !== void 0 && (e.data.anisotropy = e.resource.__data.anisotropy),
        e.resource.__data.rgbm !== void 0 && (e.data.rgbm = !!e.resource.__data.rgbm),
        e.data.frames = e.resource.__data.frames,
        delete e.resource.__data);
        const s = e.resource.texture;
        if (s && (s.name = e.name,
        e.data.hasOwnProperty("minfilter") && s.minFilter !== yd[e.data.minfilter] && (s.minFilter = yd[e.data.minfilter]),
        e.data.hasOwnProperty("magfilter") && s.magFilter !== yd[e.data.magfilter] && (s.magFilter = yd[e.data.magfilter]),
        e.data.hasOwnProperty("addressu") && s.addressU !== gd[e.data.addressu] && (s.addressU = gd[e.data.addressu]),
        e.data.hasOwnProperty("addressv") && s.addressV !== gd[e.data.addressv] && (s.addressV = gd[e.data.addressv]),
        e.data.hasOwnProperty("mipmaps") && s.mipmaps !== e.data.mipmaps && (s.mipmaps = e.data.mipmaps),
        e.data.hasOwnProperty("anisotropy") && s.anisotropy !== e.data.anisotropy && (s.anisotropy = e.data.anisotropy),
        e.data.hasOwnProperty("rgbm"))) {
            const n = e.data.rgbm ? pr : $s;
            s.type !== n && (s.type = n)
        }
        e.resource.texture = s;
        const i = {};
        for (const n in e.data.frames) {
            const r = e.data.frames[n];
            i[n] = {
                rect: new M(r.rect),
                pivot: new P(r.pivot),
                border: new M(r.border)
            }
        }
        e.resource.frames = i,
        e.off("change", this._onAssetChange, this),
        e.on("change", this._onAssetChange, this)
    }
    _onAssetChange(e, t, s) {
        let i;
        if (t === "data" || t === "data.frames") {
            const n = {};
            for (const r in s.frames)
                i = s.frames[r],
                n[r] = {
                    rect: new M(i.rect),
                    pivot: new P(i.pivot),
                    border: new M(i.border)
                };
            e.resource.frames = n
        } else {
            const n = t.match(_k);
            if (n) {
                const r = n[1];
                s ? (e.resource.frames[r] ? (i = e.resource.frames[r],
                i.rect.set(s.rect[0], s.rect[1], s.rect[2], s.rect[3]),
                i.pivot.set(s.pivot[0], s.pivot[1]),
                i.border.set(s.border[0], s.border[1], s.border[2], s.border[3])) : e.resource.frames[r] = {
                    rect: new M(s.rect),
                    pivot: new P(s.pivot),
                    border: new M(s.border)
                },
                e.resource.fire("set:frame", r, e.resource.frames[r])) : e.resource.frames[r] && (delete e.resource.frames[r],
                e.resource.fire("remove:frame", r))
            }
        }
    }
}
function yk() {
    const a = {
        cTFETC1: 0,
        cTFETC2: 1,
        cTFBC1: 2,
        cTFBC3: 3,
        cTFPVRTC1_4_RGB: 8,
        cTFPVRTC1_4_RGBA: 9,
        cTFASTC_4x4: 10,
        cTFATC_RGB: 11,
        cTFATC_RGBA_INTERPOLATED_ALPHA: 12,
        cTFRGBA32: 13,
        cTFRGB565: 14,
        cTFRGBA4444: 16
    }
      , e = {
        astc: a.cTFASTC_4x4,
        dxt: a.cTFBC1,
        etc1: a.cTFETC1,
        etc2: a.cTFETC1,
        pvr: a.cTFPVRTC1_4_RGB,
        atc: a.cTFATC_RGB,
        none: a.cTFRGB565
    }
      , t = {
        astc: a.cTFASTC_4x4,
        dxt: a.cTFBC3,
        etc1: a.cTFRGBA4444,
        etc2: a.cTFETC2,
        pvr: a.cTFPVRTC1_4_RGBA,
        atc: a.cTFATC_RGBA_INTERPOLATED_ALPHA,
        none: a.cTFRGBA4444
    }
      , s = {
        ETC1: 21,
        ETC2_RGB: 22,
        ETC2_RGBA: 23,
        DXT1: 8,
        DXT5: 10,
        PVRTC_4BPP_RGB_1: 26,
        PVRTC_4BPP_RGBA_1: 27,
        ASTC_4x4: 28,
        ATC_RGB: 29,
        ATC_RGBA: 30,
        R8_G8_B8_A8: 7,
        R5_G6_B5: 3,
        R4_G4_B4_A4: 5
    }
      , i = (S, w) => {
        switch (S) {
        case a.cTFETC1:
            return w.formats.etc1 ? s.ETC1 : s.ETC2_RGB;
        case a.cTFETC2:
            return s.ETC2_RGBA;
        case a.cTFBC1:
            return s.DXT1;
        case a.cTFBC3:
            return s.DXT5;
        case a.cTFPVRTC1_4_RGB:
            return s.PVRTC_4BPP_RGB_1;
        case a.cTFPVRTC1_4_RGBA:
            return s.PVRTC_4BPP_RGBA_1;
        case a.cTFASTC_4x4:
            return s.ASTC_4x4;
        case a.cTFATC_RGB:
            return s.ATC_RGB;
        case a.cTFATC_RGBA_INTERPOLATED_ALPHA:
            return s.ATC_RGBA;
        case a.cTFRGBA32:
            return s.R8_G8_B8_A8;
        case a.cTFRGB565:
            return s.R5_G6_B5;
        case a.cTFRGBA4444:
            return s.R4_G4_B4_A4
        }
    }
      , n = S => {
        const w = function(b, E) {
            const C = b * .00784313725490196 - 1
              , R = E * (2 / 255) - 1
              , F = Math.sqrt(1 - Math.min(1, C * C + R * R));
            return Math.max(0, Math.min(255, Math.floor((F + 1) * .5 * 255)))
        };
        for (let T = 0; T < S.length; T += 4) {
            const b = S[T + 3]
              , E = S[T + 1];
            S[T + 0] = b,
            S[T + 2] = w(b, E),
            S[T + 3] = 255
        }
        return S
    }
      , r = S => {
        const w = new Uint16Array(S.length / 4);
        for (let T = 0; T < S.length; T += 4) {
            const b = S[T + 0]
              , E = S[T + 1]
              , C = S[T + 2];
            w[T / 4] = (b & 248) << 8 | (E & 252) << 3 | C >> 3
        }
        return w
    }
      , o = (S, w) => (S & S - 1) === 0 && (w & w - 1) === 0
      , l = () => typeof performance < "u" ? performance.now() : 0;
    let c, d, h;
    const u = (S, w, T) => {
        if (T) {
            if (S.formats.astc)
                return "astc"
        } else if (w) {
            if (S.formats.etc2)
                return "etc2"
        } else if (S.formats.etc1 || S.formats.etc2)
            return "etc1";
        return (E => {
            for (let C = 0; C < E.length; ++C) {
                const R = E[C];
                if (S.formats[R])
                    return R
            }
            return "none"
        }
        )(w ? h : d)
    }
      , f = (S, w, T, b) => {
        switch (T) {
        case a.cTFETC1:
        case a.cTFETC2:
            return !0;
        case a.cTFBC1:
        case a.cTFBC3:
            return (S & 3) === 0 && (w & 3) === 0;
        case a.cTFPVRTC1_4_RGB:
        case a.cTFPVRTC1_4_RGBA:
            return o(S, w) && (S === w || b);
        case a.cTFASTC_4x4:
            return !0;
        case a.cTFATC_RGB:
        case a.cTFATC_RGBA_INTERPOLATED_ALPHA:
            return !0
        }
        return !1
    }
      , p = (S, w, T) => {
        if (!c.KTX2File)
            throw new Error("Basis transcoder module does not include support for KTX2.");
        const b = l()
          , E = new c.KTX2File(new Uint8Array(w))
          , C = E.getWidth()
          , R = E.getHeight()
          , F = E.getLevels()
          , L = !!E.getHasAlpha()
          , U = E.isUASTC && E.isUASTC();
        if (!C || !R || !F)
            throw E.close(),
            E.delete(),
            new Error(`Invalid image dimensions url=${S} width=${C} height=${R} levels=${F}`);
        const I = u(T.deviceDetails, L, U)
          , O = !!T.isGGGR && I === "pvr";
        let D;
        if (O ? D = a.cTFRGBA32 : (D = L ? t[I] : e[I],
        f(C, R, D, T.deviceDetails.webgl2) || (D = L ? a.cTFRGBA32 : a.cTFRGB565)),
        !E.startTranscoding())
            throw E.close(),
            E.delete(),
            new Error("Failed to start transcoding url=" + S);
        let A;
        const k = [];
        for (let N = 0; N < F; ++N) {
            const H = E.getImageTranscodedSizeInBytes(N, 0, 0, D)
              , K = new Uint8Array(H);
            if (!E.transcodeImage(K, N, 0, 0, D, 0, -1, -1))
                throw E.close(),
                E.delete(),
                new Error("Failed to transcode image url=" + S);
            const q = D === a.cTFRGB565 || D === a.cTFRGBA4444;
            k.push(q ? new Uint16Array(K.buffer) : K)
        }
        if (E.close(),
        E.delete(),
        O)
            for (D = a.cTFRGB565,
            A = 0; A < k.length; ++A)
                k[A] = r(n(k[A]));
        return {
            format: i(D, T.deviceDetails),
            width: C,
            height: R,
            levels: k,
            cubemap: !1,
            transcodeTime: l() - b,
            url: S,
            unswizzledGGGR: O
        }
    }
      , _ = (S, w, T) => {
        const b = l()
          , E = new c.BasisFile(new Uint8Array(w))
          , C = E.getImageWidth(0, 0)
          , R = E.getImageHeight(0, 0)
          , F = E.getNumImages()
          , L = E.getNumLevels(0)
          , U = !!E.getHasAlpha()
          , I = E.isUASTC && E.isUASTC();
        if (!C || !R || !F || !L)
            throw E.close(),
            E.delete(),
            new Error(`Invalid image dimensions url=${S} width=${C} height=${R} images=${F} levels=${L}`);
        const O = u(T.deviceDetails, U, I)
          , D = !!T.isGGGR && O === "pvr";
        let A;
        if (D ? A = a.cTFRGBA32 : (A = U ? t[O] : e[O],
        f(C, R, A, T.deviceDetails.webgl2) || (A = U ? a.cTFRGBA32 : a.cTFRGB565)),
        !E.startTranscoding())
            throw E.close(),
            E.delete(),
            new Error("Failed to start transcoding url=" + S);
        let k;
        const N = [];
        for (let H = 0; H < L; ++H) {
            const K = E.getImageTranscodedSizeInBytes(0, H, A)
              , q = new Uint8Array(K);
            if (!E.transcodeImage(q, 0, H, A, 0, 0))
                if (H === L - 1 && K === N[H - 1].buffer.byteLength)
                    q.set(new Uint8Array(N[H - 1].buffer)),
                    console.warn("Failed to transcode last mipmap level, using previous level instead url=" + S);
                else
                    throw E.close(),
                    E.delete(),
                    new Error("Failed to transcode image url=" + S);
            const se = A === a.cTFRGB565 || A === a.cTFRGBA4444;
            N.push(se ? new Uint16Array(q.buffer) : q)
        }
        if (E.close(),
        E.delete(),
        D)
            for (A = a.cTFRGB565,
            k = 0; k < N.length; ++k)
                N[k] = r(n(N[k]));
        return {
            format: i(A, T.deviceDetails),
            width: C,
            height: R,
            levels: N,
            cubemap: !1,
            transcodeTime: l() - b,
            url: S,
            unswizzledGGGR: D
        }
    }
      , m = (S, w, T) => T.isKTX2 ? p(S, w, T) : _(S, w, T)
      , g = (S, w, T) => {
        try {
            const b = m(S, w, T);
            b.levels = b.levels.map(E => E.buffer),
            self.postMessage({
                url: S,
                data: b
            }, b.levels)
        } catch (b) {
            self.postMessage({
                url: S,
                err: b
            }, null)
        }
    }
      , v = (S, w) => {
        const T = (b, E) => (WebAssembly.instantiate(S.module, b).then(C => {
            E(C)
        }
        ).catch(C => {
            console.error("instantiate failed + " + C)
        }
        ),
        {});
        self.BASIS(S.module ? {
            instantiateWasm: T
        } : null).then(b => {
            b.initializeBasis(),
            c = b,
            d = S.rgbPriority,
            h = S.rgbaPriority,
            w(null)
        }
        )
    }
      , x = [];
    self.onmessage = S => {
        const w = S.data;
        switch (w.type) {
        case "init":
            v(w.config, () => {
                for (let T = 0; T < x.length; ++T)
                    g(x[T].url, x[T].data, x[T].options);
                x.length = 0
            }
            );
            break;
        case "transcode":
            c ? g(w.url, w.data, w.options) : x.push(w);
            break
        }
    }
}
const vk = a => ({
    astc: !!a.extCompressedTextureASTC,
    atc: !!a.extCompressedTextureATC,
    dxt: !!a.extCompressedTextureS3TC,
    etc1: !!a.extCompressedTextureETC1,
    etc2: !!a.extCompressedTextureETC,
    pvr: !!a.extCompressedTexturePVRTC
})
  , Sk = (a, e) => {
    const t = r => {
        const o = ["/* basis */", r, "", "(" + yk.toString() + `)()

`].join(`
`);
        return new Blob([o],{
            type: "application/javascript"
        })
    }
      , s = () => {
        try {
            if (typeof WebAssembly == "object" && typeof WebAssembly.instantiate == "function") {
                const r = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0));
                if (r instanceof WebAssembly.Module)
                    return new WebAssembly.Instance(r)instanceof WebAssembly.Instance
            }
        } catch {}
        return !1
    }
      , i = (r, o) => {
        e(null, {
            workerUrl: URL.createObjectURL(t(r)),
            module: o,
            rgbPriority: a.rgbPriority,
            rgbaPriority: a.rgbaPriority
        })
    }
      , n = {
        cache: !0,
        responseType: "text",
        retry: a.maxRetries > 0,
        maxRetries: a.maxRetries
    };
    if (a.glueUrl && a.wasmUrl && s()) {
        let r = null
          , o = null;
        st.get(a.glueUrl, n, (d, h) => {
            d ? e(d) : o ? i(h, o) : r = h
        }
        );
        const l = fetch(a.wasmUrl)
          , c = () => {
            l.then(d => d.arrayBuffer()).then(d => WebAssembly.compile(d)).then(d => {
                r ? i(r, d) : o = d
            }
            ).catch(d => {
                e(d, null)
            }
            )
        }
        ;
        WebAssembly.compileStreaming ? WebAssembly.compileStreaming(l).then(d => {
            r ? i(r, d) : o = d
        }
        ).catch(d => {
            c()
        }
        ) : c()
    } else
        st.get(a.fallbackUrl, n, (r, o) => {
            r ? e(r, null) : i(o, null)
        }
        )
}
;
class xk {
    constructor() {
        this.callbacks = {},
        this.queue = [],
        this.clients = []
    }
    enqueueJob(e, t, s, i) {
        if (this.callbacks.hasOwnProperty(e))
            this.callbacks[e].push(s);
        else {
            this.callbacks[e] = [s];
            const n = {
                url: e,
                data: t,
                options: i
            };
            this.clients.length > 0 ? this.clients.shift().run(n) : this.queue.push(n)
        }
    }
    enqueueClient(e) {
        this.queue.length > 0 ? e.run(this.queue.shift()) : this.clients.push(e)
    }
    handleResponse(e, t, s) {
        const i = this.callbacks[e];
        if (t)
            for (let n = 0; n < i.length; ++n)
                i[n](t);
        else {
            s.format === Wh || s.format === Xh ? s.levels = s.levels.map(function(n) {
                return new Uint16Array(n)
            }) : s.levels = s.levels.map(function(n) {
                return new Uint8Array(n)
            });
            for (let n = 0; n < i.length; ++n)
                i[n](null, s)
        }
        delete this.callbacks[e]
    }
}
class wk {
    constructor(e, t, s) {
        this.queue = e,
        this.worker = new Worker(t.workerUrl),
        this.worker.addEventListener("message", i => {
            const n = i.data;
            this.queue.handleResponse(n.url, n.err, n.data),
            this.eager || this.queue.enqueueClient(this)
        }
        ),
        this.worker.postMessage({
            type: "init",
            config: t
        }),
        this.eager = s
    }
    run(e) {
        const t = [];
        e.data instanceof ArrayBuffer && t.push(e.data),
        this.worker.postMessage({
            type: "transcode",
            url: e.url,
            format: e.format,
            data: e.data,
            options: e.options
        }, t),
        this.eager && this.queue.enqueueClient(this)
    }
}
const bk = 1
  , Tk = ["etc1", "etc2", "astc", "dxt", "pvr", "atc"]
  , Ck = ["astc", "dxt", "etc2", "pvr", "atc"]
  , Ek = 5
  , a_ = new xk;
let Nv = null
  , o_ = !1;
function Ak(a) {
    if (!o_) {
        if (!a)
            a = Nv || {};
        else if (a.lazyInit) {
            Nv = a;
            return
        }
        if (!a.glueUrl || !a.wasmUrl || !a.fallbackUrl) {
            const e = TS.getConfig("BASIS");
            e && (a = {
                glueUrl: e.glueUrl,
                wasmUrl: e.wasmUrl,
                fallbackUrl: e.fallbackUrl,
                numWorkers: e.numWorkers
            })
        }
        if (a.glueUrl || a.wasmUrl || a.fallbackUrl) {
            o_ = !0;
            const e = Math.max(1, Math.min(16, a.numWorkers || bk))
              , t = a.numWorkers === 1 || (a.hasOwnProperty("eagerWorkers") ? a.eagerWorkers : !0);
            a.rgbPriority = a.rgbPriority || Tk,
            a.rgbaPriority = a.rgbaPriority || Ck,
            a.maxRetries = a.hasOwnProperty("maxRetries") ? a.maxRetries : Ek,
            Sk(a, (s, i) => {
                if (s)
                    console.error(`failed to initialize basis worker: ${s}`);
                else
                    for (let n = 0; n < e; ++n)
                        a_.enqueueClient(new wk(a_,i,t))
            }
            )
        }
    }
}
let Vp = null;
function Aw(a, e, t, s, i) {
    return Ak(),
    Vp || (Vp = {
        webgl2: a.isWebGL2,
        formats: vk(a)
    }),
    a_.enqueueJob(e, t, s, {
        deviceDetails: Vp,
        isGGGR: !!(i != null && i.isGGGR),
        isKTX2: !!(i != null && i.isKTX2)
    }),
    o_
}
class Mk {
    constructor(e, t) {
        this.device = t,
        this.maxRetries = 0
    }
    load(e, t, s) {
        const i = this.device
          , n = r => {
            var o;
            Aw(i, e.load, r, t, {
                isGGGR: ((s == null || (o = s.file) == null || (o = o.variants) == null || (o = o.basis) == null ? void 0 : o.opt) & 8) !== 0
            }) || t(`Basis module not found. Asset '${s.name}' basis texture variant will not be loaded.`)
        }
        ;
        le.fetchArrayBuffer(e.load, (r, o) => {
            r ? t(r) : n(o)
        }
        , s, this.maxRetries)
    }
    open(e, t, s, i={}) {
        const n = new ge(s,Bt({
            name: e,
            addressU: t.cubemap ? oe : wt,
            addressV: t.cubemap ? oe : wt,
            width: t.width,
            height: t.height,
            format: t.format,
            cubemap: t.cubemap,
            levels: t.levels
        }, i));
        return n.upload(),
        n
    }
}
class Pk {
    constructor(e, t) {
        this.crossOrigin = e.prefix ? "anonymous" : null,
        this.maxRetries = 0,
        this.device = t
    }
    load(e, t, s) {
        var i;
        const n = !!(s != null && (i = s.file) != null && i.contents);
        if (n) {
            if (this.device.supportsImageBitmap) {
                this._loadImageBitmapFromBlob(new Blob([s.file.contents]), t);
                return
            }
            e = {
                load: URL.createObjectURL(new Blob([s.file.contents])),
                original: e.original
            }
        }
        const r = (l, c) => {
            n && URL.revokeObjectURL(e.load),
            t(l, c)
        }
        ;
        let o;
        s && s.options && s.options.hasOwnProperty("crossOrigin") ? o = s.options.crossOrigin : Ko.test(e.load) && (o = this.crossOrigin),
        this.device.supportsImageBitmap ? this._loadImageBitmap(e.load, e.original, o, r) : this._loadImage(e.load, e.original, o, r)
    }
    open(e, t, s, i={}) {
        const n = new ge(s,Bt({
            name: e,
            width: t.width,
            height: t.height,
            format: ve
        }, i));
        return n.setSource(t),
        n
    }
    _loadImage(e, t, s, i) {
        const n = new Image;
        s && (n.crossOrigin = s);
        let r = 0;
        const o = this.maxRetries;
        let l;
        n.onload = function() {
            i(null, n)
        }
        ,
        n.onerror = function() {
            if (!l)
                if (o > 0 && ++r <= o) {
                    const c = Math.pow(2, r) * 100;
                    console.log(`Error loading Texture from: '${t}' - Retrying in ${c}ms...`);
                    const h = e.indexOf("?") >= 0 ? "&" : "?";
                    l = setTimeout(function() {
                        n.src = e + h + "retry=" + Date.now(),
                        l = null
                    }, c)
                } else
                    i(`Error loading Texture from: '${t}'`)
        }
        ,
        n.src = e
    }
    _loadImageBitmap(e, t, s, i) {
        const n = {
            cache: !0,
            responseType: "blob",
            retry: this.maxRetries > 0,
            maxRetries: this.maxRetries
        };
        st.get(e, n, (r, o) => {
            r ? i(r) : this._loadImageBitmapFromBlob(o, i)
        }
        )
    }
    _loadImageBitmapFromBlob(e, t) {
        createImageBitmap(e, {
            premultiplyAlpha: "none",
            colorSpaceConversion: "none"
        }).then(s => t(null, s)).catch(s => t(s))
    }
}
const Gp = [1481919403, 3140563232, 169478669]
  , Rk = {
    33776: jh,
    33778: Uu,
    33779: Jo,
    36196: $h,
    37492: Gu,
    37496: Hu,
    35840: qh,
    35841: tl,
    35842: Yh,
    35843: sl,
    32849: Ln,
    32856: ve,
    35905: zu,
    35907: Vu,
    35898: fa,
    34843: el,
    34842: Tt
};
function Ik(a, e, t, s) {
    return a === fa ? new Uint32Array(e,t,s / 4) : new Uint8Array(e,t,s)
}
class Lk {
    constructor(e) {
        this.maxRetries = 0
    }
    load(e, t, s) {
        le.fetchArrayBuffer(e.load, t, s, this.maxRetries)
    }
    open(e, t, s, i={}) {
        const n = this.parse(t);
        if (!n)
            return null;
        const r = new ge(s,Bt({
            name: e,
            addressU: n.cubemap ? oe : wt,
            addressV: n.cubemap ? oe : wt,
            width: n.width,
            height: n.height,
            format: n.format,
            cubemap: n.cubemap,
            levels: n.levels
        }, i));
        return r.upload(),
        r
    }
    parse(e) {
        const t = new Uint32Array(e);
        if (Gp[0] !== t[0] || Gp[1] !== t[1] || Gp[2] !== t[2])
            return null;
        const s = {
            endianness: t[3],
            glType: t[4],
            glTypeSize: t[5],
            glFormat: t[6],
            glInternalFormat: t[7],
            glBaseInternalFormat: t[8],
            pixelWidth: t[9],
            pixelHeight: t[10],
            pixelDepth: t[11],
            numberOfArrayElements: t[12],
            numberOfFaces: t[13],
            numberOfMipmapLevels: t[14],
            bytesOfKeyValueData: t[15]
        };
        if (s.pixelDepth > 1 || s.numberOfArrayElements !== 0)
            return null;
        const i = Rk[s.glInternalFormat];
        if (i === void 0)
            return null;
        let n = 16 + s.bytesOfKeyValueData / 4;
        const r = s.numberOfFaces > 1
          , o = [];
        for (let l = 0; l < (s.numberOfMipmapLevels || 1); l++) {
            const c = t[n++];
            r && o.push([]);
            const d = r ? o[l] : o;
            for (let h = 0; h < (r ? 6 : 1); ++h)
                d.push(Ik(i, e, n * 4, c)),
                n += c + 3 >> 2
        }
        return {
            format: i,
            width: s.pixelWidth,
            height: s.pixelHeight,
            levels: o,
            cubemap: r
        }
    }
}
const Dk = {
    KHR_DF_MODEL_ETC1S: 163,
    KHR_DF_MODEL_UASTC: 166
};
class Ok {
    constructor(e, t) {
        this.maxRetries = 0,
        this.device = t
    }
    load(e, t, s) {
        le.fetchArrayBuffer(e.load, (i, n) => {
            i ? t(i, n) : this.parse(n, e, t, s)
        }
        , s, this.maxRetries)
    }
    open(e, t, s, i={}) {
        const n = new ge(s,Bt({
            name: e,
            addressU: t.cubemap ? oe : wt,
            addressV: t.cubemap ? oe : wt,
            width: t.width,
            height: t.height,
            format: t.format,
            cubemap: t.cubemap,
            levels: t.levels
        }, i));
        return n.upload(),
        n
    }
    parse(e, t, s, i) {
        const n = new CS(e)
          , r = [n.readU32be(), n.readU32be(), n.readU32be()];
        if (r[0] !== 2873840728 || r[1] !== 540160187 || r[2] !== 218765834)
            return null;
        const o = {
            vkFormat: n.readU32(),
            typeSize: n.readU32(),
            pixelWidth: n.readU32(),
            pixelHeight: n.readU32(),
            pixelDepth: n.readU32(),
            layerCount: n.readU32(),
            faceCount: n.readU32(),
            levelCount: n.readU32(),
            supercompressionScheme: n.readU32()
        }
          , l = {
            dfdByteOffset: n.readU32(),
            dfdByteLength: n.readU32(),
            kvdByteOffset: n.readU32(),
            kvdByteLength: n.readU32(),
            sgdByteOffset: n.readU64(),
            sgdByteLength: n.readU64()
        }
          , c = [];
        for (let f = 0; f < Math.max(1, o.levelCount); ++f)
            c.push({
                byteOffset: n.readU64(),
                byteLength: n.readU64(),
                uncompressedByteLength: n.readU64()
            });
        if (n.readU32() !== l.kvdByteOffset - l.dfdByteOffset)
            return null;
        n.skip(8);
        const h = n.readU8();
        if (n.skip(l.dfdByteLength - 9),
        n.skip(l.kvdByteLength),
        o.supercompressionScheme === 1 || h === Dk.KHR_DF_MODEL_UASTC) {
            var u;
            Aw(this.device, t.load, e, s, {
                isGGGR: ((i == null || (u = i.file) == null || (u = u.variants) == null || (u = u.basis) == null ? void 0 : u.opt) & 8) !== 0,
                isKTX2: !0
            }) || s('Basis module not found. Asset "' + i.name + '" basis texture variant will not be loaded.')
        } else
            s("unsupported KTX2 pixel format")
    }
}
class Fk {
    constructor(e) {
        this.maxRetries = 0
    }
    load(e, t, s) {
        le.fetchArrayBuffer(e.load, t, s, this.maxRetries)
    }
    open(e, t, s, i={}) {
        const n = new Uint32Array(t,0,32)
          , r = n[4]
          , o = n[3]
          , l = Math.max(n[7], 1)
          , c = n[20] === 4
          , d = n[21]
          , h = n[22]
          , u = n[28] === 65024
          , f = 827611204
          , p = 894720068
          , _ = 113
          , m = 116
          , g = 826496069
          , v = 825438800
          , x = 825504336
          , S = 825439312
          , w = 825504848;
        let T = !1, b = !1, E = !1, C = !1, R = null, F = 1, L;
        if (c ? d === f ? (R = jh,
        T = !0) : d === p ? (R = Jo,
        T = !0) : d === _ ? (R = Tt,
        F = 2) : d === m ? (R = lt,
        F = 4) : d === g ? (R = $h,
        T = !0,
        b = !0) : d === v || d === x ? (R = d === v ? tl : sl,
        T = !0,
        E = !0) : (d === S || d === w) && (R = d === S ? qh : Yh,
        T = !0,
        C = !0) : h === 32 && (R = ve),
        !R)
            return L = new ge(s,{
                width: 4,
                height: 4,
                format: Ln,
                name: "dds-legacy-empty"
            }),
            L;
        L = new ge(s,Bt({
            name: e,
            addressU: u ? oe : wt,
            addressV: u ? oe : wt,
            width: r,
            height: o,
            format: R,
            cubemap: u,
            mipmaps: l > 1
        }, i));
        let U = 128;
        const I = u ? 6 : 1;
        let O;
        const D = 4
          , A = 4
          , k = d === f ? 8 : 16;
        let N, H, K;
        for (let q = 0; q < I; q++) {
            let se = r
              , ie = o;
            for (let ae = 0; ae < l; ae++) {
                T ? b ? O = Math.floor((se + 3) / 4) * Math.floor((ie + 3) / 4) * 8 : E ? O = Math.max(se, 16) * Math.max(ie, 8) / 4 : C ? O = Math.max(se, 8) * Math.max(ie, 8) / 2 : (N = Math.floor((se + D - 1) / D),
                H = Math.floor((ie + A - 1) / A),
                K = N * H,
                O = K * k) : O = se * ie * 4;
                const he = R === lt ? new Float32Array(t,U,O) : R === Tt ? new Uint16Array(t,U,O) : new Uint8Array(t,U,O);
                u ? (L._levels[ae] || (L._levels[ae] = []),
                L._levels[ae][q] = he) : L._levels[ae] = he,
                U += O * F,
                se = Math.max(se * .5, 1),
                ie = Math.max(ie * .5, 1)
            }
        }
        return L.upload(),
        L
    }
}
class Bk {
    constructor(e) {
        this.maxRetries = 0
    }
    load(e, t, s) {
        le.fetchArrayBuffer(e.load, t, s, this.maxRetries)
    }
    open(e, t, s, i={}) {
        const n = this.parse(t);
        if (!n)
            return null;
        const r = new ge(s,Bt({
            name: e,
            addressU: wt,
            addressV: oe,
            minFilter: be,
            magFilter: be,
            width: n.width,
            height: n.height,
            levels: n.levels,
            format: ve,
            type: B_,
            mipmaps: !1
        }, i));
        return r.upload(),
        r
    }
    parse(e) {
        const t = new CS(e);
        if (!t.readLine().startsWith("#?RADIANCE"))
            return null;
        const i = {};
        for (; ; ) {
            const c = t.readLine();
            if (c.length === 0)
                break;
            {
                const d = c.split("=");
                d.length === 2 && (i[d[0]] = d[1])
            }
        }
        if (!i.hasOwnProperty("FORMAT"))
            return null;
        const n = t.readLine().split(" ");
        if (n.length !== 4)
            return null;
        const r = parseInt(n[1], 10)
          , o = parseInt(n[3], 10)
          , l = this._readPixels(t, o, r, n[0] === "-Y");
        return l ? {
            width: o,
            height: r,
            levels: [l]
        } : null
    }
    _readPixels(e, t, s, i) {
        if (t < 8 || t > 32767)
            return this._readPixelsFlat(e, t, s);
        const n = [0, 0, 0, 0];
        if (e.readArray(n),
        n[0] !== 2 || n[1] !== 2 || n[2] & 128)
            return e.skip(-4),
            this._readPixelsFlat(e, t, s);
        const r = new ArrayBuffer(t * s * 4)
          , o = new Uint8Array(r);
        let l = i ? 0 : t * 4 * (s - 1), c, d, h, u, f, p;
        for (d = 0; d < s; ++d) {
            if (d && e.readArray(n),
            (n[2] << 8) + n[3] !== t)
                return null;
            for (u = 0; u < 4; ++u)
                for (c = 0; c < t; )
                    if (f = e.readU8(),
                    f > 128) {
                        if (f -= 128,
                        c + f > t)
                            return null;
                        for (p = e.readU8(),
                        h = 0; h < f; ++h)
                            o[l + u + 4 * c++] = p
                    } else {
                        if (f === 0 || c + f > t)
                            return null;
                        for (h = 0; h < f; ++h)
                            o[l + u + 4 * c++] = e.readU8()
                    }
            l += t * 4 * (i ? 1 : -1)
        }
        return o
    }
    _readPixelsFlat(e, t, s) {
        return e.remainingBytes === t * s * 4 ? new Uint8Array(e.arraybuffer,e.offset) : null
    }
}
const Uv = {
    repeat: wt,
    clamp: oe,
    mirror: Fu
}
  , zv = {
    nearest: be,
    linear: ot,
    nearest_mip_nearest: Vh,
    linear_mip_nearest: Hh,
    nearest_mip_linear: Gh,
    linear_mip_linear: ur
}
  , kk = {
    default: $s,
    rgbm: pr,
    rgbe: B_,
    rgbp: Bo,
    swizzleGGGR: lf
}
  , Nk = function(e) {
    const t = wn.calcMipLevelsCount(e._width, e._height)
      , s = function(r) {
        return r instanceof HTMLCanvasElement || r instanceof HTMLImageElement || r instanceof HTMLVideoElement
    };
    if (!(e._format === ve || e._format === lt) || e._volume || e._compressed || e._levels.length === 1 || e._levels.length === t || s(e._cubemap ? e._levels[0][0] : e._levels[0]))
        return;
    const i = function(r, o, l) {
        const c = Math.max(1, r >> 1)
          , d = Math.max(1, o >> 1)
          , h = new l.constructor(c * d * 4)
          , u = Math.floor(r / c)
          , f = Math.floor(o / d)
          , p = u * f;
        for (let _ = 0; _ < d; ++_)
            for (let m = 0; m < c; ++m)
                for (let g = 0; g < 4; ++g) {
                    let v = 0;
                    for (let x = 0; x < f; ++x)
                        for (let S = 0; S < u; ++S)
                            v += l[(m * u + S + (_ * f + x) * r) * 4 + g];
                    h[(m + _ * c) * 4 + g] = v / p
                }
        return h
    };
    for (let n = e._levels.length; n < t; ++n) {
        const r = Math.max(1, e._width >> n - 1)
          , o = Math.max(1, e._height >> n - 1);
        if (e._cubemap) {
            const l = [];
            for (let c = 0; c < 6; ++c)
                l.push(i(r, o, e._levels[n - 1][c]));
            e._levels.push(l)
        } else
            e._levels.push(i(r, o, e._levels[n - 1]))
    }
    e._levelsUpdated = e._cubemap ? [[!0, !0, !0, !0, !0, !0]] : [!0]
};
class Uk {
    constructor(e) {
        this.handlerType = "texture";
        const t = e.assets
          , s = e.graphicsDevice;
        this._device = s,
        this._assets = t,
        this.imgParser = new Pk(t,s),
        this.parsers = {
            dds: new Fk(t),
            ktx: new Lk(t),
            ktx2: new Ok(t,s),
            basis: new Mk(t,s),
            hdr: new Bk(t)
        }
    }
    set crossOrigin(e) {
        this.imgParser.crossOrigin = e
    }
    get crossOrigin() {
        return this.imgParser.crossOrigin
    }
    set maxRetries(e) {
        this.imgParser.maxRetries = e;
        for (const t in this.parsers)
            this.parsers.hasOwnProperty(t) && (this.parsers[t].maxRetries = e)
    }
    get maxRetries() {
        return this.imgParser.maxRetries
    }
    _getUrlWithoutParams(e) {
        return e.indexOf("?") >= 0 ? e.split("?")[0] : e
    }
    _getParser(e) {
        const t = ye.getExtension(this._getUrlWithoutParams(e)).toLowerCase().replace(".", "");
        return this.parsers[t] || this.imgParser
    }
    _getTextureOptions(e) {
        const t = {};
        if (e) {
            var s;
            ((s = e.name) == null ? void 0 : s.length) > 0 && (t.name = e.name);
            const i = e.data;
            i.hasOwnProperty("minfilter") && (t.minFilter = zv[i.minfilter]),
            i.hasOwnProperty("magfilter") && (t.magFilter = zv[i.magfilter]),
            i.hasOwnProperty("addressu") && (t.addressU = Uv[i.addressu]),
            i.hasOwnProperty("addressv") && (t.addressV = Uv[i.addressv]),
            i.hasOwnProperty("mipmaps") && (t.mipmaps = i.mipmaps),
            i.hasOwnProperty("anisotropy") && (t.anisotropy = i.anisotropy),
            i.hasOwnProperty("flipY") && (t.flipY = !!i.flipY),
            i.hasOwnProperty("type") ? t.type = kk[i.type] : i.hasOwnProperty("rgbm") && i.rgbm ? t.type = pr : e.file && e.file.opt & 8 && (t.type = lf)
        }
        return t
    }
    load(e, t, s) {
        typeof e == "string" && (e = {
            load: e,
            original: e
        }),
        this._getParser(e.original).load(e, t, s)
    }
    open(e, t, s) {
        if (!e)
            return;
        const i = this._getTextureOptions(s);
        let n = this._getParser(e).open(e, t, this._device, i);
        return n === null ? n = new ge(this._device,{
            width: 4,
            height: 4,
            format: Ln
        }) : (Nk(n),
        t.unswizzledGGGR && (s.file.variants.basis.opt &= -9)),
        n
    }
    patch(e, t) {
        const s = e.resource;
        if (!s)
            return;
        const i = this._getTextureOptions(e);
        for (const n of Object.keys(i))
            s[n] = i[n]
    }
}
const zk = "inline"
  , Vv = "immersive-vr"
  , oa = "immersive-ar"
  , Vk = "viewer"
  , Gk = "left"
  , Hk = "cpu-optimized"
  , Wk = "gpu-optimized"
  , Mw = "luminance-alpha"
  , Xk = "float32";
class If extends fe {
    constructor(e) {
        super(),
        this._manager = void 0,
        this._views = void 0,
        this._available = !1,
        this._evtDepthResize = null,
        this._uvMatrix = ee.IDENTITY.clone(),
        this._manager = e,
        this._views = e.views,
        this._views.supportedDepth && (this._manager.on("start", this._onSessionStart, this),
        this._manager.on("end", this._onSessionEnd, this))
    }
    _onSessionStart() {
        var e;
        this._views.availableDepth && (this._evtDepthResize = (e = this._views.list[0]) == null ? void 0 : e.on("depth:resize", this._onDepthResize, this))
    }
    _onSessionEnd() {
        this._evtDepthResize && (this._evtDepthResize.off(),
        this._evtDepthResize = null),
        this._available && (this._available = !1,
        this.fire("unavailable"))
    }
    _onDepthResize(e, t) {
        this.fire("resize", e, t)
    }
    getDepth(e, t) {
        var s, i;
        return (s = (i = this._views.list[0]) == null ? void 0 : i.getDepth(e, t)) != null ? s : null
    }
    update() {
        this._manager.session && this.supported && this._views.availableDepth && this._views.list.length && !this._available && (this._available = !0,
        this.fire("available"))
    }
    get supported() {
        return this._views.supportedDepth
    }
    get available() {
        return this._views.availableDepth
    }
    get usage() {
        return this._views.depthUsage
    }
    get dataFormat() {
        return this._views.depthFormat
    }
    get width() {
        var e, t;
        return (e = (t = this._views.list[0]) == null || (t = t.textureDepth) == null ? void 0 : t.width) != null ? e : 0
    }
    get height() {
        var e, t;
        return (e = (t = this._views.list[0]) == null || (t = t.textureDepth) == null ? void 0 : t.height) != null ? e : 0
    }
    get texture() {
        var e;
        return (e = this._views.list[0]) == null ? void 0 : e.textureDepth
    }
    get uvMatrix() {
        var e, t;
        return (e = (t = this._views.list[0]) == null ? void 0 : t.depthUvMatrix) != null ? e : this._uvMatrix
    }
    get rawValueToMeters() {
        var e, t;
        return (e = (t = this._views.list[0]) == null ? void 0 : t.depthValueToMeters) != null ? e : 0
    }
}
If.EVENT_AVAILABLE = "available";
If.EVENT_UNAVAILABLE = "unavailable";
If.EVENT_RESIZE = "resize";
class jk {
    constructor(e) {
        this._manager = void 0,
        this._supported = Le.browser && !!window.XRDOMOverlayState,
        this._root = null,
        this._manager = e
    }
    get supported() {
        return this._supported
    }
    get available() {
        return this._supported && this._manager.active && this._manager._session.domOverlayState !== null
    }
    get state() {
        return !this._supported || !this._manager.active || !this._manager._session.domOverlayState ? null : this._manager._session.domOverlayState.type
    }
    set root(e) {
        !this._supported || this._manager.active || (this._root = e)
    }
    get root() {
        return this._root
    }
}
const vd = []
  , Gv = [];
class bg extends fe {
    constructor(e, t, s, i=null) {
        super(),
        this.manager = void 0,
        this._xrHitTestSource = void 0,
        this._transient = void 0,
        this._inputSource = void 0,
        this.manager = e,
        this._xrHitTestSource = t,
        this._transient = s,
        this._inputSource = i
    }
    remove() {
        if (!this._xrHitTestSource)
            return;
        const e = this.manager.hitTest.sources
          , t = e.indexOf(this);
        t !== -1 && e.splice(t, 1),
        this.onStop()
    }
    onStop() {
        this._xrHitTestSource.cancel(),
        this._xrHitTestSource = null,
        this.fire("remove"),
        this.manager.hitTest.fire("remove", this)
    }
    update(e) {
        if (this._transient) {
            const t = e.getHitTestResultsForTransientInput(this._xrHitTestSource);
            for (let s = 0; s < t.length; s++) {
                const i = t[s];
                if (!i.results.length)
                    continue;
                let n;
                i.inputSource && (n = this.manager.input._getByInputSource(i.inputSource)),
                this.updateHitResults(i.results, n)
            }
        } else {
            const t = e.getHitTestResults(this._xrHitTestSource);
            if (!t.length)
                return;
            this.updateHitResults(t)
        }
    }
    updateHitResults(e, t) {
        var s, i, n;
        if (this._inputSource && this._inputSource !== t)
            return;
        const r = (s = vd.pop()) != null ? s : new y;
        t ? r.copy(t.getOrigin()) : r.copy(this.manager.camera.getPosition());
        let o = 1 / 0
          , l = null;
        const c = (i = vd.pop()) != null ? i : new y
          , d = (n = Gv.pop()) != null ? n : new ne;
        for (let h = 0; h < e.length; h++) {
            const u = e[h].getPose(this.manager._referenceSpace)
              , f = r.distance(u.transform.position);
            f >= o || (o = f,
            l = e[h],
            c.copy(u.transform.position),
            d.copy(u.transform.orientation))
        }
        this.fire("result", c, d, t || this._inputSource, l),
        this.manager.hitTest.fire("result", this, c, d, t || this._inputSource, l),
        vd.push(r),
        vd.push(c),
        Gv.push(d)
    }
}
bg.EVENT_REMOVE = "remove";
bg.EVENT_RESULT = "result";
class Tc extends fe {
    constructor(e) {
        super(),
        this.manager = void 0,
        this._supported = Le.browser && !!(window.XRSession && window.XRSession.prototype.requestHitTestSource),
        this._session = null,
        this.sources = [],
        this.manager = e,
        this._supported && (this.manager.on("start", this._onSessionStart, this),
        this.manager.on("end", this._onSessionEnd, this))
    }
    _onSessionStart() {
        this.manager.type === oa && (this._session = this.manager.session)
    }
    _onSessionEnd() {
        if (this._session) {
            this._session = null;
            for (let e = 0; e < this.sources.length; e++)
                this.sources[e].onStop();
            this.sources = []
        }
    }
    isAvailable(e, t) {
        let s;
        return this._supported || (s = new Error("XR HitTest is not supported")),
        this._session || (s = new Error("XR Session is not started (1)")),
        this.manager.type !== oa && (s = new Error("XR HitTest is available only for AR")),
        s ? (e && e(s),
        t && t.fire("error", s),
        !1) : !0
    }
    start(e={}) {
        if (!this.isAvailable(e.callback, this))
            return;
        !e.profile && !e.spaceType && (e.spaceType = Vk);
        let t;
        const s = e.offsetRay;
        if (s) {
            const n = new DOMPoint(s.origin.x,s.origin.y,s.origin.z,1)
              , r = new DOMPoint(s.direction.x,s.direction.y,s.direction.z,0);
            t = new XRRay(n,r)
        }
        const i = e.callback;
        e.spaceType ? this._session.requestReferenceSpace(e.spaceType).then(n => {
            if (!this._session) {
                const r = new Error("XR Session is not started (2)");
                i && i(r),
                this.fire("error", r);
                return
            }
            this._session.requestHitTestSource({
                space: n,
                entityTypes: e.entityTypes || void 0,
                offsetRay: t
            }).then(r => {
                this._onHitTestSource(r, !1, e.inputSource, i)
            }
            ).catch(r => {
                i && i(r),
                this.fire("error", r)
            }
            )
        }
        ).catch(n => {
            i && i(n),
            this.fire("error", n)
        }
        ) : this._session.requestHitTestSourceForTransientInput({
            profile: e.profile,
            entityTypes: e.entityTypes || void 0,
            offsetRay: t
        }).then(n => {
            this._onHitTestSource(n, !0, e.inputSource, i)
        }
        ).catch(n => {
            i && i(n),
            this.fire("error", n)
        }
        )
    }
    _onHitTestSource(e, t, s, i) {
        if (!this._session) {
            e.cancel();
            const r = new Error("XR Session is not started (3)");
            i && i(r),
            this.fire("error", r);
            return
        }
        const n = new bg(this.manager,e,t,s ?? null);
        this.sources.push(n),
        i && i(null, n),
        this.fire("add", n)
    }
    update(e) {
        for (let t = 0; t < this.sources.length; t++)
            this.sources[t].update(e)
    }
    get supported() {
        return this._supported
    }
}
Tc.EVENT_ADD = "add";
Tc.EVENT_REMOVE = "remove";
Tc.EVENT_RESULT = "result";
Tc.EVENT_ERROR = "error";
class Tg extends fe {
    constructor(e, t) {
        super(),
        this._image = void 0,
        this._width = void 0,
        this._bitmap = null,
        this._measuredWidth = 0,
        this._trackable = !1,
        this._tracking = !1,
        this._emulated = !1,
        this._pose = null,
        this._position = new y,
        this._rotation = new ne,
        this._image = e,
        this._width = t
    }
    get image() {
        return this._image
    }
    set width(e) {
        this._width = e
    }
    get width() {
        return this._width
    }
    get trackable() {
        return this._trackable
    }
    get tracking() {
        return this._tracking
    }
    get emulated() {
        return this._emulated
    }
    prepare() {
        return this._bitmap ? {
            image: this._bitmap,
            widthInMeters: this._width
        } : createImageBitmap(this._image).then(e => (this._bitmap = e,
        {
            image: this._bitmap,
            widthInMeters: this._width
        }))
    }
    destroy() {
        this._image = null,
        this._pose = null,
        this._bitmap && (this._bitmap.close(),
        this._bitmap = null)
    }
    getPosition() {
        return this._pose && this._position.copy(this._pose.transform.position),
        this._position
    }
    getRotation() {
        return this._pose && this._rotation.copy(this._pose.transform.orientation),
        this._rotation
    }
}
Tg.EVENT_TRACKED = "tracked";
Tg.EVENT_UNTRACKED = "untracked";
class Pw extends fe {
    constructor(e) {
        super(),
        this._manager = void 0,
        this._supported = Le.browser && !!window.XRImageTrackingResult,
        this._available = !1,
        this._images = [],
        this._manager = e,
        this._supported && (this._manager.on("start", this._onSessionStart, this),
        this._manager.on("end", this._onSessionEnd, this))
    }
    add(e, t) {
        if (!this._supported || this._manager.active)
            return null;
        const s = new Tg(e,t);
        return this._images.push(s),
        s
    }
    remove(e) {
        if (this._manager.active)
            return;
        const t = this._images.indexOf(e);
        t !== -1 && (e.destroy(),
        this._images.splice(t, 1))
    }
    _onSessionStart() {
        this._manager.session.getTrackedImageScores().then(e => {
            this._available = !0;
            for (let t = 0; t < e.length; t++)
                this._images[t]._trackable = e[t] === "trackable"
        }
        ).catch(e => {
            this._available = !1,
            this.fire("error", e)
        }
        )
    }
    _onSessionEnd() {
        this._available = !1;
        for (let e = 0; e < this._images.length; e++) {
            const t = this._images[e];
            t._pose = null,
            t._measuredWidth = 0,
            t._tracking && (t._tracking = !1,
            t.fire("untracked"))
        }
    }
    prepareImages(e) {
        this._images.length ? Promise.all(this._images.map(function(t) {
            return t.prepare()
        })).then(function(t) {
            e(null, t)
        }).catch(function(t) {
            e(t, null)
        }) : e(null, null)
    }
    update(e) {
        if (!this._available)
            return;
        const t = e.getImageTrackingResults()
          , s = {};
        for (let i = 0; i < t.length; i++) {
            s[t[i].index] = t[i];
            const n = this._images[t[i].index];
            n._emulated = t[i].trackingState === "emulated",
            n._measuredWidth = t[i].measuredWidthInMeters,
            n._pose = e.getPose(t[i].imageSpace, this._manager._referenceSpace)
        }
        for (let i = 0; i < this._images.length; i++)
            this._images[i]._tracking && !s[i] ? (this._images[i]._tracking = !1,
            this._images[i].fire("untracked")) : !this._images[i]._tracking && s[i] && (this._images[i]._tracking = !0,
            this._images[i].fire("tracked"))
    }
    get supported() {
        return this._supported
    }
    get available() {
        return this._available
    }
    get images() {
        return this._images
    }
}
Pw.EVENT_ERROR = "error";
class $k {
    constructor(e, t) {
        this._index = void 0,
        this._hand = void 0,
        this._joints = [],
        this._tip = null,
        this._index = e,
        this._hand = t,
        this._hand._fingers.push(this)
    }
    get index() {
        return this._index
    }
    get hand() {
        return this._hand
    }
    get joints() {
        return this._joints
    }
    get tip() {
        return this._tip
    }
}
const Hv = Le.browser && window.XRHand ? ["thumb-tip", "index-finger-tip", "middle-finger-tip", "ring-finger-tip", "pinky-finger-tip"] : []
  , Rw = {};
for (let a = 0; a < Hv.length; a++)
    Rw[Hv[a]] = !0;
class Wv {
    constructor(e, t, s, i=null) {
        this._index = void 0,
        this._id = void 0,
        this._hand = void 0,
        this._finger = void 0,
        this._wrist = void 0,
        this._tip = void 0,
        this._radius = null,
        this._localTransform = new ee,
        this._worldTransform = new ee,
        this._localPosition = new y,
        this._localRotation = new ne,
        this._position = new y,
        this._rotation = new ne,
        this._dirtyLocal = !0,
        this._index = e,
        this._id = t,
        this._hand = s,
        this._finger = i,
        this._wrist = t === "wrist",
        this._tip = this._finger && !!Rw[t]
    }
    update(e) {
        this._dirtyLocal = !0,
        this._radius = e.radius,
        this._localPosition.copy(e.transform.position),
        this._localRotation.copy(e.transform.orientation)
    }
    _updateTransforms() {
        this._dirtyLocal && (this._dirtyLocal = !1,
        this._localTransform.setTRS(this._localPosition, this._localRotation, y.ONE));
        const t = this._hand._manager.camera.parent;
        t ? this._worldTransform.mul2(t.getWorldTransform(), this._localTransform) : this._worldTransform.copy(this._localTransform)
    }
    getPosition() {
        return this._updateTransforms(),
        this._worldTransform.getTranslation(this._position),
        this._position
    }
    getRotation() {
        return this._updateTransforms(),
        this._rotation.setFromMat4(this._worldTransform),
        this._rotation
    }
    get index() {
        return this._index
    }
    get hand() {
        return this._hand
    }
    get finger() {
        return this._finger
    }
    get wrist() {
        return this._wrist
    }
    get tip() {
        return this._tip
    }
    get radius() {
        return this._radius || .005
    }
}
let Hd = [];
const Hr = new y
  , Sd = new y
  , Xv = new y;
Le.browser && window.XRHand && (Hd = [["thumb-metacarpal", "thumb-phalanx-proximal", "thumb-phalanx-distal", "thumb-tip"], ["index-finger-metacarpal", "index-finger-phalanx-proximal", "index-finger-phalanx-intermediate", "index-finger-phalanx-distal", "index-finger-tip"], ["middle-finger-metacarpal", "middle-finger-phalanx-proximal", "middle-finger-phalanx-intermediate", "middle-finger-phalanx-distal", "middle-finger-tip"], ["ring-finger-metacarpal", "ring-finger-phalanx-proximal", "ring-finger-phalanx-intermediate", "ring-finger-phalanx-distal", "ring-finger-tip"], ["pinky-finger-metacarpal", "pinky-finger-phalanx-proximal", "pinky-finger-phalanx-intermediate", "pinky-finger-phalanx-distal", "pinky-finger-tip"]]);
class Cg extends fe {
    constructor(e) {
        super(),
        this._manager = void 0,
        this._inputSource = void 0,
        this._tracking = !1,
        this._fingers = [],
        this._joints = [],
        this._jointsById = {},
        this._tips = [],
        this._wrist = null;
        const t = e._xrInputSource.hand;
        if (this._manager = e._manager,
        this._inputSource = e,
        t.get("wrist")) {
            const s = new Wv(0,"wrist",this,null);
            this._wrist = s,
            this._joints.push(s),
            this._jointsById.wrist = s
        }
        for (let s = 0; s < Hd.length; s++) {
            const i = new $k(s,this);
            for (let n = 0; n < Hd[s].length; n++) {
                const r = Hd[s][n];
                if (!t.get(r))
                    continue;
                const o = new Wv(n,r,this,i);
                this._joints.push(o),
                this._jointsById[r] = o,
                o.tip && (this._tips.push(o),
                i._tip = o),
                i._joints.push(o)
            }
        }
    }
    update(e) {
        const t = this._inputSource._xrInputSource;
        for (let d = 0; d < this._joints.length; d++) {
            const h = this._joints[d]
              , u = t.hand.get(h._id);
            if (u) {
                let f;
                if (e.session.visibilityState !== "hidden" && (f = e.getJointPose(u, this._manager._referenceSpace)),
                f)
                    h.update(f),
                    h.wrist && !this._tracking && (this._tracking = !0,
                    this.fire("tracking"));
                else if (h.wrist) {
                    this._tracking && (this._tracking = !1,
                    this.fire("trackinglost"));
                    break
                }
            }
        }
        const s = this._jointsById["thumb-metacarpal"]
          , i = this._jointsById["thumb-tip"]
          , n = this._jointsById["index-finger-phalanx-proximal"]
          , r = this._jointsById["index-finger-tip"]
          , o = this._jointsById["ring-finger-phalanx-proximal"]
          , l = this._jointsById["pinky-finger-phalanx-proximal"];
        if (s && i && n && r && o && l) {
            this._inputSource._dirtyRay = !0,
            this._inputSource._rayLocal.origin.lerp(i._localPosition, r._localPosition, .5);
            let d = s
              , h = l;
            if (this._inputSource.handedness === Gk) {
                const u = d;
                d = h,
                h = u
            }
            Hr.sub2(d._localPosition, this._wrist._localPosition),
            Sd.sub2(h._localPosition, this._wrist._localPosition),
            Xv.cross(Hr, Sd).normalize(),
            Hr.lerp(n._localPosition, o._localPosition, .5),
            Hr.sub(this._wrist._localPosition).normalize(),
            this._inputSource._rayLocal.direction.lerp(Xv, Hr, .5).normalize()
        }
        this._fingerIsClosed(1) && this._fingerIsClosed(2) && this._fingerIsClosed(3) && this._fingerIsClosed(4) ? this._inputSource._squeezing || (this._inputSource._squeezing = !0,
        this._inputSource.fire("squeezestart"),
        this._manager.input.fire("squeezestart", this._inputSource)) : this._inputSource._squeezing && (this._inputSource._squeezing = !1,
        this._inputSource.fire("squeeze"),
        this._manager.input.fire("squeeze", this._inputSource),
        this._inputSource.fire("squeezeend"),
        this._manager.input.fire("squeezeend", this._inputSource))
    }
    _fingerIsClosed(e) {
        const t = this._fingers[e];
        return Hr.sub2(t.joints[0]._localPosition, t.joints[1]._localPosition).normalize(),
        Sd.sub2(t.joints[2]._localPosition, t.joints[3]._localPosition).normalize(),
        Hr.dot(Sd) < -.8
    }
    getJointById(e) {
        return this._jointsById[e] || null
    }
    get fingers() {
        return this._fingers
    }
    get joints() {
        return this._joints
    }
    get tips() {
        return this._tips
    }
    get wrist() {
        return this._wrist
    }
    get tracking() {
        return this._tracking
    }
}
Cg.EVENT_TRACKING = "tracking";
Cg.EVENT_TRACKINGLOST = "trackinglost";
const jv = new y
  , $v = new ne;
let qk = 0;
class Ei extends fe {
    constructor(e, t) {
        super(),
        this._id = void 0,
        this._manager = void 0,
        this._xrInputSource = void 0,
        this._ray = new cr,
        this._rayLocal = new cr,
        this._grip = !1,
        this._hand = null,
        this._velocitiesAvailable = !1,
        this._velocitiesTimestamp = Hi(),
        this._localTransform = null,
        this._worldTransform = null,
        this._position = new y,
        this._rotation = new ne,
        this._localPosition = null,
        this._localPositionLast = null,
        this._localRotation = null,
        this._linearVelocity = null,
        this._dirtyLocal = !0,
        this._dirtyRay = !1,
        this._selecting = !1,
        this._squeezing = !1,
        this._elementInput = !0,
        this._elementEntity = null,
        this._hitTestSources = [],
        this._id = ++qk,
        this._manager = e,
        this._xrInputSource = t,
        t.hand && (this._hand = new Cg(this))
    }
    get id() {
        return this._id
    }
    get inputSource() {
        return this._xrInputSource
    }
    get targetRayMode() {
        return this._xrInputSource.targetRayMode
    }
    get handedness() {
        return this._xrInputSource.handedness
    }
    get profiles() {
        return this._xrInputSource.profiles
    }
    get grip() {
        return this._grip
    }
    get hand() {
        return this._hand
    }
    get gamepad() {
        return this._xrInputSource.gamepad || null
    }
    get selecting() {
        return this._selecting
    }
    get squeezing() {
        return this._squeezing
    }
    set elementInput(e) {
        this._elementInput !== e && (this._elementInput = e,
        this._elementInput || (this._elementEntity = null))
    }
    get elementInput() {
        return this._elementInput
    }
    get elementEntity() {
        return this._elementEntity
    }
    get hitTestSources() {
        return this._hitTestSources
    }
    update(e) {
        if (this._hand)
            this._hand.update(e);
        else {
            const t = this._xrInputSource.gripSpace;
            if (t) {
                const i = e.getPose(t, this._manager._referenceSpace);
                if (i) {
                    this._grip || (this._grip = !0,
                    this._localTransform = new ee,
                    this._worldTransform = new ee,
                    this._localPositionLast = new y,
                    this._localPosition = new y,
                    this._localRotation = new ne,
                    this._linearVelocity = new y);
                    const n = Hi()
                      , r = (n - this._velocitiesTimestamp) / 1e3;
                    this._velocitiesTimestamp = n,
                    this._dirtyLocal = !0,
                    this._localPositionLast.copy(this._localPosition),
                    this._localPosition.copy(i.transform.position),
                    this._localRotation.copy(i.transform.orientation),
                    this._velocitiesAvailable = !0,
                    this._manager.input.velocitiesSupported && i.linearVelocity ? this._linearVelocity.copy(i.linearVelocity) : r > 0 && (jv.sub2(this._localPosition, this._localPositionLast).divScalar(r),
                    this._linearVelocity.lerp(this._linearVelocity, jv, .15))
                } else
                    this._velocitiesAvailable = !1
            }
            const s = e.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace);
            s && (this._dirtyRay = !0,
            this._rayLocal.origin.copy(s.transform.position),
            this._rayLocal.direction.set(0, 0, -1),
            $v.copy(s.transform.orientation),
            $v.transformVector(this._rayLocal.direction, this._rayLocal.direction))
        }
    }
    _updateTransforms() {
        this._dirtyLocal && (this._dirtyLocal = !1,
        this._localTransform.setTRS(this._localPosition, this._localRotation, y.ONE));
        const e = this._manager.camera.parent;
        e ? this._worldTransform.mul2(e.getWorldTransform(), this._localTransform) : this._worldTransform.copy(this._localTransform)
    }
    _updateRayTransforms() {
        const e = this._dirtyRay;
        if (this._dirtyRay = !1,
        this._manager.camera.parent) {
            const s = this._manager.camera.parent.getWorldTransform();
            s.getTranslation(this._position),
            this._rotation.setFromMat4(s),
            this._rotation.transformVector(this._rayLocal.origin, this._ray.origin),
            this._ray.origin.add(this._position),
            this._rotation.transformVector(this._rayLocal.direction, this._ray.direction)
        } else
            e && (this._ray.origin.copy(this._rayLocal.origin),
            this._ray.direction.copy(this._rayLocal.direction))
    }
    getPosition() {
        return this._position ? (this._updateTransforms(),
        this._worldTransform.getTranslation(this._position),
        this._position) : null
    }
    getLocalPosition() {
        return this._localPosition
    }
    getRotation() {
        return this._rotation ? (this._updateTransforms(),
        this._rotation.setFromMat4(this._worldTransform),
        this._rotation) : null
    }
    getLocalRotation() {
        return this._localRotation
    }
    getLinearVelocity() {
        return this._velocitiesAvailable ? this._linearVelocity : null
    }
    getOrigin() {
        return this._updateRayTransforms(),
        this._ray.origin
    }
    getDirection() {
        return this._updateRayTransforms(),
        this._ray.direction
    }
    hitTestStart(e={}) {
        e.inputSource = this,
        e.profile = this._xrInputSource.profiles[0];
        const t = e.callback;
        e.callback = (s, i) => {
            i && this.onHitTestSourceAdd(i),
            t && t(s, i)
        }
        ,
        this._manager.hitTest.start(e)
    }
    onHitTestSourceAdd(e) {
        this._hitTestSources.push(e),
        this.fire("hittest:add", e),
        e.on("result", (t, s, i) => {
            i === this && this.fire("hittest:result", e, t, s)
        }
        ),
        e.once("remove", () => {
            this.onHitTestSourceRemove(e),
            this.fire("hittest:remove", e)
        }
        )
    }
    onHitTestSourceRemove(e) {
        const t = this._hitTestSources.indexOf(e);
        t !== -1 && this._hitTestSources.splice(t, 1)
    }
}
Ei.EVENT_REMOVE = "remove";
Ei.EVENT_SELECT = "select";
Ei.EVENT_SELECTSTART = "selectstart";
Ei.EVENT_SELECTEND = "selectend";
Ei.EVENT_SQUEEZE = "squeeze";
Ei.EVENT_SQUEEZESTART = "squeezestart";
Ei.EVENT_SQUEEZEEND = "squeezeend";
Ei.EVENT_HITTESTADD = "hittest:add";
Ei.EVENT_HITTESTREMOVE = "hittest:remove";
Ei.EVENT_HITTESTRESULT = "hittest:result";
class zn extends fe {
    constructor(e) {
        var t;
        super(),
        this.manager = void 0,
        this._inputSources = [],
        this._onInputSourcesChangeEvt = void 0,
        this.velocitiesSupported = !1,
        this.manager = e,
        this.velocitiesSupported = !!(Le.browser && (t = window.XRPose) != null && (t = t.prototype) != null && t.hasOwnProperty("linearVelocity")),
        this._onInputSourcesChangeEvt = s => {
            this._onInputSourcesChange(s)
        }
        ,
        this.manager.on("start", this._onSessionStart, this),
        this.manager.on("end", this._onSessionEnd, this)
    }
    _onSessionStart() {
        const e = this.manager.session;
        e.addEventListener("inputsourceschange", this._onInputSourcesChangeEvt),
        e.addEventListener("select", s => {
            const i = this._getByInputSource(s.inputSource);
            i.update(s.frame),
            i.fire("select", s),
            this.fire("select", i, s)
        }
        ),
        e.addEventListener("selectstart", s => {
            const i = this._getByInputSource(s.inputSource);
            i.update(s.frame),
            i._selecting = !0,
            i.fire("selectstart", s),
            this.fire("selectstart", i, s)
        }
        ),
        e.addEventListener("selectend", s => {
            const i = this._getByInputSource(s.inputSource);
            i.update(s.frame),
            i._selecting = !1,
            i.fire("selectend", s),
            this.fire("selectend", i, s)
        }
        ),
        e.addEventListener("squeeze", s => {
            const i = this._getByInputSource(s.inputSource);
            i.update(s.frame),
            i.fire("squeeze", s),
            this.fire("squeeze", i, s)
        }
        ),
        e.addEventListener("squeezestart", s => {
            const i = this._getByInputSource(s.inputSource);
            i.update(s.frame),
            i._squeezing = !0,
            i.fire("squeezestart", s),
            this.fire("squeezestart", i, s)
        }
        ),
        e.addEventListener("squeezeend", s => {
            const i = this._getByInputSource(s.inputSource);
            i.update(s.frame),
            i._squeezing = !1,
            i.fire("squeezeend", s),
            this.fire("squeezeend", i, s)
        }
        );
        const t = e.inputSources;
        for (let s = 0; s < t.length; s++)
            this._addInputSource(t[s])
    }
    _onSessionEnd() {
        let e = this._inputSources.length;
        for (; e--; ) {
            const s = this._inputSources[e];
            this._inputSources.splice(e, 1),
            s.fire("remove"),
            this.fire("remove", s)
        }
        this.manager.session.removeEventListener("inputsourceschange", this._onInputSourcesChangeEvt)
    }
    _onInputSourcesChange(e) {
        for (let t = 0; t < e.removed.length; t++)
            this._removeInputSource(e.removed[t]);
        for (let t = 0; t < e.added.length; t++)
            this._addInputSource(e.added[t])
    }
    _getByInputSource(e) {
        for (let t = 0; t < this._inputSources.length; t++)
            if (this._inputSources[t].inputSource === e)
                return this._inputSources[t];
        return null
    }
    _addInputSource(e) {
        if (this._getByInputSource(e))
            return;
        const t = new Ei(this.manager,e);
        this._inputSources.push(t),
        this.fire("add", t)
    }
    _removeInputSource(e) {
        for (let t = 0; t < this._inputSources.length; t++) {
            if (this._inputSources[t].inputSource !== e)
                continue;
            const s = this._inputSources[t];
            this._inputSources.splice(t, 1);
            let i = s.hitTestSources.length;
            for (; i--; )
                s.hitTestSources[i].remove();
            s.fire("remove"),
            this.fire("remove", s);
            return
        }
    }
    update(e) {
        for (let t = 0; t < this._inputSources.length; t++)
            this._inputSources[t].update(e)
    }
    get inputSources() {
        return this._inputSources
    }
}
zn.EVENT_ADD = "add";
zn.EVENT_REMOVE = "remove";
zn.EVENT_SELECT = "select";
zn.EVENT_SELECTSTART = "selectstart";
zn.EVENT_SELECTEND = "selectend";
zn.EVENT_SQUEEZE = "squeeze";
zn.EVENT_SQUEEZESTART = "squeezestart";
zn.EVENT_SQUEEZEEND = "squeezeend";
const no = new y
  , qv = new y
  , Hp = new ee
  , Yv = new ee;
class Eg extends fe {
    constructor(e) {
        super(),
        this._manager = void 0,
        this._supported = !1,
        this._available = !1,
        this._lightProbeRequested = !1,
        this._lightProbe = null,
        this._intensity = 0,
        this._rotation = new ne,
        this._color = new z,
        this._sphericalHarmonics = new Float32Array(27),
        this._manager = e,
        this._manager.on("start", this._onSessionStart, this),
        this._manager.on("end", this._onSessionEnd, this)
    }
    _onSessionStart() {
        this._manager.session.requestLightProbe && (this._supported = !0)
    }
    _onSessionEnd() {
        this._supported = !1,
        this._available = !1,
        this._lightProbeRequested = !1,
        this._lightProbe = null
    }
    start() {
        let e;
        if (this._manager.session || (e = new Error("XR session is not running")),
        !e && this._manager.type !== oa && (e = new Error("XR session type is not AR")),
        !e && !this._supported && (e = new Error("light-estimation is not supported")),
        (!e && this._lightProbe || this._lightProbeRequested) && (e = new Error("light estimation is already requested")),
        e) {
            this.fire("error", e);
            return
        }
        this._lightProbeRequested = !0,
        this._manager.session.requestLightProbe().then(t => {
            const s = this._lightProbeRequested;
            this._lightProbeRequested = !1,
            this._manager.active ? s && (this._lightProbe = t) : this.fire("error", new Error("XR session is not active"))
        }
        ).catch(t => {
            this._lightProbeRequested = !1,
            this.fire("error", t)
        }
        )
    }
    end() {
        this._lightProbeRequested = !1,
        this._lightProbe = null,
        this._available = !1
    }
    update(e) {
        if (!this._lightProbe)
            return;
        const t = e.getLightEstimate(this._lightProbe);
        if (!t)
            return;
        this._available || (this._available = !0,
        this.fire("available"));
        const s = t.primaryLightIntensity;
        this._intensity = Math.max(1, Math.max(s.x, Math.max(s.y, s.z))),
        no.copy(s).mulScalar(1 / this._intensity),
        this._color.set(no.x, no.y, no.z),
        no.set(0, 0, 0),
        qv.copy(t.primaryLightDirection),
        Hp.setLookAt(qv, no, y.UP),
        Yv.setFromAxisAngle(y.RIGHT, 90),
        Hp.mul(Yv),
        this._rotation.setFromMat4(Hp),
        this._sphericalHarmonics.set(t.sphericalHarmonicsCoefficients)
    }
    get supported() {
        return this._supported
    }
    get available() {
        return this._available
    }
    get intensity() {
        return this._available ? this._intensity : null
    }
    get color() {
        return this._available ? this._color : null
    }
    get rotation() {
        return this._available ? this._rotation : null
    }
    get sphericalHarmonics() {
        return this._available ? this._sphericalHarmonics : null
    }
}
Eg.EVENT_AVAILABLE = "available";
Eg.EVENT_ERROR = "error";
let Yk = 0;
class Ag extends fe {
    constructor(e, t) {
        super(),
        this._id = void 0,
        this._planeDetection = void 0,
        this._xrPlane = void 0,
        this._lastChangedTime = void 0,
        this._orientation = void 0,
        this._position = new y,
        this._rotation = new ne,
        this._id = ++Yk,
        this._planeDetection = e,
        this._xrPlane = t,
        this._lastChangedTime = t.lastChangedTime,
        this._orientation = t.orientation
    }
    destroy() {
        this._xrPlane && (this._xrPlane = null,
        this.fire("remove"))
    }
    update(e) {
        const t = this._planeDetection._manager
          , s = e.getPose(this._xrPlane.planeSpace, t._referenceSpace);
        s && (this._position.copy(s.transform.position),
        this._rotation.copy(s.transform.orientation)),
        this._lastChangedTime !== this._xrPlane.lastChangedTime && (this._lastChangedTime = this._xrPlane.lastChangedTime,
        this.fire("change"))
    }
    getPosition() {
        return this._position
    }
    getRotation() {
        return this._rotation
    }
    get id() {
        return this._id
    }
    get orientation() {
        return this._orientation
    }
    get points() {
        return this._xrPlane.polygon
    }
    get label() {
        return this._xrPlane.semanticLabel || ""
    }
}
Ag.EVENT_REMOVE = "remove";
Ag.EVENT_CHANGE = "change";
class Cc extends fe {
    constructor(e) {
        super(),
        this._manager = void 0,
        this._supported = Le.browser && !!window.XRPlane,
        this._available = !1,
        this._planesIndex = new Map,
        this._planes = [],
        this._manager = e,
        this._supported && (this._manager.on("start", this._onSessionStart, this),
        this._manager.on("end", this._onSessionEnd, this))
    }
    _onSessionStart() {
        this._supported && this._manager.session.enabledFeatures.indexOf("plane-detection") !== -1 && (this._available = !0,
        this.fire("available"))
    }
    _onSessionEnd() {
        for (let e = 0; e < this._planes.length; e++)
            this._planes[e].destroy(),
            this.fire("remove", this._planes[e]);
        this._planesIndex.clear(),
        this._planes.length = 0,
        this._available && (this._available = !1,
        this.fire("unavailable"))
    }
    update(e) {
        if (!this._supported || !this._available)
            return;
        const t = e.detectedPlanes;
        for (const [s,i] of this._planesIndex)
            t.has(s) || (this._planesIndex.delete(s),
            this._planes.splice(this._planes.indexOf(i), 1),
            i.destroy(),
            this.fire("remove", i));
        for (const s of t) {
            let i = this._planesIndex.get(s);
            i ? i.update(e) : (i = new Ag(this,s),
            this._planesIndex.set(s, i),
            this._planes.push(i),
            i.update(e),
            this.fire("add", i))
        }
    }
    get supported() {
        return this._supported
    }
    get available() {
        return this._available
    }
    get planes() {
        return this._planes
    }
}
Cc.EVENT_AVAILABLE = "available";
Cc.EVENT_UNAVAILABLE = "unavailable";
Cc.EVENT_ADD = "add";
Cc.EVENT_REMOVE = "remove";
class Ec extends fe {
    constructor(e, t, s=null) {
        super(),
        this._position = new y,
        this._rotation = new ne,
        this._uuid = null,
        this._uuidRequests = null,
        this._anchors = e,
        this._xrAnchor = t,
        this._uuid = s
    }
    destroy() {
        if (!this._xrAnchor)
            return;
        const e = this._xrAnchor;
        this._xrAnchor.delete(),
        this._xrAnchor = null,
        this.fire("destroy", e, this)
    }
    update(e) {
        if (!this._xrAnchor)
            return;
        const t = e.getPose(this._xrAnchor.anchorSpace, this._anchors.manager._referenceSpace);
        if (t) {
            if (this._position.equals(t.transform.position) && this._rotation.equals(t.transform.orientation))
                return;
            this._position.copy(t.transform.position),
            this._rotation.copy(t.transform.orientation),
            this.fire("change")
        }
    }
    getPosition() {
        return this._position
    }
    getRotation() {
        return this._rotation
    }
    persist(e) {
        if (!this._anchors.persistence) {
            e == null || e(new Error("Persistent Anchors are not supported"), null);
            return
        }
        if (this._uuid) {
            e == null || e(null, this._uuid);
            return
        }
        if (this._uuidRequests) {
            e && this._uuidRequests.push(e);
            return
        }
        this._uuidRequests = [],
        this._xrAnchor.requestPersistentHandle().then(t => {
            this._uuid = t,
            this._anchors._indexByUuid.set(this._uuid, this),
            e == null || e(null, t);
            for (let s = 0; s < this._uuidRequests.length; s++)
                this._uuidRequests[s](null, t);
            this._uuidRequests = null,
            this.fire("persist", t)
        }
        ).catch(t => {
            e == null || e(t, null);
            for (let s = 0; s < this._uuidRequests.length; s++)
                this._uuidRequests[s](t);
            this._uuidRequests = null
        }
        )
    }
    forget(e) {
        if (!this._uuid) {
            e == null || e(new Error("Anchor is not persistent"));
            return
        }
        this._anchors.forget(this._uuid, t => {
            this._uuid = null,
            e == null || e(t),
            this.fire("forget")
        }
        )
    }
    get uuid() {
        return this._uuid
    }
    get persistent() {
        return !!this._uuid
    }
}
Ec.EVENT_DESTROY = "destroy";
Ec.EVENT_CHANGE = "change";
Ec.EVENT_PERSIST = "persist";
Ec.EVENT_FORGET = "forget";
class ll extends fe {
    constructor(e) {
        var t;
        super(),
        this.manager = void 0,
        this._supported = Le.browser && !!window.XRAnchor,
        this._available = !1,
        this._persistence = Le.browser && !!((t = window) != null && (t = t.XRSession) != null && t.prototype.restorePersistentAnchor),
        this._creationQueue = [],
        this._index = new Map,
        this._indexByUuid = new Map,
        this._list = [],
        this._callbacksAnchors = new Map,
        this.manager = e,
        this._supported && (this.manager.on("start", this._onSessionStart, this),
        this.manager.on("end", this._onSessionEnd, this))
    }
    _onSessionStart() {
        const e = this.manager.session.enabledFeatures.indexOf("anchors") !== -1;
        e && (this._available = e,
        this.fire("available"))
    }
    _onSessionEnd() {
        if (!this._available)
            return;
        this._available = !1;
        for (let t = 0; t < this._creationQueue.length; t++)
            this._creationQueue[t].callback && this._creationQueue[t].callback(new Error("session ended"), null);
        this._creationQueue.length = 0,
        this._index.clear(),
        this._indexByUuid.clear();
        let e = this._list.length;
        for (; e--; )
            this._list[e].destroy();
        this._list.length = 0,
        this.fire("unavailable")
    }
    _createAnchor(e, t=null) {
        const s = new Ec(this,e,t);
        return this._index.set(e, s),
        t && this._indexByUuid.set(t, s),
        this._list.push(s),
        s.once("destroy", this._onAnchorDestroy, this),
        s
    }
    _onAnchorDestroy(e, t) {
        this._index.delete(e),
        t.uuid && this._indexByUuid.delete(t.uuid);
        const s = this._list.indexOf(t);
        s !== -1 && this._list.splice(s, 1),
        this.fire("destroy", t)
    }
    create(e, t, s) {
        if (!this._available) {
            s == null || s(new Error("Anchors API is not available"), null);
            return
        }
        if (window.XRHitTestResult && e instanceof XRHitTestResult) {
            const i = e;
            if (s = t,
            !this._supported) {
                s == null || s(new Error("Anchors API is not supported"), null);
                return
            }
            if (!i.createAnchor) {
                s == null || s(new Error("Creating Anchor from Hit Test is not supported"), null);
                return
            }
            i.createAnchor().then(n => {
                const r = this._createAnchor(n);
                s == null || s(null, r),
                this.fire("add", r)
            }
            ).catch(n => {
                s == null || s(n, null),
                this.fire("error", n)
            }
            )
        } else
            this._creationQueue.push({
                transform: new XRRigidTransform(e,t),
                callback: s
            })
    }
    restore(e, t) {
        if (!this._available) {
            t == null || t(new Error("Anchors API is not available"), null);
            return
        }
        if (!this._persistence) {
            t == null || t(new Error("Anchor Persistence is not supported"), null);
            return
        }
        if (!this.manager.active) {
            t == null || t(new Error("WebXR session is not active"), null);
            return
        }
        this.manager.session.restorePersistentAnchor(e).then(s => {
            const i = this._createAnchor(s, e);
            t == null || t(null, i),
            this.fire("add", i)
        }
        ).catch(s => {
            t == null || t(s, null),
            this.fire("error", s)
        }
        )
    }
    forget(e, t) {
        if (!this._available) {
            t == null || t(new Error("Anchors API is not available"));
            return
        }
        if (!this._persistence) {
            t == null || t(new Error("Anchor Persistence is not supported"));
            return
        }
        if (!this.manager.active) {
            t == null || t(new Error("WebXR session is not active"));
            return
        }
        this.manager.session.deletePersistentAnchor(e).then( () => {
            t == null || t(null)
        }
        ).catch(s => {
            t == null || t(s),
            this.fire("error", s)
        }
        )
    }
    update(e) {
        if (this._available) {
            if (this._creationQueue.length) {
                for (let t = 0; t < this._creationQueue.length; t++) {
                    const s = this._creationQueue[t];
                    e.createAnchor(s.transform, this.manager._referenceSpace).then(i => {
                        s.callback && this._callbacksAnchors.set(i, s.callback)
                    }
                    ).catch(i => {
                        s.callback && s.callback(i, null),
                        this.fire("error", i)
                    }
                    )
                }
                this._creationQueue.length = 0
            }
            for (const [t,s] of this._index)
                e.trackedAnchors.has(t) || (this._index.delete(t),
                s.destroy());
            for (let t = 0; t < this._list.length; t++)
                this._list[t].update(e);
            for (const t of e.trackedAnchors) {
                if (this._index.has(t))
                    continue;
                try {
                    const n = t.anchorSpace
                } catch {
                    continue
                }
                const s = this._createAnchor(t);
                s.update(e);
                const i = this._callbacksAnchors.get(t);
                i && (this._callbacksAnchors.delete(t),
                i(null, s)),
                this.fire("add", s)
            }
        }
    }
    get supported() {
        return this._supported
    }
    get available() {
        return this._available
    }
    get persistence() {
        return this._persistence
    }
    get uuids() {
        return !this._available || !this._persistence || !this.manager.active ? null : this.manager.session.persistentAnchors
    }
    get list() {
        return this._list
    }
}
ll.EVENT_AVAILABLE = "available";
ll.EVENT_UNAVAILABLE = "unavailable";
ll.EVENT_ERROR = "error";
ll.EVENT_ADD = "add";
ll.EVENT_DESTROY = "destroy";
class Mg extends fe {
    constructor(e, t) {
        super(),
        this._meshDetection = void 0,
        this._xrMesh = void 0,
        this._lastChanged = 0,
        this._position = new y,
        this._rotation = new ne,
        this._meshDetection = e,
        this._xrMesh = t,
        this._lastChanged = this._xrMesh.lastChangedTime
    }
    get xrMesh() {
        return this._xrMesh
    }
    get label() {
        return this._xrMesh.semanticLabel || ""
    }
    get vertices() {
        return this._xrMesh.vertices
    }
    get indices() {
        return this._xrMesh.indices
    }
    destroy() {
        this._xrMesh && (this._xrMesh = null,
        this.fire("remove"))
    }
    update(e) {
        const t = this._meshDetection._manager
          , s = e.getPose(this._xrMesh.meshSpace, t._referenceSpace);
        s && (this._position.copy(s.transform.position),
        this._rotation.copy(s.transform.orientation)),
        this._lastChanged !== this._xrMesh.lastChangedTime && (this._lastChanged = this._xrMesh.lastChangedTime,
        this.fire("change"))
    }
    getPosition() {
        return this._position
    }
    getRotation() {
        return this._rotation
    }
}
Mg.EVENT_REMOVE = "remove";
Mg.EVENT_CHANGE = "change";
class Ac extends fe {
    constructor(e) {
        super(),
        this._manager = void 0,
        this._supported = Le.browser && !!window.XRMesh,
        this._available = !1,
        this._index = new Map,
        this._list = [],
        this._manager = e,
        this._supported && (this._manager.on("start", this._onSessionStart, this),
        this._manager.on("end", this._onSessionEnd, this))
    }
    update(e) {
        if (!(!this._supported || !this._available)) {
            for (const t of e.detectedMeshes) {
                let s = this._index.get(t);
                s ? s.update(e) : (s = new Mg(this,t),
                this._index.set(t, s),
                this._list.push(s),
                s.update(e),
                this.fire("add", s))
            }
            for (const t of this._index.values())
                e.detectedMeshes.has(t.xrMesh) || this._removeMesh(t)
        }
    }
    _removeMesh(e) {
        this._index.delete(e.xrMesh),
        this._list.splice(this._list.indexOf(e), 1),
        e.destroy(),
        this.fire("remove", e)
    }
    _onSessionStart() {
        const e = this._manager.session.enabledFeatures.indexOf("mesh-detection") !== -1;
        e && (this._available = e,
        this.fire("available"))
    }
    _onSessionEnd() {
        if (this._available) {
            this._available = !1;
            for (const e of this._index.values())
                this._removeMesh(e);
            this.fire("unavailable")
        }
    }
    get supported() {
        return this._supported
    }
    get available() {
        return this._available
    }
    get meshes() {
        return this._list
    }
}
Ac.EVENT_AVAILABLE = "available";
Ac.EVENT_UNAVAILABLE = "unavailable";
Ac.EVENT_ADD = "add";
Ac.EVENT_REMOVE = "remove";
class Iw extends fe {
    constructor(e, t, s) {
        super(),
        this._manager = void 0,
        this._xrView = void 0,
        this._positionData = new Float32Array(3),
        this._viewport = new M,
        this._projMat = new ee,
        this._projViewOffMat = new ee,
        this._viewMat = new ee,
        this._viewOffMat = new ee,
        this._viewMat3 = new Ci,
        this._viewInvMat = new ee,
        this._viewInvOffMat = new ee,
        this._xrCamera = null,
        this._textureColor = null,
        this._textureDepth = null,
        this._depthInfo = null,
        this._emptyDepthBuffer = new Uint8Array(32),
        this._depthMatrix = new ee,
        this._manager = e,
        this._xrView = t;
        const i = this._manager.app.graphicsDevice;
        if (this._manager.views.supportedColor && (this._xrCamera = this._xrView.camera,
        this._manager.views.availableColor && this._xrCamera && (this._textureColor = new ge(i,{
            format: Ln,
            mipmaps: !1,
            addressU: oe,
            addressV: oe,
            minFilter: ot,
            magFilter: ot,
            width: this._xrCamera.width,
            height: this._xrCamera.height,
            name: `XrView-${this._xrView.eye}-Color`
        }))),
        this._manager.views.supportedDepth && this._manager.views.availableDepth) {
            this._textureDepth = new ge(i,{
                format: this._manager.views.depthPixelFormat,
                arrayLength: s === 1 ? 0 : s,
                mipmaps: !1,
                addressU: oe,
                addressV: oe,
                minFilter: ot,
                magFilter: ot,
                width: 4,
                height: 4,
                name: `XrView-${this._xrView.eye}-Depth`
            });
            for (let n = 0; n < this._textureDepth._levels.length; n++)
                this._textureDepth._levels[n] = this._emptyDepthBuffer
        }
        (this._textureColor || this._textureDepth) && i.on("devicelost", this._onDeviceLost, this)
    }
    get textureColor() {
        return this._textureColor
    }
    get textureDepth() {
        return this._textureDepth
    }
    get depthUvMatrix() {
        return this._depthMatrix
    }
    get depthValueToMeters() {
        var e;
        return ((e = this._depthInfo) == null ? void 0 : e.rawValueToMeters) || 0
    }
    get eye() {
        return this._xrView.eye
    }
    get viewport() {
        return this._viewport
    }
    get projMat() {
        return this._projMat
    }
    get projViewOffMat() {
        return this._projViewOffMat
    }
    get viewOffMat() {
        return this._viewOffMat
    }
    get viewInvOffMat() {
        return this._viewInvOffMat
    }
    get viewMat3() {
        return this._viewMat3
    }
    get positionData() {
        return this._positionData
    }
    update(e, t) {
        this._xrView = t,
        this._manager.views.availableColor && (this._xrCamera = this._xrView.camera);
        const i = e.session.renderState.baseLayer.getViewport(this._xrView);
        this._viewport.x = i.x,
        this._viewport.y = i.y,
        this._viewport.z = i.width,
        this._viewport.w = i.height,
        this._projMat.set(this._xrView.projectionMatrix),
        this._viewMat.set(this._xrView.transform.inverse.matrix),
        this._viewInvMat.set(this._xrView.transform.matrix),
        this._updateTextureColor(),
        this._updateDepth(e)
    }
    _updateTextureColor() {
        if (!this._manager.views.availableColor || !this._xrCamera || !this._textureColor)
            return;
        const e = this._manager.webglBinding;
        if (!e)
            return;
        const t = e.getCameraImage(this._xrCamera);
        if (!t)
            return;
        const s = this._manager.app.graphicsDevice
          , i = s.gl;
        if (!this._frameBufferSource)
            this._frameBufferSource = i.createFramebuffer(),
            this._frameBuffer = i.createFramebuffer();
        else {
            var n, r;
            const o = s.isWebGL2 ? i.COLOR_ATTACHMENT0 : (n = (r = s.extDrawBuffers) == null ? void 0 : r.COLOR_ATTACHMENT0_WEBGL) != null ? n : i.COLOR_ATTACHMENT0
              , l = this._xrCamera.width
              , c = this._xrCamera.height;
            s.setFramebuffer(this._frameBufferSource),
            i.framebufferTexture2D(i.FRAMEBUFFER, o, i.TEXTURE_2D, t, 0),
            s.setFramebuffer(this._frameBuffer),
            i.framebufferTexture2D(i.FRAMEBUFFER, o, i.TEXTURE_2D, this._textureColor.impl._glTexture, 0),
            i.bindFramebuffer(i.READ_FRAMEBUFFER, this._frameBufferSource),
            i.bindFramebuffer(i.DRAW_FRAMEBUFFER, this._frameBuffer),
            i.blitFramebuffer(0, c, l, 0, 0, 0, l, c, i.COLOR_BUFFER_BIT, i.NEAREST)
        }
    }
    _updateDepth(e) {
        var t, s;
        if (!this._manager.views.availableDepth || !this._textureDepth)
            return;
        const i = this._manager.views.depthGpuOptimized
          , n = i ? this._manager.webglBinding : e;
        if (!n) {
            this._depthInfo = null;
            return
        }
        const r = n.getDepthInformation(this._xrView);
        if (!r) {
            this._depthInfo = null;
            return
        }
        let o = !this._depthInfo != !r;
        this._depthInfo = r;
        const l = ((t = this._depthInfo) == null ? void 0 : t.width) || 4
          , c = ((s = this._depthInfo) == null ? void 0 : s.height) || 4;
        let d = !1;
        (this._textureDepth.width !== l || this._textureDepth.height !== c) && (this._textureDepth._width = l,
        this._textureDepth._height = c,
        o = !0,
        d = !0),
        o && (this._depthInfo ? this._depthMatrix.data.set(this._depthInfo.normDepthBufferFromNormView.matrix) : this._depthMatrix.setIdentity()),
        this._depthInfo ? i ? this._depthInfo.texture && (this._textureDepth.impl._glTexture = this._depthInfo.texture) : (this._textureDepth._levels[0] = new Uint8Array(this._depthInfo.data),
        this._textureDepth.upload()) : (this._textureDepth._levels[0] = this._emptyDepthBuffer,
        this._textureDepth.upload()),
        d && this.fire("depth:resize", l, c)
    }
    updateTransforms(e) {
        e ? (this._viewInvOffMat.mul2(e, this._viewInvMat),
        this.viewOffMat.copy(this._viewInvOffMat).invert()) : (this._viewInvOffMat.copy(this._viewInvMat),
        this.viewOffMat.copy(this._viewMat)),
        this._viewMat3.setFromMat4(this._viewOffMat),
        this._projViewOffMat.mul2(this._projMat, this._viewOffMat),
        this._positionData[0] = this._viewInvOffMat.data[12],
        this._positionData[1] = this._viewInvOffMat.data[13],
        this._positionData[2] = this._viewInvOffMat.data[14]
    }
    _onDeviceLost() {
        this._frameBufferSource = null,
        this._frameBuffer = null,
        this._depthInfo = null
    }
    getDepth(e, t) {
        var s, i;
        return this._manager.views.depthGpuOptimized ? null : (s = (i = this._depthInfo) == null ? void 0 : i.getDepthInMeters(e, t)) != null ? s : null
    }
    destroy() {
        if (this._depthInfo = null,
        this._textureColor && (this._textureColor.destroy(),
        this._textureColor = null),
        this._textureDepth && (this._textureDepth.destroy(),
        this._textureDepth = null),
        this._frameBufferSource) {
            const e = this._manager.app.graphicsDevice.gl;
            e.deleteFramebuffer(this._frameBufferSource),
            this._frameBufferSource = null,
            e.deleteFramebuffer(this._frameBuffer),
            this._frameBuffer = null
        }
    }
}
Iw.EVENT_DEPTHRESIZE = "depth:resize";
class Tu extends fe {
    constructor(e) {
        super(),
        this._manager = void 0,
        this._index = new Map,
        this._indexTmp = new Map,
        this._list = [],
        this._supportedColor = Le.browser && !!window.XRCamera && !!window.XRWebGLBinding,
        this._supportedDepth = Le.browser && !!window.XRDepthInformation,
        this._availableColor = !1,
        this._availableDepth = !1,
        this._depthUsage = "",
        this._depthFormat = "",
        this._depthFormats = {
            [Mw]: ku,
            [Xk]: ca
        },
        this._manager = e,
        this._manager.on("start", this._onSessionStart, this),
        this._manager.on("end", this._onSessionEnd, this)
    }
    get list() {
        return this._list
    }
    get supportedColor() {
        return this._supportedColor
    }
    get supportedDepth() {
        return this._supportedDepth
    }
    get availableColor() {
        return this._availableColor
    }
    get availableDepth() {
        return this._availableDepth
    }
    get depthGpuOptimized() {
        return this._depthUsage === Wk
    }
    get depthFormat() {
        return this._depthFormat
    }
    get depthPixelFormat() {
        var e;
        return (e = this._depthFormats[this._depthFormat]) != null ? e : null
    }
    get depthUsage() {
        return this._depthUsage
    }
    update(e, t) {
        for (let s = 0; s < t.length; s++)
            this._indexTmp.set(t[s].eye, t[s]);
        for (const [s,i] of this._indexTmp) {
            let n = this._index.get(s);
            n ? n.update(e, i) : (n = new Iw(this._manager,i,t.length),
            this._index.set(s, n),
            this._list.push(n),
            n.update(e, i),
            this.fire("add", n))
        }
        for (const [s,i] of this._index) {
            if (this._indexTmp.has(s))
                continue;
            i.destroy(),
            this._index.delete(s);
            const n = this._list.indexOf(i);
            n !== -1 && this._list.splice(n, 1),
            this.fire("remove", i)
        }
        this._indexTmp.clear()
    }
    get(e) {
        return this._index.get(e) || null
    }
    _onSessionStart() {
        if (this._manager.type === oa && (this._availableColor = this._manager.session.enabledFeatures.indexOf("camera-access") !== -1,
        this._availableDepth = this._manager.session.enabledFeatures.indexOf("depth-sensing") !== -1,
        this._availableDepth)) {
            const e = this._manager.session;
            this._depthUsage = e.depthUsage,
            this._depthFormat = e.depthDataFormat
        }
    }
    _onSessionEnd() {
        for (const e of this._index.values())
            e.destroy();
        this._index.clear(),
        this._availableColor = !1,
        this._availableDepth = !1,
        this._depthUsage = "",
        this._depthFormat = "",
        this._list.length = 0
    }
}
Tu.EVENT_ADD = "add";
Tu.EVENT_REMOVE = "remove";
class hl extends fe {
    constructor(e) {
        super(),
        this.app = void 0,
        this._supported = Le.browser && !!navigator.xr,
        this._available = {},
        this._type = null,
        this._spaceType = null,
        this._session = null,
        this._baseLayer = null,
        this.webglBinding = null,
        this._referenceSpace = null,
        this.depthSensing = void 0,
        this.domOverlay = void 0,
        this.hitTest = void 0,
        this.imageTracking = void 0,
        this.planeDetection = void 0,
        this.meshDetection = void 0,
        this.input = void 0,
        this.lightEstimation = void 0,
        this.views = void 0,
        this.anchors = void 0,
        this._camera = null,
        this._localPosition = new y,
        this._localRotation = new ne,
        this._depthNear = .1,
        this._depthFar = 1e3,
        this._width = 0,
        this._height = 0,
        this.app = e,
        this._available[zk] = !1,
        this._available[Vv] = !1,
        this._available[oa] = !1,
        this.views = new Tu(this),
        this.depthSensing = new If(this),
        this.domOverlay = new jk(this),
        this.hitTest = new Tc(this),
        this.imageTracking = new Pw(this),
        this.planeDetection = new Cc(this),
        this.meshDetection = new Ac(this),
        this.input = new zn(this),
        this.lightEstimation = new Eg(this),
        this.anchors = new ll(this),
        this.views = new Tu(this),
        this._supported && (navigator.xr.addEventListener("devicechange", () => {
            this._deviceAvailabilityCheck()
        }
        ),
        this._deviceAvailabilityCheck(),
        this.app.graphicsDevice.on("devicelost", this._onDeviceLost, this),
        this.app.graphicsDevice.on("devicerestored", this._onDeviceRestored, this))
    }
    destroy() {}
    start(e, t, s, i) {
        var n, r;
        let o = i;
        if (typeof i == "object" && (o = i.callback),
        !this._available[t]) {
            o && o(new Error("XR is not available"));
            return
        }
        if (this._session) {
            o && o(new Error("XR session is already started"));
            return
        }
        this._camera = e,
        this._camera.camera.xr = this,
        this._type = t,
        this._spaceType = s,
        this._setClipPlanes(e.nearClip, e.farClip);
        const l = {
            requiredFeatures: [s],
            optionalFeatures: []
        }
          , c = ((n = this.app.graphicsDevice) == null ? void 0 : n.isWebGL1) || ((r = this.app.graphicsDevice) == null ? void 0 : r.isWebGL2);
        if (t === oa) {
            if (l.optionalFeatures.push("light-estimation"),
            l.optionalFeatures.push("hit-test"),
            i && (i.imageTracking && this.imageTracking.supported && l.optionalFeatures.push("image-tracking"),
            i.planeDetection && l.optionalFeatures.push("plane-detection"),
            i.meshDetection && l.optionalFeatures.push("mesh-detection")),
            this.domOverlay.supported && this.domOverlay.root && (l.optionalFeatures.push("dom-overlay"),
            l.domOverlay = {
                root: this.domOverlay.root
            }),
            i && i.anchors && this.anchors.supported && l.optionalFeatures.push("anchors"),
            i && i.depthSensing && this.depthSensing.supported) {
                l.optionalFeatures.push("depth-sensing");
                const d = [Hk]
                  , h = [Mw];
                if (i.depthSensing.usagePreference) {
                    const u = d.indexOf(i.depthSensing.usagePreference);
                    u !== -1 && d.splice(u, 1),
                    d.unshift(i.depthSensing.usagePreference)
                }
                if (i.depthSensing.dataFormatPreference) {
                    const u = h.indexOf(i.depthSensing.dataFormatPreference);
                    u !== -1 && h.splice(u, 1),
                    h.unshift(i.depthSensing.dataFormatPreference)
                }
                l.depthSensing = {
                    usagePreference: d,
                    dataFormatPreference: h
                }
            }
            c && i && i.cameraColor && this.views.supportedColor && l.optionalFeatures.push("camera-access")
        } else
            t === Vv && l.optionalFeatures.push("hand-tracking");
        i && i.optionalFeatures && (l.optionalFeatures = l.optionalFeatures.concat(i.optionalFeatures)),
        this.imageTracking.supported && this.imageTracking.images.length ? this.imageTracking.prepareImages( (d, h) => {
            if (d) {
                o && o(d),
                this.fire("error", d);
                return
            }
            h !== null && (l.trackedImages = h),
            this._onStartOptionsReady(t, s, l, o)
        }
        ) : this._onStartOptionsReady(t, s, l, o)
    }
    _onStartOptionsReady(e, t, s, i) {
        navigator.xr.requestSession(e, s).then(n => {
            this._onSessionStart(n, t, i)
        }
        ).catch(n => {
            this._camera.camera.xr = null,
            this._camera = null,
            this._type = null,
            this._spaceType = null,
            i && i(n),
            this.fire("error", n)
        }
        )
    }
    end(e) {
        if (!this._session) {
            e && e(new Error("XR Session is not initialized"));
            return
        }
        this.webglBinding = null,
        e && this.once("end", e),
        this._session.end()
    }
    isAvailable(e) {
        return this._available[e]
    }
    _deviceAvailabilityCheck() {
        for (const e in this._available)
            this._sessionSupportCheck(e)
    }
    initiateRoomCapture(e) {
        if (!this._session) {
            e(new Error("Session is not active"));
            return
        }
        if (!this._session.initiateRoomCapture) {
            e(new Error("Session does not support manual room capture"));
            return
        }
        this._session.initiateRoomCapture().then( () => {
            e && e(null)
        }
        ).catch(t => {
            e && e(t)
        }
        )
    }
    _sessionSupportCheck(e) {
        navigator.xr.isSessionSupported(e).then(t => {
            this._available[e] !== t && (this._available[e] = t,
            this.fire("available", e, t),
            this.fire("available:" + e, t))
        }
        ).catch(t => {
            this.fire("error", t)
        }
        )
    }
    _onSessionStart(e, t, s) {
        let i = !1;
        this._session = e;
        const n = () => {
            this.fire("visibility:change", e.visibilityState)
        }
          , r = () => {
            this._setClipPlanes(this._camera.nearClip, this._camera.farClip)
        }
          , o = () => {
            this._camera && (this._camera.off("set_nearClip", r),
            this._camera.off("set_farClip", r),
            this._camera.camera.xr = null,
            this._camera = null),
            e.removeEventListener("end", o),
            e.removeEventListener("visibilitychange", n),
            i || this.fire("end"),
            this._session = null,
            this._referenceSpace = null,
            this._width = 0,
            this._height = 0,
            this._type = null,
            this._spaceType = null,
            this.app.systems && this.app.tick()
        }
        ;
        e.addEventListener("end", o),
        e.addEventListener("visibilitychange", n),
        this._camera.on("set_nearClip", r),
        this._camera.on("set_farClip", r),
        this._createBaseLayer(),
        e.requestReferenceSpace(t).then(l => {
            this._referenceSpace = l,
            this.app.tick(),
            s && s(null),
            this.fire("start")
        }
        ).catch(l => {
            i = !0,
            e.end(),
            s && s(l),
            this.fire("error", l)
        }
        )
    }
    _setClipPlanes(e, t) {
        this._depthNear === e && this._depthFar === t || (this._depthNear = e,
        this._depthFar = t,
        this._session && this._session.updateRenderState({
            depthNear: this._depthNear,
            depthFar: this._depthFar
        }))
    }
    _createBaseLayer() {
        const e = this.app.graphicsDevice
          , t = e.maxPixelRatio / window.devicePixelRatio;
        this._baseLayer = new XRWebGLLayer(this._session,e.gl,{
            alpha: !0,
            depth: !0,
            stencil: !0,
            framebufferScaleFactor: t,
            antialias: !1
        });
        const s = e.deviceType;
        if ((s === eh || s === po) && window.XRWebGLBinding)
            try {
                this.webglBinding = new XRWebGLBinding(this._session,e.gl)
            } catch (i) {
                this.fire("error", i)
            }
        this._session.updateRenderState({
            baseLayer: this._baseLayer,
            depthNear: this._depthNear,
            depthFar: this._depthFar
        })
    }
    _onDeviceLost() {
        this._session && (this.webglBinding && (this.webglBinding = null),
        this._baseLayer = null,
        this._session.updateRenderState({
            baseLayer: this._baseLayer,
            depthNear: this._depthNear,
            depthFar: this._depthFar
        }))
    }
    _onDeviceRestored() {
        this._session && setTimeout( () => {
            this.app.graphicsDevice.gl.makeXRCompatible().then( () => {
                this._createBaseLayer()
            }
            ).catch(e => {
                this.fire("error", e)
            }
            )
        }
        , 0)
    }
    update(e) {
        if (!this._session)
            return !1;
        const t = e.session.renderState.baseLayer.framebufferWidth
          , s = e.session.renderState.baseLayer.framebufferHeight;
        (this._width !== t || this._height !== s) && (this._width = t,
        this._height = s,
        this.app.graphicsDevice.setResolution(t, s));
        const i = e.getViewerPose(this._referenceSpace);
        if (!i)
            return !1;
        const n = this.views.list.length;
        this.views.update(e, i.views);
        const r = i.transform.position
          , o = i.transform.orientation;
        if (this._localPosition.set(r.x, r.y, r.z),
        this._localRotation.set(o.x, o.y, o.z, o.w),
        n === 0 && this.views.list.length > 0) {
            const l = new ee
              , c = this.views.list[0];
            l.copy(c.projMat);
            const d = l.data
              , h = 2 * Math.atan(1 / d[5]) * 180 / Math.PI
              , u = d[5] / d[0]
              , f = d[14] / (d[10] + 1)
              , p = d[14] / (d[10] - 1);
            this._camera.camera.setXrProperties({
                aspectRatio: u,
                farClip: f,
                fov: h,
                horizontalFov: !1,
                nearClip: p
            })
        }
        return this._camera.camera._node.setLocalPosition(this._localPosition),
        this._camera.camera._node.setLocalRotation(this._localRotation),
        this.input.update(e),
        this._type === oa && (this.hitTest.supported && this.hitTest.update(e),
        this.lightEstimation.supported && this.lightEstimation.update(e),
        this.imageTracking.supported && this.imageTracking.update(e),
        this.anchors.supported && this.anchors.update(e),
        this.planeDetection.supported && this.planeDetection.update(e),
        this.depthSensing.supported && this.depthSensing.update(),
        this.meshDetection.supported && this.meshDetection.update(e)),
        this.fire("update", e),
        !0
    }
    get supported() {
        return this._supported
    }
    get active() {
        return !!this._session
    }
    get type() {
        return this._type
    }
    get spaceType() {
        return this._spaceType
    }
    get session() {
        return this._session
    }
    get camera() {
        return this._camera ? this._camera.entity : null
    }
    get visibilityState() {
        return this._session ? this._session.visibilityState : null
    }
}
hl.EVENT_AVAILABLE = "available";
hl.EVENT_START = "start";
hl.EVENT_END = "end";
hl.EVENT_UPDATE = "update";
hl.EVENT_ERROR = "error";
class Kk extends ar {
    constructor(e, t={}) {
        super(e);
        const s = new MD;
        s.graphicsDevice = this.createDevice(e, t),
        this.addComponentSystems(s),
        this.addResourceHandles(s),
        s.elementInput = t.elementInput,
        s.keyboard = t.keyboard,
        s.mouse = t.mouse,
        s.touch = t.touch,
        s.gamepads = t.gamepads,
        s.scriptPrefix = t.scriptPrefix,
        s.assetPrefix = t.assetPrefix,
        s.scriptsOrder = t.scriptsOrder,
        s.soundManager = new qE,
        s.lightmapper = FD,
        s.batchManager = IR,
        s.xr = hl,
        this.init(s)
    }
    createDevice(e, t) {
        return t.graphicsDeviceOptions || (t.graphicsDeviceOptions = {}),
        Le.browser && navigator.xr && (t.graphicsDeviceOptions.xrCompatible = !0),
        t.graphicsDeviceOptions.alpha = t.graphicsDeviceOptions.alpha || !1,
        new YS(e,t.graphicsDeviceOptions)
    }
    addComponentSystems(e) {
        e.componentSystems = [Be, P2, nO, e2, a2, _O, TO, aF, hF, Xt.legacy ? BO : xF, c2, YO, l2, xO, LO, eO, p2, WO, jO, eF, pO, aO, sF, bF]
    }
    addResourceHandles(e) {
        e.resourceHandlers = [TF, EB, AB, MB, ok, ZB, Uk, mk, $B, RB, ck, lk, FB, jB, OB, dk, XB, BB, kB, IB, gk, uk, pk, DB, WB]
    }
}
class Zk extends fe {
    constructor(e, t) {
        super(),
        this._assets = new Set,
        this._loadingAssets = new Set,
        this._waitingAssets = new Set,
        this._registry = t,
        this._loading = !1,
        this._loaded = !1,
        this._failed = [],
        e.forEach(s => {
            if (s instanceof le)
                s.registry || (s.registry = t),
                this._assets.add(s);
            else {
                const i = t.get(s);
                i ? this._assets.add(i) : this._waitForAsset(s)
            }
        }
        )
    }
    destroy() {
        const e = this;
        this._registry.off("load", this._onLoad),
        this._registry.off("error", this._onError),
        this._waitingAssets.forEach(function(t) {
            e._registry.off("add:" + t, this._onAddAsset)
        }),
        this.off("progress"),
        this.off("load")
    }
    _assetHasDependencies(e) {
        var t;
        return e.type === "model" && ((t = e.file) == null ? void 0 : t.url) && e.file.url && e.file.url.match(/.json$/g)
    }
    load(e, t) {
        if (this._loading)
            return;
        this._loading = !0,
        this._callback = e,
        this._scope = t,
        this._registry.on("load", this._onLoad, this),
        this._registry.on("error", this._onError, this);
        let s = !1;
        this._assets.forEach(i => {
            i.loaded || (s = !0,
            this._assetHasDependencies(i) && this._registry.loadFromUrl(i.file.url, i.type, (n, r) => {
                if (n) {
                    this._onError(n, i);
                    return
                }
                this._onLoad(i)
            }
            ),
            this._loadingAssets.add(i),
            this._registry.add(i))
        }
        ),
        this._loadingAssets.forEach(i => {
            this._assetHasDependencies(i) || this._registry.load(i)
        }
        ),
        !s && this._waitingAssets.size === 0 && this._loadingComplete()
    }
    ready(e, t=this) {
        this._loaded ? e.call(t, Array.from(this._assets)) : this.once("load", function(s) {
            e.call(t, s)
        })
    }
    _loadingComplete() {
        this._loaded || (this._loaded = !0,
        this._registry.off("load", this._onLoad, this),
        this._registry.off("error", this._onError, this),
        this._failed.length ? (this._callback && this._callback.call(this._scope, "Failed to load some assets", this._failed),
        this.fire("error", this._failed)) : (this._callback && this._callback.call(this._scope),
        this.fire("load", Array.from(this._assets))))
    }
    _onLoad(e) {
        this._loadingAssets.has(e) && (this.fire("progress", e),
        this._loadingAssets.delete(e)),
        this._loadingAssets.size === 0 && setTimeout( () => {
            this._loadingComplete(this._failed)
        }
        , 0)
    }
    _onError(e, t) {
        this._loadingAssets.has(t) && (this._failed.push(t),
        this._loadingAssets.delete(t)),
        this._loadingAssets.size === 0 && setTimeout( () => {
            this._loadingComplete(this._failed)
        }
        , 0)
    }
    _onAddAsset(e) {
        this._waitingAssets.delete(e),
        this._assets.add(e),
        e.loaded || (this._loadingAssets.add(e),
        this._registry.load(e))
    }
    _waitForAsset(e) {
        this._waitingAssets.add(e),
        this._registry.once("add:" + e, this._onAddAsset, this)
    }
}
let Kn, Zn;
const Wp = new y
  , Kv = new y
  , cn = new cr
  , Xl = new cr
  , l_ = new cr;
cn.end = new y;
Xl.end = new y;
l_.end = new y;
const ro = new y
  , xd = new y
  , Xp = new y
  , Zv = new y
  , jp = new y
  , wd = new y
  , bd = new y
  , Td = new y
  , Cd = new y
  , $p = new y
  , Qk = new y
  , ao = new y
  , Ol = new y
  , Ed = new y
  , Ad = new y
  , Fl = new y
  , Qv = new y
  , Jv = new y
  , eS = new y
  , tS = new y
  , Jk = new M;
function sS(a, e, t) {
    return Qk.cross(a, e).dot(t)
}
function eN(a, e, t) {
    ro.sub2(e, a),
    xd.sub2(t[0], a),
    Xp.sub2(t[1], a),
    Zv.sub2(t[2], a),
    wd.cross(Zv, ro);
    let s = xd.dot(wd), i, n;
    if (s >= 0) {
        if (i = -Xp.dot(wd),
        i < 0 || (n = sS(ro, Xp, xd),
        n < 0))
            return -1;
        const r = 1 / (i + s + n);
        bd.copy(t[0]).mulScalar(i * r),
        Td.copy(t[1]).mulScalar(s * r),
        Cd.copy(t[2]).mulScalar(n * r),
        $p.copy(bd).add(Td).add(Cd)
    } else {
        if (jp.sub2(t[3], a),
        i = jp.dot(wd),
        i < 0 || (n = sS(ro, xd, jp),
        n < 0))
            return -1;
        s = -s;
        const r = 1 / (i + s + n);
        bd.copy(t[0]).mulScalar(i * r),
        Td.copy(t[3]).mulScalar(s * r),
        Cd.copy(t[2]).mulScalar(n * r),
        $p.copy(bd).add(Td).add(Cd)
    }
    return ro.sub2(t[0], t[2]).lengthSq() < 1e-4 * 1e-4 || ro.sub2(t[1], t[3]).lengthSq() < 1e-4 * 1e-4 ? -1 : $p.sub(a).lengthSq()
}
class Pg {
    constructor(e, t, s) {
        this.event = e,
        this.element = t,
        this.camera = s,
        this._stopPropagation = !1
    }
    stopPropagation() {
        this._stopPropagation = !0,
        this.event && (this.event.stopImmediatePropagation(),
        this.event.stopPropagation())
    }
}
class Bl extends Pg {
    constructor(e, t, s, i, n, r, o) {
        super(e, t, s),
        this.x = i,
        this.y = n,
        this.ctrlKey = e.ctrlKey || !1,
        this.altKey = e.altKey || !1,
        this.shiftKey = e.shiftKey || !1,
        this.metaKey = e.metaKey || !1,
        this.button = e.button,
        gr.isPointerLocked() ? (this.dx = e.movementX || e.webkitMovementX || e.mozMovementX || 0,
        this.dy = e.movementY || e.webkitMovementY || e.mozMovementY || 0) : (this.dx = i - r,
        this.dy = n - o),
        this.wheelDelta = 0,
        e.type === "wheel" && (e.deltaY > 0 ? this.wheelDelta = 1 : e.deltaY < 0 && (this.wheelDelta = -1))
    }
}
class kl extends Pg {
    constructor(e, t, s, i, n, r) {
        super(e, t, s),
        this.touches = e.touches,
        this.changedTouches = e.changedTouches,
        this.x = i,
        this.y = n,
        this.touch = r
    }
}
class Qn extends Pg {
    constructor(e, t, s, i) {
        super(e, t, s),
        this.inputSource = i
    }
}
class lh {
    constructor(e, t) {
        this._app = null,
        this._attached = !1,
        this._target = null,
        this._enabled = !0,
        this._lastX = 0,
        this._lastY = 0,
        this._upHandler = this._handleUp.bind(this),
        this._downHandler = this._handleDown.bind(this),
        this._moveHandler = this._handleMove.bind(this),
        this._wheelHandler = this._handleWheel.bind(this),
        this._touchstartHandler = this._handleTouchStart.bind(this),
        this._touchendHandler = this._handleTouchEnd.bind(this),
        this._touchcancelHandler = this._touchendHandler,
        this._touchmoveHandler = this._handleTouchMove.bind(this),
        this._sortHandler = this._sortElements.bind(this),
        this._elements = [],
        this._hoveredElement = null,
        this._pressedElement = null,
        this._touchedElements = {},
        this._touchesForWhichTouchLeaveHasFired = {},
        this._selectedElements = {},
        this._selectedPressedElements = {},
        this._useMouse = !t || t.useMouse !== !1,
        this._useTouch = !t || t.useTouch !== !1,
        this._useXr = !t || t.useXr !== !1,
        this._selectEventsAttached = !1,
        Le.touch && (this._clickedEntities = {}),
        this.attach(e)
    }
    set enabled(e) {
        this._enabled = e
    }
    get enabled() {
        return this._enabled
    }
    set app(e) {
        this._app = e
    }
    get app() {
        return this._app || Tn()
    }
    attach(e) {
        this._attached && (this._attached = !1,
        this.detach()),
        this._target = e,
        this._attached = !0;
        const t = Le.passiveEvents ? {
            passive: !0
        } : !1;
        this._useMouse && (window.addEventListener("mouseup", this._upHandler, t),
        window.addEventListener("mousedown", this._downHandler, t),
        window.addEventListener("mousemove", this._moveHandler, t),
        window.addEventListener("wheel", this._wheelHandler, t)),
        this._useTouch && Le.touch && (this._target.addEventListener("touchstart", this._touchstartHandler, t),
        this._target.addEventListener("touchend", this._touchendHandler, !1),
        this._target.addEventListener("touchmove", this._touchmoveHandler, !1),
        this._target.addEventListener("touchcancel", this._touchcancelHandler, !1)),
        this.attachSelectEvents()
    }
    attachSelectEvents() {
        !this._selectEventsAttached && this._useXr && this.app && this.app.xr && this.app.xr.supported && (this._clickedEntities || (this._clickedEntities = {}),
        this._selectEventsAttached = !0,
        this.app.xr.on("start", this._onXrStart, this))
    }
    detach() {
        if (!this._attached)
            return;
        this._attached = !1;
        const e = Le.passiveEvents ? {
            passive: !0
        } : !1;
        this._useMouse && (window.removeEventListener("mouseup", this._upHandler, e),
        window.removeEventListener("mousedown", this._downHandler, e),
        window.removeEventListener("mousemove", this._moveHandler, e),
        window.removeEventListener("wheel", this._wheelHandler, e)),
        this._useTouch && (this._target.removeEventListener("touchstart", this._touchstartHandler, e),
        this._target.removeEventListener("touchend", this._touchendHandler, !1),
        this._target.removeEventListener("touchmove", this._touchmoveHandler, !1),
        this._target.removeEventListener("touchcancel", this._touchcancelHandler, !1)),
        this._selectEventsAttached && (this._selectEventsAttached = !1,
        this.app.xr.off("start", this._onXrStart, this),
        this.app.xr.off("end", this._onXrEnd, this),
        this.app.xr.off("update", this._onXrUpdate, this),
        this.app.xr.input.off("selectstart", this._onSelectStart, this),
        this.app.xr.input.off("selectend", this._onSelectEnd, this),
        this.app.xr.input.off("remove", this._onXrInputRemove, this)),
        this._target = null
    }
    addElement(e) {
        this._elements.indexOf(e) === -1 && this._elements.push(e)
    }
    removeElement(e) {
        const t = this._elements.indexOf(e);
        t !== -1 && this._elements.splice(t, 1)
    }
    _handleUp(e) {
        this._enabled && (gr.isPointerLocked() || (this._calcMouseCoords(e),
        this._onElementMouseEvent("mouseup", e)))
    }
    _handleDown(e) {
        this._enabled && (gr.isPointerLocked() || (this._calcMouseCoords(e),
        this._onElementMouseEvent("mousedown", e)))
    }
    _handleMove(e) {
        this._enabled && (this._calcMouseCoords(e),
        this._onElementMouseEvent("mousemove", e),
        this._lastX = Kn,
        this._lastY = Zn)
    }
    _handleWheel(e) {
        this._enabled && (this._calcMouseCoords(e),
        this._onElementMouseEvent("mousewheel", e))
    }
    _determineTouchedElements(e) {
        const t = {}
          , s = this.app.systems.camera.cameras;
        for (let i = s.length - 1; i >= 0; i--) {
            const n = s[i];
            let r = 0;
            const o = e.changedTouches.length;
            for (let l = 0; l < o; l++) {
                if (t[e.changedTouches[l].identifier]) {
                    r++;
                    continue
                }
                const c = this._calcTouchCoords(e.changedTouches[l])
                  , d = this._getTargetElementByCoords(n, c.x, c.y);
                d && (r++,
                t[e.changedTouches[l].identifier] = {
                    element: d,
                    camera: n,
                    x: c.x,
                    y: c.y
                })
            }
            if (r === o)
                break
        }
        return t
    }
    _handleTouchStart(e) {
        if (!this._enabled)
            return;
        const t = this._determineTouchedElements(e);
        for (let s = 0, i = e.changedTouches.length; s < i; s++) {
            const n = e.changedTouches[s]
              , r = t[n.identifier]
              , o = this._touchedElements[n.identifier];
            r && (!o || r.element !== o.element) && (this._fireEvent(e.type, new kl(e,r.element,r.camera,r.x,r.y,n)),
            this._touchesForWhichTouchLeaveHasFired[n.identifier] = !1)
        }
        for (const s in t)
            this._touchedElements[s] = t[s]
    }
    _handleTouchEnd(e) {
        if (!this._enabled)
            return;
        const t = this.app.systems.camera.cameras;
        for (const s in this._clickedEntities)
            delete this._clickedEntities[s];
        for (let s = 0, i = e.changedTouches.length; s < i; s++) {
            const n = e.changedTouches[s]
              , r = this._touchedElements[n.identifier];
            if (!r)
                continue;
            const o = r.element
              , l = r.camera
              , c = r.x
              , d = r.y;
            delete this._touchedElements[n.identifier],
            delete this._touchesForWhichTouchLeaveHasFired[n.identifier];
            const h = this._calcTouchCoords(n);
            for (let u = t.length - 1; u >= 0; u--)
                this._getTargetElementByCoords(t[u], h.x, h.y) === o && (this._clickedEntities[o.entity.getGuid()] || (this._fireEvent("click", new kl(e,o,l,c,d,n)),
                this._clickedEntities[o.entity.getGuid()] = Date.now()));
            this._fireEvent(e.type, new kl(e,o,l,c,d,n))
        }
    }
    _handleTouchMove(e) {
        if (e.preventDefault(),
        !this._enabled)
            return;
        const t = this._determineTouchedElements(e);
        for (let s = 0, i = e.changedTouches.length; s < i; s++) {
            const n = e.changedTouches[s]
              , r = t[n.identifier]
              , o = this._touchedElements[n.identifier];
            if (o) {
                const l = this._calcTouchCoords(n);
                (!r || r.element !== o.element) && !this._touchesForWhichTouchLeaveHasFired[n.identifier] && (this._fireEvent("touchleave", new kl(e,o.element,o.camera,l.x,l.y,n)),
                this._touchesForWhichTouchLeaveHasFired[n.identifier] = !0),
                this._fireEvent("touchmove", new kl(e,o.element,o.camera,l.x,l.y,n))
            }
        }
    }
    _onElementMouseEvent(e, t) {
        let s = null;
        const i = this._hoveredElement;
        this._hoveredElement = null;
        const n = this.app.systems.camera.cameras;
        let r;
        for (let o = n.length - 1; o >= 0 && (r = n[o],
        s = this._getTargetElementByCoords(r, Kn, Zn),
        !s); o--)
            ;
        if (this._hoveredElement = s,
        (e === "mousemove" || e === "mouseup") && this._pressedElement ? this._fireEvent(e, new Bl(t,this._pressedElement,r,Kn,Zn,this._lastX,this._lastY)) : s && (this._fireEvent(e, new Bl(t,s,r,Kn,Zn,this._lastX,this._lastY)),
        e === "mousedown" && (this._pressedElement = s)),
        i !== this._hoveredElement && (i && this._fireEvent("mouseleave", new Bl(t,i,r,Kn,Zn,this._lastX,this._lastY)),
        this._hoveredElement && this._fireEvent("mouseenter", new Bl(t,this._hoveredElement,r,Kn,Zn,this._lastX,this._lastY))),
        e === "mouseup" && this._pressedElement) {
            if (this._pressedElement === this._hoveredElement) {
                const o = this._hoveredElement.entity.getGuid();
                let l = !this._clickedEntities;
                if (this._clickedEntities) {
                    const c = this._clickedEntities[o] || 0;
                    l = Date.now() - c > 300,
                    delete this._clickedEntities[o]
                }
                l && this._fireEvent("click", new Bl(t,this._hoveredElement,r,Kn,Zn,this._lastX,this._lastY))
            }
            this._pressedElement = null
        }
    }
    _onXrStart() {
        this.app.xr.on("end", this._onXrEnd, this),
        this.app.xr.on("update", this._onXrUpdate, this),
        this.app.xr.input.on("selectstart", this._onSelectStart, this),
        this.app.xr.input.on("selectend", this._onSelectEnd, this),
        this.app.xr.input.on("remove", this._onXrInputRemove, this)
    }
    _onXrEnd() {
        this.app.xr.off("update", this._onXrUpdate, this),
        this.app.xr.input.off("selectstart", this._onSelectStart, this),
        this.app.xr.input.off("selectend", this._onSelectEnd, this),
        this.app.xr.input.off("remove", this._onXrInputRemove, this)
    }
    _onXrUpdate() {
        if (!this._enabled)
            return;
        const e = this.app.xr.input.inputSources;
        for (let t = 0; t < e.length; t++)
            this._onElementSelectEvent("selectmove", e[t], null)
    }
    _onXrInputRemove(e) {
        const t = this._selectedElements[e.id];
        t && (e._elementEntity = null,
        this._fireEvent("selectleave", new Qn(null,t,null,e))),
        delete this._selectedElements[e.id],
        delete this._selectedPressedElements[e.id]
    }
    _onSelectStart(e, t) {
        this._enabled && this._onElementSelectEvent("selectstart", e, t)
    }
    _onSelectEnd(e, t) {
        this._enabled && this._onElementSelectEvent("selectend", e, t)
    }
    _onElementSelectEvent(e, t, s) {
        let i;
        const n = this._selectedElements[t.id];
        let r;
        const o = this.app.systems.camera.cameras;
        let l;
        if (t.elementInput) {
            l_.set(t.getOrigin(), t.getDirection());
            for (let d = o.length - 1; d >= 0 && (l = o[d],
            i = this._getTargetElementByRay(l_, l),
            !i); d--)
                ;
        }
        t._elementEntity = i || null,
        i ? (this._selectedElements[t.id] = i,
        r = i) : delete this._selectedElements[t.id],
        n !== r && (n && this._fireEvent("selectleave", new Qn(s,n,l,t)),
        r && this._fireEvent("selectenter", new Qn(s,r,l,t)));
        const c = this._selectedPressedElements[t.id];
        e === "selectmove" && c && this._fireEvent("selectmove", new Qn(s,c,l,t)),
        e === "selectstart" && (this._selectedPressedElements[t.id] = r,
        r && this._fireEvent("selectstart", new Qn(s,r,l,t))),
        !t.elementInput && c && (delete this._selectedPressedElements[t.id],
        n && this._fireEvent("selectend", new Qn(s,c,l,t))),
        e === "selectend" && t.elementInput && (delete this._selectedPressedElements[t.id],
        c && this._fireEvent("selectend", new Qn(s,c,l,t)),
        c && c === n && this._fireEvent("click", new Qn(s,c,l,t)))
    }
    _fireEvent(e, t) {
        let s = t.element;
        for (; s.fire(e, t),
        !(t._stopPropagation || !s.entity.parent || (s = s.entity.parent.element,
        !s)); )
            ;
    }
    _calcMouseCoords(e) {
        const t = this._target.getBoundingClientRect()
          , s = Math.floor(t.left)
          , i = Math.floor(t.top);
        Kn = e.clientX - s,
        Zn = e.clientY - i
    }
    _calcTouchCoords(e) {
        let t = 0
          , s = 0
          , i = e.target;
        for (; !(i instanceof HTMLElement); )
            i = i.parentNode;
        let n = i;
        do
            t += n.offsetLeft - n.scrollLeft,
            s += n.offsetTop - n.scrollTop,
            n = n.offsetParent;
        while (n);
        return {
            x: e.pageX - t,
            y: e.pageY - s
        }
    }
    _sortElements(e, t) {
        const s = this.app.scene.layers.sortTransparentLayers(e.layers, t.layers);
        return s !== 0 ? s : e.screen && !t.screen ? -1 : !e.screen && t.screen ? 1 : !e.screen && !t.screen ? 0 : e.screen.screen.screenSpace && !t.screen.screen.screenSpace ? -1 : t.screen.screen.screenSpace && !e.screen.screen.screenSpace ? 1 : t.drawOrder - e.drawOrder
    }
    _getTargetElementByCoords(e, t, s) {
        const i = this._calculateRayScreen(t, s, e, cn) ? cn : null
          , n = this._calculateRay3d(t, s, e, Xl) ? Xl : null;
        return this._getTargetElement(e, i, n)
    }
    _getTargetElementByRay(e, t) {
        cn.origin.copy(e.origin),
        cn.direction.copy(e.direction),
        cn.end.copy(cn.direction).mulScalar(t.farClip * 2).add(cn.origin);
        const s = cn
          , i = t.worldToScreen(s.origin, Wp)
          , n = this._calculateRayScreen(i.x, i.y, t, Xl) ? Xl : null;
        return this._getTargetElement(t, n, s)
    }
    _getTargetElement(e, t, s) {
        let i = null
          , n = 1 / 0;
        this._elements.sort(this._sortHandler);
        for (let r = 0, o = this._elements.length; r < o; r++) {
            const l = this._elements[r];
            if (l.layers.some(c => e.layersSet.has(c)))
                if (l.screen && l.screen.screen.screenSpace) {
                    if (!t)
                        continue;
                    if (this._checkElement(t, l, !0) >= 0) {
                        i = l;
                        break
                    }
                } else {
                    if (!s)
                        continue;
                    const c = this._checkElement(s, l, !1);
                    if (c >= 0 && (c < n && (i = l,
                    n = c),
                    l.screen)) {
                        i = l;
                        break
                    }
                }
        }
        return i
    }
    _calculateRayScreen(e, t, s, i) {
        const n = this.app.graphicsDevice.width
          , r = this.app.graphicsDevice.height
          , o = s.rect.z * n
          , l = s.rect.w * r
          , c = s.rect.x * n
          , d = c + o
          , h = (1 - s.rect.y) * r
          , u = h - l;
        let f = e * n / this._target.clientWidth
          , p = t * r / this._target.clientHeight;
        return f >= c && f <= d && p <= h && p >= u ? (f = n * (f - c) / o,
        p = r * (p - u) / l,
        p = r - p,
        i.origin.set(f, p, 1),
        i.direction.set(0, 0, -1),
        i.end.copy(i.direction).mulScalar(2).add(i.origin),
        !0) : !1
    }
    _calculateRay3d(e, t, s, i) {
        const n = this._target.clientWidth
          , r = this._target.clientHeight
          , o = s.rect.z * n
          , l = s.rect.w * r
          , c = s.rect.x * n
          , d = c + o
          , h = (1 - s.rect.y) * r
          , u = h - l;
        let f = e
          , p = t;
        return e >= c && e <= d && t <= h && p >= u ? (f = n * (f - c) / o,
        p = r * (p - u) / l,
        s.screenToWorld(f, p, s.nearClip, Wp),
        s.screenToWorld(f, p, s.farClip, Kv),
        i.origin.copy(Wp),
        i.direction.set(0, 0, -1),
        i.end.copy(Kv),
        !0) : !1
    }
    _checkElement(e, t, s) {
        if (t.maskedBy && this._checkElement(e, t.maskedBy.element, s) < 0)
            return -1;
        let i;
        s ? i = lh.calculateScaleToScreen(t) : i = lh.calculateScaleToWorld(t);
        const n = lh.buildHitCorners(t, s ? t.screenCorners : t.worldCorners, i);
        return eN(e.origin, e.end, n)
    }
    static buildHitCorners(e, t, s) {
        let i = t;
        if (e.entity && e.entity.button) {
            const r = e.entity.button.hitPadding || Jk;
            Ol.copy(e.entity.up),
            Ed.copy(Ol).mulScalar(-1),
            Fl.copy(e.entity.right),
            Ad.copy(Fl).mulScalar(-1),
            Ol.mulScalar(r.w * s.y),
            Ed.mulScalar(r.y * s.y),
            Fl.mulScalar(r.z * s.x),
            Ad.mulScalar(r.x * s.x),
            Qv.copy(i[0]).add(Ed).add(Ad),
            Jv.copy(i[1]).add(Ed).add(Fl),
            eS.copy(i[2]).add(Ol).add(Fl),
            tS.copy(i[3]).add(Ol).add(Ad),
            i = [Qv, Jv, eS, tS]
        }
        if (s.x < 0) {
            const r = i[2].x
              , o = i[0].x;
            i[0].x = r,
            i[1].x = o,
            i[2].x = o,
            i[3].x = r
        }
        if (s.y < 0) {
            const r = i[2].y
              , o = i[0].y;
            i[0].y = r,
            i[1].y = r,
            i[2].y = o,
            i[3].y = o
        }
        if (s.z < 0) {
            const r = i[2].x
              , o = i[2].y
              , l = i[2].z;
            i[2].x = i[0].x,
            i[2].y = i[0].y,
            i[2].z = i[0].z,
            i[0].x = r,
            i[0].y = o,
            i[0].z = l
        }
        return i
    }
    static calculateScaleToScreen(e) {
        let t = e.entity;
        const s = e.screen.screen.scale;
        for (ao.set(s, s, s); t && !t.screen; )
            ao.mul(t.getLocalScale()),
            t = t.parent;
        return ao
    }
    static calculateScaleToWorld(e) {
        let t = e.entity;
        for (ao.set(1, 1, 1); t; )
            ao.mul(t.getLocalScale()),
            t = t.parent;
        return ao
    }
}
function tN() {
    var a = oh("orbitCamera");
    a.attributes.add("distanceMax", {
        type: "number",
        default: 0,
        title: "Distance Max",
        description: "Setting this at 0 will give an infinite distance limit"
    }),
    a.attributes.add("distanceMin", {
        type: "number",
        default: 0,
        title: "Distance Min"
    }),
    a.attributes.add("pitchAngleMax", {
        type: "number",
        default: 90,
        title: "Pitch Angle Max (degrees)"
    }),
    a.attributes.add("pitchAngleMin", {
        type: "number",
        default: -90,
        title: "Pitch Angle Min (degrees)"
    }),
    a.attributes.add("inertiaFactor", {
        type: "number",
        default: 0,
        title: "Inertia Factor",
        description: "Higher value means that the camera will continue moving after the user has stopped dragging. 0 is fully responsive."
    }),
    a.attributes.add("focusEntity", {
        type: "entity",
        title: "Focus Entity",
        description: "Entity for the camera to focus on. If blank, then the camera will use the whole scene"
    }),
    a.attributes.add("frameOnStart", {
        type: "boolean",
        default: !0,
        title: "Frame on Start",
        description: 'Frames the entity or scene at the start of the application."'
    }),
    Object.defineProperty(a.prototype, "distance", {
        get: function() {
            return this._targetDistance
        },
        set: function(s) {
            this._targetDistance = this._clampDistance(s)
        }
    }),
    Object.defineProperty(a.prototype, "pitch", {
        get: function() {
            return this._targetPitch
        },
        set: function(s) {
            this._targetPitch = this._clampPitchAngle(s)
        }
    }),
    Object.defineProperty(a.prototype, "yaw", {
        get: function() {
            return this._targetYaw
        },
        set: function(s) {
            this._targetYaw = s;
            var i = this._targetYaw - this._yaw
              , n = i % 360;
            n > 180 ? this._targetYaw = this._yaw - (360 - n) : n < -180 ? this._targetYaw = this._yaw + (360 + n) : this._targetYaw = this._yaw + n
        }
    }),
    Object.defineProperty(a.prototype, "pivotPoint", {
        get: function() {
            return this._pivotPoint
        },
        set: function(s) {
            this._pivotPoint.copy(s)
        }
    }),
    a.prototype.focus = function(s) {
        this._buildAabb(s);
        var i = this._modelsAabb.halfExtents
          , n = Math.max(i.x, Math.max(i.y, i.z));
        this.distance = n * 1.5 / Math.sin(.5 * this.entity.camera.fov * W.DEG_TO_RAD),
        this._removeInertia(),
        this._pivotPoint.copy(this._modelsAabb.center)
    }
    ,
    a.distanceBetween = new y,
    a.prototype.resetAndLookAtPoint = function(s, i) {
        this.pivotPoint.copy(i),
        this.entity.setPosition(s),
        this.entity.lookAt(i);
        var n = a.distanceBetween;
        n.sub2(i, s),
        this.distance = n.length(),
        this.pivotPoint.copy(i);
        var r = this.entity.getRotation();
        this.yaw = this._calcYaw(r),
        this.pitch = this._calcPitch(r, this.yaw),
        this._removeInertia(),
        this._updatePosition()
    }
    ,
    a.prototype.resetAndLookAtEntity = function(s, i) {
        this._buildAabb(i),
        this.resetAndLookAtPoint(s, this._modelsAabb.center)
    }
    ,
    a.prototype.reset = function(s, i, n) {
        this.pitch = i,
        this.yaw = s,
        this.distance = n,
        this._removeInertia()
    }
    ,
    a.prototype.initialize = function() {
        var s = this
          , i = function() {
            s._checkAspectRatio()
        };
        window.addEventListener("resize", i, !1),
        this._checkAspectRatio(),
        this._modelsAabb = new Pe,
        this._buildAabb(this.focusEntity || this.app.root),
        this.entity.lookAt(this._modelsAabb.center),
        this._pivotPoint = new y,
        this._pivotPoint.copy(this._modelsAabb.center);
        var n = this.entity.getRotation();
        if (this._yaw = this._calcYaw(n),
        this._pitch = this._clampPitchAngle(this._calcPitch(n, this._yaw)),
        this.entity.setLocalEulerAngles(this._pitch, this._yaw, 0),
        this._distance = 0,
        this._targetYaw = this._yaw,
        this._targetPitch = this._pitch,
        this.frameOnStart)
            this.focus(this.focusEntity || this.app.root);
        else {
            var r = new y;
            r.sub2(this.entity.getPosition(), this._pivotPoint),
            this._distance = this._clampDistance(r.length())
        }
        this._targetDistance = this._distance,
        this.on("attr:distanceMin", function(o, l) {
            this._distance = this._clampDistance(this._distance)
        }),
        this.on("attr:distanceMax", function(o, l) {
            this._distance = this._clampDistance(this._distance)
        }),
        this.on("attr:pitchAngleMin", function(o, l) {
            this._pitch = this._clampPitchAngle(this._pitch)
        }),
        this.on("attr:pitchAngleMax", function(o, l) {
            this._pitch = this._clampPitchAngle(this._pitch)
        }),
        this.on("attr:focusEntity", function(o, l) {
            this.frameOnStart ? this.focus(o || this.app.root) : this.resetAndLookAtEntity(this.entity.getPosition(), o || this.app.root)
        }),
        this.on("attr:frameOnStart", function(o, l) {
            o && this.focus(this.focusEntity || this.app.root)
        }),
        this.on("destroy", function() {
            window.removeEventListener("resize", i, !1)
        })
    }
    ,
    a.prototype.update = function(s) {
        var i = this.inertiaFactor === 0 ? 1 : Math.min(s / this.inertiaFactor, 1);
        this._distance = W.lerp(this._distance, this._targetDistance, i),
        this._yaw = W.lerp(this._yaw, this._targetYaw, i),
        this._pitch = W.lerp(this._pitch, this._targetPitch, i),
        this._updatePosition()
    }
    ,
    a.prototype._updatePosition = function() {
        this.entity.setLocalPosition(0, 0, 0),
        this.entity.setLocalEulerAngles(this._pitch, this._yaw, 0);
        var s = this.entity.getPosition();
        s.copy(this.entity.forward),
        s.mulScalar(-this._distance),
        s.add(this.pivotPoint),
        this.entity.setPosition(s)
    }
    ,
    a.prototype._removeInertia = function() {
        this._yaw = this._targetYaw,
        this._pitch = this._targetPitch,
        this._distance = this._targetDistance
    }
    ,
    a.prototype._checkAspectRatio = function() {
        var s = this.app.graphicsDevice.height
          , i = this.app.graphicsDevice.width;
        this.entity.camera.horizontalFov = s > i
    }
    ,
    a.prototype._buildAabb = function(s) {
        var i, n, r = [], o = s.findComponents("render");
        for (i = 0; i < o.length; i++) {
            var l = o[i];
            for (n = 0; n < l.meshInstances.length; n++)
                r.push(l.meshInstances[n])
        }
        var c = s.findComponents("model");
        for (i = 0; i < c.length; i++) {
            var d = c[i];
            for (n = 0; n < d.meshInstances.length; n++)
                r.push(d.meshInstances[n])
        }
        for (i = 0; i < r.length; i++)
            i === 0 ? this._modelsAabb.copy(r[i].aabb) : this._modelsAabb.add(r[i].aabb)
    }
    ,
    a.prototype._calcYaw = function(s) {
        var i = new y;
        return s.transformVector(y.FORWARD, i),
        Math.atan2(-i.x, -i.z) * W.RAD_TO_DEG
    }
    ,
    a.prototype._clampDistance = function(s) {
        return this.distanceMax > 0 ? W.clamp(s, this.distanceMin, this.distanceMax) : Math.max(s, this.distanceMin)
    }
    ,
    a.prototype._clampPitchAngle = function(s) {
        return W.clamp(s, -this.pitchAngleMax, -this.pitchAngleMin)
    }
    ,
    a.quatWithoutYaw = new ne,
    a.yawOffset = new ne,
    a.prototype._calcPitch = function(s, i) {
        var n = a.quatWithoutYaw
          , r = a.yawOffset;
        r.setFromEulerAngles(0, -i, 0),
        n.mul2(r, s);
        var o = new y;
        return n.transformVector(y.FORWARD, o),
        Math.atan2(o.y, -o.z) * W.RAD_TO_DEG
    }
    ;
    var e = oh("orbitCameraInputMouse");
    e.attributes.add("orbitSensitivity", {
        type: "number",
        default: .3,
        title: "Orbit Sensitivity",
        description: "How fast the camera moves around the orbit. Higher is faster"
    }),
    e.attributes.add("distanceSensitivity", {
        type: "number",
        default: .15,
        title: "Distance Sensitivity",
        description: "How fast the camera moves in and out. Higher is faster"
    }),
    e.prototype.initialize = function() {
        if (this.orbitCamera = this.entity.script.orbitCamera,
        this.orbitCamera) {
            var s = this
              , i = function(n) {
                s.onMouseOut(n)
            };
            this.app.mouse.on($o, this.onMouseDown, this),
            this.app.mouse.on(wh, this.onMouseUp, this),
            this.app.mouse.on(qo, this.onMouseMove, this),
            this.app.mouse.on(bh, this.onMouseWheel, this),
            window.addEventListener("mouseout", i, !1),
            this.on("destroy", function() {
                this.app.mouse.off($o, this.onMouseDown, this),
                this.app.mouse.off(wh, this.onMouseUp, this),
                this.app.mouse.off(qo, this.onMouseMove, this),
                this.app.mouse.off(bh, this.onMouseWheel, this),
                window.removeEventListener("mouseout", i, !1)
            })
        }
        this.app.mouse.disableContextMenu(),
        this.lookButtonDown = !1,
        this.panButtonDown = !1,
        this.lastPoint = new P
    }
    ,
    e.fromWorldPoint = new y,
    e.toWorldPoint = new y,
    e.worldDiff = new y,
    e.prototype.pan = function(s) {
        var i = e.fromWorldPoint
          , n = e.toWorldPoint
          , r = e.worldDiff
          , o = this.entity.camera
          , l = this.orbitCamera.distance;
        o.screenToWorld(s.x, s.y, l, i),
        o.screenToWorld(this.lastPoint.x, this.lastPoint.y, l, n),
        r.sub2(n, i),
        this.orbitCamera.pivotPoint.add(r)
    }
    ,
    e.prototype.onMouseDown = function(s) {
        if (!(!this.orbitCamera || !this.orbitCamera.enabled))
            switch (s.button) {
            case Fy:
                this.lookButtonDown = !0;
                break;
            case By:
            case ky:
                this.panButtonDown = !0;
                break
            }
    }
    ,
    e.prototype.onMouseUp = function(s) {
        if (!(!this.orbitCamera || !this.orbitCamera.enabled))
            switch (s.button) {
            case Fy:
                this.lookButtonDown = !1;
                break;
            case By:
            case ky:
                this.panButtonDown = !1;
                break
            }
    }
    ,
    e.prototype.onMouseMove = function(s) {
        !this.orbitCamera || !this.orbitCamera.enabled || (this.lookButtonDown ? (this.orbitCamera.pitch -= s.dy * this.orbitSensitivity,
        this.orbitCamera.yaw -= s.dx * this.orbitSensitivity) : this.panButtonDown && this.pan(s),
        this.lastPoint.set(s.x, s.y))
    }
    ,
    e.prototype.onMouseWheel = function(s) {
        !this.orbitCamera || !this.orbitCamera.enabled || (this.orbitCamera.distance -= s.wheel * this.distanceSensitivity * (this.orbitCamera.distance * .1),
        s.event.preventDefault())
    }
    ,
    e.prototype.onMouseOut = function(s) {
        !this.orbitCamera || !this.orbitCamera.enabled || (this.lookButtonDown = !1,
        this.panButtonDown = !1)
    }
    ;
    var t = oh("orbitCameraInputTouch");
    t.attributes.add("orbitSensitivity", {
        type: "number",
        default: .4,
        title: "Orbit Sensitivity",
        description: "How fast the camera moves around the orbit. Higher is faster"
    }),
    t.attributes.add("distanceSensitivity", {
        type: "number",
        default: .2,
        title: "Distance Sensitivity",
        description: "How fast the camera moves in and out. Higher is faster"
    }),
    t.prototype.initialize = function() {
        this.orbitCamera = this.entity.script.orbitCamera,
        this.lastTouchPoint = new P,
        this.lastPinchMidPoint = new P,
        this.lastPinchDistance = 0,
        this.orbitCamera && this.app.touch && (this.app.touch.on(Jd, this.onTouchStartEndCancel, this),
        this.app.touch.on(eu, this.onTouchStartEndCancel, this),
        this.app.touch.on(su, this.onTouchStartEndCancel, this),
        this.app.touch.on(tu, this.onTouchMove, this),
        this.on("destroy", function() {
            this.app.touch.off(Jd, this.onTouchStartEndCancel, this),
            this.app.touch.off(eu, this.onTouchStartEndCancel, this),
            this.app.touch.off(su, this.onTouchStartEndCancel, this),
            this.app.touch.off(tu, this.onTouchMove, this)
        }))
    }
    ,
    t.prototype.getPinchDistance = function(s, i) {
        var n = s.x - i.x
          , r = s.y - i.y;
        return Math.sqrt(n * n + r * r)
    }
    ,
    t.prototype.calcMidPoint = function(s, i, n) {
        n.set(i.x - s.x, i.y - s.y),
        n.mulScalar(.5),
        n.x += s.x,
        n.y += s.y
    }
    ,
    t.prototype.onTouchStartEndCancel = function(s) {
        if (!(!this.orbitCamera || !this.orbitCamera.enabled)) {
            var i = s.touches;
            i.length === 1 ? this.lastTouchPoint.set(i[0].x, i[0].y) : i.length === 2 && (this.lastPinchDistance = this.getPinchDistance(i[0], i[1]),
            this.calcMidPoint(i[0], i[1], this.lastPinchMidPoint))
        }
    }
    ,
    t.fromWorldPoint = new y,
    t.toWorldPoint = new y,
    t.worldDiff = new y,
    t.prototype.pan = function(s) {
        var i = t.fromWorldPoint
          , n = t.toWorldPoint
          , r = t.worldDiff
          , o = this.entity.camera
          , l = this.orbitCamera.distance;
        o.screenToWorld(s.x, s.y, l, i),
        o.screenToWorld(this.lastPinchMidPoint.x, this.lastPinchMidPoint.y, l, n),
        r.sub2(n, i),
        this.orbitCamera.pivotPoint.add(r)
    }
    ,
    t.pinchMidPoint = new P,
    t.prototype.onTouchMove = function(s) {
        if (!(!this.orbitCamera || !this.orbitCamera.enabled)) {
            var i = t.pinchMidPoint
              , n = s.touches;
            if (n.length === 1) {
                var r = n[0];
                this.orbitCamera.pitch -= (r.y - this.lastTouchPoint.y) * this.orbitSensitivity,
                this.orbitCamera.yaw -= (r.x - this.lastTouchPoint.x) * this.orbitSensitivity,
                this.lastTouchPoint.set(r.x, r.y)
            } else if (n.length === 2) {
                var o = this.getPinchDistance(n[0], n[1])
                  , l = o - this.lastPinchDistance;
                this.lastPinchDistance = o,
                this.orbitCamera.distance -= l * this.distanceSensitivity * .1 * (this.orbitCamera.distance * .1),
                this.calcMidPoint(n[0], n[1], i),
                this.pan(i),
                this.lastPinchMidPoint.copy(i)
            }
        }
    }
}
class sN {
    static init() {}
    static addOrbitCamera(e, t, s=!0) {
        if (!B.DEBUG_UI)
            return;
        tN(),
        e.addComponent("script"),
        e.script.create("orbitCamera", {
            attributes: {
                distanceMax: 2e3,
                distanceMin: 5,
                pitchAngleMax: 90,
                pitchAngleMin: 0,
                inertiaFactor: .1,
                focusEntity: t,
                frameOnStart: !0
            }
        }),
        e.script.create("orbitCameraInputMouse"),
        e.script.create("orbitCameraInputTouch");
        let i = {
            OrbitCamera: s
        };
        e.script.orbitCameraInputMouse.enabled = i.OrbitCamera,
        e.script.orbitCameraInputTouch.enabled = i.OrbitCamera,
        e.script.orbitCamera.enabled = i.OrbitCamera;
        let n = this.gui.addFolder("Camera control");
        n.open(),
        n.add(i, "OrbitCamera").onChange( () => {
            e.script.orbitCameraInputMouse.enabled = i.OrbitCamera,
            e.script.orbitCameraInputTouch.enabled = i.OrbitCamera,
            e.script.orbitCamera.enabled = i.OrbitCamera
        }
        )
    }
}
var Nl = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function iN(a) {
    return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a
}
var dn = {};
/*!
 *  howler.js v2.2.4
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */
(function(a) {
    (function() {
        var e = function() {
            this.init()
        };
        e.prototype = {
            init: function() {
                var h = this || t;
                return h._counter = 1e3,
                h._html5AudioPool = [],
                h.html5PoolSize = 10,
                h._codecs = {},
                h._howls = [],
                h._muted = !1,
                h._volume = 1,
                h._canPlayEvent = "canplaythrough",
                h._navigator = typeof window < "u" && window.navigator ? window.navigator : null,
                h.masterGain = null,
                h.noAudio = !1,
                h.usingWebAudio = !0,
                h.autoSuspend = !0,
                h.ctx = null,
                h.autoUnlock = !0,
                h._setup(),
                h
            },
            volume: function(h) {
                var u = this || t;
                if (h = parseFloat(h),
                u.ctx || d(),
                typeof h < "u" && h >= 0 && h <= 1) {
                    if (u._volume = h,
                    u._muted)
                        return u;
                    u.usingWebAudio && u.masterGain.gain.setValueAtTime(h, t.ctx.currentTime);
                    for (var f = 0; f < u._howls.length; f++)
                        if (!u._howls[f]._webAudio)
                            for (var p = u._howls[f]._getSoundIds(), _ = 0; _ < p.length; _++) {
                                var m = u._howls[f]._soundById(p[_]);
                                m && m._node && (m._node.volume = m._volume * h)
                            }
                    return u
                }
                return u._volume
            },
            mute: function(h) {
                var u = this || t;
                u.ctx || d(),
                u._muted = h,
                u.usingWebAudio && u.masterGain.gain.setValueAtTime(h ? 0 : u._volume, t.ctx.currentTime);
                for (var f = 0; f < u._howls.length; f++)
                    if (!u._howls[f]._webAudio)
                        for (var p = u._howls[f]._getSoundIds(), _ = 0; _ < p.length; _++) {
                            var m = u._howls[f]._soundById(p[_]);
                            m && m._node && (m._node.muted = h ? !0 : m._muted)
                        }
                return u
            },
            stop: function() {
                for (var h = this || t, u = 0; u < h._howls.length; u++)
                    h._howls[u].stop();
                return h
            },
            unload: function() {
                for (var h = this || t, u = h._howls.length - 1; u >= 0; u--)
                    h._howls[u].unload();
                return h.usingWebAudio && h.ctx && typeof h.ctx.close < "u" && (h.ctx.close(),
                h.ctx = null,
                d()),
                h
            },
            codecs: function(h) {
                return (this || t)._codecs[h.replace(/^x-/, "")]
            },
            _setup: function() {
                var h = this || t;
                if (h.state = h.ctx && h.ctx.state || "suspended",
                h._autoSuspend(),
                !h.usingWebAudio)
                    if (typeof Audio < "u")
                        try {
                            var u = new Audio;
                            typeof u.oncanplaythrough > "u" && (h._canPlayEvent = "canplay")
                        } catch {
                            h.noAudio = !0
                        }
                    else
                        h.noAudio = !0;
                try {
                    var u = new Audio;
                    u.muted && (h.noAudio = !0)
                } catch {}
                return h.noAudio || h._setupCodecs(),
                h
            },
            _setupCodecs: function() {
                var h = this || t
                  , u = null;
                try {
                    u = typeof Audio < "u" ? new Audio : null
                } catch {
                    return h
                }
                if (!u || typeof u.canPlayType != "function")
                    return h;
                var f = u.canPlayType("audio/mpeg;").replace(/^no$/, "")
                  , p = h._navigator ? h._navigator.userAgent : ""
                  , _ = p.match(/OPR\/(\d+)/g)
                  , m = _ && parseInt(_[0].split("/")[1], 10) < 33
                  , g = p.indexOf("Safari") !== -1 && p.indexOf("Chrome") === -1
                  , v = p.match(/Version\/(.*?) /)
                  , x = g && v && parseInt(v[1], 10) < 15;
                return h._codecs = {
                    mp3: !!(!m && (f || u.canPlayType("audio/mp3;").replace(/^no$/, ""))),
                    mpeg: !!f,
                    opus: !!u.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                    ogg: !!u.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                    oga: !!u.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                    wav: !!(u.canPlayType('audio/wav; codecs="1"') || u.canPlayType("audio/wav")).replace(/^no$/, ""),
                    aac: !!u.canPlayType("audio/aac;").replace(/^no$/, ""),
                    caf: !!u.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                    m4a: !!(u.canPlayType("audio/x-m4a;") || u.canPlayType("audio/m4a;") || u.canPlayType("audio/aac;")).replace(/^no$/, ""),
                    m4b: !!(u.canPlayType("audio/x-m4b;") || u.canPlayType("audio/m4b;") || u.canPlayType("audio/aac;")).replace(/^no$/, ""),
                    mp4: !!(u.canPlayType("audio/x-mp4;") || u.canPlayType("audio/mp4;") || u.canPlayType("audio/aac;")).replace(/^no$/, ""),
                    weba: !!(!x && u.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                    webm: !!(!x && u.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                    dolby: !!u.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                    flac: !!(u.canPlayType("audio/x-flac;") || u.canPlayType("audio/flac;")).replace(/^no$/, "")
                },
                h
            },
            _unlockAudio: function() {
                var h = this || t;
                if (!(h._audioUnlocked || !h.ctx)) {
                    h._audioUnlocked = !1,
                    h.autoUnlock = !1,
                    !h._mobileUnloaded && h.ctx.sampleRate !== 44100 && (h._mobileUnloaded = !0,
                    h.unload()),
                    h._scratchBuffer = h.ctx.createBuffer(1, 1, 22050);
                    var u = function(f) {
                        for (; h._html5AudioPool.length < h.html5PoolSize; )
                            try {
                                var p = new Audio;
                                p._unlocked = !0,
                                h._releaseHtml5Audio(p)
                            } catch {
                                h.noAudio = !0;
                                break
                            }
                        for (var _ = 0; _ < h._howls.length; _++)
                            if (!h._howls[_]._webAudio)
                                for (var m = h._howls[_]._getSoundIds(), g = 0; g < m.length; g++) {
                                    var v = h._howls[_]._soundById(m[g]);
                                    v && v._node && !v._node._unlocked && (v._node._unlocked = !0,
                                    v._node.load())
                                }
                        h._autoResume();
                        var x = h.ctx.createBufferSource();
                        x.buffer = h._scratchBuffer,
                        x.connect(h.ctx.destination),
                        typeof x.start > "u" ? x.noteOn(0) : x.start(0),
                        typeof h.ctx.resume == "function" && h.ctx.resume(),
                        x.onended = function() {
                            x.disconnect(0),
                            h._audioUnlocked = !0,
                            document.removeEventListener("touchstart", u, !0),
                            document.removeEventListener("touchend", u, !0),
                            document.removeEventListener("click", u, !0),
                            document.removeEventListener("keydown", u, !0);
                            for (var S = 0; S < h._howls.length; S++)
                                h._howls[S]._emit("unlock")
                        }
                    };
                    return document.addEventListener("touchstart", u, !0),
                    document.addEventListener("touchend", u, !0),
                    document.addEventListener("click", u, !0),
                    document.addEventListener("keydown", u, !0),
                    h
                }
            },
            _obtainHtml5Audio: function() {
                var h = this || t;
                if (h._html5AudioPool.length)
                    return h._html5AudioPool.pop();
                var u = new Audio().play();
                return u && typeof Promise < "u" && (u instanceof Promise || typeof u.then == "function") && u.catch(function() {
                    console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")
                }),
                new Audio
            },
            _releaseHtml5Audio: function(h) {
                var u = this || t;
                return h._unlocked && u._html5AudioPool.push(h),
                u
            },
            _autoSuspend: function() {
                var h = this;
                if (!(!h.autoSuspend || !h.ctx || typeof h.ctx.suspend > "u" || !t.usingWebAudio)) {
                    for (var u = 0; u < h._howls.length; u++)
                        if (h._howls[u]._webAudio) {
                            for (var f = 0; f < h._howls[u]._sounds.length; f++)
                                if (!h._howls[u]._sounds[f]._paused)
                                    return h
                        }
                    return h._suspendTimer && clearTimeout(h._suspendTimer),
                    h._suspendTimer = setTimeout(function() {
                        if (h.autoSuspend) {
                            h._suspendTimer = null,
                            h.state = "suspending";
                            var p = function() {
                                h.state = "suspended",
                                h._resumeAfterSuspend && (delete h._resumeAfterSuspend,
                                h._autoResume())
                            };
                            h.ctx.suspend().then(p, p)
                        }
                    }, 3e4),
                    h
                }
            },
            _autoResume: function() {
                var h = this;
                if (!(!h.ctx || typeof h.ctx.resume > "u" || !t.usingWebAudio))
                    return h.state === "running" && h.ctx.state !== "interrupted" && h._suspendTimer ? (clearTimeout(h._suspendTimer),
                    h._suspendTimer = null) : h.state === "suspended" || h.state === "running" && h.ctx.state === "interrupted" ? (h.ctx.resume().then(function() {
                        h.state = "running";
                        for (var u = 0; u < h._howls.length; u++)
                            h._howls[u]._emit("resume")
                    }),
                    h._suspendTimer && (clearTimeout(h._suspendTimer),
                    h._suspendTimer = null)) : h.state === "suspending" && (h._resumeAfterSuspend = !0),
                    h
            }
        };
        var t = new e
          , s = function(h) {
            var u = this;
            if (!h.src || h.src.length === 0) {
                console.error("An array of source files must be passed with any new Howl.");
                return
            }
            u.init(h)
        };
        s.prototype = {
            init: function(h) {
                var u = this;
                return t.ctx || d(),
                u._autoplay = h.autoplay || !1,
                u._format = typeof h.format != "string" ? h.format : [h.format],
                u._html5 = h.html5 || !1,
                u._muted = h.mute || !1,
                u._loop = h.loop || !1,
                u._pool = h.pool || 5,
                u._preload = typeof h.preload == "boolean" || h.preload === "metadata" ? h.preload : !0,
                u._rate = h.rate || 1,
                u._sprite = h.sprite || {},
                u._src = typeof h.src != "string" ? h.src : [h.src],
                u._volume = h.volume !== void 0 ? h.volume : 1,
                u._xhr = {
                    method: h.xhr && h.xhr.method ? h.xhr.method : "GET",
                    headers: h.xhr && h.xhr.headers ? h.xhr.headers : null,
                    withCredentials: h.xhr && h.xhr.withCredentials ? h.xhr.withCredentials : !1
                },
                u._duration = 0,
                u._state = "unloaded",
                u._sounds = [],
                u._endTimers = {},
                u._queue = [],
                u._playLock = !1,
                u._onend = h.onend ? [{
                    fn: h.onend
                }] : [],
                u._onfade = h.onfade ? [{
                    fn: h.onfade
                }] : [],
                u._onload = h.onload ? [{
                    fn: h.onload
                }] : [],
                u._onloaderror = h.onloaderror ? [{
                    fn: h.onloaderror
                }] : [],
                u._onplayerror = h.onplayerror ? [{
                    fn: h.onplayerror
                }] : [],
                u._onpause = h.onpause ? [{
                    fn: h.onpause
                }] : [],
                u._onplay = h.onplay ? [{
                    fn: h.onplay
                }] : [],
                u._onstop = h.onstop ? [{
                    fn: h.onstop
                }] : [],
                u._onmute = h.onmute ? [{
                    fn: h.onmute
                }] : [],
                u._onvolume = h.onvolume ? [{
                    fn: h.onvolume
                }] : [],
                u._onrate = h.onrate ? [{
                    fn: h.onrate
                }] : [],
                u._onseek = h.onseek ? [{
                    fn: h.onseek
                }] : [],
                u._onunlock = h.onunlock ? [{
                    fn: h.onunlock
                }] : [],
                u._onresume = [],
                u._webAudio = t.usingWebAudio && !u._html5,
                typeof t.ctx < "u" && t.ctx && t.autoUnlock && t._unlockAudio(),
                t._howls.push(u),
                u._autoplay && u._queue.push({
                    event: "play",
                    action: function() {
                        u.play()
                    }
                }),
                u._preload && u._preload !== "none" && u.load(),
                u
            },
            load: function() {
                var h = this
                  , u = null;
                if (t.noAudio) {
                    h._emit("loaderror", null, "No audio support.");
                    return
                }
                typeof h._src == "string" && (h._src = [h._src]);
                for (var f = 0; f < h._src.length; f++) {
                    var p, _;
                    if (h._format && h._format[f])
                        p = h._format[f];
                    else {
                        if (_ = h._src[f],
                        typeof _ != "string") {
                            h._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                            continue
                        }
                        p = /^data:audio\/([^;,]+);/i.exec(_),
                        p || (p = /\.([^.]+)$/.exec(_.split("?", 1)[0])),
                        p && (p = p[1].toLowerCase())
                    }
                    if (p || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'),
                    p && t.codecs(p)) {
                        u = h._src[f];
                        break
                    }
                }
                if (!u) {
                    h._emit("loaderror", null, "No codec support for selected audio sources.");
                    return
                }
                return h._src = u,
                h._state = "loading",
                window.location.protocol === "https:" && u.slice(0, 5) === "http:" && (h._html5 = !0,
                h._webAudio = !1),
                new i(h),
                h._webAudio && r(h),
                h
            },
            play: function(h, u) {
                var f = this
                  , p = null;
                if (typeof h == "number")
                    p = h,
                    h = null;
                else {
                    if (typeof h == "string" && f._state === "loaded" && !f._sprite[h])
                        return null;
                    if (typeof h > "u" && (h = "__default",
                    !f._playLock)) {
                        for (var _ = 0, m = 0; m < f._sounds.length; m++)
                            f._sounds[m]._paused && !f._sounds[m]._ended && (_++,
                            p = f._sounds[m]._id);
                        _ === 1 ? h = null : p = null
                    }
                }
                var g = p ? f._soundById(p) : f._inactiveSound();
                if (!g)
                    return null;
                if (p && !h && (h = g._sprite || "__default"),
                f._state !== "loaded") {
                    g._sprite = h,
                    g._ended = !1;
                    var v = g._id;
                    return f._queue.push({
                        event: "play",
                        action: function() {
                            f.play(v)
                        }
                    }),
                    v
                }
                if (p && !g._paused)
                    return u || f._loadQueue("play"),
                    g._id;
                f._webAudio && t._autoResume();
                var x = Math.max(0, g._seek > 0 ? g._seek : f._sprite[h][0] / 1e3)
                  , S = Math.max(0, (f._sprite[h][0] + f._sprite[h][1]) / 1e3 - x)
                  , w = S * 1e3 / Math.abs(g._rate)
                  , T = f._sprite[h][0] / 1e3
                  , b = (f._sprite[h][0] + f._sprite[h][1]) / 1e3;
                g._sprite = h,
                g._ended = !1;
                var E = function() {
                    g._paused = !1,
                    g._seek = x,
                    g._start = T,
                    g._stop = b,
                    g._loop = !!(g._loop || f._sprite[h][2])
                };
                if (x >= b) {
                    f._ended(g);
                    return
                }
                var C = g._node;
                if (f._webAudio) {
                    var R = function() {
                        f._playLock = !1,
                        E(),
                        f._refreshBuffer(g);
                        var I = g._muted || f._muted ? 0 : g._volume;
                        C.gain.setValueAtTime(I, t.ctx.currentTime),
                        g._playStart = t.ctx.currentTime,
                        typeof C.bufferSource.start > "u" ? g._loop ? C.bufferSource.noteGrainOn(0, x, 86400) : C.bufferSource.noteGrainOn(0, x, S) : g._loop ? C.bufferSource.start(0, x, 86400) : C.bufferSource.start(0, x, S),
                        w !== 1 / 0 && (f._endTimers[g._id] = setTimeout(f._ended.bind(f, g), w)),
                        u || setTimeout(function() {
                            f._emit("play", g._id),
                            f._loadQueue()
                        }, 0)
                    };
                    t.state === "running" && t.ctx.state !== "interrupted" ? R() : (f._playLock = !0,
                    f.once("resume", R),
                    f._clearTimer(g._id))
                } else {
                    var F = function() {
                        C.currentTime = x,
                        C.muted = g._muted || f._muted || t._muted || C.muted,
                        C.volume = g._volume * t.volume(),
                        C.playbackRate = g._rate;
                        try {
                            var I = C.play();
                            if (I && typeof Promise < "u" && (I instanceof Promise || typeof I.then == "function") ? (f._playLock = !0,
                            E(),
                            I.then(function() {
                                f._playLock = !1,
                                C._unlocked = !0,
                                u ? f._loadQueue() : f._emit("play", g._id)
                            }).catch(function() {
                                f._playLock = !1,
                                f._emit("playerror", g._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."),
                                g._ended = !0,
                                g._paused = !0
                            })) : u || (f._playLock = !1,
                            E(),
                            f._emit("play", g._id)),
                            C.playbackRate = g._rate,
                            C.paused) {
                                f._emit("playerror", g._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                                return
                            }
                            h !== "__default" || g._loop ? f._endTimers[g._id] = setTimeout(f._ended.bind(f, g), w) : (f._endTimers[g._id] = function() {
                                f._ended(g),
                                C.removeEventListener("ended", f._endTimers[g._id], !1)
                            }
                            ,
                            C.addEventListener("ended", f._endTimers[g._id], !1))
                        } catch (O) {
                            f._emit("playerror", g._id, O)
                        }
                    };
                    C.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" && (C.src = f._src,
                    C.load());
                    var L = window && window.ejecta || !C.readyState && t._navigator.isCocoonJS;
                    if (C.readyState >= 3 || L)
                        F();
                    else {
                        f._playLock = !0,
                        f._state = "loading";
                        var U = function() {
                            f._state = "loaded",
                            F(),
                            C.removeEventListener(t._canPlayEvent, U, !1)
                        };
                        C.addEventListener(t._canPlayEvent, U, !1),
                        f._clearTimer(g._id)
                    }
                }
                return g._id
            },
            pause: function(h) {
                var u = this;
                if (u._state !== "loaded" || u._playLock)
                    return u._queue.push({
                        event: "pause",
                        action: function() {
                            u.pause(h)
                        }
                    }),
                    u;
                for (var f = u._getSoundIds(h), p = 0; p < f.length; p++) {
                    u._clearTimer(f[p]);
                    var _ = u._soundById(f[p]);
                    if (_ && !_._paused && (_._seek = u.seek(f[p]),
                    _._rateSeek = 0,
                    _._paused = !0,
                    u._stopFade(f[p]),
                    _._node))
                        if (u._webAudio) {
                            if (!_._node.bufferSource)
                                continue;
                            typeof _._node.bufferSource.stop > "u" ? _._node.bufferSource.noteOff(0) : _._node.bufferSource.stop(0),
                            u._cleanBuffer(_._node)
                        } else
                            (!isNaN(_._node.duration) || _._node.duration === 1 / 0) && _._node.pause();
                    arguments[1] || u._emit("pause", _ ? _._id : null)
                }
                return u
            },
            stop: function(h, u) {
                var f = this;
                if (f._state !== "loaded" || f._playLock)
                    return f._queue.push({
                        event: "stop",
                        action: function() {
                            f.stop(h)
                        }
                    }),
                    f;
                for (var p = f._getSoundIds(h), _ = 0; _ < p.length; _++) {
                    f._clearTimer(p[_]);
                    var m = f._soundById(p[_]);
                    m && (m._seek = m._start || 0,
                    m._rateSeek = 0,
                    m._paused = !0,
                    m._ended = !0,
                    f._stopFade(p[_]),
                    m._node && (f._webAudio ? m._node.bufferSource && (typeof m._node.bufferSource.stop > "u" ? m._node.bufferSource.noteOff(0) : m._node.bufferSource.stop(0),
                    f._cleanBuffer(m._node)) : (!isNaN(m._node.duration) || m._node.duration === 1 / 0) && (m._node.currentTime = m._start || 0,
                    m._node.pause(),
                    m._node.duration === 1 / 0 && f._clearSound(m._node))),
                    u || f._emit("stop", m._id))
                }
                return f
            },
            mute: function(h, u) {
                var f = this;
                if (f._state !== "loaded" || f._playLock)
                    return f._queue.push({
                        event: "mute",
                        action: function() {
                            f.mute(h, u)
                        }
                    }),
                    f;
                if (typeof u > "u")
                    if (typeof h == "boolean")
                        f._muted = h;
                    else
                        return f._muted;
                for (var p = f._getSoundIds(u), _ = 0; _ < p.length; _++) {
                    var m = f._soundById(p[_]);
                    m && (m._muted = h,
                    m._interval && f._stopFade(m._id),
                    f._webAudio && m._node ? m._node.gain.setValueAtTime(h ? 0 : m._volume, t.ctx.currentTime) : m._node && (m._node.muted = t._muted ? !0 : h),
                    f._emit("mute", m._id))
                }
                return f
            },
            volume: function() {
                var h = this, u = arguments, f, p;
                if (u.length === 0)
                    return h._volume;
                if (u.length === 1 || u.length === 2 && typeof u[1] > "u") {
                    var _ = h._getSoundIds()
                      , m = _.indexOf(u[0]);
                    m >= 0 ? p = parseInt(u[0], 10) : f = parseFloat(u[0])
                } else
                    u.length >= 2 && (f = parseFloat(u[0]),
                    p = parseInt(u[1], 10));
                var g;
                if (typeof f < "u" && f >= 0 && f <= 1) {
                    if (h._state !== "loaded" || h._playLock)
                        return h._queue.push({
                            event: "volume",
                            action: function() {
                                h.volume.apply(h, u)
                            }
                        }),
                        h;
                    typeof p > "u" && (h._volume = f),
                    p = h._getSoundIds(p);
                    for (var v = 0; v < p.length; v++)
                        g = h._soundById(p[v]),
                        g && (g._volume = f,
                        u[2] || h._stopFade(p[v]),
                        h._webAudio && g._node && !g._muted ? g._node.gain.setValueAtTime(f, t.ctx.currentTime) : g._node && !g._muted && (g._node.volume = f * t.volume()),
                        h._emit("volume", g._id))
                } else
                    return g = p ? h._soundById(p) : h._sounds[0],
                    g ? g._volume : 0;
                return h
            },
            fade: function(h, u, f, p) {
                var _ = this;
                if (_._state !== "loaded" || _._playLock)
                    return _._queue.push({
                        event: "fade",
                        action: function() {
                            _.fade(h, u, f, p)
                        }
                    }),
                    _;
                h = Math.min(Math.max(0, parseFloat(h)), 1),
                u = Math.min(Math.max(0, parseFloat(u)), 1),
                f = parseFloat(f),
                _.volume(h, p);
                for (var m = _._getSoundIds(p), g = 0; g < m.length; g++) {
                    var v = _._soundById(m[g]);
                    if (v) {
                        if (p || _._stopFade(m[g]),
                        _._webAudio && !v._muted) {
                            var x = t.ctx.currentTime
                              , S = x + f / 1e3;
                            v._volume = h,
                            v._node.gain.setValueAtTime(h, x),
                            v._node.gain.linearRampToValueAtTime(u, S)
                        }
                        _._startFadeInterval(v, h, u, f, m[g], typeof p > "u")
                    }
                }
                return _
            },
            _startFadeInterval: function(h, u, f, p, _, m) {
                var g = this
                  , v = u
                  , x = f - u
                  , S = Math.abs(x / .01)
                  , w = Math.max(4, S > 0 ? p / S : p)
                  , T = Date.now();
                h._fadeTo = f,
                h._interval = setInterval(function() {
                    var b = (Date.now() - T) / p;
                    T = Date.now(),
                    v += x * b,
                    v = Math.round(v * 100) / 100,
                    x < 0 ? v = Math.max(f, v) : v = Math.min(f, v),
                    g._webAudio ? h._volume = v : g.volume(v, h._id, !0),
                    m && (g._volume = v),
                    (f < u && v <= f || f > u && v >= f) && (clearInterval(h._interval),
                    h._interval = null,
                    h._fadeTo = null,
                    g.volume(f, h._id),
                    g._emit("fade", h._id))
                }, w)
            },
            _stopFade: function(h) {
                var u = this
                  , f = u._soundById(h);
                return f && f._interval && (u._webAudio && f._node.gain.cancelScheduledValues(t.ctx.currentTime),
                clearInterval(f._interval),
                f._interval = null,
                u.volume(f._fadeTo, h),
                f._fadeTo = null,
                u._emit("fade", h)),
                u
            },
            loop: function() {
                var h = this, u = arguments, f, p, _;
                if (u.length === 0)
                    return h._loop;
                if (u.length === 1)
                    if (typeof u[0] == "boolean")
                        f = u[0],
                        h._loop = f;
                    else
                        return _ = h._soundById(parseInt(u[0], 10)),
                        _ ? _._loop : !1;
                else
                    u.length === 2 && (f = u[0],
                    p = parseInt(u[1], 10));
                for (var m = h._getSoundIds(p), g = 0; g < m.length; g++)
                    _ = h._soundById(m[g]),
                    _ && (_._loop = f,
                    h._webAudio && _._node && _._node.bufferSource && (_._node.bufferSource.loop = f,
                    f && (_._node.bufferSource.loopStart = _._start || 0,
                    _._node.bufferSource.loopEnd = _._stop,
                    h.playing(m[g]) && (h.pause(m[g], !0),
                    h.play(m[g], !0)))));
                return h
            },
            rate: function() {
                var h = this, u = arguments, f, p;
                if (u.length === 0)
                    p = h._sounds[0]._id;
                else if (u.length === 1) {
                    var _ = h._getSoundIds()
                      , m = _.indexOf(u[0]);
                    m >= 0 ? p = parseInt(u[0], 10) : f = parseFloat(u[0])
                } else
                    u.length === 2 && (f = parseFloat(u[0]),
                    p = parseInt(u[1], 10));
                var g;
                if (typeof f == "number") {
                    if (h._state !== "loaded" || h._playLock)
                        return h._queue.push({
                            event: "rate",
                            action: function() {
                                h.rate.apply(h, u)
                            }
                        }),
                        h;
                    typeof p > "u" && (h._rate = f),
                    p = h._getSoundIds(p);
                    for (var v = 0; v < p.length; v++)
                        if (g = h._soundById(p[v]),
                        g) {
                            h.playing(p[v]) && (g._rateSeek = h.seek(p[v]),
                            g._playStart = h._webAudio ? t.ctx.currentTime : g._playStart),
                            g._rate = f,
                            h._webAudio && g._node && g._node.bufferSource ? g._node.bufferSource.playbackRate.setValueAtTime(f, t.ctx.currentTime) : g._node && (g._node.playbackRate = f);
                            var x = h.seek(p[v])
                              , S = (h._sprite[g._sprite][0] + h._sprite[g._sprite][1]) / 1e3 - x
                              , w = S * 1e3 / Math.abs(g._rate);
                            (h._endTimers[p[v]] || !g._paused) && (h._clearTimer(p[v]),
                            h._endTimers[p[v]] = setTimeout(h._ended.bind(h, g), w)),
                            h._emit("rate", g._id)
                        }
                } else
                    return g = h._soundById(p),
                    g ? g._rate : h._rate;
                return h
            },
            seek: function() {
                var h = this, u = arguments, f, p;
                if (u.length === 0)
                    h._sounds.length && (p = h._sounds[0]._id);
                else if (u.length === 1) {
                    var _ = h._getSoundIds()
                      , m = _.indexOf(u[0]);
                    m >= 0 ? p = parseInt(u[0], 10) : h._sounds.length && (p = h._sounds[0]._id,
                    f = parseFloat(u[0]))
                } else
                    u.length === 2 && (f = parseFloat(u[0]),
                    p = parseInt(u[1], 10));
                if (typeof p > "u")
                    return 0;
                if (typeof f == "number" && (h._state !== "loaded" || h._playLock))
                    return h._queue.push({
                        event: "seek",
                        action: function() {
                            h.seek.apply(h, u)
                        }
                    }),
                    h;
                var g = h._soundById(p);
                if (g)
                    if (typeof f == "number" && f >= 0) {
                        var v = h.playing(p);
                        v && h.pause(p, !0),
                        g._seek = f,
                        g._ended = !1,
                        h._clearTimer(p),
                        !h._webAudio && g._node && !isNaN(g._node.duration) && (g._node.currentTime = f);
                        var x = function() {
                            v && h.play(p, !0),
                            h._emit("seek", p)
                        };
                        if (v && !h._webAudio) {
                            var S = function() {
                                h._playLock ? setTimeout(S, 0) : x()
                            };
                            setTimeout(S, 0)
                        } else
                            x()
                    } else if (h._webAudio) {
                        var w = h.playing(p) ? t.ctx.currentTime - g._playStart : 0
                          , T = g._rateSeek ? g._rateSeek - g._seek : 0;
                        return g._seek + (T + w * Math.abs(g._rate))
                    } else
                        return g._node.currentTime;
                return h
            },
            playing: function(h) {
                var u = this;
                if (typeof h == "number") {
                    var f = u._soundById(h);
                    return f ? !f._paused : !1
                }
                for (var p = 0; p < u._sounds.length; p++)
                    if (!u._sounds[p]._paused)
                        return !0;
                return !1
            },
            duration: function(h) {
                var u = this
                  , f = u._duration
                  , p = u._soundById(h);
                return p && (f = u._sprite[p._sprite][1] / 1e3),
                f
            },
            state: function() {
                return this._state
            },
            unload: function() {
                for (var h = this, u = h._sounds, f = 0; f < u.length; f++)
                    u[f]._paused || h.stop(u[f]._id),
                    h._webAudio || (h._clearSound(u[f]._node),
                    u[f]._node.removeEventListener("error", u[f]._errorFn, !1),
                    u[f]._node.removeEventListener(t._canPlayEvent, u[f]._loadFn, !1),
                    u[f]._node.removeEventListener("ended", u[f]._endFn, !1),
                    t._releaseHtml5Audio(u[f]._node)),
                    delete u[f]._node,
                    h._clearTimer(u[f]._id);
                var p = t._howls.indexOf(h);
                p >= 0 && t._howls.splice(p, 1);
                var _ = !0;
                for (f = 0; f < t._howls.length; f++)
                    if (t._howls[f]._src === h._src || h._src.indexOf(t._howls[f]._src) >= 0) {
                        _ = !1;
                        break
                    }
                return n && _ && delete n[h._src],
                t.noAudio = !1,
                h._state = "unloaded",
                h._sounds = [],
                h = null,
                null
            },
            on: function(h, u, f, p) {
                var _ = this
                  , m = _["_on" + h];
                return typeof u == "function" && m.push(p ? {
                    id: f,
                    fn: u,
                    once: p
                } : {
                    id: f,
                    fn: u
                }),
                _
            },
            off: function(h, u, f) {
                var p = this
                  , _ = p["_on" + h]
                  , m = 0;
                if (typeof u == "number" && (f = u,
                u = null),
                u || f)
                    for (m = 0; m < _.length; m++) {
                        var g = f === _[m].id;
                        if (u === _[m].fn && g || !u && g) {
                            _.splice(m, 1);
                            break
                        }
                    }
                else if (h)
                    p["_on" + h] = [];
                else {
                    var v = Object.keys(p);
                    for (m = 0; m < v.length; m++)
                        v[m].indexOf("_on") === 0 && Array.isArray(p[v[m]]) && (p[v[m]] = [])
                }
                return p
            },
            once: function(h, u, f) {
                var p = this;
                return p.on(h, u, f, 1),
                p
            },
            _emit: function(h, u, f) {
                for (var p = this, _ = p["_on" + h], m = _.length - 1; m >= 0; m--)
                    (!_[m].id || _[m].id === u || h === "load") && (setTimeout((function(g) {
                        g.call(this, u, f)
                    }
                    ).bind(p, _[m].fn), 0),
                    _[m].once && p.off(h, _[m].fn, _[m].id));
                return p._loadQueue(h),
                p
            },
            _loadQueue: function(h) {
                var u = this;
                if (u._queue.length > 0) {
                    var f = u._queue[0];
                    f.event === h && (u._queue.shift(),
                    u._loadQueue()),
                    h || f.action()
                }
                return u
            },
            _ended: function(h) {
                var u = this
                  , f = h._sprite;
                if (!u._webAudio && h._node && !h._node.paused && !h._node.ended && h._node.currentTime < h._stop)
                    return setTimeout(u._ended.bind(u, h), 100),
                    u;
                var p = !!(h._loop || u._sprite[f][2]);
                if (u._emit("end", h._id),
                !u._webAudio && p && u.stop(h._id, !0).play(h._id),
                u._webAudio && p) {
                    u._emit("play", h._id),
                    h._seek = h._start || 0,
                    h._rateSeek = 0,
                    h._playStart = t.ctx.currentTime;
                    var _ = (h._stop - h._start) * 1e3 / Math.abs(h._rate);
                    u._endTimers[h._id] = setTimeout(u._ended.bind(u, h), _)
                }
                return u._webAudio && !p && (h._paused = !0,
                h._ended = !0,
                h._seek = h._start || 0,
                h._rateSeek = 0,
                u._clearTimer(h._id),
                u._cleanBuffer(h._node),
                t._autoSuspend()),
                !u._webAudio && !p && u.stop(h._id, !0),
                u
            },
            _clearTimer: function(h) {
                var u = this;
                if (u._endTimers[h]) {
                    if (typeof u._endTimers[h] != "function")
                        clearTimeout(u._endTimers[h]);
                    else {
                        var f = u._soundById(h);
                        f && f._node && f._node.removeEventListener("ended", u._endTimers[h], !1)
                    }
                    delete u._endTimers[h]
                }
                return u
            },
            _soundById: function(h) {
                for (var u = this, f = 0; f < u._sounds.length; f++)
                    if (h === u._sounds[f]._id)
                        return u._sounds[f];
                return null
            },
            _inactiveSound: function() {
                var h = this;
                h._drain();
                for (var u = 0; u < h._sounds.length; u++)
                    if (h._sounds[u]._ended)
                        return h._sounds[u].reset();
                return new i(h)
            },
            _drain: function() {
                var h = this
                  , u = h._pool
                  , f = 0
                  , p = 0;
                if (!(h._sounds.length < u)) {
                    for (p = 0; p < h._sounds.length; p++)
                        h._sounds[p]._ended && f++;
                    for (p = h._sounds.length - 1; p >= 0; p--) {
                        if (f <= u)
                            return;
                        h._sounds[p]._ended && (h._webAudio && h._sounds[p]._node && h._sounds[p]._node.disconnect(0),
                        h._sounds.splice(p, 1),
                        f--)
                    }
                }
            },
            _getSoundIds: function(h) {
                var u = this;
                if (typeof h > "u") {
                    for (var f = [], p = 0; p < u._sounds.length; p++)
                        f.push(u._sounds[p]._id);
                    return f
                } else
                    return [h]
            },
            _refreshBuffer: function(h) {
                var u = this;
                return h._node.bufferSource = t.ctx.createBufferSource(),
                h._node.bufferSource.buffer = n[u._src],
                h._panner ? h._node.bufferSource.connect(h._panner) : h._node.bufferSource.connect(h._node),
                h._node.bufferSource.loop = h._loop,
                h._loop && (h._node.bufferSource.loopStart = h._start || 0,
                h._node.bufferSource.loopEnd = h._stop || 0),
                h._node.bufferSource.playbackRate.setValueAtTime(h._rate, t.ctx.currentTime),
                u
            },
            _cleanBuffer: function(h) {
                var u = this
                  , f = t._navigator && t._navigator.vendor.indexOf("Apple") >= 0;
                if (!h.bufferSource)
                    return u;
                if (t._scratchBuffer && h.bufferSource && (h.bufferSource.onended = null,
                h.bufferSource.disconnect(0),
                f))
                    try {
                        h.bufferSource.buffer = t._scratchBuffer
                    } catch {}
                return h.bufferSource = null,
                u
            },
            _clearSound: function(h) {
                var u = /MSIE |Trident\//.test(t._navigator && t._navigator.userAgent);
                u || (h.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")
            }
        };
        var i = function(h) {
            this._parent = h,
            this.init()
        };
        i.prototype = {
            init: function() {
                var h = this
                  , u = h._parent;
                return h._muted = u._muted,
                h._loop = u._loop,
                h._volume = u._volume,
                h._rate = u._rate,
                h._seek = 0,
                h._paused = !0,
                h._ended = !0,
                h._sprite = "__default",
                h._id = ++t._counter,
                u._sounds.push(h),
                h.create(),
                h
            },
            create: function() {
                var h = this
                  , u = h._parent
                  , f = t._muted || h._muted || h._parent._muted ? 0 : h._volume;
                return u._webAudio ? (h._node = typeof t.ctx.createGain > "u" ? t.ctx.createGainNode() : t.ctx.createGain(),
                h._node.gain.setValueAtTime(f, t.ctx.currentTime),
                h._node.paused = !0,
                h._node.connect(t.masterGain)) : t.noAudio || (h._node = t._obtainHtml5Audio(),
                h._errorFn = h._errorListener.bind(h),
                h._node.addEventListener("error", h._errorFn, !1),
                h._loadFn = h._loadListener.bind(h),
                h._node.addEventListener(t._canPlayEvent, h._loadFn, !1),
                h._endFn = h._endListener.bind(h),
                h._node.addEventListener("ended", h._endFn, !1),
                h._node.src = u._src,
                h._node.preload = u._preload === !0 ? "auto" : u._preload,
                h._node.volume = f * t.volume(),
                h._node.load()),
                h
            },
            reset: function() {
                var h = this
                  , u = h._parent;
                return h._muted = u._muted,
                h._loop = u._loop,
                h._volume = u._volume,
                h._rate = u._rate,
                h._seek = 0,
                h._rateSeek = 0,
                h._paused = !0,
                h._ended = !0,
                h._sprite = "__default",
                h._id = ++t._counter,
                h
            },
            _errorListener: function() {
                var h = this;
                h._parent._emit("loaderror", h._id, h._node.error ? h._node.error.code : 0),
                h._node.removeEventListener("error", h._errorFn, !1)
            },
            _loadListener: function() {
                var h = this
                  , u = h._parent;
                u._duration = Math.ceil(h._node.duration * 10) / 10,
                Object.keys(u._sprite).length === 0 && (u._sprite = {
                    __default: [0, u._duration * 1e3]
                }),
                u._state !== "loaded" && (u._state = "loaded",
                u._emit("load"),
                u._loadQueue()),
                h._node.removeEventListener(t._canPlayEvent, h._loadFn, !1)
            },
            _endListener: function() {
                var h = this
                  , u = h._parent;
                u._duration === 1 / 0 && (u._duration = Math.ceil(h._node.duration * 10) / 10,
                u._sprite.__default[1] === 1 / 0 && (u._sprite.__default[1] = u._duration * 1e3),
                u._ended(h)),
                h._node.removeEventListener("ended", h._endFn, !1)
            }
        };
        var n = {}
          , r = function(h) {
            var u = h._src;
            if (n[u]) {
                h._duration = n[u].duration,
                c(h);
                return
            }
            if (/^data:[^;]+;base64,/.test(u)) {
                for (var f = atob(u.split(",")[1]), p = new Uint8Array(f.length), _ = 0; _ < f.length; ++_)
                    p[_] = f.charCodeAt(_);
                l(p.buffer, h)
            } else {
                var m = new XMLHttpRequest;
                m.open(h._xhr.method, u, !0),
                m.withCredentials = h._xhr.withCredentials,
                m.responseType = "arraybuffer",
                h._xhr.headers && Object.keys(h._xhr.headers).forEach(function(g) {
                    m.setRequestHeader(g, h._xhr.headers[g])
                }),
                m.onload = function() {
                    var g = (m.status + "")[0];
                    if (g !== "0" && g !== "2" && g !== "3") {
                        h._emit("loaderror", null, "Failed loading audio file with status: " + m.status + ".");
                        return
                    }
                    l(m.response, h)
                }
                ,
                m.onerror = function() {
                    h._webAudio && (h._html5 = !0,
                    h._webAudio = !1,
                    h._sounds = [],
                    delete n[u],
                    h.load())
                }
                ,
                o(m)
            }
        }
          , o = function(h) {
            try {
                h.send()
            } catch {
                h.onerror()
            }
        }
          , l = function(h, u) {
            var f = function() {
                u._emit("loaderror", null, "Decoding audio data failed.")
            }
              , p = function(_) {
                _ && u._sounds.length > 0 ? (n[u._src] = _,
                c(u, _)) : f()
            };
            typeof Promise < "u" && t.ctx.decodeAudioData.length === 1 ? t.ctx.decodeAudioData(h).then(p).catch(f) : t.ctx.decodeAudioData(h, p, f)
        }
          , c = function(h, u) {
            u && !h._duration && (h._duration = u.duration),
            Object.keys(h._sprite).length === 0 && (h._sprite = {
                __default: [0, h._duration * 1e3]
            }),
            h._state !== "loaded" && (h._state = "loaded",
            h._emit("load"),
            h._loadQueue())
        }
          , d = function() {
            if (t.usingWebAudio) {
                try {
                    typeof AudioContext < "u" ? t.ctx = new AudioContext : typeof webkitAudioContext < "u" ? t.ctx = new webkitAudioContext : t.usingWebAudio = !1
                } catch {
                    t.usingWebAudio = !1
                }
                t.ctx || (t.usingWebAudio = !1);
                var h = /iP(hone|od|ad)/.test(t._navigator && t._navigator.platform)
                  , u = t._navigator && t._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/)
                  , f = u ? parseInt(u[1], 10) : null;
                if (h && f && f < 9) {
                    var p = /safari/.test(t._navigator && t._navigator.userAgent.toLowerCase());
                    t._navigator && !p && (t.usingWebAudio = !1)
                }
                t.usingWebAudio && (t.masterGain = typeof t.ctx.createGain > "u" ? t.ctx.createGainNode() : t.ctx.createGain(),
                t.masterGain.gain.setValueAtTime(t._muted ? 0 : t._volume, t.ctx.currentTime),
                t.masterGain.connect(t.ctx.destination)),
                t._setup()
            }
        };
        a.Howler = t,
        a.Howl = s,
        typeof Nl < "u" ? (Nl.HowlerGlobal = e,
        Nl.Howler = t,
        Nl.Howl = s,
        Nl.Sound = i) : typeof window < "u" && (window.HowlerGlobal = e,
        window.Howler = t,
        window.Howl = s,
        window.Sound = i)
    }
    )();
    /*!
 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
 *  
 *  howler.js v2.2.4
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */
    (function() {
        HowlerGlobal.prototype._pos = [0, 0, 0],
        HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0],
        HowlerGlobal.prototype.stereo = function(t) {
            var s = this;
            if (!s.ctx || !s.ctx.listener)
                return s;
            for (var i = s._howls.length - 1; i >= 0; i--)
                s._howls[i].stereo(t);
            return s
        }
        ,
        HowlerGlobal.prototype.pos = function(t, s, i) {
            var n = this;
            if (!n.ctx || !n.ctx.listener)
                return n;
            if (s = typeof s != "number" ? n._pos[1] : s,
            i = typeof i != "number" ? n._pos[2] : i,
            typeof t == "number")
                n._pos = [t, s, i],
                typeof n.ctx.listener.positionX < "u" ? (n.ctx.listener.positionX.setTargetAtTime(n._pos[0], Howler.ctx.currentTime, .1),
                n.ctx.listener.positionY.setTargetAtTime(n._pos[1], Howler.ctx.currentTime, .1),
                n.ctx.listener.positionZ.setTargetAtTime(n._pos[2], Howler.ctx.currentTime, .1)) : n.ctx.listener.setPosition(n._pos[0], n._pos[1], n._pos[2]);
            else
                return n._pos;
            return n
        }
        ,
        HowlerGlobal.prototype.orientation = function(t, s, i, n, r, o) {
            var l = this;
            if (!l.ctx || !l.ctx.listener)
                return l;
            var c = l._orientation;
            if (s = typeof s != "number" ? c[1] : s,
            i = typeof i != "number" ? c[2] : i,
            n = typeof n != "number" ? c[3] : n,
            r = typeof r != "number" ? c[4] : r,
            o = typeof o != "number" ? c[5] : o,
            typeof t == "number")
                l._orientation = [t, s, i, n, r, o],
                typeof l.ctx.listener.forwardX < "u" ? (l.ctx.listener.forwardX.setTargetAtTime(t, Howler.ctx.currentTime, .1),
                l.ctx.listener.forwardY.setTargetAtTime(s, Howler.ctx.currentTime, .1),
                l.ctx.listener.forwardZ.setTargetAtTime(i, Howler.ctx.currentTime, .1),
                l.ctx.listener.upX.setTargetAtTime(n, Howler.ctx.currentTime, .1),
                l.ctx.listener.upY.setTargetAtTime(r, Howler.ctx.currentTime, .1),
                l.ctx.listener.upZ.setTargetAtTime(o, Howler.ctx.currentTime, .1)) : l.ctx.listener.setOrientation(t, s, i, n, r, o);
            else
                return c;
            return l
        }
        ,
        Howl.prototype.init = function(t) {
            return function(s) {
                var i = this;
                return i._orientation = s.orientation || [1, 0, 0],
                i._stereo = s.stereo || null,
                i._pos = s.pos || null,
                i._pannerAttr = {
                    coneInnerAngle: typeof s.coneInnerAngle < "u" ? s.coneInnerAngle : 360,
                    coneOuterAngle: typeof s.coneOuterAngle < "u" ? s.coneOuterAngle : 360,
                    coneOuterGain: typeof s.coneOuterGain < "u" ? s.coneOuterGain : 0,
                    distanceModel: typeof s.distanceModel < "u" ? s.distanceModel : "inverse",
                    maxDistance: typeof s.maxDistance < "u" ? s.maxDistance : 1e4,
                    panningModel: typeof s.panningModel < "u" ? s.panningModel : "HRTF",
                    refDistance: typeof s.refDistance < "u" ? s.refDistance : 1,
                    rolloffFactor: typeof s.rolloffFactor < "u" ? s.rolloffFactor : 1
                },
                i._onstereo = s.onstereo ? [{
                    fn: s.onstereo
                }] : [],
                i._onpos = s.onpos ? [{
                    fn: s.onpos
                }] : [],
                i._onorientation = s.onorientation ? [{
                    fn: s.onorientation
                }] : [],
                t.call(this, s)
            }
        }(Howl.prototype.init),
        Howl.prototype.stereo = function(t, s) {
            var i = this;
            if (!i._webAudio)
                return i;
            if (i._state !== "loaded")
                return i._queue.push({
                    event: "stereo",
                    action: function() {
                        i.stereo(t, s)
                    }
                }),
                i;
            var n = typeof Howler.ctx.createStereoPanner > "u" ? "spatial" : "stereo";
            if (typeof s > "u")
                if (typeof t == "number")
                    i._stereo = t,
                    i._pos = [t, 0, 0];
                else
                    return i._stereo;
            for (var r = i._getSoundIds(s), o = 0; o < r.length; o++) {
                var l = i._soundById(r[o]);
                if (l)
                    if (typeof t == "number")
                        l._stereo = t,
                        l._pos = [t, 0, 0],
                        l._node && (l._pannerAttr.panningModel = "equalpower",
                        (!l._panner || !l._panner.pan) && e(l, n),
                        n === "spatial" ? typeof l._panner.positionX < "u" ? (l._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime),
                        l._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime),
                        l._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : l._panner.setPosition(t, 0, 0) : l._panner.pan.setValueAtTime(t, Howler.ctx.currentTime)),
                        i._emit("stereo", l._id);
                    else
                        return l._stereo
            }
            return i
        }
        ,
        Howl.prototype.pos = function(t, s, i, n) {
            var r = this;
            if (!r._webAudio)
                return r;
            if (r._state !== "loaded")
                return r._queue.push({
                    event: "pos",
                    action: function() {
                        r.pos(t, s, i, n)
                    }
                }),
                r;
            if (s = typeof s != "number" ? 0 : s,
            i = typeof i != "number" ? -.5 : i,
            typeof n > "u")
                if (typeof t == "number")
                    r._pos = [t, s, i];
                else
                    return r._pos;
            for (var o = r._getSoundIds(n), l = 0; l < o.length; l++) {
                var c = r._soundById(o[l]);
                if (c)
                    if (typeof t == "number")
                        c._pos = [t, s, i],
                        c._node && ((!c._panner || c._panner.pan) && e(c, "spatial"),
                        typeof c._panner.positionX < "u" ? (c._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime),
                        c._panner.positionY.setValueAtTime(s, Howler.ctx.currentTime),
                        c._panner.positionZ.setValueAtTime(i, Howler.ctx.currentTime)) : c._panner.setPosition(t, s, i)),
                        r._emit("pos", c._id);
                    else
                        return c._pos
            }
            return r
        }
        ,
        Howl.prototype.orientation = function(t, s, i, n) {
            var r = this;
            if (!r._webAudio)
                return r;
            if (r._state !== "loaded")
                return r._queue.push({
                    event: "orientation",
                    action: function() {
                        r.orientation(t, s, i, n)
                    }
                }),
                r;
            if (s = typeof s != "number" ? r._orientation[1] : s,
            i = typeof i != "number" ? r._orientation[2] : i,
            typeof n > "u")
                if (typeof t == "number")
                    r._orientation = [t, s, i];
                else
                    return r._orientation;
            for (var o = r._getSoundIds(n), l = 0; l < o.length; l++) {
                var c = r._soundById(o[l]);
                if (c)
                    if (typeof t == "number")
                        c._orientation = [t, s, i],
                        c._node && (c._panner || (c._pos || (c._pos = r._pos || [0, 0, -.5]),
                        e(c, "spatial")),
                        typeof c._panner.orientationX < "u" ? (c._panner.orientationX.setValueAtTime(t, Howler.ctx.currentTime),
                        c._panner.orientationY.setValueAtTime(s, Howler.ctx.currentTime),
                        c._panner.orientationZ.setValueAtTime(i, Howler.ctx.currentTime)) : c._panner.setOrientation(t, s, i)),
                        r._emit("orientation", c._id);
                    else
                        return c._orientation
            }
            return r
        }
        ,
        Howl.prototype.pannerAttr = function() {
            var t = this, s = arguments, i, n, r;
            if (!t._webAudio)
                return t;
            if (s.length === 0)
                return t._pannerAttr;
            if (s.length === 1)
                if (typeof s[0] == "object")
                    i = s[0],
                    typeof n > "u" && (i.pannerAttr || (i.pannerAttr = {
                        coneInnerAngle: i.coneInnerAngle,
                        coneOuterAngle: i.coneOuterAngle,
                        coneOuterGain: i.coneOuterGain,
                        distanceModel: i.distanceModel,
                        maxDistance: i.maxDistance,
                        refDistance: i.refDistance,
                        rolloffFactor: i.rolloffFactor,
                        panningModel: i.panningModel
                    }),
                    t._pannerAttr = {
                        coneInnerAngle: typeof i.pannerAttr.coneInnerAngle < "u" ? i.pannerAttr.coneInnerAngle : t._coneInnerAngle,
                        coneOuterAngle: typeof i.pannerAttr.coneOuterAngle < "u" ? i.pannerAttr.coneOuterAngle : t._coneOuterAngle,
                        coneOuterGain: typeof i.pannerAttr.coneOuterGain < "u" ? i.pannerAttr.coneOuterGain : t._coneOuterGain,
                        distanceModel: typeof i.pannerAttr.distanceModel < "u" ? i.pannerAttr.distanceModel : t._distanceModel,
                        maxDistance: typeof i.pannerAttr.maxDistance < "u" ? i.pannerAttr.maxDistance : t._maxDistance,
                        refDistance: typeof i.pannerAttr.refDistance < "u" ? i.pannerAttr.refDistance : t._refDistance,
                        rolloffFactor: typeof i.pannerAttr.rolloffFactor < "u" ? i.pannerAttr.rolloffFactor : t._rolloffFactor,
                        panningModel: typeof i.pannerAttr.panningModel < "u" ? i.pannerAttr.panningModel : t._panningModel
                    });
                else
                    return r = t._soundById(parseInt(s[0], 10)),
                    r ? r._pannerAttr : t._pannerAttr;
            else
                s.length === 2 && (i = s[0],
                n = parseInt(s[1], 10));
            for (var o = t._getSoundIds(n), l = 0; l < o.length; l++)
                if (r = t._soundById(o[l]),
                r) {
                    var c = r._pannerAttr;
                    c = {
                        coneInnerAngle: typeof i.coneInnerAngle < "u" ? i.coneInnerAngle : c.coneInnerAngle,
                        coneOuterAngle: typeof i.coneOuterAngle < "u" ? i.coneOuterAngle : c.coneOuterAngle,
                        coneOuterGain: typeof i.coneOuterGain < "u" ? i.coneOuterGain : c.coneOuterGain,
                        distanceModel: typeof i.distanceModel < "u" ? i.distanceModel : c.distanceModel,
                        maxDistance: typeof i.maxDistance < "u" ? i.maxDistance : c.maxDistance,
                        refDistance: typeof i.refDistance < "u" ? i.refDistance : c.refDistance,
                        rolloffFactor: typeof i.rolloffFactor < "u" ? i.rolloffFactor : c.rolloffFactor,
                        panningModel: typeof i.panningModel < "u" ? i.panningModel : c.panningModel
                    };
                    var d = r._panner;
                    d || (r._pos || (r._pos = t._pos || [0, 0, -.5]),
                    e(r, "spatial"),
                    d = r._panner),
                    d.coneInnerAngle = c.coneInnerAngle,
                    d.coneOuterAngle = c.coneOuterAngle,
                    d.coneOuterGain = c.coneOuterGain,
                    d.distanceModel = c.distanceModel,
                    d.maxDistance = c.maxDistance,
                    d.refDistance = c.refDistance,
                    d.rolloffFactor = c.rolloffFactor,
                    d.panningModel = c.panningModel
                }
            return t
        }
        ,
        Sound.prototype.init = function(t) {
            return function() {
                var s = this
                  , i = s._parent;
                s._orientation = i._orientation,
                s._stereo = i._stereo,
                s._pos = i._pos,
                s._pannerAttr = i._pannerAttr,
                t.call(this),
                s._stereo ? i.stereo(s._stereo) : s._pos && i.pos(s._pos[0], s._pos[1], s._pos[2], s._id)
            }
        }(Sound.prototype.init),
        Sound.prototype.reset = function(t) {
            return function() {
                var s = this
                  , i = s._parent;
                return s._orientation = i._orientation,
                s._stereo = i._stereo,
                s._pos = i._pos,
                s._pannerAttr = i._pannerAttr,
                s._stereo ? i.stereo(s._stereo) : s._pos ? i.pos(s._pos[0], s._pos[1], s._pos[2], s._id) : s._panner && (s._panner.disconnect(0),
                s._panner = void 0,
                i._refreshBuffer(s)),
                t.call(this)
            }
        }(Sound.prototype.reset);
        var e = function(t, s) {
            s = s || "spatial",
            s === "spatial" ? (t._panner = Howler.ctx.createPanner(),
            t._panner.coneInnerAngle = t._pannerAttr.coneInnerAngle,
            t._panner.coneOuterAngle = t._pannerAttr.coneOuterAngle,
            t._panner.coneOuterGain = t._pannerAttr.coneOuterGain,
            t._panner.distanceModel = t._pannerAttr.distanceModel,
            t._panner.maxDistance = t._pannerAttr.maxDistance,
            t._panner.refDistance = t._pannerAttr.refDistance,
            t._panner.rolloffFactor = t._pannerAttr.rolloffFactor,
            t._panner.panningModel = t._pannerAttr.panningModel,
            typeof t._panner.positionX < "u" ? (t._panner.positionX.setValueAtTime(t._pos[0], Howler.ctx.currentTime),
            t._panner.positionY.setValueAtTime(t._pos[1], Howler.ctx.currentTime),
            t._panner.positionZ.setValueAtTime(t._pos[2], Howler.ctx.currentTime)) : t._panner.setPosition(t._pos[0], t._pos[1], t._pos[2]),
            typeof t._panner.orientationX < "u" ? (t._panner.orientationX.setValueAtTime(t._orientation[0], Howler.ctx.currentTime),
            t._panner.orientationY.setValueAtTime(t._orientation[1], Howler.ctx.currentTime),
            t._panner.orientationZ.setValueAtTime(t._orientation[2], Howler.ctx.currentTime)) : t._panner.setOrientation(t._orientation[0], t._orientation[1], t._orientation[2])) : (t._panner = Howler.ctx.createStereoPanner(),
            t._panner.pan.setValueAtTime(t._stereo, Howler.ctx.currentTime)),
            t._panner.connect(t._node),
            t._paused || t._parent.pause(t._id, !0).play(t._id, !0)
        }
    }
    )()
}
)(dn);
const nN = Object.freeze({
    ValueChanged: "GameStorage:ValueChanged"
})
  , Ru = class Ru extends fe {
    constructor() {
        super(),
        this.gameCode = B.GAME_CODE,
        B.STORAGE.CLEAR_ON_START && this.clear()
    }
    clear() {
        localStorage.clear()
    }
    getItem(e) {
        return e = this.getStorageKey(e),
        localStorage.getItem(e)
    }
    setItem(e, t) {
        e = this.getStorageKey(e),
        localStorage.setItem(e, t),
        this.fire(nN.ValueChanged, e)
    }
    addInt(e, t) {
        var s = this.getInt(e);
        return this.setItem(e, s + t),
        s + t
    }
    addFloat(e, t) {
        var s = this.getFloat(e);
        this.setItem(e, s + t)
    }
    getInt(e, t=0) {
        var s = parseInt(this.getItem(e));
        return s || (s = t),
        s
    }
    getFloat(e) {
        var t = parseFloat(this.getItem(e));
        return t || (t = 0),
        t
    }
    getObject(e) {
        var t = this.getItem(e);
        return t || (t = null),
        JSON.parse(t)
    }
    getString(e, t="") {
        var s = this.getItem(e);
        return s || (s = t),
        s
    }
    getStorageKey(e) {
        return `${B.GAME_CODE}_${e}`
    }
}
;
ti(Ru, "instance", new Ru);
let Ie = Ru;
const hi = class hi {
    static loadSetting() {
        let e = Ie.instance.getObject(B.STORAGE.KEY_SETTING);
        e ? hi._settings = e : hi.saveSetting(),
        Qe.muteAllMusic(!hi._settings.music),
        Qe.muteAllSound(!hi._settings.sound)
    }
    static saveSetting() {
        Ie.instance.setItem(B.STORAGE.KEY_SETTING, JSON.stringify(hi._settings))
    }
    static get(e) {
        return hi._settings[e]
    }
    static set(e, t) {
        switch (hi._settings[e] = t,
        hi.saveSetting(),
        e) {
        case "music":
            Qe.muteAllMusic(!t);
            break;
        case "sound":
            Qe.muteAllSound(!t);
            break
        }
    }
}
;
ti(hi, "_settings", {
    music: !0,
    sound: !0,
    vibration: !0
});
let En = hi;
class Qe {
    static _onStateChange(e) {
        var t, s;
        console.log("state change", e.target.state),
        e.target.state === "running" && ((t = this.suspendedSounds) == null || t.forEach(i => {
            (i.timeStart + i.audio.duration() * 1e3 < performance.now() || i.loop) && this.play(i.name, 1, i.loop)
        }
        ),
        (s = this.suspendedMusics) == null || s.forEach(i => {
            (i.timeStart + i.audio.duration() * 1e3 < performance.now() || i.loop) && this.playMusic(i.name, 1, i.loop)
        }
        ))
    }
    static async load(e) {
        this.audios = {},
        this.songs = {};
        let t = [];
        for (const s in e)
            t.push(this.loadAudio(s, e[s]));
        await Promise.all(t),
        dn.Howler.ctx.addEventListener("statechange", this._onStateChange.bind(this)),
        dn.Howler.ctx.resume(),
        this.analyser = dn.Howler.ctx.createAnalyser(),
        dn.Howler.autoSuspend = !1
    }
    static loadAudio(e, t) {
        return new Promise(s => {
            if (this.audios[e])
                return s();
            this.audios[e] = new dn.Howl({
                src: t,
                onloaderror: (i, n) => console.error("SoundManager", "Load error", i, n),
                onplayerror: (i, n) => console.error("SoundManager", "Play error", i, n),
                onload: () => s()
            })
        }
        )
    }
    static play(e, t=1, s=!1) {
        var i = this.audios[e]
          , n = i.play();
        return i.volume(t),
        i.loop(s),
        En.get("sound") === !1 && this.muteSound(e, !0),
        n
    }
    static playMusic(e, t=1, s=!0) {
        var i = this.audios[e]
          , n = i.play();
        return i.volume(t),
        i.loop(s),
        this.songs[e] = i,
        En.get("music") === !1 && i.mute(!0),
        n
    }
    static isPlaying(e) {
        return this.audios[e].playing()
    }
    static stop(e, t) {
        this.audios[e].stop(t)
    }
    static muteAll(e) {
        dn.Howler.mute(e)
    }
    static muteAllSound(e) {
        for (var t in this.audios)
            this.songs[t] || this.muteSound(t, e)
    }
    static muteSound(e, t) {
        var s;
        (s = this.audios[e]) == null || s.mute(t)
    }
    static muteAllMusic(e) {
        for (var t in this.songs)
            this.muteMusic(t, e)
    }
    static muteMusic(e, t) {
        console.log("mute all music", e, t),
        this.audios[e].mute(t)
    }
    static pause(e, t) {
        if (!this.enabled)
            return;
        let s = this.audios[e];
        if (!s) {
            console.error("PurusSound", `Audio ${e} not found`);
            return
        }
        t ? s.pause(t) : s.pause()
    }
    static resume(e, t) {
        if (!this.enabled)
            return;
        let s = this.audios[e];
        if (!s) {
            console.error("PurusSound", `Audio ${e} not found`);
            return
        }
        t ? s.play(t) : s.play(),
        this.resumeAudioContext()
    }
    static resumeAudioContext() {
        dn.Howler.ctx.state !== "running" && dn.Howler.ctx.resume()
    }
    static skip(e, t, s) {
        let i = this.audios[e].seek(t);
        this.audios[e].seek(i + s, t)
    }
    static getCurrentTime(e, t) {
        return this.audios[e].seek(t)
    }
    static reset(e, t=void 0) {
        this.audios[e].stop(t),
        this.audios[e].seek(0)
    }
    static getDuration(e) {
        return this.audios[e].duration()
    }
}
ti(Qe, "enabled", !0);
class X {
    static init(e) {
        this.app = e,
        this.assets = e.assets;
        let t = new le("assetData","json",{
            url: "assets/assetData.json"
        })
          , s = new Promise(i => {
            t.on("load", () => {
                this.assetData = t.resource,
                i()
            }
            )
        }
        );
        return this.assets.load(t),
        s
    }
    static load() {
        const e = []
          , t = [];
        for (const n in this.assetData.textures)
            t.push(this.getAsset(n, "texture", this.assetData.textures[n]));
        for (const n in this.assetData.models)
            t.push(this.getAsset(n, "model", this.assetData.models[n]));
        for (const n in this.assetData.fonts)
            t.push(this.getAsset(n, "font", this.assetData.fonts[n]));
        for (const n in this.assetData.jsons)
            n === "stateGraphData.json" ? t.push(this.getAsset(n, "animstategraph", this.assetData.jsons[n])) : t.push(this.getAsset(n, "json", this.assetData.jsons[n]));
        for (const n in this.assetData.materials)
            t.push(this.getAsset(n, "material", this.assetData.materials[n]));
        for (const n in this.assetData.texts)
            t.push(this.getAsset(n, "text", this.assetData.texts[n]));
        for (const n in this.assetData.animations)
            t.push(this.getAsset(n, "animation", this.assetData.animations[n]));
        for (const n in this.assetData.cubemaps)
            t.push(this.loadCubeMap(n, this.assetData.cubemaps[n]));
        for (const n in this.assetData.rawModels)
            t.push(this.getAsset(n, "container", this.assetData.rawModels[n]));
        const s = new Zk(e,this.assets)
          , i = new Promise( (n, r) => {
            s.load(o => {
                o && r(o),
                n()
            }
            )
        }
        );
        t.push(i);
        for (const n in this.assetData.webfonts)
            t.push(this.loadWebFont(this.assetData.webfonts[n], n));
        return t.push(this._loadAtlases()),
        t.push(Qe.load(this.assetData.audios)),
        Promise.all(t)
    }
    static _loadAtlases() {
        const e = [];
        for (const t in this.assetData.atlas)
            e.push(this._loadAtlas(t, this.assetData.atlas[t]));
        return Promise.all(e)
    }
    static loadCubeMap(e, t) {
        return new Promise( (s, i) => {
            let n = this.assets._loader.getHandler("json");
            if (!n) {
                i("json handler not found");
                return
            }
            n.load(t, async (r, o) => {
                let l = o.textures.filter( (p, _, m) => m.indexOf(p) === _)
                  , c = [];
                for (let p of l)
                    c.push(this.loadFromUrl(p, "texture", p));
                let d = await Promise.all(c)
                  , h = new ge(this.app.graphicsDevice,{
                    cubemap: !0
                });
                h.name = e,
                h.anisotropy = o.anisotropy,
                h.minFilter = o.minFilter,
                h.magFilter = o.magFilter;
                let u = o.textures.map(p => d.find(_ => _.name === p));
                h.setSource(u),
                this.registerAsset(h, e, "cubemap");
                let f = new le(e,"cubemap");
                f.resource = h,
                f.loaded = !0,
                s(f)
            }
            )
        }
        )
    }
    static loadFromUrl(e, t, s, i=!1) {
        return new Promise( (n, r) => {
            this.assets.loadFromUrl(e, s, (o, l) => {
                o ? r(o) : (l.name = t,
                i && this.registerAsset(l.resource, t, s),
                n(l))
            }
            )
        }
        )
    }
    static _loadAtlas(e, t) {
        const s = new le(e,"texture",{
            url: t
        })
          , i = t.replace(".png", ".json").replace(".jpg", ".json")
          , n = new le(e,"json",{
            url: i
        });
        let r = !1
          , o = !1;
        return new Promise(c => {
            const d = new Ex
              , h = () => {
                for (const f in d.frames) {
                    const p = new Cx(te.app.graphicsDevice,{
                        atlas: d,
                        frameKeys: [f]
                    });
                    this.registerAsset(p, f, "sprite")
                }
                c()
            }
              , u = () => {
                if (r && o) {
                    const f = n.resource
                      , p = s.resource
                      , _ = {};
                    for (const m in f.frames) {
                        const g = f.frames[m].frame
                          , v = f.frames[m].pivot || {
                            x: 0,
                            y: 0
                        };
                        _[m] = {
                            rect: new M(g.x,p.height - g.y - g.h,g.w,g.h),
                            pivot: new P(v.x,v.y),
                            border: new M(0,0,0,0)
                        }
                    }
                    d.frames = _,
                    d.texture = p,
                    d.texture.name = e,
                    h()
                }
            }
            ;
            s.ready( () => {
                o = !0,
                u()
            }
            ),
            n.ready( () => {
                r = !0,
                u()
            }
            ),
            this.assets.load(s),
            this.assets.load(n)
        }
        )
    }
    static loadResource(e, t) {
        return t === "texture" ? this.loadFromUrl(this.assetData.resources.textures[e], e, "texture", !0) : t === "material" ? this.loadFromUrl(this.assetData.resources.materials[e], e, "material", !0) : t === "model" ? this.loadFromUrl(this.assetData.resources.models[e], e, "model", !0) : t === "json" ? this.loadFromUrl(this.assetData.resources.jsons[e], e, "json", !0) : t === "font" ? this.loadFromUrl(this.assetData.resources.fonts[e], e, "font", !0) : t === "cubemap" ? this.loadCubeMap(this.assetData.resources.cubemaps[e], e) : t === "audio" ? Qe.loadAudio(e, this.assetData.resources.audios[e]) : t === "rawModel" ? this.loadFromUrl(this.assetData.resources.rawModels[e], e, "container") : t === "webfont" ? this.loadWebFont(this.assetData.resources.webfonts[e], e) : Promise.reject(`Unknown type: ${t}`)
    }
    static hasResource(e, t) {
        if (t !== void 0)
            return this.assetData.resources[t][e] !== void 0;
        {
            let s = !1;
            for (let i in this.assetData.resources)
                s = s || this.assetData.resources[i][e] !== void 0;
            return s
        }
    }
    static registerAsset(e, t, s) {
        const i = new le(t,s);
        i.resource = e,
        i.loaded = !0,
        this.assets.add(i)
    }
    static getAsset(e, t, s) {
        return new Promise( (i, n) => {
            this.assets.loadFromUrl(s, t, (r, o) => {
                r ? (console.error(r),
                n(r)) : (o.name = e,
                i(o))
            }
            )
        }
        )
    }
    static loadWebFont(e, t) {
        const s = document.createElement("style");
        return s.innerHTML = `
      @font-face {
        font-family: "${t}";
        src: url(${e});
      }
    `,
        document.head.appendChild(s),
        new Promise(i => {
            s.onload = () => {
                i()
            }
        }
        )
    }
    static find(e) {
        return typeof e == "string" ? this.assets.find(e) : e
    }
    static findAll(e) {
        return this.assets.findAll(e)
    }
}
class Q {
    static init() {
        this.songData = X.find("songData.json").resources,
        this.songsUnlocked = Ie.instance.getObject(B.STORAGE.KEY_SONGS_UNLOCKED),
        this.songsUnlocked || (this.songsUnlocked = [B.STORAGE.KEY_DEFAULT_SONG],
        Ie.instance.setItem(B.STORAGE.KEY_SONGS_UNLOCKED, JSON.stringify(this.songsUnlocked))),
        this._currentSong = Ie.instance.getItem(B.STORAGE.KEY_CURRENT_SONG),
        this._currentSong || (this._currentSong = B.STORAGE.KEY_DEFAULT_SONG,
        Ie.instance.setItem(B.STORAGE.KEY_CURRENT_SONG, this.currentSong)),
        this._initSkinData(),
        this._initWeaponData(),
        this._initThemData(),
        this._initGamePlayHistory(),
        this._initCurrency(),
        this.updateSongData()
    }
    static get currentSong() {
        return this._currentSong
    }
    static set currentSong(e) {
        this._currentSong = e,
        Ie.instance.setItem(B.STORAGE.KEY_CURRENT_SONG, e)
    }
    static updateSongData() {
        this.songData.map(e => {
            e.unlocked = this.songsUnlocked.includes(e.id)
        }
        )
    }
    static async getSongData(e) {
        let t = `${e}.json`
          , s = X.find(t);
        return s || X.hasResource(t) && (s = await X.loadResource(t, "json")),
        s
    }
    static unlockSong(e) {
        this.songsUnlocked.includes(e) || (this.songsUnlocked.push(e),
        Ie.instance.setItem(B.STORAGE.KEY_SONGS_UNLOCKED, JSON.stringify(this.songsUnlocked)),
        this.addGamePlayHistory(e),
        this.updateSongData())
    }
    static getSongById(e) {
        return this.songData.find(t => t.id === e)
    }
    static isSongUnlocked(e) {
        return this.songsUnlocked.includes(e)
    }
    static _initSkinData() {
        this.skinsUnlocked = Ie.instance.getObject(B.STORAGE.KEY_SKIN_UNLOCKED),
        this.skinsUnlocked || (this.skinsUnlocked = [B.STORAGE.KEY_DEFAULT_SKIN],
        Ie.instance.setItem(B.STORAGE.KEY_SKIN_UNLOCKED, JSON.stringify(this.skinsUnlocked))),
        this._currentSkin = Ie.instance.getItem(B.STORAGE.KEY_CURRENT_SKIN),
        this._currentSkin || (this._currentSkin = B.STORAGE.KEY_DEFAULT_SKIN,
        Ie.instance.setItem(B.STORAGE.KEY_CURRENT_SKIN, this._currentSkin))
    }
    static IsSkinUnlocked(e) {
        return this.skinsUnlocked.includes(e)
    }
    static unlockSkin(e) {
        this.skinsUnlocked.includes(e) || (this.skinsUnlocked.push(e),
        Ie.instance.setItem(B.STORAGE.KEY_SKIN_UNLOCKED, JSON.stringify(this.skinsUnlocked)))
    }
    static get currentSkin() {
        return this._currentSkin
    }
    static set currentSkin(e) {
        this._currentSkin = e,
        Ie.instance.setItem(B.STORAGE.KEY_CURRENT_SKIN, e)
    }
    static _initWeaponData() {
        this.weaponsUnlocked = Ie.instance.getObject(B.STORAGE.KEY_WEAPON_UNLOCKED),
        this.weaponsUnlocked || (this.weaponsUnlocked = [B.STORAGE.KEY_DEFAULT_WEAPON],
        Ie.instance.setItem(B.STORAGE.KEY_WEAPON_UNLOCKED, JSON.stringify(this.weaponsUnlocked))),
        this._currentWeapon = Ie.instance.getItem(B.STORAGE.KEY_CURRENT_WEAPON),
        this._currentWeapon || (this._currentWeapon = B.STORAGE.KEY_DEFAULT_WEAPON,
        Ie.instance.setItem(B.STORAGE.KEY_CURRENT_WEAPON, this._currentWeapon))
    }
    static IsWeaponUnlocked(e) {
        return this.weaponsUnlocked.includes(e)
    }
    static unlockWeapon(e) {
        this.weaponsUnlocked.includes(e) || (this.weaponsUnlocked.push(e),
        Ie.instance.setItem(B.STORAGE.KEY_WEAPON_UNLOCKED, JSON.stringify(this.weaponsUnlocked)))
    }
    static get currentWeapon() {
        return this._currentWeapon
    }
    static set currentWeapon(e) {
        this._currentWeapon = e,
        Ie.instance.setItem(B.STORAGE.KEY_CURRENT_WEAPON, e)
    }
    static _initThemData() {
        this.themeUnlocked = Ie.instance.getObject(B.STORAGE.KEY_THEMES_UNLOCKED),
        this.themeUnlocked || (this.themeUnlocked = [B.STORAGE.KEY_DEFAULT_THEME],
        Ie.instance.setItem(B.STORAGE.KEY_THEMES_UNLOCKED, JSON.stringify(this.themeUnlocked))),
        this._currentTheme = Ie.instance.getItem(B.STORAGE.KEY_CURRENT_THEME),
        this._currentTheme || (this._currentTheme = B.STORAGE.KEY_DEFAULT_THEME,
        Ie.instance.setItem(B.STORAGE.KEY_CURRENT_THEME, this._currentTheme))
    }
    static IsThemeUnlocked(e) {
        return this.themeUnlocked.includes(e)
    }
    static unlockTheme(e) {
        this.themeUnlocked.includes(e) || (this.themeUnlocked.push(e),
        Ie.instance.setItem(B.STORAGE.KEY_THEMES_UNLOCKED, JSON.stringify(this.themeUnlocked)))
    }
    static get currentTheme() {
        return this._currentTheme
    }
    static set currentTheme(e) {
        this._currentTheme = e,
        Ie.instance.setItem(B.STORAGE.KEY_CURRENT_THEME, e)
    }
    static _initGamePlayHistory() {
        this.gamePlayHistory = Ie.instance.getObject(B.STORAGE.GAME_PLAY_HISTORY),
        this.gamePlayHistory || (this.gamePlayHistory = [{
            songId: B.STORAGE.KEY_DEFAULT_SONG,
            score: 0,
            stars: 0,
            isCompleted: !1,
            miss: 0,
            hit: 0
        }],
        this.saveGamePlayHistory())
    }
    static addGamePlayHistory(e) {
        let t = this.gamePlayHistory.find(s => s.songId === e);
        t || (t = {
            songId: e,
            score: 0,
            stars: 0,
            isCompleted: !1,
            miss: 0,
            hit: 0
        },
        this.gamePlayHistory.push(t)),
        this.saveGamePlayHistory()
    }
    static updateGamePlayHistory(e, t, s, i) {
        let n = this.gamePlayHistory.find(r => r.songId === e);
        n && (n.score = t,
        n.stars = s,
        n.isCompleted = i,
        this.saveGamePlayHistory())
    }
    static saveGamePlayHistory() {
        Ie.instance.setItem(B.STORAGE.GAME_PLAY_HISTORY, JSON.stringify(this.gamePlayHistory))
    }
    static _initCurrency() {
        this.currency = Ie.instance.getItem(B.STORAGE.KEY_CURRENCY),
        this.currency || (this.currency = B.STORAGE.DEFAULT_CURRENCY,
        Ie.instance.setItem(B.STORAGE.KEY_CURRENCY, this.currency))
    }
    static getCurrency() {
        return this.currency
    }
    static subCurrency(e) {
        this.currency = parseInt(this.currency) - parseInt(e),
        Ie.instance.setItem(B.STORAGE.KEY_CURRENCY, this.currency)
    }
    static addCurrency(e) {
        this.currency = parseInt(this.currency) + parseInt(e),
        Ie.instance.setItem(B.STORAGE.KEY_CURRENCY, this.currency)
    }
}
let J = class jl {
    static linear(e, t, s) {
        return e + (t - e) * s
    }
    static easeIn(e, t, s) {
        return e + (t - e) * s ** 2
    }
    static easeOut(e, t, s) {
        return e + (t - e) * (1 - (1 - s) ** 2)
    }
    static easeInOut(e, t, s) {
        return e + (t - e) * (-Math.cos(s * Math.PI) / 2 + .5)
    }
    static copyObject(e, t={}) {
        return Object.keys(e).forEach(s => {
            t[s] = e[s]
        }
        ),
        t
    }
    static sign(e) {
        return e < 0 ? -1 : 1
    }
    static random(e, t) {
        return Math.random() * (t - e) + e
    }
    static randomInt(e, t) {
        return Math.floor(Math.random() * (t - e + 1) + e)
    }
    static randomFromList(e) {
        if (e && e.length > 0) {
            let t = this.randomInt(0, e.length - 1);
            return e[t]
        } else
            return -1
    }
    static randomVector(e, t, s=new y) {
        return s.x = jl.random(e.x, t.x),
        s.y = jl.random(e.y, t.y),
        s.z = jl.random(e.z, t.z),
        s
    }
    static distanceBetween(e, t) {
        return Math.abs(Math.abs(e) - Math.abs(t))
    }
    static getAlpha(e, t) {
        return t === 0 ? 90 : this.toDegree(Math.atan(Math.abs(e) / Math.abs(t)))
    }
    static toDegree(e) {
        return e * 180 / Math.PI
    }
    static toRadian(e) {
        return e * Math.PI / 180
    }
    static getRandomIntExclude(e, t, s) {
        let i = Math.floor(Math.random() * (t - e)) + e;
        return i === s && (i = t),
        i
    }
    static getSpriteFrame(e, t=1) {
        let s = e.atlas.frames[e.frameKeys[0]].rect;
        return {
            x: s.x,
            y: s.y,
            width: s.z * t,
            height: s.w * t
        }
    }
    static getSpriteAtlasFrame(e) {
        return e.atlas.frames[e.frameKeys[0]]
    }
    static getSpriteWorldSize(e) {
        let t = this.getSpriteAtlasFrame(e);
        return {
            width: t.rect.z / e.pixelsPerUnit,
            height: t.rect.w / e.pixelsPerUnit
        }
    }
    static createColor(e=255, t=255, s=255, i=1) {
        return new z(e / 255,t / 255,s / 255,i)
    }
    static setSpriteDepthTest(e, t=!0) {
        let s = e._meshInstance.material.clone();
        s.depthTest = t,
        s.update(),
        e._meshInstance.material = s
    }
    static setUpEffectModel(e) {
        e.model.castShadows = !1,
        e.model.castShadowsLightmap = !1,
        e.model.receiveShadows = !1
    }
    static setModelOpacity(e, t) {
        e.model.meshInstances.forEach(s => {
            s.material.opacity = t,
            s.material.update()
        }
        )
    }
    static setModelMaterial(e, t, s=0) {
        e.model.meshInstances[s].material = t
    }
    static registerOnTouch(e, t, s) {
        e.useInput = !0,
        e.on("mousedown", t, s),
        e.on("touchstart", t, s)
    }
    static registerOnceTouch(e, t, s) {
        e.useInput = !0,
        e.once("mousedown", t, s),
        e.once("touchstart", t, s)
    }
    static updateCircleTransform(e, t, s, i) {
        let n = e.getLocalPosition()
          , r = n.x
          , o = t ** 2
          , l = r ** 2
          , c = Math.sqrt(o + l) + s;
        n.y = c,
        e.setLocalPosition(n);
        let d = e.getLocalEulerAngles()
          , h = jl.sign(n.x)
          , u = Math.abs(c - s)
          , f = Math.atan(u / Math.abs(r)) * 180 / Math.PI;
        d.z = -h * (f - 90) * i,
        e.setLocalEulerAngles(d)
    }
    static getCashFormat(e) {
        return e >= 1e9 ? `${(e / 1e9).toFixed(1).replace(/\.0$/, "")}B` : e >= 1e6 ? `${(e / 1e6).toFixed(1).replace(/\.0$/, "")}M` : e >= 1e3 ? `${(e / 1e3).toFixed(1).replace(/\.0$/, "")}K` : e
    }
    static shuffleArray(e) {
        for (let t = e.length - 1; t > 0; t--) {
            const s = Math.floor(Math.random() * (t + 1));
            [e[t],e[s]] = [e[s], e[t]]
        }
    }
}
;
function rN(a, e) {
    return typeof a != "function" || typeof e != "function" ? !1 : a.prototype instanceof e
}
new y;
new y;
new ne;
class j {
    static createCamera(e, t) {
        let s = new V(e);
        return s.addComponent("camera", t),
        s
    }
    static createColorBackground(e=new z, t=1) {
        let s = new V("spr_bg");
        return s.addComponent("element", {
            type: "image",
            anchor: new M(0,0,1,1),
            color: e,
            opacity: t
        }),
        s
    }
    static createModel(e, ...t) {
        let s = X.find(e)
          , i = new V(s.name);
        return i.addComponent("model", {
            asset: s
        }),
        t.forEach( (n, r) => {
            var o = X.find(n).resource;
            i.model.meshInstances[r].material = o
        }
        ),
        i
    }
    static createBox(e) {
        let t = new V;
        if (t.addComponent("model", {
            type: "box"
        }),
        e) {
            let s = X.find(e).resource;
            t.model.meshInstances[0].material = s
        }
        return t
    }
    static createSphere(e) {
        let t = new V;
        if (t.addComponent("model", {
            type: "sphere"
        }),
        e) {
            let s = X.find(e).resource;
            t.model.meshInstances[0].material = s
        }
        return t
    }
    static createCone(e) {
        let t = new V;
        return t.addComponent("model", {
            type: "cone"
        }),
        e && (t.model.meshInstances[0].material = e),
        t
    }
    static createPlane(e) {
        let t = new V;
        if (t.addComponent("model", {
            type: "plane"
        }),
        e) {
            let s = X.find(e);
            t.model.meshInstances[0].material = s.resource
        }
        return t
    }
    static createSprite(e) {
        let t = X.find(e)
          , s = new V(t.name);
        return s.addComponent("sprite", {
            spriteAsset: t
        }),
        s
    }
    static createImageElement(e, t={}) {
        t.type = Ae;
        const s = t.scale || 1;
        if (e)
            if (t.spriteAsset = X.find(e),
            t.spriteAsset) {
                const c = J.getSpriteFrame(t.spriteAsset.resource, s);
                t.width = t.width || c.width,
                t.height = t.height || c.height
            } else
                console.error(`Asset ${e} not found`);
        t.opacity = t.opacity || 1,
        t.anchor = t.anchor || new M(.5,.5,.5,.5),
        t.pivot = t.pivot || new P(.5,.5),
        t.useInput = t.useInput || !1;
        let i = t.name || t.spriteAsset.name
          , n = new V(i);
        n.addComponent("element", t);
        const r = t.x || 0
          , o = t.y || 0
          , l = t.z || 0;
        return n.setLocalPosition(r, o, l),
        n
    }
    static createEmptyImageElement(e={}) {
        let t = e.x || 0
          , s = e.y || 0
          , i = e.z || 0
          , n = e.opacity || 1
          , r = e.anchor || new M(.5,.5,.5,.5)
          , o = e.pivot || new P(.5,.5)
          , l = e.width || 100
          , c = e.height || 100
          , d = e.useInput || !1
          , h = new V("element")
          , u = e.color || new z(1,1,1);
        return h.addComponent("element", {
            type: Ae,
            anchor: r,
            pivot: o,
            opacity: n,
            color: u,
            width: l,
            height: c,
            useInput: d
        }),
        h.setLocalPosition(t, s, i),
        h
    }
    static createButtonElement(e, t={}) {
        t.useInput === void 0 && (t.useInput = !0);
        let s = this.createImageElement(e, t)
          , i = t.hoverTint || new z(.9,.9,.9)
          , n = t.pressedTint || new z(.5,.5,.5);
        return s.addComponent("button", {
            active: !0,
            hoverTint: i,
            pressedTint: n,
            imageEntity: s
        }),
        s
    }
    static createGroupElement(e={}) {
        let t = e.x || 0
          , s = e.y || 0
          , i = e.z || 0
          , n = e.anchor || new M(.5,.5,.5,.5)
          , r = e.pivot || new P(.5,.5)
          , o = e.name || "groupElement"
          , l = new V(o);
        return l.addComponent("element", {
            type: us,
            anchor: n,
            pivot: r,
            width: e.width,
            height: e.height
        }),
        l.setLocalPosition(t, s, i),
        l
    }
    static createLayoutGroupElement(e={}) {
        let t = this.createGroupElement(e)
          , s = e.orientation || Se
          , i = e.spacing || new P(0,0)
          , n = e.alignment || new P(.5,.5)
          , r = e.widthFitting || Fh
          , o = e.heightFitting || Fh
          , l = e.wrap || !1
          , c = e.padding || new M(0,0,0,0)
          , d = e.reverseX || !1
          , h = e.reverseY || !1;
        return t.addComponent("layoutgroup", {
            orientation: s,
            spacing: i,
            alignment: n,
            widthFitting: r,
            heightFitting: o,
            wrap: l,
            padding: c,
            reverseX: d,
            reverseY: h
        }),
        t
    }
    static createTextElement(e, t) {
        var s = X.find(e);
        let i = t.text || ""
          , n = t.fontSize || 16
          , r = t.anchor || new M(.5,.5,.5,.5)
          , o = t.pivot || new P(.5,.5)
          , l = t.alignment || new P(.5,.5)
          , c = t.color || new z(0,0,0)
          , d = t.x || 0
          , h = t.y || 0
          , u = t.opacity || 1
          , f = new V("txt_tutorial")
          , p = t.autoFitWidth === void 0 ? !1 : t.autoFitWidth
          , _ = t.autoFitHeight === void 0 ? !1 : t.autoFitHeight
          , m = t.minFontSize || 1
          , g = t.maxFontSize || 100
          , v = t.autoWidth === void 0 ? !0 : t.autoWidth
          , x = t.autoHeight === void 0 ? !0 : t.autoHeight
          , S = t.width || 100
          , w = t.height || 50;
        return f.addComponent("element", {
            type: Oh,
            fontAsset: s,
            text: i,
            anchor: r,
            pivot: o,
            fontSize: n,
            color: c,
            opacity: u,
            alignment: l,
            autoFitWidth: p,
            autoFitHeight: _,
            minFontSize: m,
            maxFontSize: g,
            width: S,
            height: w,
            autoWidth: v,
            autoHeight: x,
            margin: new M(0,0,0,0)
        }),
        t.width && (f.element.width = t.width),
        f.setLocalPosition(d, h, 0),
        f
    }
}
var Mo = Object.freeze({
    Linear: Object.freeze({
        None: function(a) {
            return a
        },
        In: function(a) {
            return this.None(a)
        },
        Out: function(a) {
            return this.None(a)
        },
        InOut: function(a) {
            return this.None(a)
        }
    }),
    Quadratic: Object.freeze({
        In: function(a) {
            return a * a
        },
        Out: function(a) {
            return a * (2 - a)
        },
        InOut: function(a) {
            return (a *= 2) < 1 ? .5 * a * a : -.5 * (--a * (a - 2) - 1)
        }
    }),
    Cubic: Object.freeze({
        In: function(a) {
            return a * a * a
        },
        Out: function(a) {
            return --a * a * a + 1
        },
        InOut: function(a) {
            return (a *= 2) < 1 ? .5 * a * a * a : .5 * ((a -= 2) * a * a + 2)
        }
    }),
    Quartic: Object.freeze({
        In: function(a) {
            return a * a * a * a
        },
        Out: function(a) {
            return 1 - --a * a * a * a
        },
        InOut: function(a) {
            return (a *= 2) < 1 ? .5 * a * a * a * a : -.5 * ((a -= 2) * a * a * a - 2)
        }
    }),
    Quintic: Object.freeze({
        In: function(a) {
            return a * a * a * a * a
        },
        Out: function(a) {
            return --a * a * a * a * a + 1
        },
        InOut: function(a) {
            return (a *= 2) < 1 ? .5 * a * a * a * a * a : .5 * ((a -= 2) * a * a * a * a + 2)
        }
    }),
    Sinusoidal: Object.freeze({
        In: function(a) {
            return 1 - Math.sin((1 - a) * Math.PI / 2)
        },
        Out: function(a) {
            return Math.sin(a * Math.PI / 2)
        },
        InOut: function(a) {
            return .5 * (1 - Math.sin(Math.PI * (.5 - a)))
        }
    }),
    Exponential: Object.freeze({
        In: function(a) {
            return a === 0 ? 0 : Math.pow(1024, a - 1)
        },
        Out: function(a) {
            return a === 1 ? 1 : 1 - Math.pow(2, -10 * a)
        },
        InOut: function(a) {
            return a === 0 ? 0 : a === 1 ? 1 : (a *= 2) < 1 ? .5 * Math.pow(1024, a - 1) : .5 * (-Math.pow(2, -10 * (a - 1)) + 2)
        }
    }),
    Circular: Object.freeze({
        In: function(a) {
            return 1 - Math.sqrt(1 - a * a)
        },
        Out: function(a) {
            return Math.sqrt(1 - --a * a)
        },
        InOut: function(a) {
            return (a *= 2) < 1 ? -.5 * (Math.sqrt(1 - a * a) - 1) : .5 * (Math.sqrt(1 - (a -= 2) * a) + 1)
        }
    }),
    Elastic: Object.freeze({
        In: function(a) {
            return a === 0 ? 0 : a === 1 ? 1 : -Math.pow(2, 10 * (a - 1)) * Math.sin((a - 1.1) * 5 * Math.PI)
        },
        Out: function(a) {
            return a === 0 ? 0 : a === 1 ? 1 : Math.pow(2, -10 * a) * Math.sin((a - .1) * 5 * Math.PI) + 1
        },
        InOut: function(a) {
            return a === 0 ? 0 : a === 1 ? 1 : (a *= 2,
            a < 1 ? -.5 * Math.pow(2, 10 * (a - 1)) * Math.sin((a - 1.1) * 5 * Math.PI) : .5 * Math.pow(2, -10 * (a - 1)) * Math.sin((a - 1.1) * 5 * Math.PI) + 1)
        }
    }),
    Back: Object.freeze({
        In: function(a) {
            var e = 1.70158;
            return a === 1 ? 1 : a * a * ((e + 1) * a - e)
        },
        Out: function(a) {
            var e = 1.70158;
            return a === 0 ? 0 : --a * a * ((e + 1) * a + e) + 1
        },
        InOut: function(a) {
            var e = 2.5949095;
            return (a *= 2) < 1 ? .5 * (a * a * ((e + 1) * a - e)) : .5 * ((a -= 2) * a * ((e + 1) * a + e) + 2)
        }
    }),
    Bounce: Object.freeze({
        In: function(a) {
            return 1 - Mo.Bounce.Out(1 - a)
        },
        Out: function(a) {
            return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375
        },
        InOut: function(a) {
            return a < .5 ? Mo.Bounce.In(a * 2) * .5 : Mo.Bounce.Out(a * 2 - 1) * .5 + .5
        }
    }),
    generatePow: function(a) {
        return a === void 0 && (a = 4),
        a = a < Number.EPSILON ? Number.EPSILON : a,
        a = a > 1e4 ? 1e4 : a,
        {
            In: function(e) {
                return Math.pow(e, a)
            },
            Out: function(e) {
                return 1 - Math.pow(1 - e, a)
            },
            InOut: function(e) {
                return e < .5 ? Math.pow(e * 2, a) / 2 : (1 - Math.pow(2 - e * 2, a)) / 2 + .5
            }
        }
    }
})
  , vo = function() {
    return performance.now()
}
  , Lw = function() {
    function a() {
        this._tweens = {},
        this._tweensAddedDuringUpdate = {}
    }
    return a.prototype.getAll = function() {
        var e = this;
        return Object.keys(this._tweens).map(function(t) {
            return e._tweens[t]
        })
    }
    ,
    a.prototype.removeAll = function() {
        this._tweens = {}
    }
    ,
    a.prototype.add = function(e) {
        this._tweens[e.getId()] = e,
        this._tweensAddedDuringUpdate[e.getId()] = e
    }
    ,
    a.prototype.remove = function(e) {
        delete this._tweens[e.getId()],
        delete this._tweensAddedDuringUpdate[e.getId()]
    }
    ,
    a.prototype.update = function(e, t) {
        e === void 0 && (e = vo()),
        t === void 0 && (t = !1);
        var s = Object.keys(this._tweens);
        if (s.length === 0)
            return !1;
        for (; s.length > 0; ) {
            this._tweensAddedDuringUpdate = {};
            for (var i = 0; i < s.length; i++) {
                var n = this._tweens[s[i]]
                  , r = !t;
                n && n.update(e, r) === !1 && !t && delete this._tweens[s[i]]
            }
            s = Object.keys(this._tweensAddedDuringUpdate)
        }
        return !0
    }
    ,
    a
}()
  , Kr = {
    Linear: function(a, e) {
        var t = a.length - 1
          , s = t * e
          , i = Math.floor(s)
          , n = Kr.Utils.Linear;
        return e < 0 ? n(a[0], a[1], s) : e > 1 ? n(a[t], a[t - 1], t - s) : n(a[i], a[i + 1 > t ? t : i + 1], s - i)
    },
    Bezier: function(a, e) {
        for (var t = 0, s = a.length - 1, i = Math.pow, n = Kr.Utils.Bernstein, r = 0; r <= s; r++)
            t += i(1 - e, s - r) * i(e, r) * a[r] * n(s, r);
        return t
    },
    CatmullRom: function(a, e) {
        var t = a.length - 1
          , s = t * e
          , i = Math.floor(s)
          , n = Kr.Utils.CatmullRom;
        return a[0] === a[t] ? (e < 0 && (i = Math.floor(s = t * (1 + e))),
        n(a[(i - 1 + t) % t], a[i], a[(i + 1) % t], a[(i + 2) % t], s - i)) : e < 0 ? a[0] - (n(a[0], a[0], a[1], a[1], -s) - a[0]) : e > 1 ? a[t] - (n(a[t], a[t], a[t - 1], a[t - 1], s - t) - a[t]) : n(a[i ? i - 1 : 0], a[i], a[t < i + 1 ? t : i + 1], a[t < i + 2 ? t : i + 2], s - i)
    },
    Utils: {
        Linear: function(a, e, t) {
            return (e - a) * t + a
        },
        Bernstein: function(a, e) {
            var t = Kr.Utils.Factorial;
            return t(a) / t(e) / t(a - e)
        },
        Factorial: function() {
            var a = [1];
            return function(e) {
                var t = 1;
                if (a[e])
                    return a[e];
                for (var s = e; s > 1; s--)
                    t *= s;
                return a[e] = t,
                t
            }
        }(),
        CatmullRom: function(a, e, t, s, i) {
            var n = (t - a) * .5
              , r = (s - e) * .5
              , o = i * i
              , l = i * o;
            return (2 * e - 2 * t + n + r) * l + (-3 * e + 3 * t - 2 * n - r) * o + n * i + e
        }
    }
}
  , Rg = function() {
    function a() {}
    return a.nextId = function() {
        return a._nextId++
    }
    ,
    a._nextId = 0,
    a
}()
  , h_ = new Lw
  , aN = function() {
    function a(e, t) {
        t === void 0 && (t = h_),
        this._object = e,
        this._group = t,
        this._isPaused = !1,
        this._pauseStart = 0,
        this._valuesStart = {},
        this._valuesEnd = {},
        this._valuesStartRepeat = {},
        this._duration = 1e3,
        this._isDynamic = !1,
        this._initialRepeat = 0,
        this._repeat = 0,
        this._yoyo = !1,
        this._isPlaying = !1,
        this._reversed = !1,
        this._delayTime = 0,
        this._startTime = 0,
        this._easingFunction = Mo.Linear.None,
        this._interpolationFunction = Kr.Linear,
        this._chainedTweens = [],
        this._onStartCallbackFired = !1,
        this._onEveryStartCallbackFired = !1,
        this._id = Rg.nextId(),
        this._isChainStopped = !1,
        this._propertiesAreSetUp = !1,
        this._goToEnd = !1
    }
    return a.prototype.getId = function() {
        return this._id
    }
    ,
    a.prototype.isPlaying = function() {
        return this._isPlaying
    }
    ,
    a.prototype.isPaused = function() {
        return this._isPaused
    }
    ,
    a.prototype.to = function(e, t) {
        if (t === void 0 && (t = 1e3),
        this._isPlaying)
            throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
        return this._valuesEnd = e,
        this._propertiesAreSetUp = !1,
        this._duration = t,
        this
    }
    ,
    a.prototype.duration = function(e) {
        return e === void 0 && (e = 1e3),
        this._duration = e,
        this
    }
    ,
    a.prototype.dynamic = function(e) {
        return e === void 0 && (e = !1),
        this._isDynamic = e,
        this
    }
    ,
    a.prototype.start = function(e, t) {
        if (e === void 0 && (e = vo()),
        t === void 0 && (t = !1),
        this._isPlaying)
            return this;
        if (this._group && this._group.add(this),
        this._repeat = this._initialRepeat,
        this._reversed) {
            this._reversed = !1;
            for (var s in this._valuesStartRepeat)
                this._swapEndStartRepeatValues(s),
                this._valuesStart[s] = this._valuesStartRepeat[s]
        }
        if (this._isPlaying = !0,
        this._isPaused = !1,
        this._onStartCallbackFired = !1,
        this._onEveryStartCallbackFired = !1,
        this._isChainStopped = !1,
        this._startTime = e,
        this._startTime += this._delayTime,
        !this._propertiesAreSetUp || t) {
            if (this._propertiesAreSetUp = !0,
            !this._isDynamic) {
                var i = {};
                for (var n in this._valuesEnd)
                    i[n] = this._valuesEnd[n];
                this._valuesEnd = i
            }
            this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, t)
        }
        return this
    }
    ,
    a.prototype.startFromCurrentValues = function(e) {
        return this.start(e, !0)
    }
    ,
    a.prototype._setupProperties = function(e, t, s, i, n) {
        for (var r in s) {
            var o = e[r]
              , l = Array.isArray(o)
              , c = l ? "array" : typeof o
              , d = !l && Array.isArray(s[r]);
            if (!(c === "undefined" || c === "function")) {
                if (d) {
                    var h = s[r];
                    if (h.length === 0)
                        continue;
                    for (var u = [o], f = 0, p = h.length; f < p; f += 1) {
                        var _ = this._handleRelativeValue(o, h[f]);
                        if (isNaN(_)) {
                            d = !1,
                            console.warn("Found invalid interpolation list. Skipping.");
                            break
                        }
                        u.push(_)
                    }
                    d && (s[r] = u)
                }
                if ((c === "object" || l) && o && !d) {
                    t[r] = l ? [] : {};
                    var m = o;
                    for (var g in m)
                        t[r][g] = m[g];
                    i[r] = l ? [] : {};
                    var h = s[r];
                    if (!this._isDynamic) {
                        var v = {};
                        for (var g in h)
                            v[g] = h[g];
                        s[r] = h = v
                    }
                    this._setupProperties(m, t[r], h, i[r], n)
                } else
                    (typeof t[r] > "u" || n) && (t[r] = o),
                    l || (t[r] *= 1),
                    d ? i[r] = s[r].slice().reverse() : i[r] = t[r] || 0
            }
        }
    }
    ,
    a.prototype.stop = function() {
        return this._isChainStopped || (this._isChainStopped = !0,
        this.stopChainedTweens()),
        this._isPlaying ? (this._group && this._group.remove(this),
        this._isPlaying = !1,
        this._isPaused = !1,
        this._onStopCallback && this._onStopCallback(this._object),
        this) : this
    }
    ,
    a.prototype.end = function() {
        return this._goToEnd = !0,
        this.update(1 / 0),
        this
    }
    ,
    a.prototype.pause = function(e) {
        return e === void 0 && (e = vo()),
        this._isPaused || !this._isPlaying ? this : (this._isPaused = !0,
        this._pauseStart = e,
        this._group && this._group.remove(this),
        this)
    }
    ,
    a.prototype.resume = function(e) {
        return e === void 0 && (e = vo()),
        !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1,
        this._startTime += e - this._pauseStart,
        this._pauseStart = 0,
        this._group && this._group.add(this),
        this)
    }
    ,
    a.prototype.stopChainedTweens = function() {
        for (var e = 0, t = this._chainedTweens.length; e < t; e++)
            this._chainedTweens[e].stop();
        return this
    }
    ,
    a.prototype.group = function(e) {
        return e === void 0 && (e = h_),
        this._group = e,
        this
    }
    ,
    a.prototype.delay = function(e) {
        return e === void 0 && (e = 0),
        this._delayTime = e,
        this
    }
    ,
    a.prototype.repeat = function(e) {
        return e === void 0 && (e = 0),
        this._initialRepeat = e,
        this._repeat = e,
        this
    }
    ,
    a.prototype.repeatDelay = function(e) {
        return this._repeatDelayTime = e,
        this
    }
    ,
    a.prototype.yoyo = function(e) {
        return e === void 0 && (e = !1),
        this._yoyo = e,
        this
    }
    ,
    a.prototype.easing = function(e) {
        return e === void 0 && (e = Mo.Linear.None),
        this._easingFunction = e,
        this
    }
    ,
    a.prototype.interpolation = function(e) {
        return e === void 0 && (e = Kr.Linear),
        this._interpolationFunction = e,
        this
    }
    ,
    a.prototype.chain = function() {
        for (var e = [], t = 0; t < arguments.length; t++)
            e[t] = arguments[t];
        return this._chainedTweens = e,
        this
    }
    ,
    a.prototype.onStart = function(e) {
        return this._onStartCallback = e,
        this
    }
    ,
    a.prototype.onEveryStart = function(e) {
        return this._onEveryStartCallback = e,
        this
    }
    ,
    a.prototype.onUpdate = function(e) {
        return this._onUpdateCallback = e,
        this
    }
    ,
    a.prototype.onRepeat = function(e) {
        return this._onRepeatCallback = e,
        this
    }
    ,
    a.prototype.onComplete = function(e) {
        return this._onCompleteCallback = e,
        this
    }
    ,
    a.prototype.onStop = function(e) {
        return this._onStopCallback = e,
        this
    }
    ,
    a.prototype.update = function(e, t) {
        if (e === void 0 && (e = vo()),
        t === void 0 && (t = !0),
        this._isPaused)
            return !0;
        var s, i, n = this._startTime + this._duration;
        if (!this._goToEnd && !this._isPlaying) {
            if (e > n)
                return !1;
            t && this.start(e, !0)
        }
        if (this._goToEnd = !1,
        e < this._startTime)
            return !0;
        this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object),
        this._onStartCallbackFired = !0),
        this._onEveryStartCallbackFired === !1 && (this._onEveryStartCallback && this._onEveryStartCallback(this._object),
        this._onEveryStartCallbackFired = !0),
        i = (e - this._startTime) / this._duration,
        i = this._duration === 0 || i > 1 ? 1 : i;
        var r = this._easingFunction(i);
        if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, r),
        this._onUpdateCallback && this._onUpdateCallback(this._object, i),
        i === 1)
            if (this._repeat > 0) {
                isFinite(this._repeat) && this._repeat--;
                for (s in this._valuesStartRepeat)
                    !this._yoyo && typeof this._valuesEnd[s] == "string" && (this._valuesStartRepeat[s] = this._valuesStartRepeat[s] + parseFloat(this._valuesEnd[s])),
                    this._yoyo && this._swapEndStartRepeatValues(s),
                    this._valuesStart[s] = this._valuesStartRepeat[s];
                return this._yoyo && (this._reversed = !this._reversed),
                this._repeatDelayTime !== void 0 ? this._startTime = e + this._repeatDelayTime : this._startTime = e + this._delayTime,
                this._onRepeatCallback && this._onRepeatCallback(this._object),
                this._onEveryStartCallbackFired = !1,
                !0
            } else {
                this._onCompleteCallback && this._onCompleteCallback(this._object);
                for (var o = 0, l = this._chainedTweens.length; o < l; o++)
                    this._chainedTweens[o].start(this._startTime + this._duration, !1);
                return this._isPlaying = !1,
                !1
            }
        return !0
    }
    ,
    a.prototype._updateProperties = function(e, t, s, i) {
        for (var n in s)
            if (t[n] !== void 0) {
                var r = t[n] || 0
                  , o = s[n]
                  , l = Array.isArray(e[n])
                  , c = Array.isArray(o)
                  , d = !l && c;
                d ? e[n] = this._interpolationFunction(o, i) : typeof o == "object" && o ? this._updateProperties(e[n], r, o, i) : (o = this._handleRelativeValue(r, o),
                typeof o == "number" && (e[n] = r + (o - r) * i))
            }
    }
    ,
    a.prototype._handleRelativeValue = function(e, t) {
        return typeof t != "string" ? t : t.charAt(0) === "+" || t.charAt(0) === "-" ? e + parseFloat(t) : parseFloat(t)
    }
    ,
    a.prototype._swapEndStartRepeatValues = function(e) {
        var t = this._valuesStartRepeat[e]
          , s = this._valuesEnd[e];
        typeof s == "string" ? this._valuesStartRepeat[e] = this._valuesStartRepeat[e] + parseFloat(s) : this._valuesStartRepeat[e] = this._valuesEnd[e],
        this._valuesEnd[e] = t
    }
    ,
    a
}()
  , oN = "22.0.0"
  , lN = Rg.nextId
  , Ki = h_
  , hN = Ki.getAll.bind(Ki)
  , cN = Ki.removeAll.bind(Ki)
  , dN = Ki.add.bind(Ki)
  , uN = Ki.remove.bind(Ki)
  , fN = Ki.update.bind(Ki)
  , Wd = {
    Easing: Mo,
    Group: Lw,
    Interpolation: Kr,
    now: vo,
    Sequence: Rg,
    nextId: lN,
    Tween: aN,
    VERSION: oN,
    getAll: hN,
    removeAll: cN,
    add: dN,
    remove: uN,
    update: fN
};
class Gi {
    static init(e) {
        this._current = 0,
        this._dt = 0,
        this.scale = 1,
        e.on("update", this.update, this)
    }
    static update(e) {
        this._dt = e * this.scale,
        this._current += this._dt
    }
    static get dt() {
        return this._dt
    }
    static get current() {
        return this._current
    }
    static get currentMS() {
        return this._current * 1e3
    }
}
class pN extends Wd.Tween {
    constructor(e, t) {
        super(e, t)
    }
    start() {
        return super.start(Gi.currentMS)
    }
}
const bs = class bs {
    static init(e) {
        e.on("start", () => {
            e.on("update", this.update, this)
        }
        )
    }
    static update() {
        te.paused || Wd.update(Gi.currentMS)
    }
    static createElementAlphaTween(e, t, s=bs.defaultConfig, i=!0) {
        let n = {
            opacity: e.element.opacity
        }
          , r = s.onUpdate;
        s.onUpdate = l => {
            if (!e.element) {
                console.warn("Tween: element is destroyed");
                return
            }
            e.element.opacity = l.opacity,
            r && r(l)
        }
        ;
        let o = bs.createTween(n, {
            opacity: t
        }, s);
        return i && o.start(),
        o
    }
    static createShakeTween(e, t=10, s=.1, i=new y(1,1,1), n=null) {
        let r = {
            percent: 0
        }
          , o = new y;
        return this.createTween(r, {
            percent: 1
        }, {
            duration: s,
            onUpdate: () => {
                o.copy(e.getPosition()),
                o.x += J.random(-1, 1) * t * i.x,
                o.y += J.random(-1, 1) * t * i.y,
                o.z += J.random(-1, 1) * t * i.z,
                e.setPosition(o)
            }
            ,
            onComplete: () => {
                n == null || n()
            }
        })
    }
    static createLocalTranslateTween(e, t={}, s=bs.defaultConfig) {
        let i = e.getLocalPosition().clone()
          , n = new y
          , r = Object.keys(t)
          , o = this.createTween(i, t, s)
          , l = o._onUpdateCallback;
        return o.onUpdate( () => {
            n.copy(e.getLocalPosition()),
            r.forEach(c => n[c] = i[c]),
            e.setLocalPosition(n),
            l()
        }
        ),
        o
    }
    static createGlobalTranslateTween(e, t={}, s=bs.defaultConfig) {
        let i = e.getPosition().clone()
          , n = new y
          , r = Object.keys(t)
          , o = this.createTween(i, t, s)
          , l = o._onUpdateCallback;
        return o.onUpdate( () => {
            n.copy(e.getPosition()),
            r.forEach(c => n[c] = i[c]),
            e.setPosition(n),
            l()
        }
        ),
        o
    }
    static createRotateTween(e, t={}, s=bs.defaultConfig) {
        let i = e.getLocalEulerAngles().clone()
          , n = new y
          , r = Object.keys(t)
          , o = this.createTween(i, t, s)
          , l = o._onUpdateCallback;
        return o.onUpdate( () => {
            n.copy(e.getLocalEulerAngles()),
            r.forEach(c => n[c] = i[c]),
            e.setLocalEulerAngles(n),
            l()
        }
        ),
        o
    }
    static createScaleTween(e, t={}, s=bs.defaultConfig) {
        let i = e.getLocalScale().clone()
          , n = new y
          , r = Object.keys(t)
          , o = this.createTween(i, t, s)
          , l = o._onUpdateCallback;
        return o.onUpdate( () => {
            n.copy(e.getLocalScale()),
            r.forEach(c => n[c] = i[c]),
            e.setLocalScale(n),
            l()
        }
        ),
        o
    }
    static createMaterialTween(e, t={}, s=bs.defaultConfig) {
        let i = this.createTween(e, t, s)
          , n = i._onUpdateCallback;
        return i.onUpdate( () => {
            e.update(),
            n()
        }
        ),
        i
    }
    static createCountTween(e=bs.defaultConfig) {
        let t = {
            percent: 0
        };
        return this.createTween(t, {
            percent: 1
        }, e)
    }
    static createTween(e, t={}, s=bs.defaultConfig) {
        let i = this._setupConfig(s)
          , n = new pN(e);
        return n.to(t, i.duration * 1e3),
        this._setupTween(n, i),
        n
    }
    static _setupConfig(e) {
        return J.copyObject(e, J.copyObject(bs.defaultConfig))
    }
    static _setupTween(e, t) {
        e.easing(t.easing),
        e.delay(t.delay * 1e3),
        e.repeatDelay(t.repeatDelay * 1e3),
        t.loop ? e.repeat(1 / 0) : e.repeat(t.repeat),
        e.yoyo(t.yoyo),
        e.onStart(t.onStart),
        e.onRepeat(t.onRepeat),
        e.onStop(t.onStop),
        e.onUpdate(t.onUpdate),
        e.onComplete(t.onComplete)
    }
    static get Easing() {
        return Wd.Easing
    }
}
;
ti(bs, "defaultConfig", Object.freeze({
    duration: 1,
    easing: Wd.Easing.Linear.None,
    loop: !1,
    yoyo: !1,
    delay: 0,
    repeatDelay: 0,
    repeat: 0,
    onStart: () => {}
    ,
    onRepeat: () => {}
    ,
    onStop: () => {}
    ,
    onUpdate: () => {}
    ,
    onComplete: () => {}
}));
let Z = bs;
const Iu = class Iu extends V {
    constructor(e) {
        super(),
        this.app = e,
        this.layer = new Fi({
            name: "LoadingLayer"
        }),
        e.scene.layers.push(this.layer),
        this.isCompleted = !1,
        this.targetProgress = 0,
        this.currentProgress = 0,
        this.progressBarWidth = 629,
        this.speed = .9,
        this.durationDelayToCompleted = .5,
        this.bgLsc = null,
        this.bgPtr = null,
        this.gameBanner = null,
        this.loadingIcon = null,
        Promise.all([X.loadResource("spr_bg_transition_lsc", "texture"), X.loadResource("spr_bg_transition_ptr", "texture"), X.loadResource("spr_progress_bar_2", "texture"), X.loadResource("spr_icon_loading_dot", "texture"), X.loadResource("spr_icon_lagged", "texture"), X.loadResource("spr_icon_logo_game", "texture"), X.loadResource("spr_game_banner", "texture"), X.loadResource("poppins_bold", "font")]).then( () => {
            this.addComponent("camera", {
                clearColor: new z(.1,.1,.1),
                layers: [this.layer.id],
                priority: 100
            }),
            this.addComponent("screen", {
                screenSpace: !0,
                scaleMode: wc,
                resolution: new P(B.GAME_WIDTH,B.GAME_HEIGHT),
                referenceResolution: new P(B.GAME_WIDTH,B.GAME_HEIGHT)
            }),
            this.width = window.innerWidth,
            this.height = window.innerHeight,
            this.isLandscape = this.width > this.height,
            this._createBackground(),
            this._createGameLogo(),
            this._createBanner(),
            this._createLoadingProgress(),
            this._createLaggedLogo(),
            window.addEventListener("resize", () => {
                this.resize()
            }
            ),
            e.on("update", this.update, this)
        }
        )
    }
    _createBackground() {
        this.backgroundLsc = new V("background"),
        this.backgroundLsc.addComponent("element", {
            type: Ae,
            layers: [this.layer.id],
            pivot: new P(.5,.5),
            useInput: !0,
            textureAsset: X.find("spr_bg_transition_lsc"),
            anchor: new M(.5,.5,.5,.5),
            width: 1920,
            height: 1080
        }),
        this.backgroundLsc.setLocalScale(1.5, 1.5, 1.5),
        this.addChild(this.backgroundLsc),
        this.backgroundLsc.enabled = !1,
        this.backgroundPtr = new V("background"),
        this.backgroundPtr.addComponent("element", {
            type: Ae,
            pivot: new P(.5,.5),
            layers: [this.layer.id],
            useInput: !0,
            textureAsset: X.find("spr_bg_transition_ptr"),
            anchor: new M(.5,.5,.5,.5),
            width: 1080,
            height: 1920
        }),
        this.backgroundPtr.setLocalScale(1.5, 1.5, 1.5),
        this.addChild(this.backgroundPtr),
        this.backgroundPtr.enabled = !1,
        this._onResizeBg()
    }
    _onResizeBg() {
        if (!(!this.backgroundLsc || !this.backgroundPtr)) {
            this.width = window.innerWidth,
            this.height = window.innerHeight;
            var e = this.width > this.height;
            this.backgroundLsc.enabled = !1,
            this.backgroundPtr.enabled = !0,
            e && (this.backgroundLsc.enabled = !0,
            this.backgroundPtr.enabled = !1)
        }
    }
    resize() {
        this.app.resizeCanvas(window.innerWidth, window.innerHeight),
        this.width = window.innerWidth,
        this.height = window.innerHeight,
        this.isLandscape = this.width > this.height,
        this._onResizeBg(),
        this._onResizeLogo(),
        this._onResizeLoadingIcon(),
        this._onResizeBanner(),
        this._onResizeLaggedLogo()
    }
    _createGameLogo() {
        this.iconLogo = new V("spr_game_logo");
        let e = X.find("spr_icon_logo_game");
        this.iconLogo.addComponent("element", {
            type: Ae,
            anchor: new M(.5,1,.5,1),
            pivot: new P(.5,1),
            width: e.resource.width,
            height: e.resource.height,
            textureAsset: e,
            color: new z(1,1,1,1),
            layers: [this.layer.id]
        }),
        this.addChild(this.iconLogo),
        this._onResizeLogo()
    }
    _onResizeLogo() {
        if (this.iconLogo) {
            this.iconLogo.enabled = !1;
            var e = .5
              , t = -300;
            this.width > this.height && (e = .4,
            t = -200),
            this.iconLogo.setLocalScale(e, e, e),
            this.iconLogo.setLocalPosition(0, t, 0),
            this.iconLogo.enabled = !0
        }
    }
    _createLoadingProgress() {
        this.progressBarContainer = new V("loadingIcon"),
        this.progressBarContainer.addComponent("element", {
            type: Ae,
            anchor: new M(.5,.25,.5,.25),
            pivot: new P(.5,.5),
            width: this.progressBarWidth,
            height: 20,
            color: new z(1,1,1,1),
            layers: [this.layer.id]
        }),
        this.addChild(this.progressBarContainer),
        this.progress = new V,
        this.progress.addComponent("element", {
            type: Ae,
            anchor: new M(.5,.5,.5,.5),
            pivot: new P(.5,.5),
            color: J.createColor(49, 0, 105),
            width: this.progressBarWidth,
            height: this.progressBarContainer.element.height,
            layers: [this.layer.id]
        }),
        this.progressBarContainer.addChild(this.progress);
        let e = new V;
        e.addComponent("element", {
            type: Ae,
            pivot: new P(0,.5),
            anchor: new M(0,.5,0,.5),
            width: this.progressBarWidth,
            height: this.progressBarContainer.element.height,
            layers: [this.layer.id],
            textureAsset: X.find("spr_progress_bar_2")
        }),
        this.progressBarContainer.addChild(e),
        this.progress.fill = e,
        this.progress.fill.setLocalScale(.02, 1, 1),
        this.iconLoading = new V("loadingIcon"),
        this.iconLoading.addComponent("element", {
            type: Ae,
            anchor: new M(.5,.25,.5,.25),
            pivot: new P(.5,.5),
            layers: [this.layer.id],
            textureAsset: X.find("spr_icon_loading_dot")
        }),
        this.iconLoading.setLocalScale(4, 4, 4),
        this.iconLoading.setLocalPosition(-this.progressBarWidth / 2, 0, 0),
        this.addChild(this.iconLoading),
        this.targetProgress = .5,
        this._onResizeLoadingIcon()
    }
    _onResizeLoadingIcon() {
        if (this.iconLoading) {
            var e = new M(.5,.23,.5,.23);
            this.isLandscape && (e = new M(.5,.2,.5,.2)),
            this.progressBarContainer.element.anchor = e,
            this.iconLoading.element.anchor = e,
            this.progressBarContainer.enabled = !1,
            this.progressBarContainer.enabled = !0,
            this.iconLoading.enabled = !1,
            this.iconLoading.enabled = !0
        }
    }
    _createLaggedLogo() {
        this.laggedLogo = new V("spr_game_logo");
        let e = X.find("spr_icon_lagged");
        this.laggedLogo.addComponent("element", {
            type: Ae,
            anchor: new M(.5,1,.5,1),
            pivot: new P(.5,1),
            width: e.resource.width,
            height: e.resource.height,
            textureAsset: e,
            color: new z(1,1,1,1),
            layers: [this.layer.id]
        }),
        this.addChild(this.laggedLogo),
        this._onResizeLaggedLogo()
    }
    _onResizeLaggedLogo() {
        if (this.laggedLogo) {
            this.laggedLogo.enabled = !1,
            this.laggedLogo.enabled = !0;
            var e = .8
              , t = -50;
            this.isLandscape && (e = .6,
            t = -40),
            this.laggedLogo.setLocalScale(e, e, e),
            this.laggedLogo.setLocalPosition(0, t, 0)
        }
    }
    _createBanner() {
        this.gameBanner = new V("Game Banner");
        let e = X.find("spr_game_banner");
        this.gameBanner.addComponent("element", {
            type: Ae,
            anchor: new M(.5,1,.5,1),
            pivot: new P(.5,1),
            width: e.resource.width,
            height: e.resource.height,
            textureAsset: e,
            color: new z(1,1,1,1),
            layers: [this.layer.id]
        }),
        this.addChild(this.gameBanner),
        this._onResizeBanner()
    }
    _onResizeBanner() {
        if (this.gameBanner) {
            this.gameBanner.enabled = !1,
            this.gameBanner.enabled = !0;
            var e = 1
              , t = -600;
            this.isLandscape && (e = .75,
            t = -430),
            this.gameBanner.setLocalScale(e, e, e),
            this.gameBanner.setLocalPosition(0, t, 0)
        }
    }
    increaseProgress(e) {
        this.targetProgress += e;
        wop.trigger("loading.update",{pre: this.targetProgress * 100})
    }
    update(e) {
        this.isCompleted || this.currentProgress < this.targetProgress && (this.currentProgress += this.speed * e,
        this.currentProgress = W.clamp(this.currentProgress, 0, 1),
        this.progress.fill.setLocalScale(this.currentProgress, 1, 1),
        this.iconLoading.setLocalPosition(-this.progressBarWidth / 2 + this.currentProgress * this.progressBarWidth, 0, 0),
        this.currentProgress >= 1 && this.targetProgress >= 1 && this._delayToCompleted())
    }
    _delayToCompleted() {
        Z.createCountTween({
            duration: this.durationDelayToCompleted,
            onComplete: () => {
                this.onLoadCompleted()
            }
        }).start()
    }
    show() {
        this.enabled = !0
    }
    onLoadCompleted() {
        this.enabled = !1,
        window.removeEventListener("resize", this.resize),
        this.fire(Iu.EVENT_LOADED),
        wop.trigger('loading.completed')
    }
}
;
ti(Iu, "EVENT_LOADED", "loaded");
let c_ = Iu;
const An = Object.freeze({
    Default: "default",
    Player: "player",
    Obstacle: "obstacle",
    Box: "box"
})
  , hh = Object.freeze({
    OnCollide: "collide"
})
  , Lu = class Lu {
    static get instance() {
        return this._instance || (this._instance = new Lu),
        this._instance
    }
    constructor() {
        this.groups = {}
    }
    init(e) {
        this.filters = e,
        Object.keys(An).forEach(t => {
            var s = An[t];
            this.groups[s] = []
        }
        )
    }
    update() {
        this.filters.forEach(e => this._checkFilter(e))
    }
    _checkFilter(e) {
        e.collideTags.forEach(t => this._checkTags(e.tag, t))
    }
    _checkTags(e, t) {
        this.groups[e].forEach(s => {
            s.enabled && this._checkCollider(s, this.groups[t])
        }
        )
    }
    _checkCollider(e, t) {
        for (var s = 0; s < t.length; s++) {
            var i = t[s];
            if (i.enabled && this._iscollide(e, i) && (e.fire(hh.OnCollide, i, e),
            i.fire(hh.OnCollide, e, i)),
            !e.enabled)
                return
        }
    }
    _iscollide(e, t) {
        let s = e.getBound()
          , i = t.getBound();
        return s.intersects(i)
    }
    add(e) {
        let t = e.tag;
        this.groups[t].push(e)
    }
    remove(e) {
        let t = e.tag
          , s = this.groups[t]
          , i = s.indexOf(s.indexOf(e));
        i >= 0 && (console.log("remove", i),
        s.splice(i, 1))
    }
}
;
ti(Lu, "_instance");
let Qo = Lu;
class mN {
    static init(e) {
        Qo.instance.init([{
            tag: An.Player,
            collideTags: [An.Box, An.Obstacle]
        }]),
        e.on("update", this.update, this)
    }
    static update() {
        Qo.instance.update()
    }
}
V.prototype.enable = function() {
    this.enabled = !0
}
;
V.prototype.disable = function() {
    this.enabled = !1
}
;
y.prototype.min2 = function(a, e) {
    return this.x = Math.min(a.x, e.x),
    this.y = Math.min(a.y, e.y),
    this.z = Math.min(a.z, e.z),
    this
}
;
y.prototype.max2 = function(a, e) {
    return this.x = Math.max(a.x, e.x),
    this.y = Math.max(a.y, e.y),
    this.z = Math.max(a.z, e.z),
    this
}
;
const qp = new ee
  , Ii = new cr;
Fe.prototype.rayCast = function(a) {
    qp.copy(this.node.getWorldTransform()),
    qp.invert(),
    Ii.set(a.origin, a.direction),
    Ii.transform(qp),
    Ii.direction.normalize();
    const e = this._mesh.rayCast(Ii)
      , t = e && e.dist
      , s = e && e.normal;
    return t ? (Ii.direction.mulScalar(t),
    Ii.origin.add(Ii.direction),
    this.node.getWorldTransform().transformPoint(Ii.origin, Ii.origin),
    {
        point: Ii.origin,
        normal: s
    }) : null
}
;
Object.defineProperty(Pe.prototype, "halfArea", {
    get: function() {
        const {x: a, y: e, z: t} = this.halfExtents;
        return 4 * (a * (e + t) + e * t)
    }
});
cr.prototype.transform = function(a) {
    a.transformPoint(this.origin, this.origin),
    a.transformVector(this.direction, this.direction)
}
;
const Cu = Object.getOwnPropertyDescriptor(yt.prototype, "enabled");
Object.defineProperty(yt.prototype, "enabled", {
    get: function() {
        return Cu.get.call(this)
    },
    set: function(a) {
        var e, t;
        Cu.set.call(this, a),
        a ? (e = this.onEnable) == null || e.call(this) : (t = this.onDisable) == null || t.call(this)
    }
});
Object.defineProperty(yt.prototype, "_selfEnabled", {
    get: function() {
        return Cu.get.call(this)
    },
    set: function(a) {
        Cu.set.call(this, a)
    }
});
function ct(a, e=!0, t=!0) {
    const s = {};
    return s[`${a}Map`] = "texture",
    s[`${a}MapTiling`] = "vec2",
    s[`${a}MapOffset`] = "vec2",
    s[`${a}MapRotation`] = "number",
    s[`${a}MapUv`] = "number",
    e && (s[`${a}MapChannel`] = "string",
    t && (s[`${a}VertexColor`] = "boolean",
    s[`${a}VertexColorChannel`] = "string")),
    s
}
const iS = {
    name: "string",
    chunks: "chunks",
    mappingFormat: "string",
    _engine: "boolean",
    ambient: "rgb",
    ambientTint: "boolean",
    ...ct("ao"),
    ...ct("aoDetail", !0, !1),
    aoDetailMode: "string",
    diffuse: "rgb",
    diffuseTint: "boolean",
    ...ct("diffuse"),
    ...ct("diffuseDetail", !0, !1),
    diffuseDetailMode: "string",
    specular: "rgb",
    specularTint: "boolean",
    ...ct("specular"),
    occludeSpecular: "enum:occludeSpecular",
    specularityFactor: "number",
    specularityFactorTint: "boolean",
    ...ct("specularityFactor"),
    useMetalness: "boolean",
    metalness: "number",
    enableGGXSpecular: "boolean",
    anisotropy: "number",
    metalnessTint: "boolean",
    ...ct("metalness"),
    useMetalnessSpecularColor: "boolean",
    conserveEnergy: "boolean",
    shininess: "number",
    gloss: "number",
    glossInvert: "boolean",
    ...ct("gloss"),
    clearCoat: "number",
    ...ct("clearCoat"),
    clearCoatGloss: "number",
    clearCoatGlossInvert: "boolean",
    ...ct("clearCoatGloss"),
    clearCoatBumpiness: "number",
    ...ct("clearCoatNormal", !1),
    useSheen: "boolean",
    sheen: "rgb",
    sheenTint: "boolean",
    ...ct("sheen"),
    sheenGloss: "number",
    sheenGlossTint: "boolean",
    sheenGlossInvert: "boolean",
    ...ct("sheenGloss"),
    fresnelModel: "number",
    emissive: "rgb",
    emissiveTint: "boolean",
    ...ct("emissive"),
    emissiveIntensity: "number",
    ...ct("normal", !1),
    bumpiness: "number",
    ...ct("normalDetail", !1),
    normalDetailMapBumpiness: "number",
    ...ct("height", !0, !1),
    heightMapFactor: "number",
    alphaToCoverage: "boolean",
    alphaTest: "number",
    alphaFade: "number",
    opacity: "number",
    ...ct("opacity"),
    opacityFadesSpecular: "boolean",
    reflectivity: "number",
    refraction: "number",
    refractionTint: "boolean",
    ...ct("refraction"),
    refractionIndex: "number",
    thickness: "number",
    thicknessTint: "boolean",
    ...ct("thickness"),
    attenuation: "rgb",
    attenuationDistance: "number",
    useDynamicRefraction: "boolean",
    sphereMap: "texture",
    cubeMap: "cubemap",
    cubeMapProjection: "number",
    cubeMapProjectionBox: "boundingbox",
    useIridescence: "boolean",
    iridescence: "number",
    iridescenceTint: "boolean",
    ...ct("iridescence"),
    iridescenceThicknessTint: "boolean",
    iridescenceThicknessMin: "number",
    iridescenceThicknessMax: "number",
    iridescenceRefractionIndex: "number",
    ...ct("iridescenceThickness"),
    ...ct("light"),
    depthTest: "boolean",
    depthFunc: "enum:depthFunc",
    depthWrite: "boolean",
    depthBias: "number",
    slopeDepthBias: "number",
    cull: "enum:cull",
    blendType: "enum:blendType",
    shadingModel: "enum:shadingModel",
    useFog: "boolean",
    useLighting: "boolean",
    useSkybox: "boolean",
    useGammaTonemap: "boolean",
    envAtlas: "texture",
    twoSidedLighting: "boolean"
}
  , Dw = [];
for (const a in iS)
    iS[a] === "texture" && Dw.push(a);
Ar.prototype._loadModel = function(a, e) {
    const t = a.getFileUrl()
      , s = ye.getExtension(t);
    if (s === ".json" || s === ".glb") {
        const i = ye.getDirectory(t)
          , n = ye.getBasename(t)
          , r = ye.join(i, n.replace(s, ".mapping.json"));
        this._loader.load(r, "json", (o, l) => {
            o ? (a.data = {
                mapping: []
            },
            e(a)) : this._loadMaterials(a, l, (c, d) => {
                a.data = l,
                a.once("load", () => {
                    for (let u = 0; u < l.mapping.length; u++)
                        if (l.mapping[u].path) {
                            var h = d.find(f => f.file.url === l.mapping[u].path);
                            h && (a.resource.meshInstances[u].material = h.resource)
                        }
                }
                ),
                e(a)
            }
            )
        }
        )
    } else
        e(a)
}
;
Ar.prototype._loadMaterials = function(a, e, t) {
    const s = [];
    let i = e.mapping.filter(r => r.path).length;
    if (i === 0) {
        t(null, s);
        return
    }
    const n = (r, o) => {
        this._loadTextures(o, (l, c) => {
            s.push(o),
            s.length === i && t(l, s)
        }
        )
    }
    ;
    for (let r = 0; r < e.mapping.length; r++) {
        const o = e.mapping[r].path;
        if (o) {
            const l = o;
            this.loadFromUrl(l, "material", n)
        }
    }
}
;
Ar.prototype._loadTextures = function(a, e) {
    const t = a.data
      , s = []
      , i = Dw;
    let n = i.filter(o => t[o] && typeof t[o] == "string").length;
    if (t.mappingFormat !== "path") {
        e(null, s);
        return
    }
    const r = (o, l) => {
        s.push(l),
        s.length === n && e(o, s)
    }
    ;
    for (let o = 0; o < i.length; o++) {
        const l = t[i[o]];
        if (l && typeof l == "string") {
            const c = l;
            this.loadFromUrl(c, "texture", (d, h) => {
                r(d, h),
                a.resource[i[o]] = h.resource
            }
            )
        }
    }
    n === 0 && e(null, s)
}
;
function _N() {
    Be._convexShapesData = Object.create(null),
    Be._convexShapesData.ammoHalfExtents = new Ammo.btVector3,
    Be._convexShapesData.ammoRotFrom = new Ammo.btQuaternion,
    Be._convexShapesData.ammoRotTo = new Ammo.btQuaternion,
    Be._convexShapesData.ammoPosFrom = new Ammo.btVector3,
    Be._convexShapesData.ammoPosTo = new Ammo.btVector3,
    Be._convexShapesData.ammoTransformFrom = new Ammo.btTransform,
    Be._convexShapesData.ammoTransformTo = new Ammo.btTransform,
    Be._convexShapesData.pcMat4 = new ee,
    Be._convexShapesData.pcStartRot = new ne,
    Be._convexShapesData.pcEndRot = new ne;
    var a = function(c, d, h, u) {
        this.entity = c,
        this.hitFraction = d,
        this.point = h,
        this.normal = u
    }
      , e = function(c, d) {
        this.entity = c,
        this.contacts = d
    };
    Be.prototype.convexCast = function(l, c, d, h, u, f) {
        var p = null
          , _ = null
          , m = Be._convexShapesData;
        (!h || !u) && (_ = m.pcMat4.setLookAt(c, d, y.UP)),
        h || (h = m.pcStartRot.setFromMat4(_)),
        u || (u = m.pcEndRot.setFromMat4(_)),
        f || (f = 0),
        m.ammoPosFrom.setValue(c.x, c.y, c.z),
        m.ammoPosTo.setValue(d.x, d.y, d.z),
        m.ammoTransformFrom.setOrigin(m.ammoPosFrom),
        m.ammoTransformTo.setOrigin(m.ammoPosTo),
        m.ammoRotFrom.setValue(h.x, h.y, h.z, h.w),
        m.ammoTransformFrom.setRotation(m.ammoRotFrom),
        m.ammoRotTo.setValue(u.x, u.y, u.z, u.w),
        m.ammoTransformFrom.setRotation(m.ammoRotTo);
        var g = new Ammo.ClosestConvexResultCallback(m.ammoPosFrom,m.ammoPosTo);
        if (this.dynamicsWorld.convexSweepTest(l, m.ammoTransformFrom, m.ammoTransformTo, g, f),
        g.hasHit()) {
            var v = g.get_m_hitCollisionObject()
              , x = Ammo.castObject(v, Ammo.btRigidBody);
            if (x) {
                var S = g.get_m_closestHitFraction()
                  , w = g.get_m_hitPointWorld()
                  , T = g.get_m_hitNormalWorld();
                p = new a(x.entity,S,new y(w.x(),w.y(),w.z()),new y(T.x(),T.y(),T.z()))
            }
        }
        return Ammo.destroy(l),
        Ammo.destroy(g),
        p
    }
    ,
    Be.prototype.convexCastAll = function(l, c, d, h) {
        var u = null
          , f = Be._convexShapesData;
        h || (h = {}),
        (!h.startRot || !h.endRot) && (u = f.pcMat4.setLookAt(c, d, y.UP)),
        h.startRot || (h.startRot = f.pcStartRot.setFromMat4(u)),
        h.endRot || (h.endRot = f.pcEndRot.setFromMat4(u)),
        h.allowedPenetration || (h.allowedPenetration = 0),
        f.ammoPosFrom.setValue(c.x, c.y, c.z),
        f.ammoPosTo.setValue(d.x, d.y, d.z),
        f.ammoTransformFrom.setOrigin(f.ammoPosFrom),
        f.ammoTransformTo.setOrigin(f.ammoPosTo),
        f.ammoRotFrom.setValue(h.startRot.x, h.startRot.y, h.startRot.z, h.startRot.w),
        f.ammoTransformFrom.setRotation(f.ammoRotFrom),
        f.ammoRotTo.setValue(h.endRot.x, h.endRot.y, h.endRot.z, h.endRot.w),
        f.ammoTransformFrom.setRotation(f.ammoRotTo);
        var p = new Ammo.AllConvexResultCallback(f.ammoPosFrom,f.ammoPosTo);
        typeof h.filterCollisionGroup == "number" && p.set_m_collisionFilterGroup(h.filterCollisionGroup),
        typeof h.filterCollisionMask == "number" && p.set_m_collisionFilterMask(h.filterCollisionMask),
        this.dynamicsWorld.convexSweepTest(l, f.ammoTransformFrom, f.ammoTransformTo, p, h.allowedPenetration);
        var _ = [];
        const m = p.get_m_collisionObjects().size();
        if (m > 0) {
            const g = p.get_m_collisionObjects()
              , v = p.get_m_hitPointWorld()
              , x = p.get_m_hitNormalWorld()
              , S = p.get_m_hitFractions();
            for (let w = 0; w < m; w++) {
                const T = g.at(w)
                  , b = Ammo.castObject(T, Ammo.btRigidBody);
                if (b && b.entity) {
                    if (h.filterTags && !b.entity.tags.has(...h.filterTags) || h.filterCallback && !h.filterCallback(b.entity))
                        continue;
                    const E = v.at(w)
                      , C = x.at(w)
                      , R = S.at(w);
                    let F = _.find(L => L.entity === b.entity);
                    F ? (F.contacts.hitFractions.push(R),
                    F.contacts.points.push(new y(E.x(),E.y(),E.z())),
                    F.contacts.normals.push(new y(C.x(),C.y(),C.z()))) : (F = new e(b.entity,{
                        hitFractions: [R],
                        points: [new y(E.x(),E.y(),E.z())],
                        normals: [new y(C.x(),C.y(),C.z())]
                    }),
                    _.push(F))
                }
            }
            h.sort && _.sort( (w, T) => w.hitFraction - T.hitFraction)
        }
        return Ammo.destroy(l),
        Ammo.destroy(p),
        _
    }
    ,
    Be.prototype.coneCast = function(l, c, d, h, u, f, p, _) {
        u || (u = y.UP);
        var m = t(l, c, u);
        if (!m)
            throw "Failed to generate cone shape. Check attributes.";
        return this.convexCast(m, d, h, f, p, _)
    }
    ,
    Be.prototype.sphereCast = function(l, c, d, h, u, f, p) {
        var _ = s(l, h);
        if (!_)
            throw "Failed to generate sphere shape. Check attributes.";
        return this.convexCast(_, c, d, u, f, p)
    }
    ,
    Be.prototype.boxCast = function(l, c, d, h, u, f, p) {
        var _ = i(l, h);
        if (!_)
            throw "Failed to generate box shape. Check attributes.";
        return this.convexCast(_, c, d, u, f, p)
    }
    ,
    Be.prototype.cylinderCast = function(l, c, d, h, u, f, p) {
        h || (h = y.UP);
        var _ = n(l, h);
        if (!_)
            throw "Failed to generate cylinder shape. Check attributes.";
        return this.convexCast(_, c, d, u, f, p)
    }
    ,
    Be.prototype.capsuleCast = function(l, c, d, h, u, f, p, _) {
        var m = r(l, c, u);
        if (!m)
            throw "Failed to generate capsule shape. Check attributes.";
        return this.convexCast(m, d, h, f, p, _)
    }
    ,
    Be.prototype.shapeCast = function(l, c, d, h, u, f, p) {
        var _ = o(l);
        if (!_)
            throw "Failed to generate convex hull shape. Check attributes.";
        return this.convexCast(_, c, d, u, f, p)
    }
    ,
    Be.prototype.coneCastAll = function(l, c, d, h, u, f) {
        u || (u = y.UP);
        var p = t(l, c, u);
        if (!p)
            throw "Failed to generate cone shape. Check attributes.";
        return this.convexCastAll(p, d, h, f)
    }
    ,
    Be.prototype.sphereCastAll = function(l, c, d, h, u) {
        var f = s(l, u);
        if (!f)
            throw "Failed to generate sphere shape. Check attributes.";
        return this.convexCastAll(f, c, d, h)
    }
    ,
    Be.prototype.boxCastAll = function(l, c, d, h, u) {
        var f = i(l, u);
        if (!f)
            throw "Failed to generate box shape. Check attributes.";
        return this.convexCastAll(f, c, d, h)
    }
    ,
    Be.prototype.cylinderCastAll = function(l, c, d, h, u) {
        h || (h = y.UP);
        var f = n(l, h);
        if (!f)
            throw "Failed to generate cylinder shape. Check attributes.";
        return this.convexCastAll(f, c, d, u)
    }
    ,
    Be.prototype.capsuleCastAll = function(l, c, d, h, u, f) {
        var p = r(l, c, f);
        if (!p)
            throw "Failed to generate capsule shape. Check attributes.";
        return this.convexCastAll(p, d, h, u)
    }
    ,
    Be.prototype.shapeCastAll = function(l, c, d, h) {
        var u = o(l);
        if (!u)
            throw "Failed to generate convex hull shape. Check attributes.";
        return this.convexCastAll(u, c, d, h)
    }
    ;
    const t = function(l, c, d) {
        var h = null;
        switch (d) {
        case y.UP:
            h = new Ammo.btConeShape(l,c);
            break;
        case y.RIGHT:
            h = new Ammo.btConeShapeX(l,c);
            break;
        case y.BACK:
            h = new Ammo.btConeShapeZ(l,c);
            break;
        default:
            throw "Invalid orientation"
        }
        return h
    }
      , s = function(l, c) {
        var d = new Ammo.btSphereShape(l);
        return c && d.setMargin(c),
        d
    }
      , i = function(l, c) {
        var d = Be._convexShapesData.ammoHalfExtents;
        d.setValue(l.x, l.y, l.z);
        var h = new Ammo.btBoxShape(d);
        return c && h.setMargin(c),
        h
    }
      , n = function(l, c) {
        var d = null
          , h = Be._convexShapesData.ammoHalfExtents;
        switch (h.setValue(l.x, l.y, l.z),
        c) {
        case y.UP:
            d = new Ammo.btCylinderShape(h);
            break;
        case y.RIGHT:
            d = new Ammo.btCylinderShapeX(h);
            break;
        case y.BACK:
            d = new Ammo.btCylinderShapeZ(h);
            break;
        default:
            throw "Invalid orientation"
        }
        return d
    }
      , r = function(l, c, d) {
        var h = new Ammo.btCapsuleShape(l,c);
        return d && h.setMargin(d),
        h
    }
      , o = function(l) {
        var c = new Ammo.btConvexHullShape(l,l.length,3);
        return c
    }
}
( () => {
    let a = setInterval( () => {
        typeof Ammo < "u" && te.app._librariesLoaded && (clearInterval(a),
        _N())
    }
    , 100)
}
)();
var Ig = {
    exports: {}
}, Po = typeof Reflect == "object" ? Reflect : null, nS = Po && typeof Po.apply == "function" ? Po.apply : function(e, t, s) {
    return Function.prototype.apply.call(e, t, s)
}
, Xd;
Po && typeof Po.ownKeys == "function" ? Xd = Po.ownKeys : Object.getOwnPropertySymbols ? Xd = function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
}
: Xd = function(e) {
    return Object.getOwnPropertyNames(e)
}
;
function gN(a) {
    console && console.warn && console.warn(a)
}
var Ow = Number.isNaN || function(e) {
    return e !== e
}
;
function Xe() {
    Xe.init.call(this)
}
Ig.exports = Xe;
Ig.exports.once = xN;
Xe.EventEmitter = Xe;
Xe.prototype._events = void 0;
Xe.prototype._eventsCount = 0;
Xe.prototype._maxListeners = void 0;
var rS = 10;
function Lf(a) {
    if (typeof a != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof a)
}
Object.defineProperty(Xe, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
        return rS
    },
    set: function(a) {
        if (typeof a != "number" || a < 0 || Ow(a))
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + a + ".");
        rS = a
    }
});
Xe.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null),
    this._eventsCount = 0),
    this._maxListeners = this._maxListeners || void 0
}
;
Xe.prototype.setMaxListeners = function(e) {
    if (typeof e != "number" || e < 0 || Ow(e))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e,
    this
}
;
function Fw(a) {
    return a._maxListeners === void 0 ? Xe.defaultMaxListeners : a._maxListeners
}
Xe.prototype.getMaxListeners = function() {
    return Fw(this)
}
;
Xe.prototype.emit = function(e) {
    for (var t = [], s = 1; s < arguments.length; s++)
        t.push(arguments[s]);
    var i = e === "error"
      , n = this._events;
    if (n !== void 0)
        i = i && n.error === void 0;
    else if (!i)
        return !1;
    if (i) {
        var r;
        if (t.length > 0 && (r = t[0]),
        r instanceof Error)
            throw r;
        var o = new Error("Unhandled error." + (r ? " (" + r.message + ")" : ""));
        throw o.context = r,
        o
    }
    var l = n[e];
    if (l === void 0)
        return !1;
    if (typeof l == "function")
        nS(l, this, t);
    else
        for (var c = l.length, d = zw(l, c), s = 0; s < c; ++s)
            nS(d[s], this, t);
    return !0
}
;
function Bw(a, e, t, s) {
    var i, n, r;
    if (Lf(t),
    n = a._events,
    n === void 0 ? (n = a._events = Object.create(null),
    a._eventsCount = 0) : (n.newListener !== void 0 && (a.emit("newListener", e, t.listener ? t.listener : t),
    n = a._events),
    r = n[e]),
    r === void 0)
        r = n[e] = t,
        ++a._eventsCount;
    else if (typeof r == "function" ? r = n[e] = s ? [t, r] : [r, t] : s ? r.unshift(t) : r.push(t),
    i = Fw(a),
    i > 0 && r.length > i && !r.warned) {
        r.warned = !0;
        var o = new Error("Possible EventEmitter memory leak detected. " + r.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        o.name = "MaxListenersExceededWarning",
        o.emitter = a,
        o.type = e,
        o.count = r.length,
        gN(o)
    }
    return a
}
Xe.prototype.addListener = function(e, t) {
    return Bw(this, e, t, !1)
}
;
Xe.prototype.on = Xe.prototype.addListener;
Xe.prototype.prependListener = function(e, t) {
    return Bw(this, e, t, !0)
}
;
function yN() {
    if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn),
        this.fired = !0,
        arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
}
function kw(a, e, t) {
    var s = {
        fired: !1,
        wrapFn: void 0,
        target: a,
        type: e,
        listener: t
    }
      , i = yN.bind(s);
    return i.listener = t,
    s.wrapFn = i,
    i
}
Xe.prototype.once = function(e, t) {
    return Lf(t),
    this.on(e, kw(this, e, t)),
    this
}
;
Xe.prototype.prependOnceListener = function(e, t) {
    return Lf(t),
    this.prependListener(e, kw(this, e, t)),
    this
}
;
Xe.prototype.removeListener = function(e, t) {
    var s, i, n, r, o;
    if (Lf(t),
    i = this._events,
    i === void 0)
        return this;
    if (s = i[e],
    s === void 0)
        return this;
    if (s === t || s.listener === t)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[e],
        i.removeListener && this.emit("removeListener", e, s.listener || t));
    else if (typeof s != "function") {
        for (n = -1,
        r = s.length - 1; r >= 0; r--)
            if (s[r] === t || s[r].listener === t) {
                o = s[r].listener,
                n = r;
                break
            }
        if (n < 0)
            return this;
        n === 0 ? s.shift() : vN(s, n),
        s.length === 1 && (i[e] = s[0]),
        i.removeListener !== void 0 && this.emit("removeListener", e, o || t)
    }
    return this
}
;
Xe.prototype.off = Xe.prototype.removeListener;
Xe.prototype.removeAllListeners = function(e) {
    var t, s, i;
    if (s = this._events,
    s === void 0)
        return this;
    if (s.removeListener === void 0)
        return arguments.length === 0 ? (this._events = Object.create(null),
        this._eventsCount = 0) : s[e] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete s[e]),
        this;
    if (arguments.length === 0) {
        var n = Object.keys(s), r;
        for (i = 0; i < n.length; ++i)
            r = n[i],
            r !== "removeListener" && this.removeAllListeners(r);
        return this.removeAllListeners("removeListener"),
        this._events = Object.create(null),
        this._eventsCount = 0,
        this
    }
    if (t = s[e],
    typeof t == "function")
        this.removeListener(e, t);
    else if (t !== void 0)
        for (i = t.length - 1; i >= 0; i--)
            this.removeListener(e, t[i]);
    return this
}
;
function Nw(a, e, t) {
    var s = a._events;
    if (s === void 0)
        return [];
    var i = s[e];
    return i === void 0 ? [] : typeof i == "function" ? t ? [i.listener || i] : [i] : t ? SN(i) : zw(i, i.length)
}
Xe.prototype.listeners = function(e) {
    return Nw(this, e, !0)
}
;
Xe.prototype.rawListeners = function(e) {
    return Nw(this, e, !1)
}
;
Xe.listenerCount = function(a, e) {
    return typeof a.listenerCount == "function" ? a.listenerCount(e) : Uw.call(a, e)
}
;
Xe.prototype.listenerCount = Uw;
function Uw(a) {
    var e = this._events;
    if (e !== void 0) {
        var t = e[a];
        if (typeof t == "function")
            return 1;
        if (t !== void 0)
            return t.length
    }
    return 0
}
Xe.prototype.eventNames = function() {
    return this._eventsCount > 0 ? Xd(this._events) : []
}
;
function zw(a, e) {
    for (var t = new Array(e), s = 0; s < e; ++s)
        t[s] = a[s];
    return t
}
function vN(a, e) {
    for (; e + 1 < a.length; e++)
        a[e] = a[e + 1];
    a.pop()
}
function SN(a) {
    for (var e = new Array(a.length), t = 0; t < e.length; ++t)
        e[t] = a[t].listener || a[t];
    return e
}
function xN(a, e) {
    return new Promise(function(t, s) {
        function i(r) {
            a.removeListener(e, n),
            s(r)
        }
        function n() {
            typeof a.removeListener == "function" && a.removeListener("error", i),
            t([].slice.call(arguments))
        }
        Vw(a, e, n, {
            once: !0
        }),
        e !== "error" && wN(a, i, {
            once: !0
        })
    }
    )
}
function wN(a, e, t) {
    typeof a.on == "function" && Vw(a, "error", e, t)
}
function Vw(a, e, t, s) {
    if (typeof a.on == "function")
        s.once ? a.once(e, t) : a.on(e, t);
    else if (typeof a.addEventListener == "function")
        a.addEventListener(e, function i(n) {
            s.once && a.removeEventListener(e, i),
            t(n)
        });
    else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof a)
}
var bN = Ig.exports;
const TN = iN(bN);
class dt {
    static init(e) {
        this.emitter = new TN,
        this.state = e
    }
    static get state() {
        return this._state
    }
    static set state(e) {
        this._state !== e && (this.prevState = this.state,
        this._state = e,
        this.emitter && this.emitter.emit("changed", this.state, this.prevState))
    }
    static isState(...e) {
        for (var t = 0; t < e.length; t++)
            if (e[t] === this.state)
                return !0;
        return !1
    }
    static isPrevState(...e) {
        for (var t = 0; t < e.length; t++)
            if (e[t] === this.prevState)
                return !0;
        return !1
    }
    static registerOnStateChangedCallback(e) {
        this.emitter.on("changed", e)
    }
    static removeOnStateChangedCallback(e) {
        this.emitter.off("changed", e)
    }
}
const qe = {
    MainMenu: "mainmenu",
    Playing: "playing",
    Paused: "paused",
    Lose: "lose",
    Win: "win",
    GameOver: "gameover",
    Tutorial: "tutorial",
    AutoPlay: "autoplay",
    AutoPlayOver: "autoplayover"
};
class Ht {
    static init() {
        this._initMainCamera(),
        this.reset(),
        this.initialized = !0
    }
    static _initMainCamera() {
        this.main = j.createCamera("camera_main", {
            clearColor: J.createColor(0, 0, 0),
            fov: B.CAMERA_FOV
        })
    }
    static reset() {
        var e;
        this.offsetY = 0,
        (e = this.main.parent) == null || e.removeChild(this.main),
        this.main.setLocalPosition(B.CAMERA_X, B.CAMERA_Y, B.CAMERA_Z),
        this.main.setLocalEulerAngles(B.CAMERA_ROTATE_X, B.CAMERA_ROTATE_Y, B.CAMERA_ROTATE_Z),
        this._destroyChildren()
    }
    static _destroyChildren() {
        for (; this.main.children.length > 0; ) {
            let e = this.main.children[0];
            this.main.removeChild(e),
            e.destroy && e.destroy()
        }
    }
}
class Ro {
    static log(e, t, ...s) {
        this._logConsole("log", e, t, ...s)
    }
    static warn(e, t, ...s) {
        this._logConsole("warn", e, t, ...s)
    }
    static error(e, t, ...s) {
        this._logConsole("error", e, t, ...s)
    }
    static debug(e, t, ...s) {
        this._logConsole("debug", e, t, ...s)
    }
    static _logConsole(e, t, s, ...i) {
        this.enabled && console[e] && console[e](`[${t}] ${s}`, ...i)
    }
    static get enabled() {
        return B.DEBUG_ON
    }
}
class La extends V {
    constructor(e) {
        super(),
        this.key = e,
        this.addComponent("screen", {
            screenSpace: !0,
            scaleMode: wc,
            resolution: new P(B.GAME_WIDTH,B.GAME_HEIGHT),
            referenceResolution: new P(B.GAME_WIDTH,B.GAME_HEIGHT)
        }),
        this.enabled = !1
    }
    create() {
        this.created = !0
    }
    pause() {}
    resume() {}
    destroyChildren() {
        for (; this.children.length > 0; )
            this.children[0].destroy()
    }
    update(e) {}
    resize() {}
    initGameTag() {}
    getScreenSpacePosition(e, t=new y) {
        return t.x = e.x * te.app.graphicsDevice.maxPixelRatio,
        t.y = te.app.graphicsDevice.height - e.y * te.app.graphicsDevice.maxPixelRatio,
        t.z = 0,
        t.mulScalar(1 / this.screen.scale),
        t
    }
}
class CN extends V {
    constructor() {
        super("ui_manager"),
        this.screens = []
    }
    update(e) {
        this.screens.forEach(t => t.enabled && t.update(e))
    }
    pause() {
        this.screens.forEach(e => e.enabled && e.pause())
    }
    resume() {
        this.screens.forEach(e => e.enabled && e.resume())
    }
    addScreens(...e) {
        e.forEach( (t, s) => {
            this.addChild(t),
            this.screens.push(t),
            t.create(),
            t.screen.priority = s
        }
        )
    }
    removeScreen(...e) {
        e.forEach(t => {
            let s = this.getScreen(t);
            s && this.screens.splice(s, 1)
        }
        )
    }
    setScreenActive(e, t=!0) {
        let s = this.getScreen(e);
        s ? s.enabled = t : B.DEBUG_ON && console.warn(`Scene ${e} not found!`)
    }
    disableAllScreens() {
        this.screens.forEach(e => e.enabled = !1)
    }
    getScreen(e) {
        return this.screens.find(t => t.key === e)
    }
    resize() {
        this.screens.forEach(e => e.resize())
    }
    getActiveScreens() {
        return this.screens.filter(e => e.enabled)
    }
    getLastActiveScreen() {
        return this.getActiveScreens().pop()
    }
}
class Lg extends V {
    constructor(e) {
        super(e),
        this.key = e,
        this.ui = new CN,
        this.addChild(this.ui),
        this.created = !1
    }
    create() {
        Ro.log(`${this.key}Scene`, "Create")
    }
    update(e) {
        this.ui.update(e)
    }
    resize() {
        this.ui.resize()
    }
    pause() {
        this.ui.pause()
    }
    resume() {
        this.ui.resume()
    }
    destroy() {
        super.destroy()
    }
    onEnable() {}
    onDisable() {}
    get enabled() {
        return super.enabled
    }
    set enabled(e) {
        super.enabled = e,
        this.enabled !== e && (e && !this.enabled ? this.onEnable() : !e && this.enabled && this.onDisable())
    }
}
class At {
    static init(e) {
        this.scenes = e,
        this.addtiveScenes = []
    }
    static loadScene(e, t=!1) {
        let s = this.currentScene;
        this.currentScene = e,
        te.app.root.addChild(this.currentScene),
        this.currentScene.created || (this.currentScene.create(),
        this.currentScene.created = !0,
        e.enabled = !0),
        s && (te.app.root.removeChild(s),
        t ? (this.addtiveScenes.forEach(i => i.destroy()),
        s.destroy()) : s.enabled = !1),
        this.currentScene.enabled === !1 && (this.currentScene.enabled = !0)
    }
    static loadSceneAddtive(e) {
        this.addtiveScenes.push(e),
        e.created || (e.create(),
        e.created = !0),
        te.app.root.addChild(e)
    }
    static update(e) {
        var t;
        (t = this.currentScene) == null || t.update(e),
        this.addtiveScenes.forEach(s => s.update(e))
    }
    static resize() {
        var e;
        (e = this.currentScene) == null || e.resize(),
        this.addtiveScenes.forEach(t => t.resize())
    }
    static pause() {
        var e;
        (e = this.currentScene) == null || e.pause(),
        this.addtiveScenes.forEach(t => t.pause())
    }
    static resume() {
        var e;
        (e = this.currentScene) == null || e.resume(),
        this.addtiveScenes.forEach(t => t.resume())
    }
    static getScene(e) {
        return this.scenes.find(t => t.key === e)
    }
}
const Yp = Object.freeze({
    PointerDown: "inputmanager:pointerdown",
    PointerMove: "inputmanager:pointermove",
    PointerUp: "inputmanager:pointerup"
});
class Gw {
    static init(e) {
        this.app = e,
        this.emitter = new V,
        this._initMouse(),
        this._initTouch()
    }
    static _initMouse() {
        let e = this.app.mouse;
        e.on($o, t => this._handleInputEvent(t, this._onPointerDown.bind(this))),
        e.on(qo, t => this._handleInputEvent(t, this._onPointerMove.bind(this))),
        window.addEventListener("mouseup", t => this._onPointerUp(t))
    }
    static _initTouch() {
        let e = this.app.touch;
        e.on(Jd, t => this._handleInputEvent(t, this._onPointerDown.bind(this))),
        e.on(tu, t => this._handleInputEvent(t, this._onPointerMove.bind(this))),
        e.on(eu, t => this._handleInputEvent(t, this._onPointerUp.bind(this))),
        e.on(su, t => this._handleInputEvent(t, this._onPointerUp.bind(this)))
    }
    static _handleInputEvent(e, t) {
        e.event.preventDefault(),
        t(e)
    }
    static _onPointerDown(e) {
        this.emitter.fire(Yp.PointerDown, e)
    }
    static _onPointerMove(e) {
        this.emitter.fire(Yp.PointerMove, e)
    }
    static _onPointerUp(e) {
        this.emitter.fire(Yp.PointerUp, e)
    }
}
class EN {
    constructor() {
        this.name = "",
        this.attributes = {},
        this.initialize = null,
        this.postInitialize = null,
        this.update = null,
        this.fixedUpdate = null,
        this.postUpdate = null,
        this.onEnable = null,
        this.onDisable = null,
        this.onDestroy = null,
        this._initialized = !1
    }
}
class Te {
    static createScript(e=new EN) {
        return J.copyObject(e)
    }
    static _initScript(e) {
        let t = oh(e.name);
        Object.keys(e).forEach(s => {
            s === "attributes" ? Object.keys(e.attributes).forEach(i => {
                t.attributes.add(i, e.attributes[i])
            }
            ) : t.prototype[s] = e[s]
        }
        ),
        e._initialized = !0
    }
}
V.prototype.addScript = function(a, e={}) {
    this.script || this.addComponent("script");
    let t;
    if (rN(a, Jt)) {
        let n = a.scriptName || a.name;
        if (n || (n = a.prototype.constructor.name),
        a.__name = n,
        !te.app.scripts.has(n)) {
            if (!(a.attributes instanceof Pn))
                a._customAttributes = a.attributes,
                a.attributes = new Pn(a);
            else {
                var s = new a({
                    app: te.app,
                    entity: this
                })
                  , i = Object.keys(s).filter(o => o !== "app" && o !== "entity" && !o.startsWith("_"));
                a._customAttributes = {},
                i.forEach(o => {
                    a._customAttributes[o] = {
                        type: typeof s[o],
                        default: s[o]
                    }
                }
                ),
                e.attributes && Object.keys(e.attributes).forEach(o => {
                    i.includes(o) || (a._customAttributes[o] = {
                        type: typeof e.attributes[o],
                        default: e.attributes[o]
                    })
                }
                ),
                s = void 0
            }
            Object.keys(a._customAttributes).forEach(o => {
                a.attributes.add(o, a._customAttributes[o])
            }
            ),
            wg(a),
            delete a._customAttributes
        }
        e.attributes || (e.attributes = {}),
        t = this.script.create(n, e)
    } else
        a && (a._initialized || Te._initScript(a),
        t = this.script.create(a.name, {
            attributes: e
        }));
    return t.onEnable && t.on("enable", t.onEnable, t),
    t.onDisable && t.on("disable", t.onDisable, t),
    t.onDestroy && t.on("destroy", t.onDestroy, t),
    t.enable || (t.enable = () => t.enabled = !0),
    t.disable || (t.disable = () => t.enabled = !1),
    t
}
;
V.prototype.getScript = function(a) {
    if (!this.script)
        return null;
    let e = a.scriptName || a.name;
    return e || (e = a.prototype.constructor.name),
    this.script[e]
}
;
const Dg = Te.createScript({
    name: "boxCollider",
    attributes: {
        tag: {
            default: An.Default
        },
        position: {
            default: new y
        },
        scale: {
            default: new y(1,1,1)
        },
        render: {
            default: B.DEBUG_BOX_COLLIDER
        }
    },
    initialize() {
        if (this.box = new V("box"),
        this.box.addComponent("model", {
            type: "box"
        }),
        this.box.setLocalPosition(this.position),
        this.box.setLocalScale(this.scale),
        this.box.enabled = this.render,
        this.render) {
            let a = new at
              , e = new z(Math.random(),Math.random(),Math.random());
            a.diffuse = e,
            a.update(),
            this.box.model.material = a
        }
        this.entity.addChild(this.box),
        Qo.instance.add(this)
    },
    onDestroy() {
        Qo.instance.remove(this)
    },
    getBound() {
        return this.box.model.meshInstances[0].aabb
    }
})
  , AN = {
    pink: [255, 255, 255],
    blue: [168, 216, 250],
    yellow: [236, 236, 70],
    gray: [211, 208, 208]
}
  , MN = {
    pink: [119, 6, 129],
    blue: [0, 87, 149],
    yellow: [156, 156, 0],
    gray: [154, 154, 154]
}
  , PN = {
    pink: [247, 154, 255],
    blue: [168, 216, 250],
    yellow: [236, 236, 70],
    gray: [154, 154, 154]
}
  , RN = {
    pink: [233, 0, 255],
    blue: [0, 144, 255],
    yellow: [255, 204, 0],
    gray: [154, 154, 154]
}
  , Ns = {
    box: AN,
    roadLines: MN,
    frame: PN,
    trail: RN
};
class IN {
    static config() {
        this._initBgAssets(),
        this._initRoadAssets(),
        this._initFogAssets(),
        this._initLightAssets(),
        this._initSaberAssets(),
        this._initSprites(),
        this._configVisualizeNode()
    }
    static _configVisualizeNode() {
        let e = X.find("tex_sound_wave").resource
          , t = new at
          , s = Ns.roadLines[B.DEFAULT_COLOR];
        t.diffuse = J.createColor(...s),
        t.diffuseMap = e,
        t.diffuseTint = !0,
        t.opacity = 1,
        t.blendType = hc,
        t.emissive = J.createColor(...s),
        t.emissiveTint = !0,
        t.emissiveMap = e,
        t.update(),
        X.registerAsset(t, "mat_audio_visualize")
    }
    static _initBgAssets() {
        let e = X.find("tex_smoke").resource
          , t = new at;
        t.diffuseTint = !0,
        t.diffuse = J.createColor(32, 30, 69),
        t.diffuseMap = e,
        t.opacityMap = e,
        X.registerAsset(t, "mat_bg")
    }
    static _initRoadAssets() {
        let e = this.createColorMaterial(0, 0, 0);
        X.registerAsset(e, "mat_road");
        let t = X.find("tex_saber").resource
          , s = new at
          , i = Ns.roadLines[B.DEFAULT_COLOR];
        s.diffuse = J.createColor(...i),
        s.diffuseTint = !0,
        s.diffuseMap = t,
        s.opacityMap = t,
        s.blendType = fi,
        X.registerAsset(s, "mat_road_line");
        let n = new at;
        n.diffuse = J.createColor(255, 255, 255),
        n.opacity = 1,
        n.diffuseTint = !0,
        n.diffuseMap = t,
        n.opacityMap = t,
        n.blendType = fi,
        X.registerAsset(n, "mat_road_line_white")
    }
    static _initFogAssets() {
        let e = X.find("tex_gradient").resource
          , t = new at;
        t.diffuse = J.createColor(108, 0, 142),
        t.diffuseTint = !0,
        t.diffuseMap = e,
        t.opacityMap = e,
        t.opacity = .75,
        t.blendType = fi,
        X.registerAsset(t, "mat_fog_violet")
    }
    static _initLightAssets() {
        let e = X.find("tex_ray").resource
          , t = new at;
        t.diffuse = J.createColor(97, 0, 255),
        t.diffuseTint = !0,
        t.diffuseMap = e,
        t.opacityMap = e,
        t.opacity = .5,
        t.blendType = fi,
        t.depthWrite = !1,
        X.registerAsset(t, "mat_light_cone_blue");
        let s = X.find("tex_saber").resource
          , i = new at;
        i.diffuseMap = s,
        i.opacityMap = s,
        i.blendType = fi,
        i.depthWrite = !1,
        X.registerAsset(i, "mat_light_saber")
    }
    static _initMainCharacterAssets() {
        let e = X.find("tex_mc").resource
          , t = new at;
        t.diffuseMap = e,
        t.emissiveMap = e,
        t.ambient = J.createColor(255, 255, 255),
        t.ambientTint = !0,
        X.registerAsset(t, "mat_mc"),
        this.setModelMaterial("model_mc", t),
        this.setModelMaterial("model_mc", t, 1)
    }
    static _initWeaponAssets() {
        let e = X.find("tex_weapon").resource
          , t = new at;
        t.diffuseMap = e,
        t.emissiveMap = e,
        X.registerAsset(t, "mat_weapon"),
        this.setModelMaterial("model_weapon", t),
        this.setModelMaterial("model_weapon", t, 1)
    }
    static _initSaberAssets() {
        let e = X.find("tex_saber").resource
          , t = new at
          , s = Ns.roadLines[B.DEFAULT_COLOR];
        t.diffuse = J.createColor(...s),
        t.diffuseTint = !0,
        t.diffuseMap = e,
        t.opacityMap = e,
        t.blendType = fi,
        X.registerAsset(t, "mat_saber")
    }
    static _initSprites() {
        this.setSpritePixelsPerUnit("spr_flare", 50)
    }
    static setTextureFiltering(e, t=be, s=oe) {
        e.minFilter = t,
        e.magFilter = t,
        e.addressU = s,
        e.addressV = s
    }
    static setSpritePixelsPerUnit(e, t=100) {
        let s = X.find(e).resource;
        s.pixelsPerUnit = t
    }
    static setModelTexture(e, t, s=0) {
        let i = this.getMaterial(e, s)
          , n = X.find(t);
        i.diffuseMap = n.resource
    }
    static setModelDiffuse(e, t, s=0) {
        let i = this.getMaterial(e, s);
        i.diffuse.copy(t),
        i.diffuseTint = !0
    }
    static setModelMaterial(e, t, s=0) {
        let i = X.find(e).resource;
        i.meshInstances[s].material = t
    }
    static setModelMaterialInRange(e, t, s, i) {
        for (var n = s; n <= i; n++)
            this.setModelMaterial(e, t, n)
    }
    static setModelMaterialWithIndexes(e, t, s=[]) {
        s.forEach(i => {
            this.setModelMaterial(e, t, i)
        }
        )
    }
    static createColorMaterial(e=255, t=255, s=255, i=1) {
        let n = new at;
        return n.diffuse = J.createColor(e, t, s, i),
        n
    }
    static getMaterial(e, t=0) {
        let s = X.find(e)
          , i = s.resource.meshInstances[t].material;
        return i.id === 1 && (i = new at,
        s.resource.meshInstances[t].material = i),
        i
    }
}
class Eu {
    static config() {
        this.scene = te.app.scene,
        this._configScene(),
        IN.config()
    }
    static _configScene(e) {
        this.scene.ambientLight = e,
        this.scene.gammaCorrection = Z_
    }
    static _configSkyBox() {
        let e = X.find("cm_skybox").resource;
        this.scene.skybox = e
    }
}
class LN extends V {
    constructor() {
        super("cloud"),
        this._initCloud()
    }
    _initCloud() {
        this.cloud = j.createSprite("spr_smoke"),
        this.cloud.setLocalScale(.11, .1, .1),
        this.cloud.setLocalEulerAngles(90, 0, 0),
        this.addChild(this.cloud)
    }
    changeColor(e=new y(0,0,0)) {
        this.cloud.sprite.color = J.createColor(e.x, e.y, e.z)
    }
}
const en = Te.createScript({
    name: "checkOutOfScreen",
    attributes: {
        z: {
            default: 0
        },
        forward: {
            default: !1
        }
    },
    isOutOfScreen: !1,
    onEnable() {
        this.isOutOfScreen = !1
    },
    update() {
        this.forward ? !this.isOutOfScreen && this.entity.getPosition().z >= this.z && (this.isOutOfScreen = !0,
        this.fire(Zs.OutOfScreen)) : !this.isOutOfScreen && this.entity.getPosition().z <= this.z && (this.isOutOfScreen = !0,
        this.fire(Zs.OutOfScreen))
    }
})
  , Zs = Object.freeze({
    OutOfScreen: "outofscreen"
})
  , Rt = Te.createScript({
    name: "moveComp",
    attributes: {
        speed: {
            default: new y
        }
    },
    update(a) {
        let e = this.entity.getLocalPosition();
        e.x += this.speed.x * a,
        e.y += this.speed.y * a,
        e.z += this.speed.z * a,
        this.entity.setLocalPosition(e)
    }
})
  , We = Object.freeze({
    Spawn: "spawn",
    Despawn: "despawn",
    PoolInitialized: "poolInitialized"
})
  , Og = Te.createScript({
    name: "waveCloudController",
    attributes: {
        cloudHolder: {}
    },
    despawn() {
        this.cloudHolder.children.forEach(a => {
            a.fire(We.Despawn)
        }
        ),
        this.entity.fire(We.Despawn)
    },
    changeColor(a=new y) {
        this.cloudHolder.children.forEach(e => {
            e.changeColor(a)
        }
        )
    }
})
  , Hw = Object.freeze({
    Miss: "miss"
})
  , Nh = Te.createScript({
    name: "waveController",
    attributes: {
        boxHolder: {},
        mineHolder: {},
        noteData: {}
    },
    boxCount: 0,
    despawn() {
        for (this.boxHolder.children.length === this.boxCount && this.boxCount > 0 && this.fire(Hw.Miss); this.boxHolder.children.length > 0; )
            this.boxHolder.children[0].fire(We.Despawn);
        for (; this.mineHolder.children.length > 0; )
            this.mineHolder.children[0].fire(We.Despawn);
        this.entity.fire(We.Despawn)
    }
});
class DN extends V {
    constructor() {
        super("waveCloud"),
        this._initWave()
    }
    stopMove() {
        this.moveScript.enabled = !1
    }
    startMove() {
        this.moveScript.enabled = !0
    }
    _initWave() {
        this.moveScript = this.addScript(Rt, {
            speed: new y(0,0,-15)
        }),
        this.cloudHolder = new V("holder"),
        this.addChild(this.cloudHolder);
        let e = this.addScript(Og, {
            cloudHolder: this.cloudHolder
        });
        this.addScript(en, {
            z: -10
        }).on(Zs.OutOfScreen, () => {
            e.despawn()
        }
        )
    }
}
class ON extends La {
    constructor() {
        super(B.SCREEN_PLAY),
        this.initGameTag(),
        this.score = 0,
        this.percent = 0,
        this.countStar = 0,
        this.stars = []
    }
    create() {
        this.destroyChildren(),
        super.create(),
        this.initProgress(),
        this._initScore(),
        this._initTextResult(),
        this.shakeTween = void 0
    }
    resize() {
        super.resize(),
        this._onResizeScore(),
        this._onResizeTxtResult(),
        this._onResizeProgress()
    }
    initProgress() {
        this.progress = new V,
        this.progress.addComponent("element", {
            type: Ae,
            anchor: new M(.5,1,.5,1),
            pivot: new P(.5,.5)
        }),
        this.progress.setLocalPosition(0, -50, 0),
        this.progress.element.width = 629,
        this.progress.element.height = 13,
        this.addChild(this.progress);
        let e = new V;
        e.addComponent("element", {
            type: Ae,
            pivot: new P(0,.5),
            anchor: new M(0,.5,0,.5),
            color: J.createColor(255, 220, 48)
        }),
        e.element.width = this.progress.element.width,
        e.element.height = this.progress.element.height,
        this.progress.addChild(e),
        e.setLocalScale(0, 1, 1),
        this.progress.fill = e,
        this.progress.addChild(this._createStar(.33)),
        this.progress.addChild(this._createStar(.66)),
        this.progress.addChild(this._createStar(1)),
        this._onResizeProgress()
    }
    _onResizeProgress() {
        let e = -50
          , t = 1;
        te.isLandScape && (e = -30,
        t = .75),
        this.progress.setLocalPosition(0, e, 0),
        this.progress.setLocalScale(t, t, t)
    }
    _createStar(e) {
        let t = j.createImageElement("spr_star_unfill", {
            anchor: new M(e,.5,e,.5),
            pivot: new P(.5,.5),
            scale: .7,
            y: 5
        });
        return t.fill = j.createImageElement("spr_star", {
            scale: .7
        }),
        t.fill.enabled = !1,
        t.addChild(t.fill),
        this.stars.push(t),
        t
    }
    _initScore() {
        this.txtScore = j.createTextElement("font_rounded", {
            anchor: new M(.5,1,.5,1),
            text: "0",
            fontText: "0123456789",
            fontWeight: "bold",
            fontSize: 70,
            color: J.createColor(255, 255, 255)
        }),
        this.txtScore.element.outlineThickness = 1,
        this.txtScore.element.outlineColor = J.createColor(153, 153, 153),
        this.txtScore.element.spacing = 1.2,
        this.addChild(this.txtScore),
        this.setScore(this.score),
        this._onResizeScore()
    }
    _onResizeScore() {
        let e = -150
          , t = 1;
        te.isLandScape && (e = -85,
        t = .7),
        this.txtScore.setLocalScale(t, t, t),
        this.txtScore.setLocalPosition(0, e, 0)
    }
    _initTextResult() {
        this.txtResultGroup = j.createGroupElement({
            anchor: new M(.5,.83,.5,.83)
        }),
        this.addChild(this.txtResultGroup),
        this.txtResult = j.createImageElement("spr_perfect", {
            anchor: new M(.5,.83,.5,.83),
            scale: .8
        }),
        this.txtResult.element.opacity = 0,
        this.txtResultGroup.addChild(this.txtResult),
        this.txtResultCounter = j.createTextElement("font_rounded", {
            fontSize: 55,
            text: "x1",
            fontText: "0123456789",
            pivot: new P(.5,.5),
            fontWeight: "bold",
            alignment: new P(.5,.5),
            color: J.createColor(255, 255, 255),
            y: -60
        }),
        this.txtResultGroup.addChild(this.txtResultCounter),
        this.txtResultCounter.element.opacity = 0,
        this.txtMissResult = j.createImageElement("spr_miss", {
            y: 10
        }),
        this.txtMissResult.element.opacity = 0,
        this.txtResultGroup.addChild(this.txtMissResult),
        this._onResizeTxtResult()
    }
    _onResizeTxtResult() {
        let e = new M(.5,1,.5,1)
          , t = .8
          , s = -240;
        te.isLandScape && (s = -145,
        t = .6),
        this.txtResultGroup.setLocalScale(t, t, t),
        this.txtResultGroup.setLocalPosition(0, s, 0),
        this.txtResultGroup.element.anchor = e,
        this.txtMissResult.setLocalScale(t, t, t)
    }
    playResult(e, t=null) {
        this.shakeTween && (this.shakeTween.stop(),
        this.alphaOffTween.stop()),
        t && (t.element.opacity = 1),
        e.element.opacity = 1,
        this.shakeTween = Z.createTween({
            value: -5
        }, {
            value: 5
        }, {
            duration: .05,
            repeat: 2,
            delay: .15,
            yoyo: !0,
            onUpdate: s => {
                e.setLocalPosition(-s.value, s.value, 0)
            }
            ,
            onComplete: () => {
                this.alphaOffTween.start()
            }
        }).start(),
        this.alphaOffTween = Z.createTween({
            opacity: 1
        }, {
            opacity: 0
        }, {
            duration: .1,
            onUpdate: s => {
                t && (t.element.opacity = s.opacity),
                e.element.opacity = s.opacity
            }
        })
    }
    playScaleResultGroupTween() {
        this.scaleGroup && this.scaleGroup.stop();
        let e = te.isLandScape ? .6 : .8;
        this.scaleGroup = Z.createTween({
            scale: e - .4
        }, {
            scale: e
        }, {
            duration: .15,
            onUpdate: t => {
                this.txtResultGroup.setLocalScale(t.scale, t.scale, 1)
            }
            ,
            onComplete: () => {}
        }).start()
    }
    playMissResult() {
        this.txtResult.element.opacity = 0,
        this.txtResultCounter.element.opacity = 0,
        this.playScaleResultGroupTween(),
        this.playResult(this.txtMissResult)
    }
    playPerfectResult(e) {
        this.txtMissResult.element.opacity = 0,
        this.txtResultCounter.element.text = `x${e}`,
        this.playScaleResultGroupTween(),
        e > 1 ? this.playResult(this.txtResult, this.txtResultCounter) : this.playResult(this.txtResult)
    }
    resetProgress() {
        this.countStar = 0,
        this.score = 0,
        this.percent = 0,
        this.progress.fill.setLocalScale(0, 1, 1)
    }
    setScore(e) {
        this.score = e,
        this.txtScore.element.text = e.toString()
    }
    setPercent(e) {
        this.percent = W.clamp(e, 0, 1)
    }
    update(e) {
        super.update(e);
        let t = W.lerp(this.progress.fill.getLocalScale().x, this.percent, e * 5);
        this.progress.fill.setLocalScale(t, 1, 1),
        this.stars.forEach( (s, i) => {
            this.percent >= (i + 1) / 3 ? (s.fill.enabled = !0,
            this.countStar < i + 1 && (this.countStar = i + 1)) : s.fill.enabled = !1
        }
        )
    }
}
class FN extends La {
    constructor() {
        super(B.SCREEN_TUTORIAL),
        this.tweens = [],
        this._initFakeBackground(),
        this._initTutorial(),
        this.initGameTag()
    }
    create() {
        super.create(),
        this.isLandScape ? (this.tutorial.element.anchor = new M(.5,.3,.5,.3),
        this.tutorial.setLocalScale(.8, .8, .8)) : (this.tutorial.element.anchor = new M(.5,.2,.5,.2),
        this.tutorial.setLocalScale(1, 1, 1))
    }
    resize() {
        super.resize()
    }
    _initFakeBackground() {
        this.bgFake = new V("fake_background"),
        this.addChild(this.bgFake),
        this.bgFake.addComponent("element", {
            type: "image",
            anchor: new M(0,0,1,1)
        }),
        this.bgFake.element.opacity = 0,
        this.bgFake.element.useInput = !0,
        this.bgFake.element.on("mousedown", this._onTapBackground.bind(this)),
        this.bgFake.element.on("touchstart", this._onTapBackground.bind(this))
    }
    _onTapBackground() {
        this.enabled = !1,
        dt.state = qe.Playing
    }
    _initTutorial() {
        this.tutorial = j.createGroupElement({
            anchor: new M(.5,.2,.5,.2)
        }),
        this.addChild(this.tutorial),
        this._initTutorialText(),
        this._initHand(),
        this._initArrows()
    }
    _initTutorialText() {
        this.txtTutorial = j.createImageElement("spr_text_tutorial", {
            anchor: new M(.5,.5,.5,.5),
            scale: .8
        }),
        this.txtTutorial.setLocalScale(1.5, 1.5, 0),
        this.tutorial.addChild(this.txtTutorial)
    }
    _initHand() {
        this.hand = j.createImageElement("spr_hand", {
            anchor: new M(0,0,0,0),
            scale: .8
        }),
        this.tutorial.addChild(this.hand),
        this.hand.setLocalPosition(-70, -120, 0),
        this.tweenHand = Z.createLocalTranslateTween(this.hand, {
            x: 70
        }, {
            duration: .7,
            loop: !0,
            yoyo: !0,
            easing: Z.Easing.Sinusoidal.InOut
        }).start()
    }
    _initArrows() {
        let e = 0;
        for (let t = 0; t < 3; t++) {
            let s = this._createArrow(e);
            this.tutorial.addChild(s),
            e += .35
        }
        e = 0;
        for (let t = 0; t < 3; t++) {
            let s = this._createArrow(e, !0);
            this.tutorial.addChild(s),
            e += .35
        }
    }
    _createArrow(e, t=!1) {
        let s = t ? -100 : 100
          , i = 1
          , n = j.createImageElement("spr_arrow", {
            anchor: new M(.5,.2,.5,.2),
            y: -80,
            x: s
        })
          , r = t ? -250 : 250;
        n.element.opacity = 0,
        t && n.setEulerAngles(0, 0, 180);
        let o = Z.createLocalTranslateTween(n, {
            x: r
        }, {
            loop: !0,
            duration: i,
            delay: e
        })
          , l = Z.createElementAlphaTween(n, 1, {
            loop: !0,
            duration: i,
            delay: e,
            onRepeat: () => {
                n.element.opacity = 0
            }
        });
        return o.start(),
        this.tweens.push(o),
        this.tweens.push(l),
        n
    }
}
const BN = Te.createScript({
    name: "inputHandler",
    initialize() {
        this._initMouse(),
        this._initTouch()
    },
    _initMouse() {
        let a = this.app.mouse;
        a.on($o, e => this._handleInputEvent(e, this._onMouseDown.bind(this))),
        a.on(qo, e => this._handleInputEvent(e, this._onMouseMove.bind(this))),
        a.on(wh, e => this._handleInputEvent(e, this._onMouseUp.bind(this)))
    },
    _initTouch() {
        let a = this.app.touch;
        a.on(Jd, e => this._handleInputEvent(e, this._onMouseDown.bind(this))),
        a.on(tu, e => this._handleInputEvent(e, this._onMouseMove.bind(this))),
        a.on(eu, e => this._handleInputEvent(e, this._onMouseUp.bind(this))),
        a.on(su, e => this._handleInputEvent(e, this._onMouseUp.bind(this)))
    },
    _handleInputEvent(a, e) {
        a.event.preventDefault(),
        this.enabled && e(a)
    },
    _onMouseDown(a) {
        this.app.fire(_n.PointerDown, a)
    },
    _onMouseMove(a) {
        this.app.fire(_n.PointerMove, a)
    },
    _onMouseUp(a) {
        this.app.fire(_n.PointerUp, a)
    }
})
  , _n = Object.freeze({
    PointerDown: "inputHandler:pointerdown",
    PointerMove: "inputHandler:pointermove",
    PointerUp: "inputHandler:pointerup"
})
  , kN = Te.createScript({
    name: "swipeMovement",
    attributes: {
        screenEntity: {},
        multiplier: {
            default: 0
        },
        speed: {
            default: 1
        },
        range: {
            default: 1
        }
    },
    touchedDown: !1,
    startPos: 0,
    currPos: 0,
    _tmpPos: new y,
    _tmpTouchPosition: new y,
    initialize() {
        this.app.on(_n.PointerDown, this.onPointerDown, this),
        this.app.on(_n.PointerMove, this.onPointerMove, this),
        this.app.on(_n.PointerUp, this.onPointerUp, this)
    },
    onDestroy() {
        this.app.off(_n.PointerDown, this.onPointerDown, this),
        this.app.off(_n.PointerMove, this.onPointerMove, this),
        this.app.off(_n.PointerUp, this.onPointerUp, this)
    },
    update(a) {
        if (!this.touchedDown)
            return;
        let t = (this.startPos - this.currPos) * this.multiplier
          , s = Math.min(1, this.speed * a);
        this.startPos = W.lerp(this.startPos, this.currPos, s),
        this._tmpPos.copy(this.entity.getLocalPosition());
        let i = W.lerp(this._tmpPos.x, this._tmpPos.x + t, s);
        Math.abs(i) > this.range && (i = this.range * Math.sign(i)),
        this._tmpPos.x = i,
        this.entity.setLocalPosition(this._tmpPos)
    },
    onPointerDown(a) {
        this.touchedDown = !0,
        a.touches && a.touches[0] ? this.setStart(a.touches[0]) : this.setStart(a)
    },
    onPointerMove(a) {
        this.touchedDown && (a.touches && a.touches[0] ? this.setMove(a.touches[0]) : this.setMove(a))
    },
    onPointerUp(a) {
        this.touchedDown = !1,
        this.startPos = 0,
        this.currPos = 0
    },
    setStart(a) {
        this.getScreenSpacePosition(a, this._tmpTouchPosition),
        this.startPos = this._tmpTouchPosition.x,
        this.currPos = this.startPos
    },
    setMove(a) {
        this.getScreenSpacePosition(a, this._tmpTouchPosition),
        this.currPos = this._tmpTouchPosition.x
    },
    getScreenSpacePosition(a, e=new y) {
        e.x = a.x * this.app.graphicsDevice.maxPixelRatio,
        e.y = this.app.graphicsDevice.height - a.y * this.app.graphicsDevice.maxPixelRatio,
        e.z = 0,
        e.mulScalar(1 / this.screenEntity.screen.scale)
    }
})
  , Ww = Te.createScript({
    name: "cloudManager",
    attributes: {
        spawnPosZ: {},
        spawnGap: {},
        spawner: {}
    },
    initialize() {
        this.spawnFirstClounds()
    },
    update() {},
    changeColor(a) {
        this.entity.children.forEach(e => {
            e.getScript(Og).changeColor(a)
        }
        )
    },
    stopMove() {
        this.entity.children.forEach(a => {
            a.stopMove()
        }
        )
    },
    startMove() {
        this.entity.children.forEach(a => {
            a.startMove()
        }
        )
    },
    spawnFirstClounds() {
        let a = this.spawnPosZ;
        for (this.number = 0; a >= -10; )
            this.spawner.spawn(this.entity, a),
            a -= this.spawnGap
    },
    respawn() {
        this.spawner.spawn(this.entity, this.spawnPosZ)
    }
})
  , Df = Te.createScript({
    name: "boxController",
    isComboBox: !1,
    wave: null,
    onHit() {
        this.entity.fire(We.Despawn)
    }
})
  , la = Te.createScript({
    name: "rotateComp",
    attributes: {
        speed: {
            default: new y
        }
    },
    update(a) {
        this.entity.rotateLocal(this.speed.x * a, this.speed.y * a, this.speed.z * a)
    }
})
  , ki = Object.freeze({
    ModelLoaded: "resourceEntity:modelLoaded",
    Loaded: "resourceEntity:loaded",
    OnProgress: "resourceEntity:progress"
});
class Rn extends V {
    constructor(e, t=!1, s=void 0, i={
        autoLoad: !0
    }) {
        super(e.name),
        this.isCaching = t,
        this.options = i,
        this.data = e,
        this.data.children = this.data.children || [],
        this._modelLoaded = !1,
        this._parent = s,
        this._childrenLoaded = 0,
        this.once(ki.ModelLoaded, this.checkLoaded, this),
        (!this.options || this.options.autoLoad) && this.load()
    }
    load() {
        this._addTags(),
        this._applyTransformData(),
        this._initComponents(),
        this.data.children.length === 0 && (this.data.components && !this.data.components.model || !this.data.components) && this.checkLoaded(),
        this.children.forEach(e => {
            var t;
            e instanceof Rn ? (!e.loaded && !this.options.autoLoad && !e.options.autoLoad || e.loaded && (!e.data.components || !((t = e.data.components) != null && t.model))) && e.load() : e instanceof ei && this.onChildLoaded()
        }
        )
    }
    _addTags() {
        this.data.tags && this.data.tags.forEach(e => {
            this.tags.add(e)
        }
        )
    }
    _applyTransformData() {
        let e = this.data.eulerAngles || this.data.rotation;
        this.data.position && this.setLocalPosition(...this.data.position),
        e && this.setLocalEulerAngles(...e),
        this.data.scale && this.setLocalScale(...this.data.scale)
    }
    async _mappingMaterial(e) {
        typeof e == "string" && e.includes(".json") && (e = e.replace(".json", ""));
        const t = X.find(e);
        if (t)
            return t;
        if (X.hasResource(e))
            return await X.loadResource(e, "material")
    }
    async _initRender(e) {
        if (e.materialAssets && e.materialAssets.length > 0) {
            let t = [];
            for (let s = 0; s < e.materialAssets.length; s++) {
                let i = e.materialAssets[s]
                  , n = await this._mappingMaterial(i);
                t.push(n)
            }
            e.materialAssets = t
        }
        this.addComponent("render", e),
        this.fire(ki.ModelLoaded)
    }
    async _initModel(e, t={}) {
        if (e) {
            let s = X.find(e);
            s ? t.asset = s : X.hasResource(e) ? (s = await X.loadResource(e, "model"),
            t.asset = s) : console.error(`Model ${e} not found`),
            t.asset = s
        }
        if (t.materialAssets && t.materialAssets.length > 0) {
            let s = {};
            for (let i = 0; i < t.materialAssets.length; i++) {
                let n = t.materialAssets[i]
                  , r = await this._mappingMaterial(n);
                s[i] = r.id
            }
            t.mapping = s
        }
        this.addComponent("model", t),
        this._modelLoaded = !0,
        this.fire(ki.ModelLoaded),
        this.options.layers && (this.model.layers = this.options.layers)
    }
    _initParticle(e) {
        for (let t in e)
            (t.toLowerCase().includes("asset") || t === "mesh") && (e[t] = X.find(e[t]));
        this.addComponent("particlesystem", e)
    }
    _initComponents() {
        if (this.data.components)
            for (let e in this.data.components)
                e === "model" ? this._initModel(this.data.components[e].asset, this.data.components[e]) : e === "render" ? this._initRender(this.data.components[e]) : e === "particlesystem" ? this._initParticle(this.data.components[e]) : e === "script" ? this._initScripts(this.data.components[e]) : this.addComponent(e, this.data.components[e])
    }
    _initScripts(e) {
        for (let t in e) {
            let s = e[t];
            t === "rotate" && this.addScript(la, {
                speed: new y(s.speed)
            })
        }
    }
    get loaded() {
        let e = !0;
        return this.data.components && (this.data.components.model && !this._modelLoaded && (e = !1),
        this.data.components.render && !this.render && (e = !1)),
        this._childrenLoaded < this.data.children.length && (e = !1),
        e
    }
    checkLoaded() {
        this.loaded && (this.fire(ki.Loaded),
        this._parent && this._parent instanceof Rn && this._parent.onChildLoaded(this))
    }
    onChildLoaded() {
        this._childrenLoaded += 1,
        this.checkLoaded(),
        this.fire(ki.OnProgress, this._childrenLoaded / this.data.children.length)
    }
}
const NN = Object.freeze({})
  , zt = Object.freeze({
    Loaded: "jsonEntity:loaded",
    Progress: "jsonEntity:progress"
});
class ei extends V {
    constructor(e, t=!1, s=NN, i={
        autoLoad: !0
    }) {
        super(e.name || "theme"),
        this.data = e,
        this.finish = null,
        this.isCaching = t,
        this._objectMapping = s,
        this.options = i,
        this.loaded = !1,
        this.rootNode = this._addEntityNode(e, void 0, !1),
        this.rootNode.once(ki.Loaded, this._checkLoad, this),
        this.options.autoLoad && this.load(),
        this.addChild(this.rootNode)
    }
    load() {
        this.rootNode.load()
    }
    _addEntityNode(e, t, s=!0) {
        let i = this._createEntityNode(e, t, s);
        return t == null || t.addChild(i),
        i
    }
    _createEntityNode(e, t, s=!0) {
        var n;
        let i;
        return this._objectMapping[e.name] ? i = new this._objectMapping[e.name](e,this.isCaching,t,{
            autoLoad: s
        }) : (n = e.tags) == null || n.forEach(r => {
            i || this._objectMapping[r] && (i = new this._objectMapping[r](e,this.isCaching,t,{
                autoLoad: s
            }))
        }
        ),
        i || (i = new Rn(e,this.isCaching,t,{
            autoLoad: s
        })),
        e.children && e.children.length > 0 && e.children.forEach(r => {
            this._addEntityNode(r, i, s)
        }
        ),
        i
    }
    _checkLoad() {
        this.fire(zt.Loaded)
    }
}
const Gs = Te.createScript({
    name: "spawner",
    attributes: {
        class: {},
        args: {
            default: []
        },
        poolSize: {
            default: 0
        }
    },
    initialize() {
        this.pool ?? (this.pool = [])
    },
    postInitialize() {
        this._createPool()
    },
    spawn(a=null, e=-1) {
        var n;
        this.pool || (this.pool = [],
        this._createPool());
        let t = (n = this.pool) == null ? void 0 : n.pop();
        if (t || (t = this.createEntity()),
        t.name === "lightStick") {
            t.enabled = !0;
            var s = t.children[0];
            s.children[0].enabled = !1;
            var i = s.children[1];
            i.children[0].enabled = !1,
            i.children[1].enabled = !1
        } else
            t.enabled = !0;
        return t.once(We.Despawn, () => this.despawn(t)),
        a && (e >= 0 ? a.insertChild(t, e) : a.addChild(t)),
        t.fire(We.Spawn),
        t
    },
    despawn(a) {
        var e;
        a.enabled = !1,
        (e = a.parent) == null || e.removeChild(a),
        this.pool.push(a)
    },
    spawnAt(a, e=null, t=-1) {
        let s = a.getPosition()
          , i = this.spawn(e || a, t);
        return i.setPosition(s),
        i
    },
    spawnTo(a, e=null, t=-1) {
        let s = this.spawn(e || this.entity, t);
        return s.setPosition(a),
        s
    },
    _createPool: function() {
        let a = 0;
        for (var e = 0; e < this.poolSize; e++) {
            let t = this.createEntity();
            t instanceof Rn && !t.loaded ? t.once(ki.Loaded, () => {
                a++,
                a >= this.poolSize && this.fire(We.PoolInitialized)
            }
            ) : t instanceof ei && !t.loaded ? t.once(zt.Loaded, () => {
                a++,
                a >= this.poolSize && this.fire(We.PoolInitialized)
            }
            ) : this.fire(We.PoolInitialized),
            this.pool.push(t)
        }
    },
    createEntity() {
        return new this.class(...this.args)
    }
})
  , UN = Te.createScript({
    name: "boxSpawner",
    attributes: {
        spawnerEntity: {},
        layer: {
            default: null
        }
    },
    initialize() {
        this.spawner = this.spawnerEntity.getScript(Gs),
        this.spawner.createEntity = this.createBox.bind(this)
    },
    createBox() {
        let a = new V;
        return a.addScript(Df),
        a.boxModel = j.createModel("model_box"),
        a.boxModel.model.layers[0] = this.layer.id,
        a.addChild(a.boxModel),
        a.boxModel.setLocalEulerAngles(0, 180, 0),
        a.boxModel.setLocalPosition(0, .5, .5),
        a.boxModel.setLocalScale(1, 1, 1),
        a.shadowBox = j.createModel("model_box_shadow"),
        a.shadowBox.model.layers[0] = this.layer.id,
        a.addChild(a.shadowBox),
        a.shadowBox.setLocalEulerAngles(0, 180, 0),
        a.shadowBox.setLocalPosition(0, -1, .5),
        a.shadowBox.setLocalScale(1, 1, 1),
        a.collider = a.addScript(Dg, {
            tag: An.Box,
            scale: new y(1,1,1)
        }),
        a
    }
})
  , zN = Te.createScript({
    name: "cloudSpawner",
    attributes: {
        spawner: {},
        waveSpawner: {}
    },
    spawn(a, e) {
        let t = a.getScript(Ww)
          , s = this.waveSpawner.spawn(a);
        s.setPosition(0, 0, e);
        let i = s.getScript(Og);
        i.cloudHolder = s.cloudHolder;
        let n = this.spawner.spawn(s.cloudHolder)
          , r = this.spawner.spawn(s.cloudHolder);
        n.setLocalPosition(J.random(-5, 0), J.random(-5, -2), 0),
        r.setLocalPosition(J.random(0, 5), J.random(-5, -2), 0),
        n.cloud.sprite.opacity = 0,
        r.cloud.sprite.opacity = 0,
        s.once(We.Despawn, () => {
            t.respawn()
        }
        );
        let o = {
            opacity: 0
        };
        Z.createTween(o, {
            opacity: J.random(.1, .3)
        }, {
            duration: 1,
            onUpdate: () => {
                n.cloud.sprite.opacity = o.opacity,
                r.cloud.sprite.opacity = o.opacity
            }
        }).start()
    }
})
  , VN = Te.createScript({
    name: "mineController",
    onHit() {
        this.entity.fire(We.Spawn)
    }
})
  , GN = Te.createScript({
    name: "mineSpawner",
    attributes: {
        spawnerEntity: {
            type: "entity",
            default: null
        },
        layer: {
            default: null
        }
    },
    initialize() {
        this.spawner = this.spawnerEntity.getScript(Gs),
        this.spawner.createEntity = this.createMine.bind(this)
    },
    createMine() {
        let a = new V;
        a.addScript(VN);
        let e = j.createModel("model_obstacle");
        return e.model.layers[0] = this.layer.id,
        a.addChild(e),
        e.setLocalScale(1.2, 1.2, 1.2),
        e.setLocalPosition(0, .5, .5),
        a.shadowBox = j.createModel("model_obstacle_shadow"),
        a.shadowBox.model.layers[0] = this.layer.id,
        a.addChild(a.shadowBox),
        a.shadowBox.setLocalPosition(0, -1, .5),
        a.shadowBox.setLocalScale(1.2, 1.2, 1.2),
        a.collider = a.addScript(Dg, {
            tag: An.Obstacle,
            scale: new y(.7,1,1),
            position: new y(0,0,1)
        }),
        a
    }
})
  , Md = Object.freeze({
    Empty: "empty",
    Box: "box",
    Obstacle: "obstacle"
})
  , Xw = Te.createScript({
    name: "waveManager",
    attributes: {
        boxCollideWidth: {
            default: 1
        },
        mineCollideWidth: {
            default: 1
        },
        colliderWidth: {
            default: 1
        },
        collider: {}
    },
    onWaveSpawn(a) {
        this.checkCollide(a)
    },
    onWaveSpawned() {},
    turnOffColliders() {
        this.entity.children.forEach(a => {
            a.children.forEach(e => {
                e.children.forEach(t => {
                    t.collider && t.collider.off(hh.OnCollide)
                }
                )
            }
            )
        }
        )
    },
    update(a) {},
    playback(a=null) {
        let e = B.REVERT_TIME * B.GAME_SPEED
          , t = this.entity.getLocalPosition().clone();
        t.z += e,
        Z.createLocalTranslateTween(this.entity, t, {
            duration: .5,
            onComplete: () => {
                a && a()
            }
        }).start()
    },
    activeAllColliders(a=!0) {
        this.entity.children.forEach(e => {
            e.children.forEach(t => {
                t.children.forEach(s => {
                    s.collider && (s.collider.enabled = a)
                }
                )
            }
            )
        }
        )
    },
    checkCollide(a) {
        let e = a.getScript(Nh)
          , t = e.mineHolder.children;
        for (var s = 0; s < t.length; s++) {
            let o = t[s];
            o.collider.off(),
            o.collider.on(hh.OnCollide, () => {
                this.onHitMine(o)
            }
            )
        }
        let i = e.boxHolder.children
          , n = this;
        for (var r = 0; r < i.length; r++) {
            let o = i[r];
            o.collider.off(),
            o.collider.on(hh.OnCollide, () => {
                n.onHitBox(o)
            }
            )
        }
    },
    isCollide(a, e, t, s) {
        return a.x - e / 2 < t.x + s / 2 && a.x + e / 2 > t.x - s / 2 && a.z - e / 2 < t.z + s / 2 && a.z >= t.z
    },
    onHitBox(a) {
        if (!a)
            return;
        a.collider.enabled = !1;
        let e = a.getScript(Df);
        e.onHit(),
        this.fire(Ye.HitBox, a),
        a.changeColor && this.fire(Ye.HitChangeColorBox, a.changeColor),
        a.enableVisualizer && this.fire(Ye.HitEnableVisualizer, a),
        e.isComboBox ? this.fire(Ye.HitComboBox, a) : this.fire(Ye.HitSingleBox, a)
    },
    onHitMine(a) {
        a.collider.enabled = !1,
        this.activeAllColliders(!1),
        this.fire(Ye.HitMine, a)
    },
    onMiss() {
        this.fire(Ye.Miss)
    },
    stopWaves() {
        this.enabled = !1,
        this.entity.children.forEach(a => {
            var e = a.getScript(Rt);
            e && (e.enabled = !1)
        }
        )
    },
    resumeWaves() {
        this.enabled = !0,
        this.activeAllColliders(!0),
        this.entity.children.forEach(a => {
            var e = a.getScript(Rt);
            e && (e.enabled = !0)
        }
        )
    },
    removeWaves() {
        for (; this.entity.children.length > 0; )
            this.despawnWave(this.entity.children[0])
    },
    despawnWave(a) {
        var e = a.getScript(Nh);
        e.despawn()
    }
})
  , Ye = Object.freeze({
    HitBox: "wavemanager:hitbox",
    HitMine: "wavemanager:hitmine",
    HitSingleBox: "wavemanager:hitsinglebox",
    HitComboBox: "wavemanager:hitcombobox",
    HitChangeColorBox: "wavemanager:hitchangecolorbox",
    HitEnableVisualizer: "wavemanager:hitenablevisualizer",
    Miss: "wavemanager:miss"
})
  , Io = Object.freeze({
    Spawn: "wavespawner:spawn",
    Despawn: "wavespawner:despawn"
})
  , HN = Te.createScript({
    name: "waveSpawner",
    attributes: {
        poolSize: {
            default: 0
        },
        spawner: {},
        boxSpawner: {},
        mineSpawner: {},
        waveHolder: {}
    },
    preSpawnWaves: [],
    boxNum: 0,
    initialize() {
        this.spawner.createEntity = this.createWave.bind(this)
    },
    spawnAll(a) {
        this.countTotal = 0,
        a.forEach( (e, t) => {
            let s = e.note
              , i = e.nextNote
              , n = this.spawn(s, i);
            n.index = t,
            this.waves.push(n),
            this.countTotal++,
            this.countTotal >= a.length && (this.waveLoaded = !0,
            this.fire(Io.AllWaveSpawned))
        }
        )
    },
    createWave() {
        let a = new V("wave");
        this.moveScript = a.addScript(Rt, {
            speed: new y(0,0,-B.GAME_SPEED)
        });
        let e = new V("boxHolder")
          , t = new V("mineHolder");
        a.addChild(e),
        a.addChild(t);
        let s = a.addScript(Nh, {
            boxHolder: e,
            mineHolder: t
        })
          , i = this.waveHolder.getScript(Xw);
        return s.on(Hw.Miss, i.onMiss, i),
        a.addScript(en, {
            z: -5
        }).on(Zs.OutOfScreen, () => {
            s.despawn()
        }
        ),
        a
    },
    spawn(a, e) {
        let t = this.spawner.spawn(this.waveHolder, 0)
          , s = (a.time - a.spawnTime) * B.GAME_SPEED - 1.5;
        t.setPosition(0, 0, s);
        let i = t.getScript(Rt);
        i.enabled = !0;
        let n = t.getScript(Nh);
        n.boxCount = 0,
        n.noteData = a;
        let r = this.defineLaneNotePosition(a)
          , o = this.isCombo(r)
          , l = this.defineLaneNotePosition(e)
          , c = this.isCombo(l) && e.time - a.time < .5;
        return r.forEach(d => {
            switch (d.type) {
            case Md.Box:
                var h = this.boxSpawner.spawn();
                if (a.changeColor) {
                    let m = X.find("mat_box_special").resource;
                    h.boxModel.model.meshInstances[0].material = m;
                    let g = X.find("mat_box_special_shadow").resource;
                    h.shadowBox.model.meshInstances[0].material = g
                } else {
                    let m = X.find("mat_box_yellow").resource;
                    h.boxModel.model.meshInstances[0].material = m;
                    let g = X.find("mat_box_shadow_yellow").resource;
                    h.shadowBox.model.meshInstances[0].material = g
                }
                h.setLocalPosition(d.position, 0, 0),
                n.boxHolder.addChild(h),
                n.boxCount += 1;
                var u = h.getScript(Df);
                u.isComboBox = o,
                u.isNextBoxCombo = c,
                h.isComboBox = o,
                u.wave = n,
                h.index = a.noteIndex,
                h.changeColor = a.changeColor;
                var f = h.collider;
                f.enabled = !0;
                break;
            case Md.Obstacle:
                var p = this.mineSpawner.spawn();
                p.setLocalPosition(d.position, 0, 0),
                n.mineHolder.addChild(p);
                var _ = p.collider;
                _.enabled = !0;
                break
            }
        }
        ),
        this.fire(Io.Spawn, t),
        t.once(We.Despawn, () => {
            this.fire(Io.Despawn, t)
        }
        ),
        t
    },
    defineLaneNotePosition(a) {
        const {lane1: e, lane2: t, lane3: s, lane4: i, lane5: n} = a;
        return [{
            type: e,
            position: 2
        }, {
            type: t,
            position: 1
        }, {
            type: s,
            position: 0
        }, {
            type: i,
            position: -1
        }, {
            type: n,
            position: -2
        }]
    },
    isCombo(a) {
        let e = !1;
        for (let t = 0; t < a.length && t !== a.length - 1; t++)
            if (a[t].type === Md.Box && a[t + 1].type === Md.Box) {
                e = !0;
                break
            }
        return e
    },
    preSpawn(a, e) {
        let t = this.spawn(a, e)
          , s = t.getScript(Rt);
        s.enabled = !1,
        this.preSpawnWaves.push(t)
    },
    start() {
        this.preSpawnWaves.forEach(a => {
            let e = a.getScript(Rt);
            e.enabled = !0
        }
        ),
        this.preSpawnWaves = []
    },
    reset() {
        this.preSpawnWaves.forEach(a => {
            let e = a.getScript(Rt);
            e.enabled = !1,
            a.fire(We.Despawn)
        }
        ),
        this.preSpawnWaves = []
    }
})
  , WN = Te.createScript({
    name: "songManager",
    attributes: {
        delayStart: {
            default: 0
        },
        spawnOffset: {
            default: 0
        },
        countPreSpawn: {
            default: 0
        }
    },
    playTime: 0,
    loaded: !1,
    songStarted: !1,
    playing: !1,
    ended: !1,
    passedLastNote: !1,
    songData: [],
    songDuration: 0,
    currSpawnIndex: 0,
    loadSongData(a, e, t) {
        Ro.log("SongManager", "Load Song"),
        this.songData = a,
        this.songDuration = t,
        this.reset(),
        this.loaded = !0;
        for (let s = 0; s < this.countPreSpawn; s++)
            this._preSpawn()
    },
    reset() {
        this.songData[0] && (this.playTime = -this.delayStart,
        this.currSpawnIndex = 0,
        this.songStarted = !1,
        this.loaded = !1,
        this.playing = !1,
        this.ended = !1)
    },
    play() {
        this.playing = !0,
        this.songStarted && this.fire(ns.SongResume)
    },
    update(a) {
        if (!this.loaded || !this.playing)
            return;
        if (!this.ended && this.playTime >= this.songDuration + 1) {
            Ro.log("SongManager", "End"),
            this.ended = !0,
            this.fire(ns.SongEnd);
            return
        }
        this.playTime += a,
        !this.songStarted && this.playTime >= 0 && this._onSongStart();
        let e = this.songData[this.currSpawnIndex];
        e && this.playTime >= e.time - this.spawnOffset && this._spawn()
    },
    revert(a) {
        this.playTime -= a
    },
    _onSongStart() {
        Ro.log("SongManager", "Start"),
        this.fire(ns.SongStart),
        this.songStarted = !0
    },
    _spawn() {
        let a = this.songData[this.currSpawnIndex]
          , e = this.songData[this.currSpawnIndex + 1];
        this.songData[this.currSpawnIndex + 1] || (e = a),
        a.spawnTime = this.playTime,
        a.noteIndex = this.currSpawnIndex,
        this.currSpawnIndex++,
        this.fire(ns.SpawnNote, a, e)
    },
    _preSpawn() {
        let a = this.songData[this.currSpawnIndex]
          , e = this.songData[this.currSpawnIndex + 1];
        this.songData[this.currSpawnIndex + 1] || (e = a),
        a.spawnTime = this.playTime,
        a.noteIndex = this.currSpawnIndex,
        this.currSpawnIndex++,
        this.fire(ns.PreSpawnNote, a, e)
    },
    onDespawnWave(a) {
        a.getScript(Nh)
    }
})
  , ns = Object.freeze({
    SongStart: "songmanager:songstart",
    SongResume: "songmanager:songresume",
    SongEnd: "songmanager:songend",
    SpawnNote: "songmanger:spawnnote",
    PreSpawnNote: "songmanager:prespawnnote"
})
  , XN = Te.createScript({
    name: "songPlayer",
    attributes: {
        songManager: {},
        songName: {
            default: ""
        }
    },
    songId: null,
    started: !1,
    paused: !1,
    loadSong(a) {
        this.songName = a
    },
    play() {
        this.started || (this.songId = Qe.play(this.songName),
        this.started = !0)
    },
    revert() {
        this.started && Qe.skip(this.songName, this.songId, -B.REVERT_TIME)
    },
    resume() {
        this.started && this.paused && (this.paused = !1,
        Qe.play("sfx_hit", 0, !1),
        Qe.resume(this.songName, this.songId))
    },
    pause() {
        this.started && !this.paused && (this.paused = !0,
        Qe.pause(this.songName, this.songId))
    },
    stop() {
        Qe.stop(this.songName, this.songId)
    },
    reset() {
        this.started = !1,
        this.paused = !1,
        this.songId = null
    }
});
Te.createScript({
    name: "randomRotation",
    attributes: {
        min: {
            default: new y
        },
        max: {
            default: new y
        }
    },
    rotate() {
        let a = this.getRandomEuler();
        this.entity.setLocalEulerAngles(a)
    },
    getRandomEuler() {
        return J.randomVector(this.min, this.max)
    }
});
const jN = Te.createScript({
    name: "cut",
    attributes: {
        left: {},
        right: {},
        duration: {
            default: .55
        }
    },
    onEnable() {
        this.tweens || this._initAnimation(),
        this.play()
    },
    _initAnimation() {
        let a = this._createMotion(this.left, -1, this.onAnimationComplete.bind(this))
          , e = this._createMotion(this.right);
        this.tweens = a.concat(e)
    },
    play() {
        this.tweens.forEach(a => a.start()),
        this.fire(Au.Start)
    },
    _createMotion(a, e=1, t) {
        var s = J.random(18, 20);
        let i = Z.createLocalTranslateTween(a, {
            z: s
        }, {
            duration: this.duration,
            onComplete: t
        });
        var n = J.random(5, 5.5);
        let r = .6
          , o = Z.createLocalTranslateTween(a, {
            y: n
        }, {
            duration: this.duration * r,
            easing: Z.Easing.Quadratic.Out
        })
          , l = a.getLocalPosition();
        l.y = n,
        a.setLocalPosition(l);
        let c = Z.createLocalTranslateTween(a, {
            y: n - .1
        }, {
            duration: this.duration * (1 - r),
            easing: Z.Easing.Quadratic.In
        });
        o.chain(c),
        l.y = 0,
        a.setLocalPosition(l);
        var d = J.random(7, 8);
        let h = Z.createLocalTranslateTween(a, {
            x: d * e
        }, {
            duration: this.duration
        });
        var u = J.random(0, 360)
          , f = 20
          , p = a.getLocalEulerAngles().clone();
        let _ = Z.createTween({
            rotationX: p.x,
            rotationY: p.y
        }, {
            rotationX: f,
            rotationY: p.y + u
        }, {
            duration: this.duration,
            onUpdate: m => {
                a.setLocalEulerAngles(m.rotationX, m.rotationY, p.z)
            }
        });
        return [i, o, h, _]
    },
    onAnimationComplete() {
        this.fire(Au.Complete)
    }
})
  , Au = Object.freeze({
    Start: "cut:start",
    Complete: "cut:complete"
})
  , $N = Te.createScript({
    name: "cutBoxEffectSpawner",
    attributes: {
        spawner: {}
    },
    initialize() {
        this.spawner.createEntity = this.createEffect.bind(this)
    },
    createEffect() {
        let a = new V("fx_cut_box")
          , e = new V("left")
          , t = j.createModel("model_box_half");
        a.addChild(e),
        e.addChild(t),
        e.setLocalPosition(.005, .5, 2),
        t.setLocalEulerAngles(0, 0, 0),
        t.setLocalScale(1, 1, 1);
        let s = new V("right")
          , i = j.createModel("model_box_half");
        a.addChild(s),
        s.addChild(i),
        s.setLocalPosition(.005, .5, 2),
        s.setLocalEulerAngles(0, 0, 180),
        i.setLocalScale(1, 1, 1);
        const n = Bi.scene.layers.getLayerByName("Box");
        let r = j.createSprite("spr_flare_1");
        r.sprite.layers = [n.id],
        a.addChild(r),
        r.setLocalPosition(0, .5, .245),
        r.setLocalEulerAngles(30, 0, 0),
        r.setLocalScale(0, 0, 0);
        let o = Z.createScaleTween(r, {
            x: .01,
            y: .01,
            z: .01
        }, {
            duration: .05
        })
          , l = 1;
        r.sprite.opacity = 0;
        let c = Z.createTween(r.sprite, {
            opacity: l
        }, {
            duration: .1,
            onStart: () => o.start()
        });
        r.sprite.opacity = l;
        let d = Z.createTween(r.sprite, {
            opacity: 0
        }, {
            duration: .05,
            onStart: () => {}
            ,
            onComplete: () => {}
        });
        c.chain(d);
        let h = a.addScript(jN, {
            left: e,
            right: s
        });
        return h.on(Au.Start, () => c.start()),
        h.on(Au.Complete, () => a.fire(We.Despawn)),
        a
    }
})
  , qN = Te.createScript({
    name: "gameManager",
    attributes: {
        txtHello: {
            type: "string",
            default: "no one say hello"
        }
    },
    startGame() {
        this.fire(ke.Start)
    },
    pause() {
        this.fire(ke.Pause)
    },
    resume() {
        this.fire(ke.Resume)
    },
    lose() {
        this.fire(ke.Lose)
    },
    win() {
        this.fire(ke.Win)
    }
})
  , ke = Object.freeze({
    Start: "start",
    Pause: "pause",
    Resume: "resume",
    Lose: "lose",
    Win: "win"
})
  , jw = Object.freeze({
    ScoreChanged: "scoremanager:scorechanged"
})
  , YN = Te.createScript({
    name: "scoreManager",
    score: 0,
    setScore(a) {
        this.score = a,
        this.fire(jw.ScoreChanged, this.score)
    },
    onHitBox() {
        this.setScore(this.score + B.BOX_SCORE)
    }
})
  , aS = Object.freeze({
    OnProgress: "progress:onprogress",
    OnThreshold: "progress:onthreshold",
    OnMidway: "progress:onmidway",
    OnFull: "progress:onfull"
})
  , KN = Te.createScript({
    name: "progress",
    attributes: {
        songDuration: {
            default: 0
        },
        thresholdCount: {
            default: 0
        }
    },
    currentCount: 0,
    setCurrentIndex(a) {}
})
  , oS = Te.createScript({
    name: "nodeMover",
    attributes: {
        speed: {
            default: 0
        },
        followNode: {
            default: null
        }
    },
    scaleVector: null,
    targetHeight: 1,
    minHeight: .5,
    initialize() {
        this.scaleVector = this.entity.getLocalScale()
    },
    update(a) {
        this.followNode ? (this.scaleVector.y = W.lerp(this.entity.getLocalScale().y, this.followNode.node.getLocalScale().y, this.speed * a),
        this.scaleVector.y = Math.max(this.scaleVector.y, this.minHeight),
        this.entity.setLocalScale(this.scaleVector)) : (this.scaleVector.y = W.lerp(this.entity.getLocalScale().y, this.targetHeight, this.speed * a),
        this.scaleVector.y = Math.max(this.scaleVector.y, this.minHeight),
        this.entity.setLocalScale(this.scaleVector))
    },
    setHeight(a) {
        this.targetHeight = a
    },
    setSpeed(a) {
        this.speed = a
    }
});
Object.freeze({
    Pink: J.createColor(221, 51, 205),
    Yellow: J.createColor(223, 209, 151),
    Blue: J.createColor(233, 110, 140)
});
class ZN extends V {
    constructor() {
        super(),
        this.initModel()
    }
    init(e=!1, t=null) {
        this.isMainNode = e,
        this.mover && this.removeScript(oS),
        this.mover = this.addScript(oS, {
            speed: B.VISUALIZER_SPEED,
            followNode: t
        })
    }
    initModel() {
        this.node = j.createModel("model_audio_visualize"),
        this.addChild(this.node),
        this.node.setEulerAngles(90, 130, 180),
        this.node.setLocalScale(10, 100, 100),
        this.setLocalScale(1, 1, 1)
    }
    setHeight(e) {
        this.mover.setHeight(e)
    }
    setSpeed(e) {
        this.mover.setSpeed(e)
    }
}
class lS extends V {
    constructor(e, t=5, s=1) {
        super(),
        this.length = e,
        this.mainNodeRate = t,
        this.nodeSpacing = s,
        this.nodeSpawner = this.addScript(Gs, {
            class: ZN,
            poolSize: 100
        }),
        this.mainNode = [],
        this.nodes = []
    }
    init(e=!1) {
        this._spawnNodes(e),
        this._setUpNode()
    }
    _spawnNodes(e) {
        let t = this.nodeSpacing;
        for (let s = 0; s < this.length; s++) {
            let i = this.nodeSpawner.spawn();
            i.setPosition(0, 0, s * this.nodeSpacing + t),
            t *= 1.08,
            e && i.setEulerAngles(0, 180, 0),
            this.addChild(i),
            this.nodes.push(i)
        }
    }
    _setUpNode() {
        for (let e = 0; e < this.length; e += this.mainNodeRate * 2 + 1) {
            let t = Math.floor(e + this.mainNodeRate)
              , s = this.nodes[t];
            this.mainNode.push(s),
            s.init(!0, null);
            for (let i = t - 1; i >= t - this.mainNodeRate; i--)
                this.nodes[i].init(!0, null);
            for (let i = t + 1; i <= t + this.mainNodeRate; i++)
                this.nodes[i].init(!0, null)
        }
    }
    updateHeight(e) {
        let t = this.nodes.length > e.length ? e.length : this.nodes.length;
        for (let s = 0; s < t; s++) {
            let i = this.nodes[s]
              , n = e[s];
            i.setHeight(n)
        }
    }
    setSpeed(e) {
        this.nodes.forEach(t => {
            t.setSpeed(e)
        }
        )
    }
}
class ss {
    static init(e) {
        this._current = 0,
        this._dt = 0,
        this.scale = 1,
        this.started = !1,
        e.on("update", this.update, this)
    }
    static start() {
        this.scale = 1,
        this.started = !0
    }
    static stop() {
        this.scale = 0,
        this.started = !1
    }
    static pause() {
        this.scale = 0
    }
    static resume() {
        this.started && (this.scale = 1)
    }
    static reset() {
        this._current = 0,
        this._dt = 0,
        this.scale = 1,
        this.started = !1
    }
    static update(e) {
        this._dt = e * this.scale,
        this._current += this._dt
    }
    static get dt() {
        return this._dt
    }
    static get current() {
        return this._current
    }
    static get currentMS() {
        return this._current * 1e3
    }
    static revert(e, t= () => {}
    ) {
        this.isRevert = !0;
        let s = Math.min(this._current, e);
        return Z.createTween(this, {
            _current: this._current - s
        }, {
            onComplete: () => {
                this.isRevert = !1,
                t()
            }
        }).start(),
        s
    }
}
const QN = Te.createScript({
    name: "sinWave",
    attributes: {
        analyser: {},
        sinWidth: {
            default: .1
        },
        waves: {
            default: null
        },
        speed: {
            default: 1
        },
        minHeight: {
            default: 0
        },
        maxHeight: {
            default: 5
        },
        sinCount: {
            default: 5
        },
        jumpHeight: {
            default: 5
        },
        returnSpeed: {
            default: 1
        },
        jumpTime: {
            default: 1
        }
    },
    dataArray: null,
    multiplierArray: null,
    isJumping: !1,
    isJumped: !1,
    lastJumpTime: 0,
    currentNodeIndex: 1,
    initialize() {
        this.wave = this.wave || this.entity,
        this.dataArray = new Uint8Array(this.sinCount),
        this.multiplierArray = new Float32Array(this.sinCount);
        for (let a = 0; a < this.sinCount; a++)
            this.multiplierArray[a] = 1
    },
    updateDataArray(a=[]) {},
    updateWave() {
        this.waves.forEach(a => a.updateHeight(this.dataArray))
    },
    updateData() {
        if (this.isJumping && !this.isJumped) {
            let a = Util.random(0, this.sinCount - 1)
              , e = this.sinCount
              , t = Math.floor(e / 2);
            this.updateMultiplier(a, t);
            let s = a > t ? a - t : a + t;
            this.updateMultiplier(s, t),
            this.isJumped = !0
        }
        for (let a = 0; a < this.sinCount; a++) {
            let e = Math.sin((this.sinCount - 1 - a) * this.sinWidth + this.speed * Gi.current)
              , t = (this.maxHeight - this.minHeight) / 2
              , s = (this.maxHeight + this.minHeight) / 2;
            this.dataArray[a] = e * t + s
        }
    },
    updateMultiplier(a, e) {
        a = Math.floor(a);
        let t = parseInt(a + Math.floor(e / 2));
        for (let i = a; i < (t < this.sinCount ? t : this.sinCount); i++) {
            let n = 1 - (i - a) / (e / 2);
            this.multiplierArray[i] = this.jumpHeight * n + 1
        }
        let s = parseInt(a - Math.floor(e / 2));
        for (let i = a; i > (s >= 0 ? s : 0); i--) {
            let n = 1 - (a - i) / (e / 2);
            this.multiplierArray[i] = this.jumpHeight * n + 1
        }
    },
    _getHightestIndex() {
        let a = 0;
        for (let e = 0; e < this.sinCount; e++)
            this.dataArray[e] > this.dataArray[a] && (a = e);
        return a
    },
    jump() {
        this.isJumping || (this.isJumping = !0,
        this.isJumped = !1,
        this.lastJumpTime = Gi.current,
        this.setWaveSpeed(B.VISUALIZER_JUMP_SPEED))
    },
    returnToNormal() {
        for (let a = 0; a < this.sinCount; a++)
            this.multiplierArray[a] = W.lerp(this.multiplierArray[a], 1, this.returnSpeed * Gi.dt);
        Gi.current - this.lastJumpTime > this.jumpTime && (this.isJumping = !1,
        this.setWaveSpeed(B.VISUALIZER_SPEED))
    },
    setWaveSpeed(a) {
        this.waves.forEach(e => {
            e.setSpeed(a)
        }
        )
    },
    updateAudioData() {
        let a = songData[this.currentNodeIndex];
        a && a.time <= ss.current && this.currentNodeIndex < songData.length && (this.currentNodeIndex++,
        this.jump())
    },
    update() {
        this.updateData(),
        this.updateWave()
    }
})
  , JN = Te.createScript({
    name: "bindAnalyser",
    attributes: {
        analyser: {
            default: null
        },
        updateCallback: {
            default: () => {}
        }
    },
    initialize() {
        this.bufferLength = this.analyser.frequencyBinCount,
        this.dataArray = new Uint8Array(this.bufferLength)
    },
    update() {
        this.analyser && (this.analyser.getByteFrequencyData(this.dataArray),
        this.updateCallback(this.dataArray))
    }
});
class hS extends V {
    constructor() {
        super(),
        this._init()
    }
    _init() {
        this.spark = new V,
        this.addChild(this.spark);
        let e = .6
          , t = new Ot([0, e])
          , s = new Ot([0, 1, 1, 0])
          , i = 30
          , n = new Qt([0, 0],[0, i],[0, 0])
          , r = new Qt([0, 0],[0, i / 5],[0, 0])
          , o = new Qt([0, 0],[0, 1],[0, 0]);
        this.colorGraph = o,
        this.spark.addComponent("particlesystem", {
            numParticles: 200,
            lifetime: .5,
            rate: 0,
            autoPlay: !1,
            loop: !1,
            localSpace: !0,
            blendType: fi,
            emitterShape: di,
            emitterExtents: new y(0,0,80),
            scaleGraph: t,
            alphaGraph: s,
            localVelocityGraph: n,
            localVelocityGraph2: r,
            colorGraph: o
        })
    }
    play() {
        this.spark.particlesystem.reset(),
        this.spark.particlesystem.play()
    }
    stop() {
        this.spark.particlesystem.stop()
    }
    setColor(e) {
        this.colorGraph = new Qt([0, e.r],[0, e.g],[0, e.b]),
        this.spark.particlesystem.colorGraph = this.colorGraph
    }
}
class Ds {
    static showPrerollAds() {
        this.isPrerolAdsShown || (this.isPrerolAdsShown = !0,
        this._showAds())
    }
    static showMidrollAds() {
        this._showAds()
    }
    static _showAds() {
        te.setPause(!0);
        typeof window.wsdk < "u" && window.wsdk.showAd !== "undefined" && window.wsdk.showAd().then(()=>{
            te.setPause(!1);
        }).catch(()=>{
            te.setPause(!1);
        })
    }
    static checkRewardAds() {
        return new Promise(e => {
            if (this._isRewardAdsReady) {
                e(!0);
                return
            }
            this._isRewardAdsReady = !0,
            e(!0)
            // typeof window.wsdk < "u" && window.wsdk.preloadAd !== "undefined" ? window.wsdk.preloadAd("rewarded").then( () => {
            // }
            // ).catch( () => {
            //     this._isRewardAdsReady = !1,
            //     e(!1)
            // }
            // ) : (this._isRewardAdsReady = !1,
            // e(!1))
        }
        )
    }
    static showRewardAds() {
        return new Promise(e => {
            if (!this._isRewardAdsReady) {
                e(!1);
                return
            }
            
            te.setPause(!0);
            typeof window.wsdk < "u" && window.wsdk.showAd !== "undefined" ? window.wsdk.showAd("rewarded")
            .then( () => {
                this._isRewardAdsReady = !1,
                e(!0)
                te.setPause(!1);
            }).catch( () => {
                e(!1);
                 te.setPause(!1)
            })
            :e(!0)

            // this._isRewardAdsReady = !1,
        }
        )
    }
}
ti(Ds, "isPrerolAdsShown", !0),
ti(Ds, "_isRewardAdsReady", !0);
class Kp extends V {
    constructor(e, t, s={}) {
        super(),
        this.textAssets = t,
        s.type = us,
        s.anchor = s.anchor || new M(.5,.5,.5,.5),
        s.pivot = s.pivot || new P(.5,.5),
        s.margin = s.margin || new M,
        s.padding = s.padding || new M,
        s.color = s.color || new z(1,1,1),
        s.opacity = s.opacity || 1,
        s.spriteAsset = X.find(e),
        this.addComponent("element", s),
        this.frame = j.createImageElement(e),
        this.addChild(this.frame),
        this._initText()
    }
    _initText() {
        this.text = j.createTextElement(this.textAssets, {
            text: "",
            color: new z(1,1,1),
            fontSize: 46,
            pivot: new P(.5,.5),
            anchor: new M(.5,.5,.5,.5),
            alignment: new P(.5,.5)
        }),
        this.addChild(this.text),
        this.text.setLocalPosition(0, this.text.element.height / 2, 0)
    }
    changeTextColor(e) {
        this.text.element.color = e
    }
    changeText(e) {
        this.text.element.text = e
    }
}
const e3 = Te.createScript({
    name: "layoutGroupFitter",
    attributes: {
        orientation: {
            default: Re
        }
    },
    initialize() {
        this.fit()
    },
    onEnable() {
        this.fit()
    },
    fit() {
        this.orientation === Re ? this.fitVertical() : this.orientation === Se && this.fitHorizontal()
    },
    fitVertical() {
        let a = this.entity.layoutgroup
          , e = a.padding.y + a.padding.w
          , t = this.entity.children;
        for (var s = 0; s < t.length; ++s) {
            var i = t[s];
            i._enabled && (e += i.element.height)
        }
        e += Math.max(0, t.length) * a.spacing.y,
        this.entity.element.height = e
    },
    fitHorizontal() {
        let a = this.entity.layoutgroup
          , e = a.padding.x + a.padding.z
          , t = this.entity.children;
        for (var s = 0; s < t.length; ++s) {
            var i = t[s];
            i._enabled && (e += i.element.width)
        }
        e += Math.max(0, t.length - 1) * a.spacing.x,
        this.entity.element.width = e
    }
})
  , d_ = Object.freeze({
    Select: "listViewItem:select",
    Deselect: "listViewItem:deselect"
})
  , t3 = Te.createScript({
    name: "listViewItem",
    attributes: {
        buttonComponent: {
            default: null
        },
        selectedElements: {
            default: []
        },
        unselectedElements: {
            default: []
        }
    },
    initialize() {
        this.buttonComponent.on("click", this.select, this)
    },
    select() {
        this.unselectedElements.forEach(a => {
            a.enabled = !1
        }
        ),
        this.selectedElements.forEach(a => {
            a.enabled = !0
        }
        ),
        this.buttonComponent.selected = !0,
        this.fire(d_.Select, this)
    },
    deselect() {
        this.selectedElements.forEach(a => {
            a.enabled = !1
        }
        ),
        this.unselectedElements.forEach(a => {
            a.enabled = !0
        }
        ),
        this.buttonComponent.selected = !1,
        this.fire(d_.Deselect, this)
    }
});
class $w extends V {
    constructor(e={}) {
        super("list-view"),
        this.items = [],
        this.selectedItem = null,
        e.type = us,
        e.anchor = e.anchor || new M(0,0,1,1),
        e.margin = e.margin || new M,
        this.addComponent("element", e),
        this.addComponent("layoutgroup", {
            orientation: Re,
            alignment: new P(.5,1),
            spacing: new P(0,4)
        }),
        this.layoutGroupFitter = this.addScript(e3)
    }
    resize() {
        let e = new P(0,4);
        te.isPortrait && (e = new P(0,140)),
        this.layoutgroup.spacing = e
    }
    addItem(e) {
        let t = e.getScript(t3);
        t && (this.items.push(t),
        t.on(d_.Select, this.onSelectItem, this)),
        this.addChild(e),
        this.layoutGroupFitter.fit()
    }
    clearList() {
        this.children.forEach(e => {
            this.removeChild(e),
            e == null || e.destroy()
        }
        )
    }
    onSelectItem(e) {
        var t;
        this.selectedItem !== e && ((t = this.selectedItem) == null || t.deselect(),
        this.selectedItem = e)
    }
}
const s3 = Te.createScript({
    name: "onEnableCallback",
    attributes: {
        callback: {
            default: null
        }
    },
    onEnable() {
        var a;
        (a = this.callback) == null || a.call(this)
    }
});
class i3 extends V {
    constructor(e={}) {
        super("scroll-bar"),
        e.type = us,
        e.anchor = e.anchor || new M(0,0,1,1),
        e.margin = e.margin || new M,
        this.addComponent("element", e),
        this._initBg(),
        this._initHandle(),
        this.addComponent("scrollbar", {
            orientation: Re,
            value: 0,
            handleSize: .5,
            handleEntity: this.handle
        })
    }
    _initBg() {
        let e = X.find("spr_scrollbar_bg");
        this.bg = new V("bg"),
        this.bg.addComponent("element", {
            type: Ae,
            spriteAsset: e,
            anchor: new M(.5,0,.5,1),
            pivot: new P(.5,.5),
            margin: new M(0,8,0,8),
            color: new z,
            opacity: .5,
            width: 4
        }),
        this.addChild(this.bg)
    }
    _initHandle() {
        let e = X.find("spr_scrollbar_handle");
        this.handle = new V("handler"),
        this.handle.addComponent("element", {
            type: Ae,
            spriteAsset: e,
            anchor: new M(.5,1,.5,1),
            pivot: new P(.5,1),
            margin: new M(0,8,0,8),
            width: 8,
            height: 300,
            useInput: !0
        }),
        this.addChild(this.handle),
        this.handle.addComponent("button", {
            active: !0,
            imageEntity: this.handle,
            hitPadding: new M(0,0,0,0),
            transitionMode: mu,
            hoverTint: new z(1,1,1),
            pressedTint: new z(1,1,1),
            inactiveTint: new z(1,1,1),
            fadeDuration: 0
        })
    }
}
class qw extends V {
    constructor(e, t={}) {
        super("scroll-view"),
        t.type = us,
        t.anchor = t.anchor || new M(0,0,1,1),
        t.margin = t.margin || new M,
        this.addComponent("element", t),
        this._initBackground(),
        this._initScrollBar(),
        this._initViewport(),
        e.element.useInput = !0,
        this.viewport.addChild(e),
        this.addComponent("scrollview", {
            scrollMode: yu,
            bounceAmount: .1,
            friction: .05,
            useMouseWheel: !0,
            mouseWheelSensitivity: new P(1,1),
            viewportEntity: this.viewport,
            contentEntity: e,
            horizontal: !1,
            vertical: !0,
            verticalScrollbarEntity: this.scrollBar,
            verticalScrollbarVisibility: _g
        }),
        this.addScript(s3, {
            callback: () => this.scrollBar.scrollbar._updateHandlePositionAndSize()
        })
    }
    _initBackground() {
        this.bg = j.createColorBackground(),
        this.bg.element.opacity = .5,
        this.addChild(this.bg)
    }
    _initViewport() {
        this.viewport = new V("viewport"),
        this.viewport.addComponent("element", {
            anchor: new M(0,0,1,1),
            color: new z(.2,.2,.2),
            margin: new M,
            mask: !0,
            opacity: 1,
            pivot: new P(0,1),
            rect: new M(0,0,1,1),
            type: Ae
        }),
        this.addChild(this.viewport)
    }
    _initScrollBar() {
        this.scrollBar = new i3({
            anchor: new M(1,0,1,1)
        }),
        this.addChild(this.scrollBar)
    }
}
class Ms {
    static init() {
        var e = X.find("shopData.json");
        if (e === null) {
            console.warn("Shop data not found!");
            return
        }
        this.data = e.resources
    }
    static getData() {
        return this.data
    }
    static getShopItemsByType(e) {
        var t = this.data.findIndex(s => s.type === e);
        return t === -1 ? null : this.data[t].data
    }
    static getShopItemById(e, t) {
        var s = this.getShopItemsByType(e);
        return s === null ? null : s.find(i => i.id === t)
    }
    static getTypeItemById(e) {
        var t = this.data.findIndex(s => s.data.find(i => i.id === e));
        return t === -1 ? null : this.data[t].type
    }
}
const ha = Object.freeze({
    Selected: "Selected",
    Bought: "bought"
});
class Yw extends V {
    constructor() {
        super(),
        this.data = null,
        this.addComponent("element", {
            type: Ae,
            anchor: new M(.5,.5,.5,.5),
            pivot: new P(.5,.5),
            opacity: 0,
            width: 874,
            height: 216
        }),
        this.difficultyColorData = [{
            name: "Easy",
            color: new z(.345,.86,.298)
        }, {
            name: "Medium",
            color: new z(.18,.61,.98)
        }, {
            name: "Hard",
            color: new z(.447,.18,.98)
        }, {
            name: "Expert",
            color: new z(.95,.48,.18)
        }],
        this.activeStarsList = [],
        this.create()
    }
    create() {
        this._createBg(),
        this._createFrameOverlay(),
        this._createFrames(),
        this._createIcon(),
        this._createNameSong(),
        this._createAuthorName(),
        this._createStars(),
        this._createScore(),
        this._createButtonBuy(),
        this._createButtonPlay(),
        this._createButtonBuyWithCoin()
    }
    updateData(e) {
        this.data = e;
        var t = X.find(e.iconName);
        t && (this.icon.element.sprite = t.resource),
        this.nameSong.element.text = e.name,
        this.authorName.element.text = e.author,
        this.updateDifficulty(e.difficulty),
        Q.isSongUnlocked(e.id) ? this.unlock() : this.data.isUnlockByCoin ? (this.buyButtonWithCoin.enabled = !0,
        this.buyButton.enabled = !1,
        this.playButton.enabled = !1,
        this.updateCoinText()) : (this.buyButtonWithCoin.enabled = !1,
        this.disableBuyButton(),
        this.lock());
        let s = 0
          , i = 0
          , n = 0
          , r = 0;
        var o = Q.gamePlayHistory.find(l => l.songId === this.data.id);
        o && (s = o.score,
        i = o.stars,
        n = o.hit,
        r = o.miss),
        this._updateDataHistory(s, i, n, r)
    }
    lock() {
        this.buyButton.enabled = !0,
        this.playButton.enabled = !1
    }
    unlock() {
        this.buyButtonWithCoin.enabled = !1,
        this.buyButton.enabled = !1,
        this.playButton.enabled = !0
    }
    enableBuyButton() {
        this.buyButton.button.enabled = !0,
        this.buyButton.element.useInput = !0,
        this.buyButton.element.color = J.createColor(255, 255, 255, 1)
    }
    disableBuyButton() {
        this.buyButton.button.enabled = !1,
        this.buyButton.element.useInput = !1,
        this.buyButton.element.color = J.createColor(64, 64, 64, 1)
    }
    _createBg() {
        this.background = j.createImageElement("spr_frame_song_item", {
            width: 874,
            height: 216
        }),
        this.background.element.pivot = new P(1,.5),
        this.background.element.anchor = new M(1,.5,1,.5),
        this.background.setLocalScale(.96, 1, 1),
        this.addChild(this.background)
    }
    _createFrameOverlay() {
        this.frameOverlay = j.createImageElement("spr_frame_song_item_overlay"),
        this.frameOverlay.element.pivot = new P(.5,.5),
        this.frameOverlay.element.anchor = new M(.5,.5,.5,.5),
        this.frameOverlay.setLocalScale(.85, .92, 1),
        this.frameOverlay.setLocalPosition(5, -15, 0),
        this.addChild(this.frameOverlay)
    }
    _createIcon() {
        this.icon = j.createImageElement("spr_icon_song_01"),
        this.addChild(this.icon),
        this.icon.element.pivot = new P(0,.5),
        this.icon.element.anchor = new M(0,.5,0,.5),
        this.icon.setLocalScale(.87, .87, 1)
    }
    _createNameSong() {
        this.nameSong = j.createTextElement("poppins_bold", {
            anchor: new M(.3,.7,.3,.7),
            pivot: new P(0,.5),
            text: "Wear me out",
            fontText: "0123456789",
            fontWeight: "bold",
            fontSize: 35,
            color: J.createColor(255, 255, 255),
            x: -22,
            y: -10
        }),
        this.addChild(this.nameSong)
    }
    _createAuthorName() {
        this.authorName = j.createTextElement("poppins_bold", {
            anchor: new M(.3,.5,.3,.5),
            pivot: new P(0,.5),
            text: "Author",
            fontText: "0123456789",
            fontSize: 25,
            color: J.createColor(255, 255, 255),
            x: -22,
            y: -10
        }),
        this.addChild(this.authorName)
    }
    _createButtonBuy() {
        this.buyButton = j.createButtonElement("spr_btn_buy", {
            anchor: new M(.95,.35,.95,.35),
            pressedTint: new z(.5,.5,.5,1),
            pivot: new P(1,.5),
            width: 200,
            height: 100
        }),
        this.addChild(this.buyButton);
        var e = j.createImageElement("spr_icon_ads", {
            anchor: new M(.25,.5,.25,.5)
        });
        this.buyButton.addChild(e);
        var t = j.createTextElement("poppins_bold", {
            anchor: new M(.67,.5,.67,.5),
            alignment: new P(.5,.5),
            text: "GET",
            color: J.createColor(255, 255, 255),
            fontSize: 50
        });
        this.buyButton.addChild(t),
        this.buyButton.button.on("click", this._onBuyButtonClicked, this)
    }
    _onBuyButtonClicked() {
        this.disableBuyButton(),
        Ds.showRewardAds().then(e => {
            e ? (this.unlock(),
            Q.unlockSong(this.data.id),
            this.fire(ha.Bought, this.data.id)) : this.enableBuyButton()
        }
        )
    }
    _createButtonPlay() {
        this.playButton = j.createButtonElement("spr_btn_play", {
            anchor: new M(.95,.35,.95,.35),
            pressedTint: new z(.5,.5,.5,1),
            pivot: new P(1,.5),
            width: 200,
            height: 100
        }),
        this.addChild(this.playButton);
        var e = j.createTextElement("poppins_bold", {
            text: "PLAY",
            fontSize: 50,
            alignment: new P(.5,.5),
            color: J.createColor(255, 255, 255)
        });
        this.playButton.addChild(e),
        this.playButton.button.on("click", () => {
            Ds.showPrerollAds(),
            this.fire(ha.Selected, this.data.id)
        }
        , this)
    }
    updateDifficulty(e) {
        this.difficulty.element.text = e;
        var t = this._findDifficultyColor(e);
        t && (this.difficultyFrame.element.color = t)
    }
    _findDifficultyColor(e) {
        return this.difficultyColorData.find(t => t.name === e).color
    }
    _createStars() {
        this.starContainer = j.createGroupElement({
            anchor: new M(.5,1,.5,1),
            pivot: new P(.5,.5),
            y: -22,
            x: -145
        }),
        this.addChild(this.starContainer),
        this.starUnfill1 = this._initStarUnfilled(),
        this.starUnfill2 = this._initStarUnfilled(),
        this.starUnfill3 = this._initStarUnfilled();
        var e = this.starUnfill2.getLocalPosition().x
          , t = 40;
        this.starUnfill1.setLocalPosition(e - t, 0, 0),
        this.starUnfill2.setLocalPosition(e + t, 0, 0),
        this.starFill1 = this._initStarFilled(),
        this.starFill2 = this._initStarFilled(),
        this.starFill3 = this._initStarFilled(),
        this.activeStarsList = [this.starFill1, this.starFill2, this.starFill3],
        this.starFill1.setLocalPosition(e - t, 0, 0),
        this.starFill2.setLocalPosition(e, 0, 0),
        this.starFill3.setLocalPosition(e + t, 0, 0)
    }
    _initStarUnfilled() {
        var e = j.createImageElement("spr_star_unfill");
        return e.setLocalScale(.4, .4, .4),
        this.starContainer.addChild(e),
        e
    }
    _initStarFilled() {
        var e = j.createImageElement("spr_star");
        return e.setLocalScale(.4, .4, .4),
        this.starContainer.addChild(e),
        e
    }
    _createFrames() {
        this._createFrameDifficulty(),
        this._createFrameHit(),
        this._createFrameMiss()
    }
    _createFrameDifficulty() {
        this.difficultyFrame = j.createImageElement("spr_frame_white", {
            anchor: new M(.5,0,.5,0),
            pivot: new P(.5,0),
            scale: .9,
            x: -180,
            y: 15
        }),
        this.addChild(this.difficultyFrame),
        this.difficulty = j.createTextElement("poppins_bold", {
            anchor: new M(.6,.5,.6,.5),
            pivot: new P(.5,.5),
            alignment: new P(.5,.5),
            text: "Easy",
            fontText: "0123456789",
            fontWeight: "bold",
            fontSize: 20,
            color: J.createColor(255, 255, 255)
        }),
        this.difficultyFrame.addChild(this.difficulty)
    }
    _createFrameHit() {
        let e = j.createImageElement("spr_frame_black", {
            anchor: new M(.5,0,.5,0),
            pivot: new P(.5,0),
            scale: .9,
            x: -40,
            y: 15
        });
        this.addChild(e),
        this.hit = j.createTextElement("poppins_bold", {
            anchor: new M(.5,.5,.5,.5),
            pivot: new P(.5,.5),
            alignment: new P(.5,.5),
            text: "Hit: 0",
            fontText: "0123456789",
            fontSize: 20,
            color: z.WHITE
        }),
        e.addChild(this.hit)
    }
    _createFrameMiss() {
        let e = j.createImageElement("spr_frame_black", {
            anchor: new M(.5,0,.5,0),
            pivot: new P(.5,0),
            scale: .9,
            x: 100,
            y: 15
        });
        this.addChild(e),
        this.miss = j.createTextElement("poppins_bold", {
            anchor: new M(.5,.5,.5,.5),
            pivot: new P(.5,.5),
            alignment: new P(.5,.5),
            text: "Miss: 0",
            fontText: "0123456789",
            fontSize: 20,
            color: z.WHITE
        }),
        e.addChild(this.miss)
    }
    _createScore() {
        this.score = j.createTextElement("poppins_bold", {
            anchor: new M(.85,.9,.85,.9),
            pivot: new P(.5,.5),
            alignment: new P(.5,.5),
            text: "Pt. 0",
            fontText: "0123456789",
            fontSize: 25,
            color: z.WHITE,
            y: -5
        }),
        this.addChild(this.score)
    }
    _updateDataHistory(e, t, s, i) {
        this.score.element.text = `Pt. ${e}`,
        this.hit.element.text = `Hit: ${s}`,
        this.miss.element.text = `Miss: ${i}`,
        this.fillStar(t)
    }
    fillStar(e) {
        this.unFillAllStar();
        for (let t = 0; t < e; t++)
            this.activeStarsList[t].enabled = !0
    }
    unFillAllStar() {
        this.activeStarsList.forEach(e => {
            e.enabled = !1
        }
        )
    }
    _createButtonBuyWithCoin() {
        this.buyButtonWithCoin = j.createButtonElement("spr_btn_buy", {
            anchor: new M(.95,.35,.95,.35),
            pressedTint: new z(.5,.5,.5,1),
            pivot: new P(1,.5),
            useInput: !0,
            width: 200,
            height: 100
        }),
        this.addChild(this.buyButtonWithCoin);
        var e = j.createImageElement("spr_icon_currency", {
            anchor: new M(.25,.5,.25,.5)
        });
        e.setLocalScale(.23, .23, .23),
        this.buyButtonWithCoin.currencyIcon = e,
        this.buyButtonWithCoin.addChild(e);
        var t = j.createTextElement("poppins_bold", {
            anchor: new M(.67,.5,.67,.5),
            alignment: new P(.5,.5),
            text: "1000",
            color: J.createColor(255, 255, 255),
            fontSize: 42
        });
        this.buyButtonWithCoin.addChild(t),
        this.buyButtonWithCoin.priceText = t,
        this.buyButtonWithCoin.button.on("click", this._onBuyButtonWithCoinClicked, this)
    }
    updateCoinText() {
        let e = Ms.getShopItemById(B.SHOP_SONG, this.data.id);
        if (e === null) {
            this.buyButtonWithCoin.enabled = !1;
            return
        }
        this.buyButtonWithCoin.priceText.element.text = `${e.price}`,
        this._isAffordable(e.price) ? this.enableBuyButtonWithCoin() : this.disableBuyButtonWithCoin()
    }
    _onBuyButtonWithCoinClicked() {
        this.unlock(),
        Q.unlockSong(this.data.id),
        Q.subCurrency(Ms.getShopItemById(B.SHOP_SONG, this.data.id).price),
        this.fire(ha.Bought, this.data.id)
    }
    enableBuyButtonWithCoin() {
        this.buyButtonWithCoin.currencyIcon.element.color = J.createColor(255, 255, 255, 1),
        this.buyButtonWithCoin.priceText.element.color = J.createColor(255, 255, 255, 1),
        this.buyButtonWithCoin.element.useInput = !0,
        this.buyButtonWithCoin.element.color = J.createColor(255, 255, 255, 1)
    }
    disableBuyButtonWithCoin() {
        this.buyButtonWithCoin.priceText.element.color = J.createColor(96, 96, 96, 1),
        this.buyButtonWithCoin.element.useInput = !1,
        this.buyButtonWithCoin.element.color = J.createColor(64, 64, 64, 1),
        this.buyButtonWithCoin.currencyIcon.element.color = J.createColor(96, 96, 96, 1)
    }
    _isAffordable(e) {
        return parseInt(Q.getCurrency()) >= e
    }
}
class Fg extends V {
    constructor() {
        super(),
        this.addComponent("element", {
            type: us,
            anchor: new M(0,1,1,1),
            pivot: new P(.5,.5)
        }),
        this.create()
    }
    create() {
        this._initCurrencyFrame()
    }
    _initCurrencyFrame() {
        this.currencyFrame = new V("currencyFrame"),
        this.currencyFrame.addComponent("element", {
            type: Ae,
            anchor: new M(0,.5,0,.5),
            pivot: new P(0,1),
            width: 280,
            height: 90
        }),
        this.addChild(this.currencyFrame),
        this.currencyFrame.element.spriteAsset = X.find("spr_frame_currency"),
        this.currencyFrame.setLocalPosition(80, -50, 0),
        this._initCurrencyIcon(),
        this._initCurrencyText()
    }
    _initCurrencyIcon() {
        this.currencyIcon = new V("currencyIcon"),
        this.currencyIcon.addComponent("element", {
            type: Ae,
            pivot: new P(.5,.5),
            anchor: new M(0,.5,0,.5),
            spriteAsset: X.find("spr_icon_currency"),
            width: 56,
            height: 56
        }),
        this.currencyFrame.addChild(this.currencyIcon),
        this.currencyIcon.setLocalPosition(48, 0, 0)
    }
    _initCurrencyText() {
        this.currencyText = j.createTextElement("poppins_bold", {
            anchor: new M(.5,.5,.5,.5),
            pivot: new P(.5,.5),
            autoFitWidth: !0,
            width: 150,
            autoWidth: !1,
            alignment: new P(.5,.5),
            minFontSize: 8,
            maxFontSize: 50,
            wrapLine: !0,
            color: new z(1,1,1),
            text: "0"
        }),
        this.currencyText.setLocalPosition(30, 0, 0),
        this.currencyFrame.addChild(this.currencyText),
        this.updateCurrencyText(Q.getCurrency())
    }
    updateCurrencyText(e) {
        this.currencyText.element.text = e
    }
}
const Zt = Object.freeze({
    Next: "Next",
    Home: "Home",
    Retry: "Retry",
    SongItemSelected: "SongItemSelected",
    SongLoaded: "SongItemLoaded"
});
class n3 extends La {
    constructor() {
        super(B.SCREEN_RESULT),
        this.activeStarList = [],
        this.songItemList = [],
        this.nextSongId = null,
        this.isWin = !1,
        this.difficultyColorData = [{
            name: "Easy",
            color: new z(.345,.86,.298)
        }, {
            name: "Medium",
            color: new z(.18,.61,.98)
        }, {
            name: "Hard",
            color: new z(.447,.18,.98)
        }, {
            name: "Expert",
            color: new z(.95,.48,.18)
        }]
    }
    create() {
        super.create(),
        this.destroyChildren(),
        this._initBackground(),
        this._initSongName(),
        this._initStars(),
        this._initScoreText(),
        this._initInformationGroup(),
        this._initSongList(),
        this._initButtons(),
        this._initTopBar()
    }
    resize() {
        super.resize(),
        this._onResizeBg(),
        this._onResizeSongName(),
        this._onResizeStars(),
        this._onResizeScore(),
        this._onResizeInformationGroup(),
        this._onResizeSongList(),
        this._onResizeButtons()
    }
    setResult(e=!1) {
        this.isWin = e,
        this._updateResultButtons(),
        this.topBar.updateCurrencyText(Q.getCurrency())
    }
    _updateResultButtons() {
        this.centerButton.button.off("click"),
        this.leftButton.button.off("click"),
        this.isWin ? (this.centerButtonText.element.text = "Next",
        this.leftButtonText.element.text = "Retry",
        this.centerButton.button.on("click", this._onNextSong.bind(this)),
        this.leftButton.button.on("click", this._onRetry.bind(this))) : (this.centerButtonText.element.text = "Retry",
        this.leftButtonText.element.text = "Next",
        this.centerButton.button.on("click", this._onRetry.bind(this)),
        this.leftButton.button.on("click", this._onNextSong.bind(this)))
    }
    updateInformation(e, t, s, i) {
        var n = X.find("songData.json");
        if (n) {
            var r = n.resources.find(l => l.id === Q.currentSong);
            r && (this.songName.element.text = r.name,
            this.emptyFrame.changeText(r.difficulty),
            this.updateDifficulty(r.difficulty))
        }
        this.countTextTween("", 0, e, 1, this.scoreText.element),
        this.countTextTween("Hit: ", 0, t, 1, this.hitInformation.text.element),
        this.countTextTween("Miss: ", 0, s, 1, this.missInformation.text.element),
        this.unFillAllStars();
        for (var o = 0; o < i; o++)
            this.activeStarList[o] && (this.scaleStarTween(this.activeStarList[o], o),
            this.rotateStarTween(this.activeStarList[o], o))
    }
    updateDifficulty(e) {
        var t = this._findDifficultyColor(e);
        t && (this.emptyFrame.frame.element.color = t)
    }
    _findDifficultyColor(e) {
        return this.difficultyColorData.find(t => t.name === e).color
    }
    countTextTween(e, t, s, i, n) {
        var r = Z.createTween({
            value: t
        }, {
            value: s
        }, {
            duration: i,
            onUpdate: o => {
                n.text = `${e}${Math.floor(o.value)}`
            }
        });
        r.start()
    }
    scaleStarTween(e, t) {
        Z.createTween({
            scale: 5
        }, {
            scale: 1.6
        }, {
            delay: t * .5,
            duration: .2,
            easing: Z.Easing.Circular.In,
            onStart: () => {
                e.enabled = !0
            }
            ,
            onUpdate: s => {
                e.setLocalScale(s.scale, s.scale, s.scale)
            }
        }).start()
    }
    rotateStarTween(e, t) {
        Z.createTween({
            angle: 30
        }, {
            angle: 0
        }, {
            delay: t * .5,
            duration: .2,
            easing: Z.Easing.Circular.In,
            onUpdate: s => {
                e.setLocalEulerAngles(0, 0, s.angle)
            }
        }).start()
    }
    moveScrollViewTween() {
        var t;
        var e = this.songListContainer.getLocalPosition().y;
        (t = this.moveTween) == null || t.stop(),
        this.moveTween = Z.createTween({
            y: e - 800
        }, {
            y: e
        }, {
            duration: .6,
            easing: Z.Easing.Quintic.Out,
            onUpdate: s => {
                this.songListContainer.setLocalPosition(0, s.y, 0)
            }
        }),
        this.moveTween.start()
    }
    moveButtonGroupTween() {
        var t;
        this.buttonContainer.enabled = !0;
        var e = this.buttonContainer.getLocalPosition().y;
        (t = this.moveButtonTween) == null || t.stop(),
        this.moveButtonTween = Z.createTween({
            y: e - 800
        }, {
            y: e
        }, {
            duration: .6,
            easing: Z.Easing.Quintic.Out,
            onUpdate: s => {
                this.buttonContainer.setLocalPosition(0, s.y, 0)
            }
        }),
        this.moveButtonTween.start()
    }
    unFillAllStars() {
        this.activeStarList.forEach(e => {
            e && (e.enabled = !1)
        }
        )
    }
    _showInterstitialAds() {
        te.pause(),
        Ds.showMidrollAds()
    }
    updateSongDataList() {
        var e = X.find("songData.json");
        if (e === null) {
            console.warn("Song data not found!");
            return
        }
        this.nextSongId = this._randomNextSong();
        let t = this._sortSongList(e.resources);
        for (var s = 0; s < t.length; s++) {
            let r = this.songItemList[s] || this.addSongItem(s);
            r.enabled = !0,
            r.updateData(t[s])
        }
        var i = this._findSongItemById(Q.currentSong);
        this.isWin && i && (i.enabled = !1);
        for (var n = t.length; n < this.songItemList.length; n++) {
            let r = this.songItemList[n];
            r.enabled = !1
        }
        this.songListScrollView.scrollview.scroll.y = 0,
        this.buttonContainer.enabled = !1,
        this.moveScrollViewTween(),
        this.moveButtonGroupTween(),
        this.playBgMusic(),
        this.checkRewardAds()
    }
    _sortSongList(e) {
        var t = [];
        this.isWin || t.push(e.find(r => r.id === Q.currentSong));
        var s = e.filter(r => r.unlocked && !this._isSongCompleted(r.id) && r.id !== Q.currentSong);
        s.sort( (r, o) => this._getHighestScore(o.id) - this._getHighestScore(r.id)),
        s.forEach(r => {
            t.indexOf(r) === -1 && t.push(r)
        }
        );
        var i = e.filter(r => !r.unlocked);
        i.forEach(r => {
            t.indexOf(r) === -1 && t.push(r)
        }
        );
        var n = e.filter(r => this._isSongCompleted(r.id) && r.id !== Q.currentSong);
        return n.forEach(r => {
            t.indexOf(r) === -1 && t.push(r)
        }
        ),
        this.isWin && (t.splice(t.findIndex(r => r.id === this.nextSongId), 1),
        t.unshift(e.find(r => r.id === this.nextSongId))),
        t
    }
    _isSongCompleted(e) {
        var t = Q.gamePlayHistory
          , s = t.find(i => i.songId === e);
        return s ? s.isCompleted : !1
    }
    _getHighestScore(e) {
        var t = Q.gamePlayHistory
          , s = t.find(i => i.id === e);
        return s ? s.score : 0
    }
    playBgMusic() {
        let e = this.isWin ? this.nextSongId : Q.currentSong
          , t = Q.getSongById(e).songName;
        this.songBgName = t,
        X.loadResource(t, "audio").then( () => {
            Qe.play(t, .5, !0)
        }
        )
    }
    stopBgMusic() {
        this.songBgName && Qe.stop(this.songBgName)
    }
    checkRewardAds() {
        this.songItemList.forEach(e => {
            e.disableBuyButton()
        }
        ),
        Ds.checkRewardAds().then(e => {
            e ? this.songItemList.forEach(t => {
                t.enableBuyButton()
            }
            ) : this.songItemList.forEach(t => {
                t.disableBuyButton()
            }
            )
        }
        )
    }
    _findSongItemById(e) {
        return this.songItemList.find(t => t.data.id === e)
    }
    _randomNextSong() {
        var e = X.find("songData.json");
        if (e === null)
            return Q.currentSong;
        var t = e.resources.filter(i => Q.isSongUnlocked(i.id) && i.id !== Q.currentSong);
        if (t.length === 0)
            return Q.currentSong;
        var s = t[J.randomInt(0, t.length - 1)];
        return s.id
    }
    addSongItem() {
        var e = new Yw;
        return this.songItemList.push(e),
        this.listView.addItem(e),
        this.registerEvents(e),
        e
    }
    registerEvents(e) {
        e.on(ha.Selected, this.onSongItemSelected.bind(this)),
        e.on(ha.Bought, this.onSongItemBought.bind(this))
    }
    onSongItemSelected(e) {
        let t = Q.currentSong
          , s = Q.getSongById(e).songName;
        Q.currentSong = e,
        this.fire(Zt.SongItemSelected, e),
        t === e ? this.fire(Zt.SongLoaded) : X.loadResource(s, "audio").then( () => {
            this.fire(Zt.SongLoaded)
        }
        ),
        this.stopBgMusic()
    }
    onSongItemBought(e) {
        let t = Q.currentSong
          , s = Q.getSongById(e).songName;
        Q.currentSong = e,
        this.fire(Zt.SongItemSelected, e),
        t === e ? this.fire(Zt.SongLoaded) : X.loadResource(s, "audio").then( () => {
            this.fire(Zt.SongLoaded)
        }
        ),
        this.stopBgMusic()
    }
    _initTopBar() {
        this.topBar = new Fg,
        this.addChild(this.topBar)
    }
    _initBackground() {
        this.ptrBg = j.createImageElement("spr_bg_result_ptr"),
        this.ptrBg.element.pivot = new P(.5,.5),
        this.ptrBg.setLocalScale(1.4, 1.4, 1.4),
        this.addChild(this.ptrBg),
        this.lscBg = j.createImageElement("spr_bg_result_lsc"),
        this.lscBg.element.pivot = new P(.5,.5),
        this.lscBg.setLocalScale(1.4, 1.4, 1.4),
        this.addChild(this.lscBg),
        this._onResizeBg()
    }
    _onResizeBg() {
        te.isLandScape ? (this.lscBg.enabled = !0,
        this.ptrBg.enabled = !1) : (this.lscBg.enabled = !1,
        this.ptrBg.enabled = !0)
    }
    _initSongName() {
        this.songName = new V,
        this.addChild(this.songName),
        this.songName.addComponent("element", {
            type: Oh,
            anchor: new M(.5,1,.5,1),
            pivot: new P(.5,.5),
            alignment: new P(.5,.5),
            fontAsset: X.find("poppins_bold"),
            fontSize: 65,
            color: new z(1,1,1),
            text: "Song Name"
        }),
        this.songName.setLocalPosition(0, -70, 0),
        this._onResizeSongName()
    }
    _onResizeSongName() {
        var e = 65
          , t = -180;
        te.isLandScape && (e = 50,
        t = -50),
        this.songName.element.fontSize = e,
        this.songName.setLocalPosition(0, t, 0)
    }
    _initStars() {
        this.starContainer = j.createGroupElement({
            anchor: new M(.5,1,.5,1),
            pivot: new P(.5,.5)
        }),
        this.addChild(this.starContainer),
        this.starUnfill1 = this._initStarUnfilled(),
        this.starUnfill2 = this._initStarUnfilled(),
        this.starUnfill3 = this._initStarUnfilled(),
        this.starFill1 = this._initStarFilled(),
        this.starFill2 = this._initStarFilled(),
        this.starFill3 = this._initStarFilled(),
        this.activeStarList.push(this.starFill1, this.starFill2, this.starFill3);
        var e = this.starUnfill2.getLocalPosition().x
          , t = 130;
        this.starUnfill1.setLocalPosition(e - t, 0, 0),
        this.starUnfill2.setLocalPosition(e + t, 0, 0),
        this.starFill1.setLocalPosition(e - t, 0, 0),
        this.starFill2.setLocalPosition(e, 0, 0),
        this.starFill3.setLocalPosition(e + t, 0, 0),
        this._onResizeStars()
    }
    _onResizeStars() {
        var e = -100
          , t = 1;
        te.isLandScape && (t = .8,
        e = -80),
        this.starContainer.setLocalScale(t, t, t);
        var s = this.songName.getLocalPosition().y;
        this.starContainer.setLocalPosition(0, s + e, 0)
    }
    _initStarUnfilled() {
        var e = j.createImageElement("spr_icon_star_unfill_result");
        return e.setLocalScale(1.6, 1.6, 1.6),
        this.starContainer.addChild(e),
        e
    }
    _initStarFilled() {
        var e = j.createImageElement("spr_icon_star_result");
        return e.setLocalScale(1.6, 1.6, 1.6),
        this.starContainer.addChild(e),
        e
    }
    _initScoreText() {
        this.scoreText = new V,
        this.addChild(this.scoreText),
        this.scoreText.addComponent("element", {
            type: Oh,
            anchor: new M(.5,1,.5,1),
            pivot: new P(.5,.5),
            alignment: new P(.5,.5),
            fontAsset: X.find("poppins_bold"),
            fontSize: 100,
            color: new z(1,1,1),
            text: "0"
        }),
        this._onResizeScore()
    }
    _onResizeScore() {
        var e = -130
          , t = 100;
        te.isLandScape && (t = 70,
        e = -100),
        this.scoreText.element.fontSize = t;
        var s = this.starContainer.getLocalPosition().y;
        this.scoreText.setLocalPosition(0, s + e, 0)
    }
    _initInformationGroup() {
        this.informationGroup = j.createGroupElement({
            anchor: new M(.5,1,.5,1),
            pivot: new P(.5,.5),
            width: 1e3,
            height: 300
        }),
        this.addChild(this.informationGroup),
        this.informationGroup.addComponent("layoutgroup", {
            orientation: Se,
            alignment: new P(.5,.5),
            padding: new M(0,0,0,0),
            spacing: new P(20,0)
        }),
        this.emptyFrame = new Kp("spr_btn_white","poppins_bold",{
            width: 220,
            height: 300
        }),
        this.informationGroup.addChild(this.emptyFrame),
        this.hitInformation = new Kp("spr_btn_white","poppins_bold",{
            width: 240,
            height: 300
        }),
        this.hitInformation.changeTextColor(new z(.565,0,1)),
        this.hitInformation.changeText("Hit: 0"),
        this.informationGroup.addChild(this.hitInformation),
        this.missInformation = new Kp("spr_btn_white","poppins_bold",{
            width: 220,
            height: 300
        }),
        this.missInformation.changeTextColor(new z(.894,.078,.537)),
        this.missInformation.changeText("Miss: 0"),
        this.informationGroup.addChild(this.missInformation),
        this._onResizeInformationGroup()
    }
    _onResizeInformationGroup() {
        var e = -110
          , t = 1;
        te.isLandScape && (t = .8,
        e = -80),
        this.informationGroup.setLocalScale(t, t, t);
        var s = this.scoreText.getLocalPosition().y;
        this.informationGroup.setLocalPosition(0, s + e, 0)
    }
    _initSongList() {
        this.songListContainer = j.createGroupElement({
            anchor: new M(.5,.75,.5,.75),
            pivot: new P(.5,1),
            width: 900,
            height: 1e3
        }),
        this.addChild(this.songListContainer),
        this.songListBg = j.createImageElement("spr_bg_scroll_view"),
        this.songListBg.element.pivot = new P(.5,.5),
        this.songListBg.element.anchor = new M(.5,.5,.5,.5),
        this.songListBg.setLocalScale(.9, 1.1, 1),
        this.songListContainer.addChild(this.songListBg),
        this._initScrollView(),
        this._onResizeSongList()
    }
    _onResizeSongList() {
        var e = te.width / te.height
          , t = 1
          , s = 900
          , i = new y(.9,1,1)
          , n = -160;
        e < .47 && (s = 1050,
        i = new y(.9,1.15,1)),
        e > .65 && (n = -220,
        i = new y(.9,.78,1),
        s = 680),
        te.isLandScape && (t = .7,
        s = 650,
        n = -120,
        i = new y(.9,.75,1),
        e > 2 && (s = 500,
        n = -150,
        i = new y(.9,.6,1)),
        e < 1.4 && (s = 800,
        i = new y(.9,.9,1))),
        this.songListContainer.setLocalPosition(0, n, 0),
        this.songListContainer.element.height = s,
        this.songListContainer.setLocalScale(t, t, t),
        this.songListBg.setLocalScale(i)
    }
    _initScrollView() {
        this.listView = new $w({
            anchor: new M(0,1,1,1),
            pivot: new P(0,1),
            margin: new M
        }),
        this.listView.layoutgroup.spacing = new P(0,50),
        this.songListScrollView = new qw(this.listView,{
            anchor: new M(0,0,1,1),
            pivot: new P(.5,1)
        }),
        this.songListContainer.addChild(this.songListScrollView),
        this.songListScrollView.bg.enabled = !1
    }
    _initButtons() {
        this.buttonContainer = j.createGroupElement({
            anchor: new M(.5,.1,.5,.1)
        }),
        this.addChild(this.buttonContainer),
        this.centerButton = j.createImageElement("spr_btn_rhombus", {
            useInput: !0
        }),
        this.centerButton.setLocalScale(.85, .85, .85),
        this.buttonContainer.addChild(this.centerButton),
        this.centerButtonText = j.createTextElement("poppins_bold", {
            text: "Next",
            fontSize: 80,
            color: new z(1,1,1)
        }),
        this.centerButton.addChild(this.centerButtonText),
        this.centerButton.addComponent("button", {
            active: !0
        }),
        this.centerButton.button.on("click", this._onNextSong.bind(this)),
        this.homeButton = j.createImageElement("spr_btn_rhombus_white", {
            useInput: !0
        }),
        this.homeButton.setLocalScale(.85, .85, .85),
        this.buttonContainer.addChild(this.homeButton),
        this.homeButtonText = j.createTextElement("poppins_bold", {
            text: "Home",
            fontSize: 50,
            color: new z(1,1,1)
        }),
        this.homeButton.addChild(this.homeButtonText),
        this.homeButton.addComponent("button", {
            active: !0
        }),
        this.homeButton.button.on("click", this._onBackHome.bind(this)),
        this.leftButton = j.createImageElement("spr_btn_rhombus_white", {
            useInput: !0
        }),
        this.leftButton.setLocalScale(.85, .85, .85),
        this.buttonContainer.addChild(this.leftButton),
        this.leftButtonText = j.createTextElement("poppins_bold", {
            text: "Retry",
            fontSize: 50,
            color: new z(1,1,1)
        }),
        this.leftButton.addChild(this.leftButtonText),
        this.leftButton.addComponent("button", {
            active: !0
        }),
        this.leftButton.button.on("click", this._onRetry.bind(this)),
        this._onResizeButtons()
    }
    _onBackHome() {
        this.stopBgMusic(),
        this.fire(Zt.Home)
    }
    _onRetry() {
        this.stopBgMusic(),
        this.fire(Zt.Retry)
    }
    _onNextSong() {
        Q.currentSong = this.nextSongId;
        let e = Q.getSongById(this.nextSongId).songName;
        this.stopBgMusic(),
        this.fire(Zt.Next),
        X.loadResource(e, "audio").then( () => {
            this.fire(Zt.SongLoaded, this.nextSongId)
        }
        )
    }
    _onResizeButtons() {
        this.homeButton.setLocalPosition(-310, 0, 0),
        this.leftButton.setLocalPosition(310, 0, 0);
        var e = 1;
        te.isLandScape && (e = .75),
        this.buttonContainer.setLocalScale(e, e, e)
    }
}
const r3 = Te.createScript({
    name: "mcController",
    attributes: {
        animComponent: {},
        mcModelShadow: {}
    },
    initialize() {
        this.countHit = 0,
        this.baseLayer = this.animComponent.baseLayer,
        this.upperLayer = this.animComponent.layers[1],
        this.upperLayer.weight = 0,
        this.baseLayerShadow = this.mcModelShadow.anim.baseLayer,
        this.upperLayerShadow = this.mcModelShadow.anim.layers[1],
        this.upperLayerShadow.weight = 0,
        this.idle()
    },
    idle() {
        this.animComponent.reset(),
        this.mcModelShadow.anim.reset(),
        this.upperLayer.weight = 0,
        this.upperLayerShadow.weight = 0
    },
    onHitMine() {
        this.animComponent.reset(),
        this.mcModelShadow.anim.reset(),
        this.upperLayer.weight = 0,
        this.upperLayerShadow.weight = 0,
        this.animComponent.setTrigger("Die"),
        this.mcModelShadow.anim.setTrigger("Die"),
        this.fire(Zp.Die)
    },
    _attackTornado() {
        this.upperLayer.weight = 0,
        this.upperLayerShadow.weight = 0,
        !this.animComponent.getTrigger("Tornado") && (this.animComponent.setTrigger("Tornado"),
        this.mcModelShadow.anim.setTrigger("Tornado"))
    },
    _attackTornadoNoloop() {
        this.upperLayer.weight = 0,
        this.upperLayerShadow.weight = 0,
        this.animComponent.reset(),
        this.mcModelShadow.anim.reset(),
        this.animComponent.setTrigger("Run"),
        this.mcModelShadow.anim.setTrigger("Run")
    },
    onHitBox(a) {
        let e = a.getScript(Df);
        e.isComboBox ? e.isNextBoxCombo ? this._attackTornado(e) : this._attackTornadoNoloop() : this.onAttack()
    },
    onAttack() {
        var a;
        this.countHit++,
        this.upperLayer.weight = 1,
        this.upperLayerShadow.weight = 1,
        this.animComponent.resetTrigger("AttackRight"),
        this.animComponent.resetTrigger("AttackLeft"),
        this.mcModelShadow.anim.resetTrigger("AttackRight"),
        this.mcModelShadow.anim.resetTrigger("AttackLeft"),
        this.countHit % 2 === 0 ? (this.animComponent.setTrigger("AttackRight", !1),
        this.mcModelShadow.anim.setTrigger("AttackRight", !1)) : (this.animComponent.setTrigger("AttackLeft", !1),
        this.mcModelShadow.anim.setTrigger("AttackLeft", !1)),
        (a = this.tweenCount) == null || a.stop(),
        this.tweenCount = Z.createTween({
            weight: 1
        }, {
            weight: 0
        }, {
            duration: .5,
            onUpdate: e => {
                this.upperLayer.weight = e.weight,
                this.upperLayerShadow.weight = e.weight
            }
        }).start()
    },
    run() {
        this.upperLayer.weight = 0,
        this.upperLayerShadow.weight = 0,
        this.animComponent.setTrigger("Run"),
        this.mcModelShadow.anim.setTrigger("Run")
    },
    pause() {
        this.fire(Zp.Pause)
    },
    resume() {
        this.fire(Zp.Resume)
    }
})
  , Zp = Object.freeze({
    Die: "mc:die",
    Pause: "mc:pause",
    Resume: "mc:resume"
})
  , Pd = 600
  , Qp = 4
  , cS = Te.createScript({
    name: "trail",
    attributes: {
        lifetime: {
            default: 1
        },
        xoffset: {
            default: -1
        },
        yoffset: {
            default: 1
        },
        height: {
            default: 1
        },
        color: {
            default: new z(1,0,0)
        },
        layer: {
            default: null
        }
    },
    initialize() {
        var a = {
            attributes: {
                aPositionAge: ut
            },
            vshader: `
              attribute vec4 aPositionAge;

              uniform mat4 matrix_viewProjection;
              uniform float trail_time;
              
              varying float vAge;
              
              void main(void)
              {
                  vAge = trail_time - aPositionAge.w;
                  gl_Position = matrix_viewProjection * vec4(aPositionAge.xyz, 1.0);
              }`,
            fshader: `
              precision mediump float;

              varying float vAge;
              
              uniform float trail_lifetime;

              uniform vec4 uCustomColor;
              
              void main(void)
              {
                  gl_FragColor = uCustomColor;
              }`
        };
        let e = new Xi(this.app.graphicsDevice,a);
        this.material = new Yi,
        this.material.shader = e,
        this.material.setParameter("trail_time", 0),
        this.material.setParameter("trail_lifetime", this.lifetime),
        this.material.setParameter("uCustomColor", [this.color.r, this.color.g, this.color.b, this.color.a]),
        this.material.update(),
        this.material.cull = bt,
        this.material.blend = !0,
        this.material.blendType = fi,
        this.material.depthWrite = !1,
        this.timer = 0,
        this.vertices = [],
        this.vertexData = new Float32Array(Pd * Qp),
        this.vertexIndexArray = [];
        for (var t = 0; t < this.vertexData.length; ++t)
            this.vertexIndexArray.push(t);
        this.mesh = new ms(this.app.graphicsDevice),
        this.mesh.clear(!0, !1),
        this.mesh.setPositions(this.vertexData, Qp, Pd),
        this.mesh.setIndices(this.vertexIndexArray, Pd),
        this.mesh.update(Ks);
        var s = new Fe(this.mesh,this.material);
        if (!this.layer) {
            const i = Bi.scene.layers.getLayerByName("World");
            this.layer = i
        }
        this.entity.addComponent("render", {
            meshInstances: [s],
            layers: [this.layer.id]
        }),
        this.entity.render.enabled = !1
    },
    update(a) {
        if (this.timer += a,
        this.material.setParameter("trail_time", this.timer),
        this.clearOldVertices(),
        this.spawnNewVertices(),
        this.vertices.length > 1) {
            this.prepareVertexData();
            var e = this.vertices.length * 2
              , t = Pd;
            e < t && (t = e),
            this.mesh.setPositions(this.vertexData, Qp, t),
            this.mesh.setIndices(this.vertexIndexArray, t),
            this.mesh.update(Ks),
            this.entity.render.enabled = !0
        }
    },
    onDisable() {
        this.entity.render && (this.entity.render.enabled = !1)
    },
    onEnable() {
        this.entity.render && (this.entity.render.enabled = !0)
    },
    prepareVertexData() {
        for (var a = 0; a < this.vertices.length; a++) {
            var e = this.vertices[a]
              , t = (this.timer - e.spawnTime) / this.lifetime
              , s = e.vertexPair[0]
              , i = e.vertexPair[1]
              , n = e.vertexPair[2]
              , r = e.vertexPair[3]
              , o = e.vertexPair[4]
              , l = e.vertexPair[5];
            if (this.vertexData[a * 8 + 0] = s + (r - s) * t * .5,
            this.vertexData[a * 8 + 1] = i + (o - i) * t * .5,
            this.vertexData[a * 8 + 2] = n + (l - n) * t * .5,
            this.vertexData[a * 8 + 3] = e.spawnTime,
            this.vertexData[a * 8 + 4] = r + (s - r) * t * .5,
            this.vertexData[a * 8 + 5] = o + (i - o) * t * .5,
            this.vertexData[a * 8 + 6] = l + (n - l) * t * .5,
            this.vertexData[a * 8 + 7] = e.spawnTime,
            this.vertexData.length === a)
                break
        }
    },
    clearOldVertices() {
        for (var a = this.vertices.length - 1; a >= 0; a--) {
            var e = this.vertices[a];
            if (this.timer - e.spawnTime >= this.lifetime)
                this.vertices.pop();
            else
                break
        }
    },
    spawnNewVertices() {
        var a = this.entity
          , e = a.getPosition()
          , t = this.timer
          , s = a.up.clone().mulScalar(this.height)
          , i = this.xoffset
          , n = this.yoffset
          , r = [e.x + s.x * i, e.y + s.y * i, e.z + s.z * i, e.x + s.x * n, e.y + s.y * n, e.z + s.z * n];
        this.vertices.unshift({
            spawnTime: t,
            vertexPair: r
        })
    },
    changeColor(a, e, t, s) {
        this.color = new z(a,e,t,s),
        this.material.setParameter("uCustomColor", [this.color.r, this.color.g, this.color.b, this.color.a]),
        this.material.update()
    }
});
class a3 {
    static vibrate(e=.1) {
        navigator.vibrate && En.get("vibration") && navigator.vibrate(e * 1e3)
    }
}
class o3 extends V {
    constructor(e) {
        super(),
        this.layer = e || X_,
        this._initEffect()
    }
    play() {
        this.particleSlash.particlesystem.reset(),
        this.particleSlash.particlesystem.play(),
        Z.createCountTween({
            duration: this.particleSlash.particlesystem.lifetime,
            onComplete: () => {
                this.fire(We.Despawn)
            }
        }).start()
    }
    _initEffect() {
        this.particleSlash = new V,
        this.addChild(this.particleSlash),
        this.particleSlash.setLocalScale(2, 1.5, 2),
        this.particleSlash.setLocalPosition(0, 0, 0);
        let e = {
            numParticles: 1,
            lifetime: .4,
            rate: .2,
            colorMap: X.find("tex_slash_yellow").resource,
            initialVelocity: 1,
            emitterShape: K_,
            emitterRadius: 0,
            startAngle: -55,
            loop: !1,
            localSpace: !0,
            animLoop: !1,
            animTilesX: 4,
            animTilesY: 2,
            animSpeed: 1.25,
            autoPlay: !1,
            layers: [this.layer.id]
        }, t;
        t = Object.assign(e, {
            animNumFrames: 8,
            animIndex: 0
        }),
        this.particleSlash.addComponent("particlesystem", t)
    }
}
class Kw extends V {
    constructor(e=null, t=!1) {
        super("mainCharacter"),
        this.anims = {
            Idle: {
                name: "Idle",
                asset: X.find("anim_mc_idle").resource
            },
            AttackRight: {
                name: "AttackRight",
                asset: X.find("anim_mc_attack_right").resource
            },
            AttackLeft: {
                name: "AttackLeft",
                asset: X.find("anim_mc_attack_left").resource
            },
            AttackTornado: {
                name: "Tornado",
                asset: X.find("anim_mc_attack_tornado").resource
            },
            Die: {
                name: "Die",
                asset: X.find("anim_mc_die").resource
            },
            Run: {
                name: "Run",
                asset: X.find("anim_mc_run").resource
            }
        },
        this.layer = e,
        this.spawnShadow = t,
        this._initModel(),
        this._initScript(),
        this.changeMainCharacterWeapons(),
        this.changeSkin(),
        this._initWeaponCover(),
        this._initEffect()
    }
    _initEffect() {
        let e = new V;
        this.addChild(e),
        this.fxSpawner = e.addScript(Gs, {
            class: o3,
            poolSize: 10,
            args: [this.layer]
        })
    }
    _initModel() {
        let e = {
            RootNode: {
                value: !1
            },
            "RootNode/run__2_": {
                value: !1
            },
            "RootNode/run__2_/mixamorig:Hips": {
                value: !1
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:LeftUpLeg": {
                value: !1
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:LeftUpLeg/mixamorig:LeftLeg": {
                value: !1
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:LeftUpLeg/mixamorig:LeftLeg/mixamorig:LeftFoot": {
                value: !1
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:LeftUpLeg/mixamorig:LeftLeg/mixamorig:LeftFoot/mixamorig:LeftToeBase": {
                value: !1
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:LeftUpLeg/mixamorig:LeftLeg/mixamorig:LeftFoot/mixamorig:LeftToeBase/mixamorig:LeftToe_End": {
                value: !1
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:RightUpLeg": {
                value: !1
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:RightUpLeg/mixamorig:RightLeg": {
                value: !1
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:RightUpLeg/mixamorig:RightLeg/mixamorig:RightFoot": {
                value: !1
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:RightUpLeg/mixamorig:RightLeg/mixamorig:RightFoot/mixamorig:RightToeBase": {
                value: !1
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:RightUpLeg/mixamorig:RightLeg/mixamorig:RightFoot/mixamorig:RightToeBase/mixamorig:RightToe_End": {
                value: !1
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandIndex1": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandIndex1/mixamorig:LeftHandIndex2": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandIndex1/mixamorig:LeftHandIndex2/mixamorig:LeftHandIndex3": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandIndex1/mixamorig:LeftHandIndex2/mixamorig:LeftHandIndex3/mixamorig:LeftHandIndex4": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandThumb1": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandThumb1/mixamorig:LeftHandThumb2": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandThumb1/mixamorig:LeftHandThumb2/mixamorig:LeftHandThumb3": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandThumb1/mixamorig:LeftHandThumb2/mixamorig:LeftHandThumb3/mixamorig:LeftHandThumb4": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:Neck": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:Neck/mixamorig:Head": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:Neck/mixamorig:Head/mixamorig:HeadTop_End": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandIndex1": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandIndex1/mixamorig:RightHandIndex2": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandIndex1/mixamorig:RightHandIndex2/mixamorig:RightHandIndex3": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandIndex1/mixamorig:RightHandIndex2/mixamorig:RightHandIndex3/mixamorig:RightHandIndex4": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandThumb1": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandThumb1/mixamorig:RightHandThumb2": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandThumb1/mixamorig:RightHandThumb2/mixamorig:RightHandThumb3": {
                value: !0
            },
            "RootNode/run__2_/mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandThumb1/mixamorig:RightHandThumb2/mixamorig:RightHandThumb3/mixamorig:RightHandThumb4": {
                value: !0
            },
            "RootNode/run__2_/model_mc": {
                value: !1
            }
        };
        const t = X.find("stateGraphData.json").resource;
        this.bodyMc = j.createModel("model_mc"),
        this.addChild(this.bodyMc),
        this.animComponent = this.bodyMc.addComponent("anim"),
        this.bodyMc.anim.loadStateGraph(t),
        this.bodyMc.anim.layers[1].mask = e,
        this.bodyMc.anim.baseLayer.assignAnimation(this.anims.Idle.name, this.anims.Idle.asset),
        this.bodyMc.anim.baseLayer.assignAnimation(this.anims.Run.name, this.anims.Run.asset),
        this.bodyMc.anim.baseLayer.assignAnimation(this.anims.AttackTornado.name, this.anims.AttackTornado.asset),
        this.bodyMc.anim.baseLayer.assignAnimation(this.anims.AttackRight.name, this.anims.AttackRight.asset),
        this.bodyMc.anim.baseLayer.assignAnimation(this.anims.AttackLeft.name, this.anims.AttackLeft.asset),
        this.bodyMc.anim.baseLayer.assignAnimation(this.anims.Die.name, this.anims.Die.asset),
        this.bodyMc.anim.layers[1].assignAnimation(this.anims.Run.name, this.anims.Run.asset),
        this.bodyMc.anim.layers[1].assignAnimation(this.anims.AttackRight.name, this.anims.AttackRight.asset),
        this.bodyMc.anim.layers[1].assignAnimation(this.anims.AttackLeft.name, this.anims.AttackLeft.asset),
        this.mcModelShadow = j.createModel("model_mc"),
        this.mcModelShadow.setLocalScale(1, -1, 1),
        this.mcModelShadow.setLocalPosition(0, -17, 0);
        let s = X.find("mat_mc_shadow");
        this.mcModelShadow.model.meshInstances[0].material = s.resource,
        this.mcModelShadow.model.meshInstances[0].material.update(),
        this.addChild(this.mcModelShadow),
        this.mcModelShadow.addComponent("anim"),
        this.mcModelShadow.anim.loadStateGraph(t),
        this.mcModelShadow.anim.layers[1].mask = e,
        this.mcModelShadow.anim.baseLayer.assignAnimation(this.anims.Idle.name, this.anims.Idle.asset),
        this.mcModelShadow.anim.baseLayer.assignAnimation(this.anims.Run.name, this.anims.Run.asset),
        this.mcModelShadow.anim.baseLayer.assignAnimation(this.anims.AttackTornado.name, this.anims.AttackTornado.asset),
        this.mcModelShadow.anim.baseLayer.assignAnimation(this.anims.AttackRight.name, this.anims.AttackRight.asset),
        this.mcModelShadow.anim.baseLayer.assignAnimation(this.anims.AttackLeft.name, this.anims.AttackLeft.asset),
        this.mcModelShadow.anim.baseLayer.assignAnimation(this.anims.Die.name, this.anims.Die.asset),
        this.mcModelShadow.anim.layers[1].assignAnimation(this.anims.Run.name, this.anims.Run.asset),
        this.mcModelShadow.anim.layers[1].assignAnimation(this.anims.AttackRight.name, this.anims.AttackRight.asset),
        this.mcModelShadow.anim.layers[1].assignAnimation(this.anims.AttackLeft.name, this.anims.AttackLeft.asset),
        this.spawnShadow || (this.mcModelShadow.enabled = !1),
        this.layer && (this.bodyMc.model.layers[0] = this.layer.id,
        this.mcModelShadow.model.layers[0] = this.layer.id)
    }
    _initScript() {
        this.mcController = this.bodyMc.addScript(r3, {
            animComponent: this.animComponent,
            mcModelShadow: this.mcModelShadow
        })
    }
    changeTexEffect(e) {
        this.particleSlash.particlesystem.colorMap = e
    }
    _initWeaponCover() {
        this.weaponCover = j.createModel("model_weapon_01"),
        this.body = this.bodyMc.findByName("mixamorig:Hips"),
        this.body.addChild(this.weaponCover),
        this.weaponCover.setLocalScale(700, 500, 700),
        this.weaponCover.setLocalEulerAngles(-70.05, 5.4, 169.99),
        this.weaponCover.setLocalPosition(670.761, 604.854, 1089.678),
        this.weaponCoverShadow = this.weaponCover.clone(),
        this.bodyShadow = this.mcModelShadow.findByName("mixamorig:Hips"),
        this.bodyShadow.addChild(this.weaponCoverShadow),
        this.weaponCoverShadow.setLocalScale(700, 500, 700),
        this.weaponCoverShadow.setLocalEulerAngles(-70.05, 5.4, 169.99),
        this.weaponCoverShadow.setLocalPosition(670.761, 604.854, 1089.678);
        let e = this.weaponCoverShadow.model.meshInstances[0].material.clone();
        e.opacityMap = e.diffuseMap,
        e.blendType = 2,
        e.opacityMapChannel = "a",
        e.opacity = .6,
        e.alphaToCoverage = !0,
        this.weaponCoverShadow.model.meshInstances[0].material = e,
        this.weaponCoverShadow.model.meshInstances[0].material.update(),
        this.layer && (this.weaponCover.model.layers[0] = this.layer.id,
        this.weaponCoverShadow.model.layers[0] = this.layer.id)
    }
    playEffect() {
        a3.vibrate(.1);
        let e = this.fxSpawner.spawn();
        e.setPosition(0, 30, 0),
        this.addChild(e),
        e.play()
    }
    changeMainCharacterWeapons(e, t=!1) {
        if (this.weaponRight && (this.rightHand.removeChild(this.weaponRight),
        this.rightHandShadow.removeChild(this.weaponRightShadow)),
        !e) {
            let s = Q.currentWeapon;
            e = Ms.getShopItemById(B.SHOP_WEAPON, s).asset
        }
        if (typeof e == "string") {
            if (!X.find(e))
                if (X.hasResource(e)) {
                    X.loadResource(e, "model", this.changeMainCharacterWeapons.bind(this, e), () => {
                        console.warn(`Model "${e}" is not found!`)
                    }
                    );
                    return
                } else {
                    console.warn(`Model "${e}" is not found!`);
                    return
                }
            this.weaponRight = j.createModel(e),
            this.weaponRightShadow = j.createModel(e);
            let i = this.weaponRightShadow.model.meshInstances[0].material.clone();
            i.opacityMap = i.diffuseMap,
            i.blendType = 2,
            i.opacityMapChannel = "a",
            i.opacity = .6,
            i.alphaToCoverage = !0,
            this.weaponRightShadow.model.meshInstances[0].material = i,
            this.weaponRightShadow.model.meshInstances[0].material.update(),
            this.layer && (this.weaponRightShadow.model.layers[0] = this.layer.id,
            this.weaponRight.model.layers[0] = this.layer.id)
        } else
            this.weaponRight = e.clone(),
            this.weaponRightShadow = e.clone();
        this.rightHand = this.bodyMc.findByName("mixamorig:RightHand"),
        this.rightHand.addChild(this.weaponRight),
        this.weaponRight.setLocalScale(700, 600, 700),
        this.weaponRight.setLocalEulerAngles(171.47, -75.57, 115.06),
        this.weaponRight.setLocalPosition(-851.689, 332.065, 77.127),
        this.rightTrail = this.weaponRight.addScript(cS, {
            lifetime: .2,
            xoffset: 0,
            height: 1.5,
            color: new z(1,0,1,.4)
        }),
        this.rightTrail.enabled = !0,
        this.rightHandShadow = this.mcModelShadow.findByName("mixamorig:RightHand"),
        this.rightHandShadow.addChild(this.weaponRightShadow),
        this.weaponRightShadow.setLocalScale(700, 600, 700),
        this.weaponRightShadow.setLocalEulerAngles(143.59, -76.7, 167.79),
        this.weaponRightShadow.setLocalPosition(-596.95, -236.174, -62.654),
        this.rightTrailShadow = this.weaponRightShadow.addScript(cS, {
            lifetime: .2,
            xoffset: 0,
            height: 1.5,
            color: new z(1,0,1,.05),
            layer: this.layer
        }),
        this.rightTrailShadow.enabled = !0
    }
    async changeSkin(e) {
        if (!e) {
            let r = Q.currentSkin;
            e = Ms.getShopItemById(B.SHOP_SKIN, r).asset
        }
        this.bodyMc || console.warn("Main character model is not found!");
        let t = this.bodyMc.model.meshInstances[0].material
          , s = X.find(e);
        if (!s)
            if (X.hasResource(e))
                s = await X.loadResource(e, "texture");
            else {
                console.warn(`Texture "${e}" is not found!`);
                return
            }
        t.diffuseMap = s.resource,
        t.emissiveMap = s.resource,
        t.update();
        let i = this.mcModelShadow.model.meshInstances[0].material
          , n = X.find(e);
        if (!s)
            if (X.hasResource(e))
                n = await X.loadResource(e, "texture");
            else {
                console.warn(`Texture "${e}" is not found!`);
                return
            }
        i.diffuseMap = n.resource,
        i.emissiveMap = n.resource,
        i.opacityMap = n.resource,
        i.update(),
        this.fire("skinChanged")
    }
    changeTrailColor(e) {
        this.rightTrail.changeColor(e.r, e.g, e.b, .4),
        this.rightTrailShadow.changeColor(e.r, e.g, e.b, .05)
    }
}
const Zw = Object.freeze({
    SelectItem: "selectItem"
});
class l3 extends V {
    constructor() {
        super(),
        this.data = null,
        this.frameIconWidth = 0,
        this.frameIconHeight = 0,
        this.addComponent("element", {
            type: Ae,
            anchor: new M(.5,.5,.5,.5),
            pivot: new P(.5,.5),
            color: new z(.2,.2,.2),
            opacity: 0,
            width: 316,
            height: 319,
            useInput: !0
        }),
        this.addComponent("button", {
            active: !0
        }),
        this._initBg(),
        this._initIcon(),
        this._initLoadingIcon(),
        this._initLockIcon(),
        this._initSelectedIcon(),
        this._initEquippedIcon(),
        this._initWarningIcon(),
        this.hideSelectedIcon(),
        this.button.on("click", this._onInventoryItemSelect.bind(this))
    }
    updateData(e) {
        this.data = e,
        this.iconLoading.enabled = !0,
        this.icon.enabled = !1,
        X.loadResource(e.icon, "texture").then(t => {
            this.icon.element.textureAsset = t,
            this.frameIconWidth = t.resource.width,
            this.frameIconHeight = t.resource.height,
            this.iconLoading.enabled = !1,
            this.icon.enabled = !0,
            this._onResizeIcon()
        }
        ),
        Q.IsSkinUnlocked(e.id) || Q.IsWeaponUnlocked(e.id) || Q.IsThemeUnlocked(e.id) ? this.unlock() : this.lock()
    }
    lock() {
        this.lockBg.element.enabled = !0,
        this.lockIcon.element.enabled = !0
    }
    unlock() {
        this.lockBg.element.enabled = !1,
        this.lockIcon.element.enabled = !1
    }
    resize() {
        var e = .35
          , t = 1;
        te.isLandScape && (e = .15,
        t = .8),
        this.lockIcon.setLocalScale(e, e, e),
        this.selectedIcon.element.width = this.element.width,
        this.selectedIcon.element.height = this.element.height,
        this.lockBg.element.width = this.element.width,
        this.lockBg.element.height = this.element.height,
        this.bg.element.width = this.element.width,
        this.bg.element.height = this.element.height,
        this.equippedIcon.setLocalScale(t, t, t),
        this._onResizeIcon(),
        this._onResizeLoadingIcon()
    }
    _initBg() {
        this.bg = j.createImageElement("spr_frame_shop_item_bg", {}),
        this.bg.element.width = this.element.width,
        this.bg.element.height = this.element.height,
        this.addChild(this.bg)
    }
    _initSelectedIcon() {
        this.selectedIcon = j.createImageElement("spr_frame_selection", {}),
        this.addChild(this.selectedIcon)
    }
    _initIcon() {
        this.icon = j.createEmptyImageElement({}),
        this.addChild(this.icon)
    }
    _initLoadingIcon() {
        this.iconLoading = j.createImageElement("spr_icon_loading", {
            anchor: new M(.5,.5,.5,.5),
            scale: .7
        }),
        this.addChild(this.iconLoading),
        this.rotateLoadingIconTween = Z.createTween({
            rotation: 0
        }, {
            rotation: 360
        }, {
            duration: 1.5,
            loop: !0,
            onUpdate: e => {
                this.iconLoading.setLocalEulerAngles(0, 0, e.rotation)
            }
        }).start(),
        this._onResizeLoadingIcon()
    }
    _onResizeLoadingIcon() {
        var e = .7
          , t = te.width / te.height;
        t >= .65 && (e = .5),
        this.iconLoading.setLocalScale(e, e, e)
    }
    _onResizeIcon() {
        if (!(this.frameIconWidth <= 0 || this.frameIconHeight <= 0)) {
            var e = .5;
            te.isLandScape && (e = .5),
            this.icon.element.width = this.frameIconWidth * e,
            this.icon.element.height = this.frameIconHeight * e;
            var t = Ms.getTypeItemById(this.data.id);
            t === B.SHOP_THEME && (this.icon.element.width = this.element.width - 30,
            this.icon.element.height = this.element.height - 30)
        }
    }
    _initLockIcon() {
        this.lockBg = j.createImageElement("spr_frame_shop_item_overlay", {
            color: new z(0,0,0,1),
            opacity: .5
        }),
        this.addChild(this.lockBg),
        this.lockIcon = j.createImageElement("spr_icon_lock", {}),
        this.lockIcon.setLocalScale(.4, .4, .4),
        this.addChild(this.lockIcon)
    }
    hideSelectedIcon() {
        this.selectedIcon.element.enabled = !1
    }
    showSelectedIcon() {
        this.selectedIcon.element.enabled = !0
    }
    _onInventoryItemSelect() {
        this.fire(Zw.SelectItem, this)
    }
    _initEquippedIcon() {
        this.equippedIcon = j.createImageElement("spr_icon_checked", {}),
        this.equippedIcon.element.pivot = new P(1,0),
        this.equippedIcon.element.anchor = new M(1,0,1,0),
        this.addChild(this.equippedIcon),
        this.hideEquippedIcon()
    }
    hideEquippedIcon() {
        this.equippedIcon.element.enabled = !1
    }
    showEquippedIcon() {
        this.equippedIcon.element.enabled = !0
    }
    _initWarningIcon() {
        this.warningIcon = j.createImageElement("spr_icon_warning", {
            anchor: new M(.9,.9,.9,.9),
            pivot: new P(.5,.5),
            scale: .23
        }),
        this.addChild(this.warningIcon);
        let e = Z.createRotateTween(this.warningIcon, {
            z: 10
        }, {
            duration: .1,
            repeat: 5,
            yoyo: !0,
            easing: Z.Easing.Quadratic.InOut
        })
          , t = Z.createCountTween({
            duration: .5
        });
        e.chain(t),
        t.chain(e),
        e.start()
    }
    hideHintIcon() {
        this.warningIcon.enabled = !1
    }
    showHintIcon() {
        this.warningIcon.enabled = !0
    }
}
const rs = Object.freeze({
    Open: "open",
    Close: "close",
    ItemSelected: "item-selected",
    ItemBought: "item-bought"
});
class Jp extends V {
    constructor(e) {
        super(),
        this.type = e,
        this.currentItemSelected = null,
        this.items = [],
        this.row = 1,
        this.addComponent("element", {
            type: us,
            anchor: new M(0,0,1,1),
            pivot: new P(.5,.5),
            margin: new M(0,0,0,0),
            padding: new M(0,0,0,0)
        }),
        this._initScrollView(),
        this._initCloseButton(),
        this._initBuyButton(),
        this._initButtonAds(),
        te.app.on("resize", this.resize, this)
    }
    resize() {
        this._onResizeBuyButton(),
        this._onResizeCloseButton(),
        this._onResizeAdsButton()
    }
    open() {
        this._updateItemData(),
        this.checkRewardAds();
        var e = this._getItemIndexById(this.currentItemSelected);
        if (e !== -1) {
            var t = e / (this.items.length - 1);
            t = Math.max(0, Math.min(t, 1)),
            this.scrollbarPanel.scrollbar.value = t,
            this.scrollbarPanel.scrollbar._updateHandlePositionAndSize()
        }
        this.btnBuyContainer.enabled = !1,
        this.fire(rs.Open)
    }
    checkRewardAds() {
        this.disableAdsButton(),
        Ds.checkRewardAds().then(e => {
            e ? this.enableAdsButton() : this.disableAdsButton()
        }
        )
    }
    disableAdsButton() {
        this.adsButton.element.useInput = !1,
        this.adsButton.element.color = J.createColor(64, 64, 64, 1),
        this.adsButton.adsText.element.color = J.createColor(96, 96, 96, 1),
        this.adsButton.adsIcon.element.color = J.createColor(96, 96, 96, 1)
    }
    enableAdsButton() {
        this.adsButton.element.useInput = !0,
        this.adsButton.element.color = J.createColor(255, 255, 255, 1),
        this.adsButton.adsText.element.color = J.createColor(255, 255, 255, 1),
        this.adsButton.adsIcon.element.color = J.createColor(255, 255, 255, 1)
    }
    showHintIconInItem(e) {
        this.items.forEach(t => {
            e.includes(t.data.id) ? t.showHintIcon() : t.hideHintIcon()
        }
        )
    }
    close() {
        this.btnAdsContainer.enabled = !1,
        this.btnBuyContainer.enabled = !1,
        this.fire(rs.Close)
    }
    _getItemIndexById(e) {
        return this.items.findIndex(t => t.data.id === e)
    }
    _initCloseButton() {
        this.closeButton = j.createButtonElement("spr_icon_back", {
            anchor: new M(0,1,0,1)
        }),
        this.closeButton.setLocalPosition(50, 120, 0),
        this.closeButton.element.on("click", () => {
            this.close()
        }
        ),
        this.addChild(this.closeButton),
        this._onResizeCloseButton()
    }
    _onResizeCloseButton() {
        var e = 60
          , t = 120
          , s = .7
          , i = te.width / te.height;
        i <= .5 && (e = 70),
        i > .65 && (e = 70,
        t = 140),
        te.isLandScape && (s = .6,
        e = 50,
        t = 95,
        i <= 1.51 && (t = 110)),
        this.closeButton.setLocalScale(s, s, 1),
        this.closeButton.setLocalPosition(e, t, 0)
    }
    _initButtonAds() {
        this.btnAdsContainer = j.createGroupElement({
            anchor: new M(.5,.5,.5,.5),
            pivot: new P(.5,.5)
        }),
        this.btnAdsContainer.setPosition(0, 0, 0),
        this.addChild(this.btnAdsContainer),
        this.adsButton = j.createButtonElement("spr_btn_buy", {
            anchor: new M(.5,.5,.5,.5),
            pressedTint: new z(.8,.8,.8,1),
            pivot: new P(.5,.5),
            width: 270,
            height: 110
        }),
        this.btnAdsContainer.addChild(this.adsButton);
        var e = j.createImageElement("spr_icon_ads", {
            anchor: new M(.25,.5,.25,.5)
        });
        this.adsButton.adsIcon = e,
        this.adsButton.addChild(e);
        var t = j.createTextElement("poppins_bold", {
            anchor: new M(.67,.5,.67,.5),
            text: "GET",
            color: J.createColor(255, 255, 255),
            fontSize: 55
        });
        this.adsButton.adsText = t,
        this.adsButton.addChild(t),
        this.btnAdsContainer.enabled = !1,
        this.adsButton.button.on("click", this._onAdsButtonClicked, this),
        this._onResizeAdsButton()
    }
    _onAdsButtonClicked() {
        Ds.showRewardAds().then(e => {
            e && (this.unlockItem(),
            this.checkRewardAds(),
            this.fire(rs.ItemBought, this.currentItemSelected))
        }
        )
    }
    _onResizeAdsButton() {
        var e = 200
          , t = 120
          , s = 1
          , i = te.width / te.height
          , n = new M(.5,1,.5,1);
        i <= .5 && (e = 150),
        i > .65 && (t = 140,
        n = new M(.5,1,.5,1)),
        te.isLandScape && (s = .8,
        e = 200,
        n = new M(.5,1,.5,1),
        t = 90,
        i >= 2 && (t = 100),
        i <= 1.51 && (t = 110)),
        this.btnAdsContainer.setLocalScale(s, s, s),
        this.btnAdsContainer.setLocalPosition(e - this.buyButton.element.width * s / 2, t, 0),
        this.btnAdsContainer.element.anchor = n
    }
    _initBuyButton() {
        this.btnBuyContainer = j.createGroupElement({
            anchor: new M(.5,.5,.5,.5),
            pivot: new P(.5,.5)
        }),
        this.btnBuyContainer.setPosition(0, 0, 0),
        this.addChild(this.btnBuyContainer),
        this.buyButton = j.createButtonElement("spr_btn_buy", {
            anchor: new M(.5,.5,.5,.5),
            pressedTint: new z(.8,.8,.8,1),
            pivot: new P(.5,.5),
            width: 270,
            height: 110
        }),
        this.btnBuyContainer.addChild(this.buyButton);
        var e = j.createImageElement("spr_icon_currency", {
            anchor: new M(.25,.5,.25,.5),
            y: 5,
            scale: .25
        });
        this.buyButton.currencyIcon = e,
        this.buyButton.addChild(e);
        var t = j.createTextElement("poppins_bold", {
            anchor: new M(.65,.5,.65,.5),
            alignment: new P(.5,.5),
            text: "1000",
            color: J.createColor(255, 255, 255),
            fontSize: 50
        });
        this.buyButton.addChild(t),
        this.btnBuyContainer.enabled = !1,
        this.buyButton.button.on("click", this._onBuyButtonClick, this),
        this.buyButton.priceText = t,
        this._onResizeBuyButton()
    }
    _onBuyButtonClick() {
        this.unlockItem(),
        Q.subCurrency(Ms.getShopItemById(this.type, this.currentItemSelected).price),
        this.fire(rs.ItemBought, this.currentItemSelected)
    }
    unlockItem() {
        this.type === B.SHOP_SKIN && this.unlockSkin(),
        this.type === B.SHOP_WEAPON && this.unlockWeapon(),
        this.type === B.SHOP_THEME && this.unlockTheme()
    }
    unlockSkin() {
        Q.unlockSkin(this.currentItemSelected),
        Q.currentSkin = this.currentItemSelected,
        this.onUnlockItem(this.currentItemSelected)
    }
    unlockWeapon() {
        Q.unlockWeapon(this.currentItemSelected),
        Q.currentWeapon = this.currentItemSelected,
        this.onUnlockItem(this.currentItemSelected)
    }
    unlockTheme() {
        Q.unlockTheme(this.currentItemSelected),
        Q.currentTheme = this.currentItemSelected,
        this.onUnlockItem(this.currentItemSelected)
    }
    onUnlockItem(e) {
        var t = this.items.find(s => s.data.id === e);
        t && (t.unlock(),
        this._showItemEquippedIcon(e),
        this.btnAdsContainer.enabled = !1,
        this.btnBuyContainer.enabled = !1)
    }
    _onResizeBuyButton() {
        var e = 500
          , t = 120
          , s = 1
          , i = te.width / te.height
          , n = new M(.5,1,.5,1);
        i <= .5 && (e = 450),
        i > .65 && (t = 140,
        n = new M(.5,1,.5,1)),
        te.isLandScape && (s = .8,
        e = 450,
        n = new M(.5,1,.5,1),
        t = 90,
        i >= 2 && (t = 100),
        i <= 1.51 && (t = 110)),
        this.btnBuyContainer.setLocalScale(s, s, s),
        this.btnBuyContainer.setLocalPosition(e - this.buyButton.element.width * s / 2, t, 0),
        this.btnBuyContainer.element.anchor = n
    }
    updateCurrencyText(e, t) {
        var s = Ms.getShopItemById(e, t);
        s !== null && (this.buyButton.priceText.element.text = s.price,
        this._isAffordable(s.price) ? (this.buyButton.currencyIcon.element.color = J.createColor(255, 255, 255, 1),
        this.buyButton.priceText.element.color = J.createColor(255, 255, 255, 1),
        this.buyButton.element.useInput = !0,
        this.buyButton.element.color = J.createColor(255, 255, 255, 1)) : (this.buyButton.priceText.element.color = J.createColor(96, 96, 96, 1),
        this.buyButton.element.useInput = !1,
        this.buyButton.element.color = J.createColor(64, 64, 64, 1),
        this.buyButton.currencyIcon.element.color = J.createColor(96, 96, 96, 1)))
    }
    _isAffordable(e) {
        return parseInt(Q.getCurrency()) >= e
    }
    playMoveInBuyButtonTween() {
        var s;
        (s = this.moveInBuyButtonTween) == null || s.end(),
        this.btnBuyContainer.enabled = !0;
        var e = 500
          , t = this.btnBuyContainer.getLocalPosition();
        this.btnBuyContainer.enabled = !0,
        this.moveInBuyButtonTween = Z.createTween({
            x: t.x + e
        }, {
            x: t.x
        }, {
            duration: .5,
            easing: Z.Easing.Quartic.Out,
            onUpdate: i => {
                this.btnBuyContainer.setLocalPosition(i.x, t.y, 0)
            }
            ,
            onComplete: () => {}
        }).start()
    }
    playMoveOutBuyButtonTween() {
        var i;
        (i = this.moveOutBuyButtonTween) == null || i.end();
        var e = this.btnBuyContainer.getLocalPosition()
          , t = e.x;
        this.btnBuyContainer.enabled = !0;
        var s = 500;
        this.moveOutBuyButtonTween = Z.createTween({
            x: e.x
        }, {
            x: e.x + s
        }, {
            duration: .25,
            easing: Z.Easing.Linear.None,
            onUpdate: n => {
                this.btnBuyContainer.setLocalPosition(n.x, e.y, 0)
            }
            ,
            onComplete: () => {
                this.btnBuyContainer.setLocalPosition(t, e.y, 0),
                this.btnBuyContainer.enabled = !1
            }
        }).start()
    }
    playMoveInAdsButtonTween() {
        var s;
        (s = this.moveInAdsButtonTween) == null || s.end(),
        this.btnAdsContainer.enabled = !0;
        var e = 500
          , t = this.btnAdsContainer.getLocalPosition();
        this.btnAdsContainer.enabled = !0,
        this.moveInAdsButtonTween = Z.createTween({
            x: t.x + e
        }, {
            x: t.x
        }, {
            duration: .5,
            easing: Z.Easing.Quartic.Out,
            onUpdate: i => {
                this.btnAdsContainer.setLocalPosition(i.x, t.y, 0)
            }
            ,
            onComplete: () => {}
        }).start()
    }
    playMoveOutAdsButtonTween() {
        var i;
        (i = this.moveOutAdsButtonTween) == null || i.end();
        var e = this.btnAdsContainer.getLocalPosition()
          , t = e.x;
        this.btnAdsContainer.enabled = !0;
        var s = 500;
        this.moveOutAdsButtonTween = Z.createTween({
            x: e.x
        }, {
            x: e.x + s
        }, {
            duration: .25,
            easing: Z.Easing.Linear.None,
            onUpdate: n => {
                this.btnAdsContainer.setLocalPosition(n.x, e.y, 0)
            }
            ,
            onComplete: () => {
                this.btnAdsContainer.setLocalPosition(t, e.y, 0),
                this.btnAdsContainer.enabled = !1
            }
        }).start()
    }
    _updateItemData() {
        for (var e = Ms.getShopItemsByType(this.type), t = 0; t < e.length; t++)
            (this.items[t] || this._initShopUIItem()).updateData(e[t]);
        var s = Q._currentSkin;
        switch (this.type) {
        case B.SHOP_WEAPON:
            s = Q._currentWeapon;
            break;
        case B.SHOP_THEME:
            s = Q._currentTheme;
            break
        }
        this.items.forEach(n => {
            n.hideSelectedIcon(),
            n.hideEquippedIcon()
        }
        );
        var i = this.items.find(n => n.data.id === s);
        i && (i.showEquippedIcon(),
        i.showSelectedIcon(),
        this.currentItemSelected = i.data.id)
    }
    _initShopUIItem() {
        var e = new l3;
        return this.addItem(e),
        this._registerInventoryUIItemEvent(e),
        e
    }
    _registerInventoryUIItemEvent(e) {
        e.on(Zw.SelectItem, this._onItemSelected, this)
    }
    _onItemSelected(e) {
        if (e.data.id !== this.currentItemSelected) {
            switch (this.items.forEach(t => {
                t.hideSelectedIcon()
            }
            ),
            e.showSelectedIcon(),
            this.type) {
            case B.SHOP_SKIN:
                Q.IsSkinUnlocked(e.data.id) && (Q.IsSkinUnlocked(this.currentItemSelected) || this.moveButton(),
                this._changeUserItem(e.data.id)),
                Q.IsSkinUnlocked(e.data.id) || this._onLockedItemSelected(this.type, e.data.id);
                break;
            case B.SHOP_WEAPON:
                Q.IsWeaponUnlocked(e.data.id) && (Q.IsWeaponUnlocked(this.currentItemSelected) || this.moveButton(),
                this._changeUserItem(e.data.id)),
                Q.IsWeaponUnlocked(e.data.id) || this._onLockedItemSelected(this.type, e.data.id);
                break;
            case B.SHOP_THEME:
                Q.IsThemeUnlocked(e.data.id) && (Q.IsThemeUnlocked(this.currentItemSelected) || this.moveButton(),
                this._changeUserItem(e.data.id)),
                Q.IsThemeUnlocked(e.data.id) || this._onLockedItemSelected(this.type, e.data.id);
                break
            }
            this.currentItemSelected = e.data.id,
            this.fire(rs.ItemSelected, e.data)
        }
    }
    _onLockedItemSelected(e, t) {
        let s = Ms.getShopItemById(e, t);
        s !== null && (this.buyButton.priceText.element.text = s.price,
        this.updateCurrencyText(this.type, t),
        this.playMoveInBuyButtonTween(),
        this.playMoveInAdsButtonTween())
    }
    moveButton() {
        this.btnBuyContainer.enabled && this.playMoveOutBuyButtonTween(),
        this.btnAdsContainer.enabled && this.playMoveOutAdsButtonTween()
    }
    _changeUserItem(e) {
        switch (this.type) {
        case B.SHOP_SKIN:
            Q.currentSkin = e;
            break;
        case B.SHOP_WEAPON:
            Q.currentWeapon = e;
            break;
        case B.SHOP_THEME:
            Q.currentTheme = e;
            break
        }
        this._showItemEquippedIcon(e)
    }
    _showItemEquippedIcon(e) {
        this.items.forEach(s => {
            s.hideEquippedIcon()
        }
        );
        var t = this._findItemById(e);
        t && t.showEquippedIcon()
    }
    _findItemById(e) {
        return this.items.find(t => t.data.id === e)
    }
    changeHeight(e) {
        this.content.element.height = e,
        this._updateItemsHeight(),
        this._reCalculateLayout(),
        this._onResizeItems()
    }
    addItem(e) {
        this.items.push(e),
        this.content.addChild(e),
        this._reCalculateLayout()
    }
    _updateItemsHeight() {
        for (var e = 0; e < this.items.length; e++) {
            var t = this.items[e];
            if (t) {
                var s = (this.content.element.height - (this.row * this.content.layoutgroup.spacing.y + 20)) / this.row
                  , i = t.element.width / t.element.height;
                t.element.height = s,
                t.element.width = s * i
            }
        }
    }
    _reCalculateLayout() {
        let e = this.items;
        if (!e[0] || !e[0].element)
            return;
        let t = e[0]
          , s = t.element.height
          , i = Math.floor(this.content.element.height / (s + this.content.layoutgroup.spacing.y))
          , n = this.content.layoutgroup;
        var r = this.content.children
          , o = n.padding.x + n.padding.z
          , l = Math.ceil(r.length / i);
        o += l * t.element.width,
        o += Math.max(0, l - 1) * n.spacing.x,
        this.content.element.width = o,
        this.scrollbarPanel.scrollbar._updateHandlePositionAndSize()
    }
    _onResizeItems() {
        this.items.forEach(e => {
            e.resize()
        }
        )
    }
    _initScrollView() {
        this._createViewPort(),
        this._createHorizontalScrollBar(),
        this.addComponent("scrollview", {
            scrollMode: yu,
            bounceAmount: .1,
            friction: .05,
            useMouseWheel: !0,
            mouseWheelSensitivity: new P(1,1),
            viewportEntity: this.viewport,
            contentEntity: this.content,
            horizontal: !0,
            horizontalScrollbarEntity: this.scrollbarPanel,
            horizontalScrollbarVisibility: _g
        }),
        this.scrollbarPanel.scrollbar._updateHandlePositionAndSize()
    }
    _createViewPort() {
        this.viewport = new V("viewport"),
        this.viewport.addComponent("element", {
            type: Ae,
            anchor: new M(0,0,1,1),
            pivot: new P(.5,.5),
            color: new z(.2,.2,.2),
            margin: new M(0,0,0,0),
            padding: new M(0,0,0,0),
            mask: !0,
            opacity: 1,
            rect: new M(0,0,1,1)
        }),
        this.addChild(this.viewport),
        this.content = new V("content"),
        this.content.addComponent("element", {
            type: us,
            anchor: new M(0,1,0,1),
            pivot: new P(0,1),
            margin: new M,
            height: 650,
            useInput: !0
        }),
        this.content.addComponent("layoutgroup", {
            orientation: Re,
            padding: new M(0,0,0,0),
            alignment: new P(0,1),
            spacing: new P(20,20),
            wrap: !0
        }),
        this.viewport.addChild(this.content)
    }
    _createHorizontalScrollBar() {
        this.handle = new V("handle"),
        this.handle.addComponent("element", {
            type: Ae,
            color: J.createColor(170, 75, 214, 1),
            anchor: new M(0,0,0,1),
            pivot: new P(0,0),
            width: 0,
            margin: new M(0,0,0,0),
            useInput: !0
        }),
        this.handle.addComponent("button", {
            active: !0,
            hoverTint: new z(.9,.9,.9),
            pressedTint: new z(.5,.5,.5),
            imageEntity: this.handle
        }),
        this.scrollbarPanel = new V("scrollbar"),
        this.scrollbarPanel.addComponent("element", {
            type: Ae,
            anchor: new M(0,0,1,0),
            pivot: new P(0,0),
            height: 7,
            margin: new M(0,0,0,0),
            rect: new M(0,0,1,1),
            color: J.createColor(55, 0, 81, 1)
        }),
        this.scrollbarPanel.addChild(this.handle),
        this.scrollbarPanel.addComponent("scrollbar", {
            orientation: Se,
            value: 0,
            handleSize: .5,
            handleEntity: this.handle
        }),
        this.addChild(this.scrollbarPanel)
    }
}
const Mt = Object.freeze({
    ShopPanelOpen: "shopPanelOpen",
    SkinPanelClose: "skinPanelClose",
    WeaponPanelClose: "weaponPanelClose",
    ThemePanelClose: "themePanelClose",
    SkinChanged: "skinChanged",
    WeaponChanged: "weaponChanged",
    ThemeChanged: "themeChanged"
});
class h3 extends La {
    constructor() {
        super(B.SCREEN_SHOP)
    }
    create() {
        super.create(),
        this._initFakeBg(),
        this._initButtons(),
        this._initTopBar(),
        this._initShopPanel(),
        this._initLoadingPanel()
    }
    resize() {
        super.resize(),
        this._onResizeShopButtons(),
        this._onResizeShopPanel()
    }
    _initFakeBg() {
        this.bgFake = new V("fake_background"),
        this.addChild(this.bgFake),
        this.bgFake.addComponent("element", {
            type: "image",
            anchor: new M(0,0,1,1)
        }),
        this.bgFake.element.opacity = 0,
        this.bgFake.element.useInput = !0,
        this.bgFake.enabled = !1
    }
    _initTopBar() {
        this.topBar = new Fg,
        this.addChild(this.topBar),
        this.topBar.enabled = !1
    }
    _initLoadingPanel() {
        this.loadingPanel = new V("loading_panel"),
        this.addChild(this.loadingPanel),
        this.loadingPanel.addComponent("element", {
            type: "image",
            anchor: new M(0,0,1,1),
            color: new z(0,0,0,1)
        }),
        this.loadingPanel.element.opacity = .8,
        this.loadingPanel.element.useInput = !0,
        this.iconLoading = j.createImageElement("spr_icon_loading", {}),
        this.loadingPanel.addChild(this.iconLoading),
        this.rotateLoadingIconTween = Z.createTween({
            rotation: 0
        }, {
            rotation: 360
        }, {
            duration: 1.5,
            loop: !0,
            onUpdate: e => {
                this.iconLoading.setLocalEulerAngles(0, 0, e.rotation)
            }
        }),
        this.loadingPanel.enabled = !1
    }
    showLoadingPanel() {
        var e, t;
        this.loadingPanel.enabled = !0,
        (e = this.rotateLoadingIconTween) == null || e.stop(),
        (t = this.rotateLoadingIconTween) == null || t.start()
    }
    hideLoadingPanel() {
        this.loadingPanel.enabled && Z.createTween({}, {}, {
            duration: .7,
            onComplete: () => {
                var e;
                this.loadingPanel.enabled = !1,
                (e = this.rotateLoadingIconTween) == null || e.stop()
            }
        }).start()
    }
    checkShowHint() {
        let e = Ms.getShopItemsByType(B.SHOP_SKIN)
          , t = this._getAffordableItems(e);
        this.skinShop.showHintIconInItem(t),
        this.btnSkin.warningIcon.enabled = t.length > 0;
        let s = Ms.getShopItemsByType(B.SHOP_WEAPON)
          , i = this._getAffordableItems(s);
        this.weaponShop.showHintIconInItem(i),
        this.btnWeapon.warningIcon.enabled = i.length > 0;
        let n = Ms.getShopItemsByType(B.SHOP_THEME)
          , r = this._getAffordableItems(n);
        this.themeShop.showHintIconInItem(r),
        this.btnTheme.warningIcon.enabled = r.length > 0
    }
    _getAffordableItems(e) {
        let t = []
          , s = parseInt(Q.getCurrency());
        for (let i of e)
            s >= i.price && !this._isItemUnlocked(i.id) && t.push(i.id);
        return t
    }
    _isItemUnlocked(e) {
        return Q.IsSkinUnlocked(e) || Q.IsWeaponUnlocked(e) || Q.IsThemeUnlocked(e)
    }
    _initButtons() {
        this.btnSkin = j.createButtonElement("spr_btn_skin", {
            anchor: new M(.3,.3,.3,.3),
            pivot: new P(.5,.5),
            scale: .8,
            useInput: !0
        }),
        this.addChild(this.btnSkin),
        this.btnSkin.element.on("click", this._openSkinPanel.bind(this));
        let e = this._initWarningIcon();
        e.element.anchor = new M(.8,.9,.8,.9),
        this.btnSkin.addChild(e),
        this.btnSkin.warningIcon = e,
        this.btnWeapon = j.createButtonElement("spr_btn_weapon", {
            anchor: new M(.7,.3,.7,.3),
            pivot: new P(.5,.5),
            scale: .8
        }),
        this.btnWeapon.element.on("click", this._openWWeaponPanel.bind(this)),
        this.addChild(this.btnWeapon);
        let t = this._initWarningIcon();
        t.element.anchor = new M(.8,.9,.8,.9),
        this.btnWeapon.addChild(t),
        this.btnWeapon.warningIcon = t,
        this.btnTheme = j.createButtonElement("spr_btn_theme", {
            anchor: new M(.5,.3,.5,.3),
            pivot: new P(.5,.5),
            scale: .8
        }),
        this.addChild(this.btnTheme),
        this.btnTheme.element.on("click", this._openThemePanel.bind(this));
        let s = this._initWarningIcon();
        s.element.anchor = new M(.8,.9,.8,.9),
        this.btnTheme.addChild(s),
        this.btnTheme.warningIcon = s,
        this._onResizeShopButtons()
    }
    _onResizeShopButtons() {
        var e = 250
          , t = new M(.5,.3,.5,.3)
          , s = new M(.5,.3,.5,.3)
          , i = new M(.5,.3,.5,.3);
        te.isLandScape && (t = new M(.5,.35,.5,.35),
        i = new M(.5,.35,.5,.35),
        s = new M(.5,.35,.5,.35)),
        this.btnSkin.element.anchor = t,
        this.btnWeapon.element.anchor = s,
        this.btnTheme.element.anchor = i,
        this.btnSkin.setLocalPosition(-e, 0, 0),
        this.btnTheme.setLocalPosition(e, 0, 0)
    }
    _initWarningIcon() {
        let e = j.createImageElement("spr_icon_warning", {
            anchor: new M(.5,.5,.5,.5),
            pivot: new P(.5,.5),
            scale: .2
        })
          , t = Z.createRotateTween(e, {
            z: 10
        }, {
            duration: .1,
            repeat: 5,
            yoyo: !0,
            easing: Z.Easing.Quadratic.InOut
        })
          , s = Z.createCountTween({
            duration: .5
        });
        return t.chain(s),
        s.chain(t),
        t.start(),
        e
    }
    _initShopPanel() {
        this.shopPanelBg = new V("inventory_bg"),
        this.addChild(this.shopPanelBg),
        this.shopPanelBg.addComponent("element", {
            type: us,
            anchor: new M(0,0,1,.2),
            pivot: new P(.5,0),
            padding: new M(0,0,0,0)
        }),
        this.shopBg = j.createImageElement("spr_frame_shop_bg", {}),
        this.shopBg.element.anchor = new M(0,0,1,1),
        this.shopPanelBg.addChild(this.shopBg),
        this.shopContainer = new V("inventory_container"),
        this.addChild(this.shopContainer),
        this.shopContainer.addComponent("element", {
            type: Ae,
            anchor: new M(.5,0,.5,.1),
            pivot: new P(.5,0),
            color: new z(.5,.5,.5,1),
            margin: new M(20,10,20,10),
            width: 1e3
        }),
        this.shopContainer.element.opacity = 0,
        this._initSkinShop(),
        this._initWeaponShop(),
        this._initThemeShop(),
        this.closeAllShopPanel(),
        this._onResizeShopPanel()
    }
    closeAllShopPanel() {
        this.bgFake.enabled = !1,
        this.shopPanelBg.enabled = !1,
        this.shopContainer.enabled = !1,
        this.skinShop.enabled = !1,
        this.weaponShop.enabled = !1,
        this.themeShop.enabled = !1
    }
    _onResizeShopPanel() {
        var e = te.width / te.height
          , t = new M(0,0,1,.17)
          , s = new M(.5,0,.5,.22)
          , i = 1e3;
        e <= .5 && (i = 900,
        s = new M(.5,0,.5,.21)),
        te.isLandScape && (s = new M(.5,0,.5,.39),
        t = new M(0,0,1,.28),
        e >= 2 && (s = new M(.5,0,.5,.42)),
        e <= 1.51 && (s = new M(.5,0,.5,.36))),
        this.shopContainer.element.width = i,
        this.shopContainer.element.anchor = s,
        this.shopPanelBg.element.anchor = t,
        this.skinShop.changeHeight(this.shopContainer.element.height),
        this.weaponShop.changeHeight(this.shopContainer.element.height),
        this.themeShop.changeHeight(this.shopContainer.element.height)
    }
    _initSkinShop() {
        this.skinShop = new Jp(B.SHOP_SKIN),
        this.shopContainer.addChild(this.skinShop),
        this.skinShop.on(rs.Close, () => {
            this._closeSkinPanel()
        }
        , this),
        this.skinShop.on(rs.ItemSelected, this._onSkinShopItemSelect, this),
        this.skinShop.on(rs.ItemBought, this._onSkinShopItemBought, this)
    }
    _onSkinShopItemSelect(e) {
        this.fire(Mt.SkinChanged, e)
    }
    _onSkinShopItemBought(e) {
        this.checkShowHint(),
        this.topBar.updateCurrencyText(Q.getCurrency()),
        this.fire(Mt.SkinChanged, e)
    }
    _initWeaponShop() {
        this.weaponShop = new Jp(B.SHOP_WEAPON),
        this.shopContainer.addChild(this.weaponShop),
        this.weaponShop.on(rs.Close, () => {
            this._closeWeaponPanel()
        }
        , this),
        this.weaponShop.on(rs.ItemSelected, this._onWeaponShopItemSelect, this),
        this.weaponShop.on(rs.ItemBought, this._onWeaponShopItemBought, this)
    }
    _onWeaponShopItemSelect(e) {
        this.fire(Mt.WeaponChanged, e)
    }
    _onWeaponShopItemBought(e) {
        this.checkShowHint(),
        this.topBar.updateCurrencyText(Q.getCurrency()),
        this.fire(Mt.WeaponChanged, e)
    }
    _initThemeShop() {
        this.themeShop = new Jp(B.SHOP_THEME),
        this.shopContainer.addChild(this.themeShop),
        this.themeShop.on(rs.Close, () => {
            this._closeThemePanel()
        }
        ),
        this.themeShop.on(rs.ItemSelected, this._onThemeShopItemSelect, this),
        this.themeShop.on(rs.ItemBought, this._onThemeShopItemBought, this)
    }
    _onThemeShopItemSelect(e) {
        this.fire(Mt.ThemeChanged, e)
    }
    _onThemeShopItemBought(e) {
        this.checkShowHint(),
        this.topBar.updateCurrencyText(Q.getCurrency()),
        this.fire(Mt.ThemeChanged, e)
    }
    _openThemePanel() {
        this.fire(Mt.ShopPanelOpen),
        this.topBar.updateCurrencyText(Q.getCurrency()),
        this.themeShop.enabled = !0,
        this.themeShop.open(),
        this.playOpenTween()
    }
    _closeThemePanel() {
        this.playCloseTween(),
        this.fire(Mt.ThemePanelClose)
    }
    _openSkinPanel() {
        this.fire(Mt.ShopPanelOpen),
        this.topBar.updateCurrencyText(Q.getCurrency()),
        this.playOpenTween(),
        this.skinShop.enabled = !0,
        this.skinShop.open()
    }
    _closeSkinPanel() {
        this.playCloseTween(),
        this.fire(Mt.SkinPanelClose)
    }
    _openWWeaponPanel() {
        this.fire(Mt.ShopPanelOpen),
        this.topBar.updateCurrencyText(Q.getCurrency()),
        this.playOpenTween(),
        this.weaponShop.enabled = !0,
        this.weaponShop.open()
    }
    _closeWeaponPanel() {
        this.playCloseTween(),
        this.fire(Mt.WeaponPanelClose)
    }
    playOpenTween() {
        this.moveButtonOutTween(this.btnTheme, !1),
        this.moveButtonOutTween(this.btnSkin, !0),
        this.fadeOutButtonTween(this.btnWeapon),
        this.moveUpShopContainerTween(),
        this.moveInTopBarTween()
    }
    playCloseTween() {
        this.moveButtonInTween(this.btnTheme, !1),
        this.moveButtonInTween(this.btnSkin, !0),
        this.fadeInButtonTween(this.btnWeapon),
        this.moveOutTopBarTween(),
        this.moveDownShopContainerTween()
    }
    moveInTopBarTween() {
        var e = this.topBar.getLocalPosition().clone();
        this.topBar.enabled = !0,
        Z.createTween({
            x: e.x - 500
        }, {
            x: e.x
        }, {
            duration: .3,
            onUpdate: t => {
                this.topBar.setLocalPosition(t.x, e.y, e.z)
            }
        }).start()
    }
    moveOutTopBarTween() {
        var e = this.topBar.getLocalPosition().clone();
        Z.createTween({
            x: e.x
        }, {
            x: e.x - 500
        }, {
            duration: .3,
            onUpdate: t => {
                this.topBar.setLocalPosition(t.x, e.y, e.z)
            }
            ,
            onComplete: () => {
                this.topBar.setLocalPosition(e.x, e.y, e.z),
                this.topBar.enabled = !1
            }
        }).start()
    }
    moveButtonOutTween(e, t=!0) {
        var s = te.width * 2
          , i = t ? -1 : 1
          , n = e.getLocalPosition().clone();
        Z.createTween({
            x: n.x
        }, {
            x: n.x + s * i
        }, {
            duration: .3,
            onUpdate: r => {
                e.setLocalPosition(r.x, n.y, n.z)
            }
            ,
            onComplete: () => {
                e.enabled = !1,
                e.setLocalPosition(n.x, n.y, n.z)
            }
        }).start()
    }
    moveButtonInTween(e, t=!0) {
        var s = te.width * 2
          , i = t ? -1 : 1
          , n = e.getLocalPosition().clone();
        e.enabled = !0,
        Z.createTween({
            x: n.x + s * i
        }, {
            x: n.x
        }, {
            duration: .3,
            onUpdate: r => {
                e.setLocalPosition(r.x, n.y, n.z)
            }
        }).start()
    }
    fadeOutButtonTween(e) {
        Z.createTween({
            opacity: 1
        }, {
            opacity: 0
        }, {
            duration: .3,
            onUpdate: t => {
                e.element.opacity = t.opacity
            }
            ,
            onComplete: () => {
                e.enabled = !1,
                e.element.opacity = 1
            }
        }).start()
    }
    fadeInButtonTween(e) {
        e.enabled = !0,
        Z.createTween({
            opacity: 0
        }, {
            opacity: 1
        }, {
            duration: .3,
            onUpdate: t => {
                e.element.opacity = t.opacity
            }
        }).start()
    }
    moveUpShopContainerTween() {
        var i;
        this.bgFake.enabled = !0,
        this.shopPanelBg.enabled = !0,
        this.shopContainer.enabled = !0;
        var e = this.shopPanelBg.getLocalPosition().clone()
          , t = this.shopContainer.getLocalPosition().clone();
        (i = this.moveContainerTween) == null || i.stop();
        var s = -700;
        this.moveContainerTween = Z.createTween({
            y: s
        }, {
            y: 0
        }, {
            duration: .3,
            onUpdate: n => {
                this.shopPanelBg.setLocalPosition(e.x, n.y, e.z),
                this.shopContainer.setLocalPosition(t.x, n.y, t.z)
            }
        }).start()
    }
    moveDownShopContainerTween() {
        var i;
        var e = this.shopPanelBg.getLocalPosition().clone()
          , t = this.shopContainer.getLocalPosition().clone();
        (i = this.moveContainerTween) == null || i.stop();
        var s = -700;
        this.moveContainerTween = Z.createTween({
            y: 0
        }, {
            y: s
        }, {
            duration: .3,
            onUpdate: n => {
                this.shopPanelBg.setLocalPosition(e.x, n.y, e.z),
                this.shopContainer.setLocalPosition(t.x, n.y, t.z)
            }
            ,
            onComplete: () => {
                this.shopPanelBg.setLocalPosition(e.x, e.y, e.z),
                this.shopContainer.setLocalPosition(t.x, t.y, t.z),
                this.closeAllShopPanel()
            }
        }).start()
    }
}
const c3 = Te.createScript({
    name: "interval",
    attributes: {
        time: {
            default: .35
        },
        delay: {
            default: 0
        }
    },
    _currTime: 0,
    check: !1,
    initialize() {
        Z.createCountTween({
            duration: this.delay,
            onComplete: () => {
                this.start()
            }
        }).start()
    },
    start() {
        this.check = !0
    },
    update(a) {
        if (this.check)
            for (this._currTime += a; this._currTime >= this.time; )
                this._currTime -= this.time,
                this.fire(u_.Interval)
    }
})
  , u_ = Object.freeze({
    Interval: "interval"
})
  , d3 = Te.createScript({
    name: "decorController",
    attributes: {
        spawner: {
            default: null
        },
        interval: {
            default: null
        },
        delay: {
            default: 0
        }
    },
    _curAngle: 0,
    initialize() {
        this.spawner.once(We.PoolInitialized, () => {
            this.startSpawn()
        }
        )
    },
    startMove() {
        this.spawner.enabled = !0,
        this.interval.enabled = !0,
        this.entity.children.forEach(a => {
            let e = a.getScript(Rt);
            e && (e.enabled = !0)
        }
        )
    },
    startSpawn() {
        this.interval.on(u_.Interval, () => {
            this.spawn()
        }
        ),
        this.preSpawn(),
        this.stopMove()
    },
    spawn() {
        let a = this.spawner.spawn(this.entity)
          , e = a.getLocalPosition();
        return e.z = this.entity.getLocalPosition().z,
        a.setLocalPosition(e),
        a
    },
    preSpawn() {
        let a = this.entity.getLocalPosition()
          , e = a.z
          , t = e
          , s = 0
          , i = this.interval.time
          , n = 0;
        for (; t >= -a.z; ) {
            var r = this.spawn()
              , o = r.getScript(Rt);
            if (o) {
                var l = r.getLocalPosition();
                r.setLocalPosition(l),
                t = e + (n + this.delay) * o.speed.z,
                l.z = t
            }
            var c = r.getScript(la);
            c && (s = n * c.speed.z,
            r.setLocalEulerAngles(0, 0, s),
            s = r.getLocalEulerAngles().z,
            this._curAngle = s),
            n += i
        }
    },
    stopMove() {
        this.entity.children.forEach(a => {
            let e = a.getScript(Rt);
            e && (e.enabled = !1)
        }
        )
    },
    stopSpawn() {
        this.interval.enabled = !1
    },
    stop() {
        this.interval.enabled = !1,
        this.spawner.enabled = !1,
        this.despawnAll(),
        this.interval.off(u_.Interval)
    },
    despawnAll() {
        for (let a = this.entity.children.length - 1; a >= 0; a--)
            this.entity.children[a].fire(We.Despawn)
    }
});
class u3 extends Rn {
    constructor(e, t, s=!1, i=void 0, n={
        autoLoad: !0
    }) {
        n.autoLoad = !0,
        super(e, s, i, n),
        this.loaded ? this.onLoaded() : this.once(ki.Loaded, this.onLoaded, this)
    }
    onLoaded() {
        this.addScript(Rt, {
            speed: new y(0,0,-15)
        }),
        this.addScript(en, {
            z: -10
        }).on(Zs.OutOfScreen, () => {
            this.fire(We.Despawn)
        }
        )
    }
}
class f3 extends Rn {
    constructor(e, t=0, s=!1, i=void 0, n={
        autoLoad: !0
    }) {
        n.autoLoad = !0,
        n.layers = [t],
        super(e, s, i, n)
    }
    checkLoaded() {
        super.checkLoaded(),
        this.setLocalScale(2, 2, 2),
        this.addScript(Rt, {
            speed: new y(0,0,-15)
        }),
        this.addScript(en, {
            z: -10
        }).on(Zs.OutOfScreen, () => {
            this.fire(We.Despawn)
        }
        ),
        this.addScript(la, {
            speed: new y(0,0,30)
        })
    }
}
class p3 extends ei {
    constructor(e, t, s=!1, i=void 0, n={
        autoLoad: !0
    }) {
        n.autoLoad = !0,
        super(e, s, i, n),
        this.loaded ? this.onLoaded() : this.once(zt.Loaded, this.onLoaded, this)
    }
    onLoaded() {
        this.addScript(Rt, {
            speed: new y(0,0,-15)
        }),
        this.addScript(en, {
            z: -10
        }).on(Zs.OutOfScreen, () => {
            this.fire(We.Despawn)
        }
        ),
        this.diamond = this.findByName("model_diamond"),
        this.lightRotate = this.findByName("lightRotate"),
        this.initAnimation()
    }
    initAnimation() {
        let e = J.random(0, 1);
        this.diamond.setLocalPosition(0, .2, 0),
        Z.createGlobalTranslateTween(this.diamond, {
            y: .6
        }, {
            duration: .5,
            delay: e,
            loop: !0,
            yoyo: !0,
            easing: Z.Easing.Sinusoidal.InOut
        }).start(),
        this.lightRotate.addScript(la, {
            speed: new y(0,100,0)
        })
    }
}
class m3 extends ei {
    constructor(e, t, s=!1, i=void 0, n={
        autoLoad: !0
    }) {
        n.autoLoad = !0,
        super(e, s, i, n),
        this.loaded ? this.onLoaded() : this.once(zt.Loaded, this.onLoaded, this)
    }
    onLoaded() {
        this.addScript(Rt, {
            speed: new y(0,0,-15)
        }),
        this.addScript(en, {
            z: -10
        }).on(Zs.OutOfScreen, () => {
            this.fire(We.Despawn)
        }
        )
    }
}
class _3 extends Rn {
    constructor(e, t, s=!1, i=void 0, n={
        autoLoad: !0
    }) {
        n.autoLoad = !0,
        super(e, s, i, n),
        this.loaded ? this.onLoaded() : this.once(ki.Loaded, this.onLoaded, this)
    }
    onLoaded() {
        this.addScript(Rt, {
            speed: new y(0,0,-15)
        }),
        this.addScript(en, {
            z: -10
        }).on(Zs.OutOfScreen, () => {
            this.fire(We.Despawn)
        }
        )
    }
}
class g3 extends Rn {
    constructor(e, t, s=!1, i=void 0, n={
        autoLoad: !0
    }) {
        n.autoLoad = !0,
        super(e, s, i, n),
        this.loaded ? this.onLoaded() : this.once(ki.Loaded, this.onLoaded, this)
    }
    onLoaded() {
        this.addScript(Rt, {
            speed: new y(0,0,-15)
        }),
        this.addScript(en, {
            z: -10
        }).on(Zs.OutOfScreen, () => {
            this.fire(We.Despawn)
        }
        )
    }
}
class y3 extends ei {
    constructor(e, t, s=!1, i=void 0, n={
        autoLoad: !0
    }) {
        n.autoLoad = !0,
        super(e, s, i, n),
        this.loaded ? this.onLoaded() : this.once(zt.Loaded, this.onLoaded, this)
    }
    onLoaded() {
        this.enabled = !1,
        this.addScript(Rt, {
            speed: new y(0,0,-15)
        }),
        this.addScript(en, {
            z: -10
        }).on(Zs.OutOfScreen, () => {
            this.fire(We.Despawn)
        }
        )
    }
}
const v3 = Object.freeze({
    cat: u3,
    gate: f3,
    light: p3,
    lineRoad: m3,
    baseDecor: _3,
    baseDecorSmall: g3,
    lightStick: y3
})
  , Qw = Object.freeze({
    StopMove: "decor:stopMove",
    Initialized: "decor:initialized"
});
class S3 extends V {
    constructor(e, t=0) {
        super("decor"),
        this.decorData = e,
        this.layer = t,
        this._initObject()
    }
    stopMove() {
        this.decorControllers.forEach(e => {
            e.stopMove(),
            e.stopSpawn()
        }
        )
    }
    startMove() {
        this.decorControllers.forEach(e => {
            e.startMove()
        }
        )
    }
    _initObject() {
        this.decorControllers = [];
        let e = 0;
        this.decorData.forEach(t => {
            let s = new V(t.name);
            s.setLocalPosition(0, 0, 40),
            this.addChild(s);
            let i = v3[t.name]
              , n = s.addScript(Gs, {
                poolSize: 20,
                class: i,
                args: [t, this.layer]
            });
            n.once(We.PoolInitialized, () => {
                e++,
                e === this.decorData.length && this.fire(Qw.Initialized)
            }
            );
            let r = t.delay;
            r || (r = 0);
            let o = s.addScript(c3, {
                time: t.interval,
                delay: r
            });
            o.enabled = !1;
            let l = s.addScript(d3, {
                spawner: n,
                interval: o,
                delay: r
            });
            this.decorControllers.push(l)
        }
        )
    }
    findChildrenByName(e) {
        return this.children.find(t => t.name === e)
    }
}
const dS = Te.createScript({
    name: "randomRotateComp",
    attributes: {
        minSpeed: {
            default: new y(0,0,0)
        },
        maxSpeed: {
            default: new y(0,0,0)
        },
        timeToChange: {
            default: 1
        }
    },
    _currTime: 0,
    _speed: new y,
    initialize() {
        this.changeSpeed()
    },
    changeSpeed() {
        this._speed = J.randomVector(this.minSpeed, this.maxSpeed)
    },
    update(a) {
        this._currTime += a,
        this._currTime >= this.timeToChange && (this._currTime = 0,
        this.changeSpeed()),
        this.entity.rotateLocal(this._speed.x * a, this._speed.y * a, this._speed.z * a)
    }
});
class x3 extends ei {
    constructor(e, t, s=!1, i=void 0, n={
        autoLoad: !0
    }) {
        n.autoLoad = !0,
        super(e, s, i, n),
        this.loaded ? this.onLoaded() : this.once(zt.Loaded, this.onLoaded, this)
    }
    onLoaded() {
        this.boxRotate1 = this.findByName("boxRotate1"),
        this.boxRotate2 = this.findByName("boxRotate2"),
        this.initAnimation()
    }
    initAnimation() {
        this.boxRotate1.addScript(dS, {
            minSpeed: new y(0,0,-100),
            maxSpeed: new y(0,0,-50),
            timeToChange: 5
        }),
        this.boxRotate2.addScript(dS, {
            minSpeed: new y(0,0,50),
            maxSpeed: new y(0,0,100),
            timeToChange: 5
        })
    }
}
class w3 extends ei {
    constructor(e, t, s=!1, i=void 0, n={
        autoLoad: !0
    }) {
        n.autoLoad = !0,
        super(e, s, i, n),
        this.loaded ? this.onLoaded() : this.once(zt.Loaded, this.onLoaded, this)
    }
    onLoaded() {
        this.circle1 = this.findByName("circle1"),
        this.circle2 = this.findByName("circle2"),
        this.circle3 = this.findByName("circle3"),
        this.initAnimation()
    }
    initAnimation() {
        this.circle1.addScript(la, {
            speed: new y(0,10,0)
        }),
        this.circle2.addScript(la, {
            speed: new y(0,-10,0)
        }),
        this.circle3.addScript(la, {
            speed: new y(0,10,0)
        })
    }
}
const $l = Te.createScript({
    name: "eyeLightRandomRotation",
    attributes: {
        minRotation: {
            default: new y(0,0,0)
        },
        maxRotation: {
            default: new y(0,0,0)
        },
        timeToChange: {
            default: 1
        },
        eyeLightLeft: {},
        eyeLightRight: {}
    },
    _currTime: 0,
    initialize() {
        this.changeTargetRotation()
    },
    changeTargetRotation() {
        var a = this.timeToChange / 2
          , e = J.randomVector(this.minRotation, this.maxRotation);
        let t = Z.createTween({
            x: 0,
            y: 0,
            z: 0
        }, {
            x: e.x,
            y: e.y,
            z: e.z
        }, {
            duration: a,
            onUpdate: i => {
                this.eyeLightLeft && this.eyeLightLeft.setLocalEulerAngles(i.x, i.y, i.z),
                this.eyeLightRight && this.eyeLightRight.setLocalEulerAngles(i.x, i.y, i.z)
            }
        })
          , s = Z.createTween({
            x: e.x,
            y: e.y,
            z: e.z
        }, {
            x: 0,
            y: 0,
            z: 0
        }, {
            duration: a,
            onUpdate: i => {
                this.eyeLightLeft && this.eyeLightLeft.setLocalEulerAngles(i.x, i.y, i.z),
                this.eyeLightRight && this.eyeLightRight.setLocalEulerAngles(i.x, i.y, i.z)
            }
        });
        t.chain(s),
        t.start()
    },
    update(a) {
        this._currTime += a,
        this._currTime >= this.timeToChange && (this._currTime = 0,
        this.changeTargetRotation())
    }
});
class b3 extends ei {
    constructor(e, t, s=!1, i=void 0, n={
        autoLoad: !0
    }) {
        n.autoLoad = !0,
        super(e, s, i, n),
        this.loaded ? this.onLoaded() : this.once(zt.Loaded, this.onLoaded, this)
    }
    onLoaded() {
        this.eyeLightRight = this.findByName("eyeLightRightEntity"),
        this.eyeLightLeft = this.findByName("eyeLightLeftEntity"),
        this.initAnimation()
    }
    _checkLoad() {
        this.loaded = !0,
        this.fire(zt.Loaded)
    }
    initAnimation() {
        this.eyeLightLeft.addScript($l, {
            minRotation: new y(-5,0,-5),
            maxRotation: new y(10,0,5),
            timeToChange: 4,
            eyeLightLeft: this.eyeLightLeft,
            eyeLightRight: this.eyeLightRight
        })
    }
}
class T3 extends ei {
    constructor(e, t, s=!1, i=void 0, n={
        autoLoad: !0
    }) {
        n.autoLoad = !0,
        super(e, s, i, n),
        this.loaded ? this.onLoaded() : this.once(zt.Loaded, this.onLoaded, this)
    }
    onLoaded() {
        this.lightLeft = [],
        this.lightRight = [],
        this.light1 = this.findByName("light1"),
        this.lightLeft.push(this.light1),
        this.light2 = this.findByName("light2"),
        this.lightLeft.push(this.light2),
        this.light5 = this.findByName("light5"),
        this.lightRight.push(this.light5),
        this.light6 = this.findByName("light6"),
        this.lightRight.push(this.light6),
        this.initAnimation()
    }
    _checkLoad() {
        this.loaded = !0,
        this.fire(zt.Loaded)
    }
    initAnimation() {
        this.light1.addScript($l, {
            minRotation: new y(-5,0,-40),
            maxRotation: new y(10,0,40),
            timeToChange: J.random(3, 5),
            eyeLightLeft: this.light1
        }),
        this.light2.addScript($l, {
            minRotation: new y(-5,0,-40),
            maxRotation: new y(10,0,40),
            timeToChange: J.random(3, 5),
            eyeLightLeft: this.light2
        }),
        this.light5.addScript($l, {
            minRotation: new y(-5,0,-40),
            maxRotation: new y(10,0,40),
            timeToChange: J.random(3, 5),
            eyeLightLeft: this.light5
        }),
        this.light6.addScript($l, {
            minRotation: new y(-5,0,-40),
            maxRotation: new y(10,0,40),
            timeToChange: J.random(3, 5),
            eyeLightLeft: this.light6
        })
    }
}
const uS = Te.createScript({
    name: "rotateRange",
    attributes: {
        rotation: {
            default: new y(0,0,0)
        },
        time: {
            default: 1
        }
    },
    initialize() {
        this.rotate()
    },
    rotate() {
        var a = this.entity.getLocalEulerAngles().clone();
        Z.createTween({
            rotation: a
        }, {
            rotation: this.rotation
        }, {
            duration: this.time,
            loop: !0,
            yoyo: !0,
            easing: Z.Easing.Linear.None,
            onUpdate: t => {
                this.entity.setLocalEulerAngles(t.rotation.x, t.rotation.y, t.rotation.z)
            }
        }).start()
    }
});
class C3 extends ei {
    constructor(e, t, s=!1, i=void 0, n={
        autoLoad: !0
    }) {
        n.autoLoad = !0,
        super(e, s, i, n),
        this.loaded ? this.onLoaded() : this.once(zt.Loaded, this.onLoaded, this)
    }
    onLoaded() {
        this.eyeLightRight = this.findByName("lightRotate1"),
        this.eyeLightLeft = this.findByName("lightRotate2"),
        this.initAnimation()
    }
    _checkLoad() {
        this.loaded = !0,
        this.fire(zt.Loaded)
    }
    initAnimation() {
        this.eyeLightLeft.addScript(uS, {
            rotation: new y(0,0,0),
            time: 1.5
        }),
        this.eyeLightRight.addScript(uS, {
            rotation: new y(0,0,0),
            time: 1.5
        })
    }
}
const E3 = Object.freeze({
    circleRotate: w3,
    boxRotate: x3,
    eyeLightRotate: b3,
    lightRotate: C3,
    lightDecorTheme: T3
});
class A3 extends ei {
    constructor(e, t=!0, s=0) {
        super(e, t, E3, {
            autoLoad: !1
        }),
        this.decorData = e.decorData,
        this.layer = s,
        this.decorLoaded = !1,
        this._initDecor()
    }
    _checkLoad() {
        this.loaded = !0,
        this.loaded && this.decorLoaded && this.fire(zt.Loaded)
    }
    _initDecor() {
        this.decor = new S3(this.decorData,this.layer),
        this.decor.once(Qw.Initialized, () => {
            this.decorLoaded = !0,
            this._checkLoad()
        }
        ),
        this.addChild(this.decor)
    }
    findChildrenInResourceByName(e) {
        return this.children[0].children.find(t => t.name === e)
    }
    stopMove() {
        var e;
        (e = this.decor) == null || e.stopMove()
    }
    startMove() {
        var e;
        (e = this.decor) == null || e.startMove()
    }
}
const f_ = Object.freeze({
    LOADED: "themeManager:loaded",
    LOADING_PROGRESS: "themeManager:loadingProgress"
});
class M3 extends V {
    constructor(e=!1, t=0) {
        super("themeManager"),
        this.isCaching = e,
        this.currentTheme = null,
        this.currentThemeKey = B.STORAGE.KEY_DEFAULT_THEME,
        this.layer = t
    }
    async loadTheme(e=B.STORAGE.KEY_DEFAULT_THEME) {
        this.currentTheme && this.currentTheme.destroy();
        let t = `${e}.json`
          , s = X.find(t);
        s || (X.hasResource(t) ? s = await X.loadResource(t, "json") : console.error(`Theme ${t} not found!`)),
        this.currentThemeKey = e,
        this.load(s.resource)
    }
    load(e) {
        let t = new A3(e,this.isCaching,this.layer);
        t.loaded && t.decorLoaded ? (this.currentTheme = t,
        this._onLoaded()) : (t.once(zt.Loaded, this._onLoaded, this),
        t.on(zt.Progress, s => {
            this.fire(f_.LOADING_PROGRESS, s)
        }
        )),
        t.load(),
        this.currentTheme = t,
        this.addChild(t)
    }
    stopMove() {
        var e;
        (e = this.currentTheme) == null || e.stopMove()
    }
    startMove() {
        var e;
        (e = this.currentTheme) == null || e.startMove()
    }
    _onLoaded() {
        this.fire(f_.LOADED)
    }
}
const Mu = Object.freeze({
    TurnOn: "turnOn",
    TurnOff: "turnOff"
});
class P3 extends V {
    constructor(e="spr_icon_toggle_switch_on", t="spr_icon_toggle_switch_off") {
        super(),
        this.spriteActive = e,
        this.spriteInactive = t,
        this.addComponent("element", {
            type: us,
            anchor: new M(.5,.5,.5,.5),
            pivot: new P(.5,.5),
            width: 100,
            height: 50
        }),
        this._initActiveIcon(),
        this._initInactiveIcon()
    }
    _initActiveIcon() {
        this.activeIcon = j.createImageElement(this.spriteActive, {
            useInput: !0
        }),
        this.addChild(this.activeIcon),
        this.activeIcon.addComponent("button", {
            active: !0
        }),
        this.activeIcon.button.on("click", () => {
            this.turnOff(),
            this.fire(Mu.TurnOff)
        }
        )
    }
    _initInactiveIcon() {
        this.inactiveIcon = j.createImageElement(this.spriteInactive, {
            useInput: !0
        }),
        this.addChild(this.inactiveIcon),
        this.inactiveIcon.addComponent("button", {
            active: !0
        }),
        this.inactiveIcon.button.on("click", () => {
            this.turnOn(),
            this.fire(Mu.TurnOn)
        }
        )
    }
    turnOn() {
        this.activeIcon.enabled = !0,
        this.inactiveIcon.enabled = !1
    }
    turnOff() {
        this.activeIcon.enabled = !1,
        this.inactiveIcon.enabled = !0
    }
}
const Lo = Object.freeze({
    Close: "close",
    BackToHome: "backToHome",
    Replay: "replay"
});
class R3 extends V {
    constructor() {
        super(),
        this.addComponent("element", {
            type: Ae,
            anchor: new M(0,0,1,1),
            pivot: new P(.5,.5),
            color: new z(0,0,0,.5),
            opacity: .8,
            useInput: !0
        }),
        this.create()
    }
    create() {
        this._initPanel(),
        this._initTitle(),
        this._initVibrateSetting(),
        this._initButtonHome(),
        this._initCloseButton(),
        this._initButtonReplay(),
        this.show()
    }
    show() {
        var e = En.get(B.GAME_SETTING_KEY.VIBRATION);
        e ? this.toggleVibrate.turnOn() : this.toggleVibrate.turnOff(),
        this.playAnimationAppear()
    }
    playAnimationAppear() {
        var t;
        (t = this.appearTween) == null || t.stop();
        var e = this.panel.getLocalPosition().clone();
        this.panel.enabled = !0,
        this.appearTween = Z.createTween({
            y: e.y + 1e3
        }, {
            y: e.y
        }, {
            duration: .25,
            onUpdate: s => {
                this.panel.setLocalPosition(e.x, s.y, e.z)
            }
            ,
            onComplete: () => {
                this.panel.setLocalPosition(e.x, e.y, e.z)
            }
        }).start()
    }
    playAnimationDisappear() {
        var t;
        (t = this.disappearTween) == null || t.stop();
        var e = this.panel.getLocalPosition().clone();
        this.disappearTween = Z.createTween({
            y: e.y
        }, {
            y: e.y + 1e3
        }, {
            duration: .3,
            onUpdate: s => {
                this.panel.setLocalPosition(e.x, s.y, e.z)
            }
            ,
            onComplete: () => {
                this.panel.setLocalPosition(e.x, e.y, e.z),
                this.panel.enabled = !1,
                this.enabled = !1,
                this.fire(Lo.Close)
            }
        }).start()
    }
    _initPanel() {
        this.panel = new V,
        this.panel.addComponent("element", {
            type: Ae,
            anchor: new M(.5,.5,.5,.5),
            pivot: new P(.5,.5),
            width: 800,
            height: 530,
            color: new z(1,1,1),
            spriteAsset: X.find("spr_frame_setting")
        }),
        this.addChild(this.panel)
    }
    _initVibrateSetting() {
        this.texVibrate = j.createTextElement("poppins_bold", {
            anchor: new M(.25,.5,.25,.5),
            pivot: new P(.5,.5),
            fontSize: 60,
            color: new z(1,1,1),
            text: "Vibrate",
            y: 20
        }),
        this.panel.addChild(this.texVibrate),
        this.toggleVibrate = new P3("spr_icon_toggle_switch_on","spr_icon_toggle_switch_off"),
        this.toggleVibrate.setLocalPosition(200, 20, 0),
        this.toggleVibrate.setLocalScale(1.2, 1.2, 1.2),
        this.panel.addChild(this.toggleVibrate),
        this.registerToggleVibrateEvent()
    }
    registerToggleVibrateEvent() {
        this.toggleVibrate.on(Mu.TurnOn, () => {
            En.set(B.GAME_SETTING_KEY.VIBRATION, !0)
        }
        ),
        this.toggleVibrate.on(Mu.TurnOff, () => {
            En.set(B.GAME_SETTING_KEY.VIBRATION, !1)
        }
        )
    }
    _initTitle() {
        this.tittleText = j.createImageElement("spr_icon_setting_text", {
            anchor: new M(.5,1,.5,1),
            pivot: new P(.5,1),
            scale: 1.3,
            y: -60
        }),
        this.panel.addChild(this.tittleText)
    }
    _initButtonHome() {
        this.homeButton = j.createImageElement("spr_btn_home", {
            useInput: !0,
            anchor: new M(.5,0,.5,0),
            pivot: new P(.5,0),
            scale: 1
        }),
        this.homeButton.setLocalPosition(150, 30, 0),
        this.homeButton.addComponent("button", {
            active: !0
        }),
        this.panel.addChild(this.homeButton),
        this.homeButton.button.on("click", () => {
            this.fire(Lo.BackToHome)
        }
        )
    }
    _initButtonReplay() {
        this.replayButton = j.createImageElement("spr_btn_replay", {
            useInput: !0,
            anchor: new M(.5,0,.5,0),
            pivot: new P(.5,0),
            scale: 1
        }),
        this.replayButton.setLocalPosition(-150, 30, 0),
        this.replayButton.addComponent("button", {
            active: !0
        }),
        this.panel.addChild(this.replayButton),
        this.replayButton.button.on("click", () => {
            this.fire(Lo.Replay)
        }
        )
    }
    _initCloseButton() {
        this.closeButton = j.createImageElement("spr_btn_close", {
            useInput: !0,
            anchor: new M(1,1,1,1),
            pivot: new P(.5,.5),
            scale: 1.15,
            x: -20,
            y: -20
        }),
        this.closeButton.addComponent("button", {
            active: !0
        }),
        this.closeButton.button.on("click", () => {
            this.playAnimationDisappear()
        }
        ),
        this.panel.addChild(this.closeButton)
    }
}
class I3 extends V {
    constructor() {
        super(),
        this.setLocalPosition(0, 1.5, 1.5),
        this.setLocalEulerAngles(90, 0, 0),
        this._initGeoEffect()
    }
    play() {
        this.geo.particlesystem.reset(),
        this.geo.particlesystem.play(),
        Z.createCountTween({
            duration: this.geo.particlesystem.lifetime,
            onComplete: () => {
                this.fire(We.Despawn)
            }
        }).start()
    }
    _initGeoEffect() {
        let e = X.find("tex_geo").resource;
        this.geo = new V;
        let t = new Ot([0, 1]);
        t.type = Kl;
        let s = 4
          , i = new Qt([[0, s], [0, s], [0, s]]);
        i.type = uh;
        let n = new Qt([[0, -s], [0, -s], [0, -s]]);
        n.type = uh;
        let r = new Ot([0, 0, 1, 5])
          , o = new Ot([0, 0, .088, .22, .838, 0, 1, 0]);
        o.type = Kl;
        let l = new Ot([0, 0, .088, .15, .838, 0, 1, 0]);
        l.type = Kl;
        let c = new Qt([[0, 255 / 255], [0, 241 / 255], [0, 102 / 255]]);
        this.geo.addComponent("particlesystem", {
            numParticles: 30,
            lifetime: .4,
            rate: 0,
            autoPlay: !1,
            loop: !1,
            colorMap: e,
            screenSpace: !1,
            emitterShape: K_,
            alignToMotion: !0,
            localSpace: !0,
            orientation: ih,
            blendType: hc,
            radialSpeedGraph: r,
            startAngle: 0,
            startAngle2: 0,
            velocityGraph: i,
            velocityGraph2: n,
            scaleGraph: o,
            alphaGraph: t,
            scaleGraph2: l,
            colorGraph: c
        }),
        this.addChild(this.geo)
    }
}
const Pu = Object.freeze({
    Revive: "revive",
    OutOfTime: "outOfTime"
});
class L3 extends La {
    constructor() {
        super(B.SCREEN_REVIVE),
        this.countDownTime = 5
    }
    create() {
        super.create(),
        this._initBg(),
        this._initTxtContinue(),
        this._initCircleProgress(),
        this._initButtonRevive()
    }
    resize() {
        super.resize(),
        this._onResizeTxtContinue(),
        this._onResizeCircleProgress(),
        this._onResizeButtonRevive()
    }
    show() {
        this.resize(),
        this.mat.resource.alphaTest = 0,
        this.progressBarText.element.text = this.countDownTime.toString(),
        this.startCountDown()
    }
    checkRewardAds() {
        this.btnRevive.enabled = !1,
        this.btnReviveWithoutAds.enabled = !0,
        Ds.checkRewardAds().then(e => {
            e ? (this.btnRevive.enabled = !0,
            this.btnReviveWithoutAds.enabled = !1) : (this.btnRevive.enabled = !1,
            this.btnReviveWithoutAds.enabled = !0)
        }
        )
    }
    _initBg() {
        this.bg = new V,
        this.addChild(this.bg),
        this.bg.addComponent("element", {
            type: Ae,
            anchor: new M(0,0,1,1),
            pivot: new P(.5,.5),
            color: new z(0,0,0,.5),
            opacity: .8,
            useInput: !0
        })
    }
    _initTxtContinue() {
        this.txtContinue = j.createImageElement("spr_txt_continue", {
            anchor: new M(.5,.7,.5,.7)
        }),
        this.addChild(this.txtContinue),
        this._onResizeTxtContinue()
    }
    _onResizeTxtContinue() {
        var e = new M(.5,.75,.5,.75)
          , t = 1.2;
        te.isLandScape && (e = new M(.5,.8,.5,.8),
        t = 1),
        this.txtContinue.element.anchor = e,
        this.txtContinue.setLocalScale(t, t, t)
    }
    _initCircleProgress() {
        this.circleProgressBarContainer = j.createGroupElement(),
        this.addChild(this.circleProgressBarContainer),
        this.circleProgressBg = j.createImageElement("spr_frame_circle", {
            anchor: new M(.5,.5,.5,.5),
            pivot: new P(.5,.5),
            width: 500,
            height: 500,
            color: J.createColor(37, 54, 82, 1)
        }),
        this.circleProgressBarContainer.addChild(this.circleProgressBg),
        this.radialMask = new V,
        this.circleProgressBarContainer.addChild(this.radialMask),
        this.radialMask.addComponent("element", {
            type: Ae,
            anchor: new M(.5,.5,.5,.5),
            pivot: new P(.5,.5),
            color: new z(0,0,0,0),
            opacity: 1,
            mask: !0,
            width: 600,
            height: 600,
            materialAsset: X.find("mat_ui_radial_mask")
        }),
        this.circleProgress = j.createEmptyImageElement({
            width: 500,
            height: 500
        }),
        this.circleProgress.element.textureAsset = X.find("spr_frame_circle2"),
        this.circleProgress.element.color = J.createColor(235, 73, 154, 1),
        this.radialMask.addChild(this.circleProgress),
        this.mat = X.find("mat_ui_radial_mask"),
        this.mat.resource.alphaTest = 0,
        this.progressBarText = j.createTextElement("poppins_bold", {
            anchor: new M(.5,.6,.5,.6),
            pivot: new P(.5,.5),
            fontSize: 200,
            color: new z(1,1,1),
            text: this.countDownTime
        }),
        this.circleProgressBarContainer.addChild(this.progressBarText),
        this._onResizeCircleProgress()
    }
    _onResizeCircleProgress() {
        var e = 1;
        te.isLandScape && (e = .7),
        this.circleProgressBarContainer.setLocalScale(e, e, e)
    }
    _initButtonRevive() {
        this.btnRevive = j.createButtonElement("spr_btn_revive", {
            anchor: new M(.5,.25,.5,.25),
            pivot: new P(.5,.5),
            scale: .7
        }),
        this.addChild(this.btnRevive),
        this.btnRevive.button.on("click", () => {
            var e;
            (e = this.countDownTween) == null || e.stop(),
            this.btnRevive.enabled = !1,
            Ds.showRewardAds().then(t => {
                t && (this.enabled = !1,
                this.fire(Pu.Revive))
            }
            )
        }
        ),
        this.btnReviveWithoutAds = j.createButtonElement("spr_btn_revive_without_ads", {
            anchor: new M(.5,.25,.5,.25),
            pivot: new P(.5,.5),
            scale: .7
        }),
        this.addChild(this.btnReviveWithoutAds),
        this._onResizeButtonRevive()
    }
    _onResizeButtonRevive() {
        var e = 1.2
          , t = new M(.5,.25,.5,.25);
        te.isLandScape && (e = 1,
        t = new M(.5,.2,.5,.2)),
        this.btnRevive.element.anchor = t,
        this.btnReviveWithoutAds.element.anchor = t,
        this.btnRevive.setLocalScale(e, e, e),
        this.btnReviveWithoutAds.setLocalScale(e, e, e)
    }
    startCountDown() {
        this.countDownTween = Z.createTween({
            time: this.countDownTime
        }, {
            time: 0
        }, {
            duration: this.countDownTime,
            onUpdate: e => {
                this.mat.resource.alphaTest = 1 - e.time / this.countDownTime,
                this.progressBarText.element.text = Math.ceil(e.time)
            }
            ,
            onComplete: () => {
                this.fire(Pu.OutOfTime)
            }
        }).start()
    }
}
const p_ = Object.freeze({
    Continue: "continue"
});
class D3 extends La {
    constructor() {
        super(B.SCREEN_REWARD),
        this.coefficient = 1,
        this.rewardCoin = 100
    }
    create() {
        super.create(),
        this._initBg(),
        this._initRibbon(),
        this._initCoinReceive(),
        this._initSliderRewardMultiple(),
        this._initButtonReward(),
        this._initButtonContinue()
    }
    resize() {
        super.resize(),
        this._onResizeRibbon(),
        this._onResizeCoinReceive(),
        this._onResizeSliderRewardMultiple(),
        this._onResizeButtonReward(),
        this._onResizeButtonContinue()
    }
    show() {
        Q.addCurrency(this.rewardCoin),
        this.txtCoinReceive.element.text = `+${this.rewardCoin}`
    }
    checkRewardAds() {
        this.disableButtonReward(),
        Ds.checkRewardAds().then(e => {
            e ? this.enableButtonReward() : this.disableButtonReward()
        }
        )
    }
    _initBg() {
        this.bg = new V("bg"),
        this.addChild(this.bg),
        this.bg.addComponent("element", {
            type: Ae,
            anchor: new M(0,0,1,1),
            pivot: new P(.5,.5),
            color: new z(0,0,0,.6),
            opacity: .8,
            useInput: !0
        })
    }
    _initRibbon() {
        this.ribbon = j.createImageElement("spr_ribbon_completed", {
            anchor: new M(.5,.85,.5,.85),
            scale: 1.2
        }),
        this.addChild(this.ribbon),
        this._onResizeRibbon()
    }
    _onResizeRibbon() {}
    _initCoinReceive() {
        this.rewardGroup = j.createGroupElement({
            anchor: new M(.5,.7,.5,.7)
        }),
        this.addChild(this.rewardGroup),
        this.txtCoinReceive = j.createTextElement("poppins_bold", {
            anchor: new M(.5,.7,.5,.7),
            fontSize: 70,
            text: "+100",
            color: J.createColor(255, 255, 255),
            alignment: new P(1,.5),
            pivot: new P(1,.5),
            y: -10
        }),
        this.rewardGroup.addChild(this.txtCoinReceive),
        this.coinIcon = j.createImageElement("spr_icon_currency", {
            scale: .4,
            x: 75
        }),
        this.rewardGroup.addChild(this.coinIcon),
        this._onResizeCoinReceive()
    }
    _onResizeCoinReceive() {}
    _initSliderRewardMultiple() {
        this.slider = j.createImageElement("spr_slider_reward_multiple", {
            scale: 1.5
        }),
        this.addChild(this.slider),
        this.arrow = j.createImageElement("spr_icon_arrow", {
            x: -350,
            y: -75,
            scale: 1.5
        }),
        this.slider.addChild(this.arrow);
        let e = 700 / 7;
        this.arrowMoveTween = Z.createLocalTranslateTween(this.arrow, {
            x: 350
        }, {
            duration: 1,
            loop: !0,
            yoyo: !0,
            onUpdate: () => {
                this.posX = this.arrow.getLocalPosition().x;
                let t = Math.floor((this.posX + 350) / e + 1);
                if (t <= 4)
                    this.coefficient = t + 1;
                else
                    switch (t) {
                    case 5:
                        this.coefficient = 4;
                        break;
                    case 6:
                        this.coefficient = 3;
                        break;
                    case 7:
                        this.coefficient = 2;
                        break
                    }
                this.updateBounusCoin()
            }
        }).start(),
        this._onResizeSliderRewardMultiple()
    }
    _onResizeSliderRewardMultiple() {}
    _initButtonReward() {
        this.btnReward = j.createButtonElement("spr_btn_yellow_2", {
            anchor: new M(.5,.35,.5,.35),
            scale: 1.2
        }),
        this.addChild(this.btnReward);
        let e = j.createImageElement("spr_icon_ads", {
            anchor: new M(.25,.5,.25,.5),
            scale: 1.2
        });
        this.btnReward.addChild(e),
        this.btnReward.adsIcon = e;
        let t = j.createTextElement("poppins_bold", {
            fontSize: 58,
            color: J.createColor(255, 255, 255),
            x: 50
        });
        this.btnReward.addChild(t),
        this.btnReward.textReward = t,
        this.btnReward.button.on("click", () => {
            Ds.showRewardAds().then(s => {
                s && (Q.addCurrency(this.rewardCoin * this.coefficient),
                this.fire(p_.Continue))
            }
            )
        }
        ),
        this._onResizeButtonReward()
    }
    _onResizeButtonReward() {
        var e = 1
          , t = new M(.5,.35,.5,.35);
        te.isLandScape && (e = .9,
        t = new M(.5,.3,.5,.3)),
        this.btnReward.setLocalScale(e, e, e),
        this.btnReward.element.anchor = t
    }
    updateBounusCoin() {
        this.btnReward.textReward.element.text = `+${this.rewardCoin * this.coefficient}`
    }
    _initButtonContinue() {
        this.btnContinue = j.createButtonElement("spr_btn_green_2", {
            anchor: new M(.5,.35,.5,.35),
            scale: 1.2,
            y: -200
        }),
        this.addChild(this.btnContinue);
        let e = j.createTextElement("poppins_bold", {
            fontSize: 50,
            text: "Continue",
            color: J.createColor(255, 255, 255)
        });
        this.btnContinue.addChild(e),
        this.btnContinue.button.on("click", () => {
            this.fire(p_.Continue)
        }
        ),
        this._onResizeButtonContinue()
    }
    _onResizeButtonContinue() {
        var e = 1
          , t = -200
          , s = new M(.5,.35,.5,.35);
        te.isLandScape && (e = .9,
        s = new M(.5,.3,.5,.3),
        t = -150),
        this.btnContinue.setLocalScale(e, e, e),
        this.btnContinue.element.anchor = s,
        this.btnContinue.setLocalPosition(0, t, 0)
    }
    enableButtonReward() {
        this.btnReward.button.active = !0,
        this.btnReward.element.useInput = !0,
        this.btnReward.element.color = new z(1,1,1),
        this.btnReward.textReward.element.color = new z(1,1,1),
        this.btnReward.adsIcon.element.color = new z(1,1,1)
    }
    disableButtonReward() {
        this.btnReward.button.active = !1,
        this.btnReward.element.useInput = !1,
        this.btnReward.element.color = new z(.5,.5,.5),
        this.btnReward.textReward.element.color = new z(.5,.5,.5),
        this.btnReward.adsIcon.element.color = new z(.5,.5,.5)
    }
}
class O3 extends Lg {
    constructor() {
        super(B.SCENE_PLAY),
        this.achievementData = [{
            completedSongCount: 1,
            id: "completed_1_song"
        }, {
            completedSongCount: 3,
            id: "completed_3_song"
        }, {
            completedSongCount: 5,
            id: "completed_5_song"
        }, {
            completedSongCount: 10,
            id: "completed_10_song"
        }],
        this._isSettingPanelOpened = !1,
        this.perfectCounter = 0,
        this.boxHit = 0,
        this.currentBoxIndex = null,
        this.matDecorBigEmissiveIntensity = 1.34,
        this.matLineRoadEmissiveIntensity = 0,
        this.matLightEmissiveIntensity = 1.32,
        this.isShaderCached = !1
    }
    create() {
        super.create();
        const e = Bi.scene.layers.getLayerByName("World")
          , t = Bi.scene.layers.getTransparentIndex(e);
        this.clearDepthLayer = new Fi({
            name: "ClearDepth"
        }),
        Bi.scene.layers.insertOpaque(this.clearDepthLayer, t + 1),
        this.clearDepthLayer.clearDepthBuffer = !0,
        this.boxLayer = new Fi({
            name: "Box"
        }),
        Bi.scene.layers.insert(this.boxLayer, this.clearDepthLayer.id + 1),
        this._initCamera(),
        this._initUI(),
        this._initGameplay(),
        Eu._configScene(J.createColor(10, 10, 10)),
        this._onGameStateChangedCallback = this._onGameStateChanged.bind(this),
        dt.registerOnStateChangedCallback(this._onGameStateChangedCallback)
    }
    _initCloudSpawner() {
        let e = new V;
        this.addChild(e),
        this.cloudSpawner = e.addScript(Gs, {
            class: LN,
            poolSize: 10
        })
    }
    _initCloudManager() {
        let e = new V;
        this.addChild(e);
        let t = e.addScript(Gs, {
            class: DN,
            poolSize: 10
        });
        this.waveCloudSpawner = e.addScript(zN, {
            spawner: this.cloudSpawner,
            waveSpawner: t
        });
        let s = new V("cloundManager");
        this.addChild(s),
        this.cloudManager = s.addScript(Ww, {
            spawnPosZ: B.CLOUD_SPAWN_Z,
            spawnGap: B.CLOUD_SPAWN_GAP,
            spawner: this.waveCloudSpawner
        }),
        this.cloudManager.changeColor(new y(...Ns.frame[B.DEFAULT_COLOR]))
    }
    destroy() {
        super.destroy(),
        dt.removeOnStateChangedCallback(this._onGameStateChangedCallback)
    }
    _onGameStateChanged(e, t) {
        t === qe.Tutorial && e === qe.Playing && this._onStart(),
        e === qe.Paused && (this._pause(),
        t === qe.Playing && this.mcController.idle()),
        t === qe.Paused && e === qe.Playing && (dt.state = qe.Tutorial,
        this.ui.setScreenActive(B.SCREEN_TUTORIAL)),
        e === qe.Playing && t === qe.Paused && this._isSettingPanelOpened === !0 && (dt.state = qe.Paused)
    }
    update(e) {
        if (dt.state === qe.Playing) {
            this.progress.currentCount = this.songManager.playTime;
            let t = this.progress.currentCount / this.progress.songDuration;
            this.playScreen.setPercent(t)
        }
        super.update(e)
    }
    loadSongData(e, t, s) {
        Eu._configScene(J.createColor(10, 10, 10)),
        this._resetScripts(),
        this.waveManager.removeWaves(),
        this.waveSpawner.reset(),
        this.songPlayer.reset(),
        this.songManager.loadSongData(e, t, s),
        this.progress.songDuration = s,
        this.songPlayer.loadSong(t),
        this._resetCharacter(),
        this._resetUI()
    }
    _resetScripts() {
        this.songManager.enable(),
        this.waveSpawner.enable(),
        this.waveManager.enable(),
        this.songPlayer.enable(),
        this.scoreManager.score = 0,
        this.perfectCounter = 0,
        ss.reset()
    }
    _resetUI() {
        this.playScreen.resetProgress(),
        this.playScreen.setScore(0),
        this.pauseButton.enabled = !0,
        this.settingPanel.enabled = !1,
        this._isSettingPanelOpened = !1
    }
    songLoaded() {
        this.progress.currentCount = 0,
        this.playTime = 0,
        this.waveSpawner.boxNum = 0,
        this.boxHit = 0,
        this._changeCameraPositionAndCharacterRotationOnTutorial(),
        this.themeManager.loadTheme(Q.currentTheme),
        this._showTutorial(),
        this._showShopScreen(),
        this.checkRewardAdsReady(),
        this._loadSong(),
        this._cacheShader()
    }
    _cacheShader() {
        if (this.isShaderCached) {
            this._onShaderCached();
            return
        }
        let e = new V;
        this.addChild(e);
        let t = j.createModel("model_box");
        e.addChild(t);
        let s = j.createModel("model_box_shadow");
        e.addChild(s);
        let i = j.createModel("model_box_half");
        e.addChild(i);
        let n = j.createModel("model_obstacle");
        e.addChild(n);
        let r = j.createModel("model_obstacle_shadow");
        e.addChild(r),
        this.leftFireflyEffect.play(),
        this.rightFireflyEffect.play(),
        this.loadResourceDecor("mat_line_road"),
        this.loadResourceDecor("mat_light"),
        this.loadResourceDecor("mat_light_stick"),
        this.loadResourceDecor("mat_line_static"),
        this.loadResourceDecor("mat_arrow_run"),
        this.loadResourceDecor("mat_line_road"),
        this.loadResourceDecor("mat_decor_big"),
        this.playAnimArrowRun(),
        this.playScreen.playPerfectResult(),
        this.playScreen.playMissResult(),
        this.cloudSpawner.spawnAt(e),
        this.characterHitEffectSpawner.spawnAt(e),
        this.fxCutBoxSpawner.spawnAt(e),
        this.boxSpawner.spawnAt(e),
        this.mineSpawner.spawnAt(e),
        this.mc.fxSpawner.spawnAt(e).play(),
        setTimeout( () => {
            this.leftFireflyEffect.stop(),
            this.rightFireflyEffect.stop(),
            e.destroy(),
            this._onShaderCached()
        }
        , 1e3)
    }
    _cacheShaderLightStick() {
        this._isThemeHasLightStick && (this._setEnableAllLightStick(!0),
        setTimeout( () => {
            this._setEnableAllLightStick(!1)
        }
        , 100))
    }
    _setEnableAllLightStick(e) {
        this.lightStickComboContainerList.forEach(t => {
            t.enabled = e
        }
        ),
        this.lightStickLeftContainerList.forEach(t => {
            t.enabled = e
        }
        ),
        this.lightStickRightContainerList.forEach(t => {
            t.enabled = e
        }
        )
    }
    onSongLoaded() {
        var e = At.getScene(B.SCENE_TRANSITION);
        e.increaseProgress(.21)
       
    }
    _onShaderCached() {
        this.isShaderCached = !0;
        var e = At.getScene(B.SCENE_TRANSITION);
        e.increaseProgress(.1)
    }
    checkRewardAdsReady() {
        this.reviveScreen.checkRewardAds(),
        this.rewardScreen.checkRewardAds()
    }
    _changeCameraPositionAndCharacterRotationOnTutorial() {
        Ht.main.setLocalPosition(0, 2, -4.6),
        Ht.main.setEulerAngles(-35, 180, 0),
        this.mc.setLocalEulerAngles(0, 210, 0)
    }
    _changeCameraPositionAndCharacterRotationOnStart() {
        var e = Ht.main.getLocalPosition().clone()
          , t = new y(B.CAMERA_X,B.CAMERA_Y,B.CAMERA_Z);
        Z.createTween(e, t, {
            duration: .3,
            onUpdate: i => {
                Ht.main.setLocalPosition(i)
            }
            ,
            onComplete: () => {
                Ht.reset()
            }
        }).start();
        var s = this.mc.getLocalEulerAngles().clone();
        Z.createTween({
            angle: s
        }, {
            angle: new y(0,0,0)
        }, {
            duration: .15,
            onUpdate: i => {
                this.mc.setLocalEulerAngles(0, i.angle.y, 0)
            }
        }).start()
    }
    _resetCharacter() {
        this.mcController.idle(),
        this.mc.setLocalPosition(0, 0, -1.5)
    }
    _showTutorial() {
        B.DEBUG_UI || (dt.state = qe.Tutorial,
        this.ui.disableAllScreens(),
        this.ui.setScreenActive(B.SCREEN_TUTORIAL))
    }
    _showShopScreen() {
        this.shopScreen.closeAllShopPanel(),
        this.shopScreen.checkShowHint(),
        this.ui.setScreenActive(B.SCREEN_SHOP)
    }
    _onStart() {
        te.onStart(),
        this.ui.disableAllScreens(),
        this.ui.setScreenActive(B.SCREEN_PLAY),
        this._changeCameraPositionAndCharacterRotationOnStart(),
        this.gameManager.startGame(),
        this.themeManager.startMove(),
        this.songManager.enable(),
        this.waveManager.resumeWaves(),
        this.songPlayer.resume(),
        this.cloudManager.startMove(),
        this.mcCollider.enabled = !0
    }
    _pause() {
        dt.isPrevState(qe.Playing) && (this.gameManager.pause(),
        this.ui.setScreenActive(B.SCREEN_TUTORIAL))
    }
    _resume() {
        dt.isState(qe.Playing) && this._isSettingPanelOpened === !1 && this.gameManager.resume()
    }
    _revive() {
        this._resetCharacter(),
        this.songPlayer.revert(),
        this.songManager.revert(B.REVERT_TIME),
        this.waveManager.playback( () => {
            dt.state = qe.Tutorial,
            this._showTutorial(),
            this.perfectCounter = 0,
            this.pauseButton.enabled = !0
        }
        )
    }
    _showRewardScreen() {
        this.ui.disableAllScreens(),
        this.rewardScreen.rewardCoin = this.boxHit,
        this.rewardScreen.show(),
        this.ui.setScreenActive(B.SCREEN_REWARD)
    }
    _onWin() {
        dt.state === qe.Playing && (this.themeManager.stopMove(),
        this.cloudManager.stopMove(),
        this.pauseButton.enabled = !1,
        this._saveToHistory(!0),
        this.mcController.idle(),
        Qe.play("sfx_outro"),
        te.onWin(),
        dt.state = qe.Win,
        Gw.enabled = !1,
        this.waveManager.turnOffColliders(),
        this._showRewardScreen())
    }
    _onLose() {
        this.pauseButton.enabled = !1,
        this.themeManager.stopMove(),
        this.cloudManager.stopMove(),
        this._saveToHistory(!1),
        this.mcCollider.enabled = !1,
        te.onLose(),
        dt.state = qe.Lose,
        Qe.play("sfx_outro"),
        setTimeout( () => {
            this._showReviveScreen()
        }
        , B.LOSE_DELAY * 1e3)
    }
    _showLoseScreen() {
        this.ui.disableAllScreens();
        let e = this.songManager.songData.length - this.boxHit;
        e < 0 && (e = 0),
        this.resultScreen.setResult(!1),
        this.resultScreen.updateInformation(this.playScreen.score, this.boxHit, e, this.playScreen.countStar),
        this.resultScreen.updateSongDataList(),
        this.resultScreen._showInterstitialAds(),
        this.waveManager.turnOffColliders(),
        this.ui.setScreenActive(B.SCREEN_RESULT)
    }
    _showWinScreen() {
        this.ui.disableAllScreens();
        let e = this.songManager.songData.length - this.boxHit;
        e < 0 && (e = 0),
        this.resultScreen.setResult(!0),
        this.resultScreen.updateInformation(this.playScreen.score, this.boxHit, e, 3),
        this.resultScreen.updateSongDataList(),
        this.resultScreen._showInterstitialAds(),
        this.ui.setScreenActive(B.SCREEN_RESULT)
    }
    _saveToHistory(e=!1) {
        var t = Q.gamePlayHistory.findIndex(o => o.songId === Q.currentSong);
        if (t === -1)
            return;
        let s = this.songManager.songData.length - this.boxHit;
        s < 0 && (s = 0);
        var i = Q.gamePlayHistory[t]
          , n = this.playScreen.countStar
          , r = i.stars;
        n >= r && (Q.gamePlayHistory[t].score = this.scoreManager.score,
        Q.gamePlayHistory[t].stars = this.playScreen.countStar,
        Q.gamePlayHistory[t].hit = this.boxHit,
        Q.gamePlayHistory[t].miss = s),
        !i.isCompleted && e && (Q.gamePlayHistory[t].isCompleted = e,
        this._saveAchievement()),
        Q.saveGamePlayHistory()
    }
    _saveAchievement() {
        var e = Q.gamePlayHistory.filter(s => s.isCompleted).length
          , t = this.achievementData.find(s => s.completedSongCount === e);
        if (t) {
            let s = window.LAGGED_SDK_CONFIG;
            s != null && s.API_AWARDS[t.id]
        }
    }
    _showReviveScreen() {
        this.ui.disableAllScreens(),
        this.ui.setScreenActive(B.SCREEN_REVIVE),
        this.reviveScreen.show()
    }
    _initCamera() {
        this.frameLayer = new Fi({
            name: "Frame"
        }),
        Bi.scene.layers.insert(this.frameLayer),
        Ht.reset(),
        this.addChild(Ht.main),
        sN.addOrbitCamera(Ht.main, this.mc, !1),
        Ht.main.camera.layers = [...Ht.main.camera.layers, this.frameLayer.id, this.clearDepthLayer.id, this.boxLayer.id]
    }
    _initUI() {
        this.ui.addScreens(new FN, new ON, new h3, new n3, new L3, new D3),
        this.playScreen = this.ui.getScreen(B.SCREEN_PLAY),
        this.TutorialScreen = this.ui.getScreen(B.SCREEN_TUTORIAL),
        this.resultScreen = this.ui.getScreen(B.SCREEN_RESULT),
        this.shopScreen = this.ui.getScreen(B.SCREEN_SHOP),
        this.rewardScreen = this.ui.getScreen(B.SCREEN_REWARD),
        this._initPauseButton(),
        this._showTutorial(),
        this._registerResultScreenEvents(),
        this._registerReviveScreenEvents(),
        this._registerRewardScreenEvents()
    }
    _initGameplay() {
        this._initInputHandler(),
        this._initLight(),
        this._initMainCharacter(),
        this._initCutBoxEffect(),
        this._initScoreManager(),
        this._initWaveManager(),
        this._initSpawners(),
        this._initSongManager(),
        this._initAudioPlayers(),
        this._initProgress(),
        this._initGameManager(),
        this._initLineEffect(),
        this._initThemeManager(),
        this._initArrowRun(),
        this._registerShopScreenEvents()
    }
    _initPauseButton() {
        this.screenContainer = new V("screen"),
        this.addChild(this.screenContainer),
        this.screenContainer.addComponent("screen", {
            screenSpace: !0,
            scaleMode: wc,
            resolution: new P(B.GAME_WIDTH,B.GAME_HEIGHT),
            referenceResolution: new P(B.GAME_WIDTH,B.GAME_HEIGHT),
            priority: 5
        }),
        this.pauseButton = j.createImageElement("spr_icon_pause", {
            useInput: !0,
            anchor: new M(.85,.95,.85,.95),
            pivot: new P(1,1)
        }),
        this.pauseButton.addComponent("button", {
            active: !0
        }),
        this.pauseButton.button.on("click", this._showSettingPanel.bind(this)),
        this.screenContainer.addChild(this.pauseButton),
        this._onResizePauseButton(),
        this.settingPanel = new R3,
        this.settingPanel.enabled = !1,
        this.screenContainer.addChild(this.settingPanel),
        this.settingPanel.on(Lo.BackToHome, () => {
            this.settingPanel.enabled = !1,
            this._onClearGamePlay(),
            this._backToHome()
        }
        ),
        this.settingPanel.on(Lo.Close, this._onSettingPanelClosed.bind(this)),
        this.settingPanel.on(Lo.Replay, () => {
            this.settingPanel.enabled = !1,
            this._onClearGamePlay(),
            this._showTransitionScene()
        }
        )
    }
    _onResizePauseButton() {
        var e = te.width / te.height
          , t = .3
          , s = new M(.95,.95,.95,.95);
        te.isLandScape && (t = .25,
        s = new M(.75,.95,.75,.95),
        e <= 1.5 && (s = new M(.8,.95,.8,.95))),
        this.pauseButton.setLocalScale(t, t, t),
        this.pauseButton.element.anchor = s
    }
    _onClearGamePlay() {
        this.songPlayer.stop(),
        this.waveManager.stopWaves(),
        this.waveManager.disable(),
        this.songManager.disable(),
        this.mcSwipeMovement.disable(),
        this.ui.disableAllScreens()
    }
    _showSettingPanel() {
        this.settingPanel.enabled = !0,
        this.settingPanel.show(),
        this.settingPanel.playAnimationAppear(),
        this._onSettingPanelOpened()
    }
    _onSettingPanelOpened() {
        this._isSettingPanelOpened = !0,
        dt.isState(qe.Playing) && (this.gameManager.pause(),
        dt.state = qe.Paused)
    }
    _onSettingPanelClosed() {
        dt.state = qe.Tutorial,
        this._isSettingPanelOpened = !1
    }
    resize() {
        super.resize(),
        this._onResizePauseButton()
    }
    _registerResultScreenEvents() {
        this.resultScreen.on(Zt.Home, this._backToHome.bind(this)),
        this.resultScreen.on(Zt.Next, () => {
            this._showTransitionScene()
        }
        ),
        this.resultScreen.on(Zt.Retry, () => {
            this._showTransitionScene(),
            this.onSongLoaded()
        }
        ),
        this.resultScreen.on(Zt.SongItemSelected, () => {
            this._showTransitionScene()
        }
        ),
        this.resultScreen.on(Zt.SongLoaded, () => {
            this.onSongLoaded()
        }
        )
    }
    _registerShopScreenEvents() {
        this.shopScreen.on(Mt.SkinChanged, e => {
            this.shopScreen.showLoadingPanel();
            var t = e.asset;
            this.mc.changeSkin(t)
        }
        ),
        this.shopScreen.on(Mt.WeaponChanged, e => {
            var t = e.asset;
            this.mc.changeMainCharacterWeapons(t, !0)
        }
        ),
        this.shopScreen.on(Mt.ThemeChanged, e => {
            if (e.id !== void 0) {
                var t = this.themeManager.currentThemeKey;
                t !== e.id && (this.shopScreen.showLoadingPanel(),
                this.themeManager.loadTheme(e.id))
            }
        }
        ),
        this.shopScreen.on(Mt.ShopPanelOpen, () => {
            this.pauseButton.enabled = !1,
            this.ui.setScreenActive(B.SCREEN_TUTORIAL, !1)
        }
        ),
        this.shopScreen.on(Mt.SkinPanelClose, () => {
            Z.createCountTween({
                duration: .3,
                onComplete: () => {
                    this.pauseButton.enabled = !0
                }
            }).start(),
            this.ui.setScreenActive(B.SCREEN_TUTORIAL, !0),
            this.mc.changeSkin()
        }
        ),
        this.shopScreen.on(Mt.WeaponPanelClose, () => {
            Z.createCountTween({
                duration: .3,
                onComplete: () => {
                    this.pauseButton.enabled = !0
                }
            }).start(),
            this.ui.setScreenActive(B.SCREEN_TUTORIAL, !0),
            this.mc.changeMainCharacterWeapons()
        }
        ),
        this.shopScreen.on(Mt.ThemePanelClose, () => {
            Z.createCountTween({
                duration: .3,
                onComplete: () => {
                    this.pauseButton.enabled = !0
                }
            }).start(),
            this.ui.setScreenActive(B.SCREEN_TUTORIAL, !0);
            var e = this.themeManager.currentThemeKey
              , t = Q.currentTheme;
            e !== t && (this.themeManager.loadTheme(t),
            this.shopScreen.showLoadingPanel())
        }
        )
    }
    _registerReviveScreenEvents() {
        this.reviveScreen = this.ui.getScreen(B.SCREEN_REVIVE),
        this.reviveScreen.on(Pu.Revive, () => {
            this.reviveScreen.checkRewardAds(),
            this._revive()
        }
        ),
        this.reviveScreen.on(Pu.OutOfTime, () => {
            this._onClearGamePlay(),
            this._showLoseScreen()
        }
        )
    }
    _registerRewardScreenEvents() {
        this.rewardScreen.on(p_.Continue, this._showWinScreen.bind(this))
    }
    _showTransitionScene() {
        var e = At.getScene(B.SCENE_TRANSITION);
        e.playTransition(.7),
        Z.createTween({}, {}, {
            duration: .1,
            onComplete: () => {
                this.songLoaded(),
                this.onSongLoaded()
            }
        }).start()
    }
    _backToHome() {
        dt.state = qe.MainMenu,
        this.ui.disableAllScreens();
        let e = At.getScene(B.SCENE_HOME);
        e.showHomeScreen(),
        At.loadScene(e)
    }
    _initLight() {
        let e = Ns.frame[B.DEFAULT_COLOR];
        this.frameLight = new V,
        this.frameLight.addComponent("light", {
            type: "directional",
            color: J.createColor(...e),
            intensity: 1,
            layers: [this.frameLayer.id]
        }),
        this.frameLight.setLocalEulerAngles(0, 0, 0),
        this.frameLight.setLocalPosition(0, 0, 0),
        this.addChild(this.frameLight);
        let t = new V;
        t.addComponent("light", {
            type: "directional",
            color: z.WHITE
        }),
        t.setLocalEulerAngles(0, 0, 0),
        t.setLocalPosition(0, 0, 0),
        this.addChild(t)
    }
    _initInputHandler() {
        let e = new V;
        this.inputHandlerScript = e.addScript(BN),
        this.addChild(e)
    }
    _initMainCharacter() {
        this.mc = new Kw(this.boxLayer,!0),
        this.addChild(this.mc),
        this.mc.setLocalScale(.025, .025, .025),
        this.mcAnimator = this.mc.mcAnimator,
        this.mcController = this.mc.mcController,
        this.mcSwipeMovement = this.mc.addScript(kN, {
            screenEntity: this.playScreen,
            multiplier: .02,
            speed: 80,
            range: 2.5
        }),
        this.mcSwipeMovement.enabled = !1,
        this.mcCollider = this.mc.addScript(Dg, {
            tag: An.Player,
            scale: new y(35,100,50),
            position: new y(0,50,50)
        });
        var e = J.createColor(...Ns.trail[B.DEFAULT_COLOR]);
        this.mc.changeTrailColor(e),
        this._initCharacterHitEffect(),
        this.mc.on("skinChanged", () => {
            this.shopScreen.hideLoadingPanel()
        }
        )
    }
    _initCharacterHitEffect() {
        let e = new V("fx_character_hit_effect");
        this.characterHitEffectSpawner = e.addScript(Gs, {
            class: I3,
            poolsize: 20
        })
    }
    _initCutBoxEffect() {
        let e = new V("fx_cut_box_spawner");
        this.fxCutBoxSpawner = e.addScript(Gs),
        e.addScript($N, {
            spawner: this.fxCutBoxSpawner
        }),
        this.addChild(e)
    }
    _initScoreManager() {
        let e = new V("scoreManager");
        this.addChild(e),
        this.scoreManager = e.addScript(YN),
        this.scoreManager.on(jw.ScoreChanged, this.playScreen.setScore, this.playScreen)
    }
    _initSpawners() {
        this._initBoxSpawner(),
        this._initMineSpawner(),
        this._initWaveSpawner()
    }
    _initBoxSpawner() {
        let e = new V("boxSpawner");
        this.addChild(e),
        this.boxSpawner = e.addScript(Gs, {
            poolsize: 10
        }),
        e.addScript(UN, {
            spawnerEntity: e,
            layer: this.boxLayer
        })
    }
    _initMineSpawner() {
        let e = new V("mineSpawner");
        this.addChild(e),
        this.mineSpawner = e.addScript(Gs, {
            poolsize: 10
        }),
        e.addScript(GN, {
            spawnerEntity: e,
            layer: this.boxLayer
        })
    }
    _initWaveSpawner() {
        let e = new V("waveSpawner");
        this.addChild(e);
        let t = e.addScript(Gs);
        this.waveSpawner = e.addScript(HN, {
            spawner: t,
            boxSpawner: this.boxSpawner,
            mineSpawner: this.mineSpawner,
            waveHolder: this.waveManager.entity
        }),
        this.waveSpawner.on(Io.AllWaveSpawned, () => {
            this.allWaveSpawned = !0,
            this._onShaderCached(),
            this.waveManager.onWaveSpawned()
        }
        )
    }
    _initWaveManager() {
        let e = new V("waveManager");
        this.addChild(e),
        this.waveManager = e.addScript(Xw, {
            boxCollideWidth: 1.5,
            mineCollideWidth: .5,
            colliderWidth: 1,
            collider: this.mcCollider
        }),
        this.waveManager.on(Ye.HitBox, t => {
            let s = t.getPosition().clone();
            this.fxCutBoxSpawner.spawn(this).setPosition(s.x, s.y + 1.5, s.z - 2)
        }
        ),
        this.waveManager.on(Ye.HitBox, this.mcController.onHitBox, this.mcController),
        this.waveManager.on(Ye.HitBox, this.mc.playEffect, this.mc),
        this.waveManager.on(Ye.HitBox, t => {
            var s = this.characterHitEffectSpawner.spawnAt(this)
              , i = t.getPosition().clone();
            s.setPosition(i.x, i.y + 1, i.z),
            s.play()
        }
        , this),
        this.waveManager.on(Ye.HitBox, this.scoreManager.onHitBox, this.scoreManager),
        this.waveManager.on(Ye.HitBox, t => {
            var i, n;
            (i = this.shakeCameraTweenSingle) == null || i.end(),
            (n = this.shakeCameraTweenCombo) == null || n.end();
            var s = Ht.main.getPosition().clone();
            t.isComboBox ? this.shakeCameraTweenCombo = Z.createShakeTween(Ht.main, .2, .05, new y(.2,.2,.2), () => {
                Ht.main.setPosition(s)
            }
            ).start() : this.shakeCameraTweenSingle = Z.createShakeTween(Ht.main, .4, .05, new y(.2,.2,.2), () => {
                Ht.main.setPosition(s)
            }
            ).start()
        }
        , this),
        this.waveManager.on(Ye.HitMine, this.mcController.onHitMine, this.mcController),
        this.waveManager.on(Ye.HitBox, this._changeRoadLight, this),
        this.waveManager.on(Ye.HitBox, () => {
            this.perfectCounter++,
            this.playScreen.playPerfectResult(this.perfectCounter)
        }
        , this),
        this.waveManager.on(Ye.HitBox, this.onHit, this),
        this.waveManager.on(Ye.HitComboBox, this.onHit, this),
        this.waveManager.on(Ye.HitComboBox, this.onHitComboVfx, this),
        this.waveManager.once(Ye.HitMine, () => {
            Qe.play("sfx_dead")
        }
        ),
        this.lastChangeColorTime = 0,
        this.lastEnableVisualizerTime = 0,
        this.lastHitTime = 0,
        this.waveManager.on(Ye.HitChangeColorBox, this.onHitChangeColorBox, this),
        this.waveManager.on(Ye.HitEnableVisualizer, this.onHitEnableVisualizer, this),
        this.waveManager.on(Ye.Miss, () => {
            dt.state === qe.Playing && (this.perfectCounter = 0,
            this.playScreen.playMissResult())
        }
        , this),
        this.waveManager.on(Ye.HitSingleBox, this.playTweenSingleLightStick, this),
        this.waveManager.on(Ye.HitComboBox, this.playTweenSingleLightStick, this)
    }
    _initArrowRun() {
        this.loadResourceDecor("mat_arrow_run"),
        this.arrowChangeColor = j.createPlane("mat_arrow_run"),
        this.addChild(this.arrowChangeColor);
        let e = this.arrowChangeColor.addScript(en, {
            z: 60,
            forward: !0
        })
          , t = this.arrowChangeColor.model.meshInstances[0].material;
        this.arrowChangeColor.addScript(Rt, {
            speed: new y(0,0,80)
        }),
        e.on(Zs.OutOfScreen, () => {
            Z.createTween({
                opacity: 1
            }, {
                opacity: 0
            }, {
                duration: .2,
                onUpdate: s => {
                    t.opacity = s.opacity,
                    t.update()
                }
                ,
                onComplete: () => {
                    this.arrowChangeColor.enabled = !1
                }
            }).start()
        }
        ),
        this.arrowChangeColor.enabled = !1,
        this._resetArrowRun()
    }
    playAnimArrowRun() {
        this._resetArrowRun(),
        this.arrowChangeColor.enabled = !0
    }
    _changeColorArrow(e) {
        let t = this.arrowChangeColor.model.meshInstances[0].material;
        t.emissive = e,
        t.diffuse = e,
        t.update()
    }
    _resetArrowRun() {
        this.arrowChangeColor.setLocalPosition(0, .1, 0),
        this.arrowChangeColor.setEulerAngles(180, 0, 180),
        this.arrowChangeColor.setLocalScale(8, 1, 50);
        let e = this.arrowChangeColor.model.meshInstances[0].material;
        e.opacity = 1,
        e.update()
    }
    _changeRoadLight() {
        this._onChangeRoadLightOpacity("mat_line_road"),
        this.decorVfxWithOpacity("mat_line_static", .122)
    }
    _onChangeRoadLightOpacity(e) {
        this.loadResourceDecor(e);
        let t = X.find(e);
        if (t) {
            if (this.matLineOpacityIncreaseTween)
                this.matLineOpacityIncreaseTween.stop();
            else {
                let s = t.resource.opacity;
                this.matLineOpacityIncreaseTween = Z.createTween({
                    opacity: s
                }, {
                    opacity: 1
                }, {
                    duration: .1,
                    onUpdate: i => {
                        t.resource.opacity = i.opacity,
                        t.resource.update()
                    }
                    ,
                    onComplete: () => {
                        t.resource.opacity = s,
                        t.resource.update()
                    }
                })
            }
            this.matLineOpacityIncreaseTween.start()
        }
    }
    onHitComboVfx() {
        this.decorVfx("mat_decor_big", this.matDecorBigEmissiveIntensity),
        this.decorVfx("mat_light", this.matLightEmissiveIntensity)
    }
    decorVfxWithOpacity(e, t) {
        this.loadResourceDecor(e);
        let s = X.find(e);
        if (s) {
            let i = Z.createTween({
                opacity: t
            }, {
                opacity: .5
            }, {
                duration: .15,
                easing: Z.Easing.Quintic.Out,
                onUpdate: r => {
                    s.resource.opacity = r.opacity,
                    s.resource.update()
                }
            })
              , n = Z.createTween({
                opacity: .5
            }, {
                opacity: t
            }, {
                duration: .2,
                easing: Z.Easing.Quintic.Out,
                onUpdate: r => {
                    s.resource.opacity = r.opacity,
                    s.resource.update()
                }
            });
            i.chain(n),
            i.start()
        }
    }
    decorVfx(e, t) {
        this.loadResourceDecor(e);
        let s = X.find(e);
        s && Z.createTween({
            intensity: t
        }, {
            intensity: 3
        }, {
            duration: .2,
            easing: Z.Easing.Quintic.In,
            onUpdate: n => {
                s.resource.emissiveIntensity = n.intensity,
                s.resource.update()
            }
            ,
            onComplete: () => {
                Z.createTween({
                    intensity: 3
                }, {
                    intensity: t
                }, {
                    duration: .2,
                    easing: Z.Easing.Quintic.Out,
                    onUpdate: r => {
                        s.resource.emissiveIntensity = r.intensity,
                        s.resource.update()
                    }
                }).start()
            }
        }).start()
    }
    onHitChangeColorBox(e) {
        let t = Date.now();
        if (t - this.lastChangeColorTime < 1e3)
            return;
        this.lastChangeColorTime = t,
        this.frameLight.light.color = J.createColor(...Ns.frame[e]);
        let s = J.createColor(...Ns.roadLines[e]);
        this.cloudManager.changeColor(new y(...Ns.frame[e]));
        let i = X.find("mat_box_yellow").resource
          , n = `tex_box_${e}`;
        i.diffuseMap = X.find(n).resource,
        i.emissiveMap = X.find(n).resource,
        i.emissive = J.createColor(...Ns.box[e]),
        i.update();
        let r = X.find("mat_box_shadow_yellow").resource;
        r.diffuseMap = X.find(n).resource,
        r.opacityMap = X.find(n).resource,
        r.emissiveMap = X.find(n).resource,
        r.emissive = J.createColor(...Ns.box[e]),
        r.update(),
        Z.createTween(this.frameLight.light, {
            intensity: 3
        }, {
            duration: .3,
            repeat: 1,
            yoyo: !0
        }).start();
        let o = X.find("mat_road_line").resource;
        o.diffuse = s,
        o.update(),
        this.leftFireflyEffect.setColor(s),
        this.rightFireflyEffect.setColor(s),
        this.leftFireflyEffect.play(),
        this.rightFireflyEffect.play(),
        this.changeColorDecor("mat_line_road", s),
        this.changeColorDecor("mat_light", s),
        this.changeColorDecor("mat_light_stick", s),
        this.changeColorDecor("mat_line_static", s),
        this._changeColorArrow(s),
        this.playAnimArrowRun(),
        this.mc.changeTrailColor(J.createColor(...Ns.trail[e]))
    }
    loadResourceDecor(e) {
        if (!X.find(e))
            if (X.hasResource(e)) {
                X.loadResource(e, "material");
                return
            } else {
                console.warn(`Model "${e}" is not found!`);
                return
            }
    }
    changeColorDecor(e, t) {
        this.loadResourceDecor(e);
        let s = X.find(e);
        s && (s.resource.diffuse = t,
        s.resource.emissive = t,
        s.resource.update())
    }
    onHit(e) {
        e.index !== this.currentBoxIndex && (this.boxHit += 1,
        this.currentBoxIndex = e.index);
        let t = Date.now();
        this.lastHitTime + 10 > t || (Qe.play("sfx_hit", .6, !1),
        this.lastHitTime = t)
    }
    onHitEnableVisualizer() {
        let e = Date.now();
        this.lastEnableVisualizerTime = e
    }
    _initSongManager() {
        let e = new V("songManager");
        this.songManager = e.addScript(WN, {
            delayStart: 1,
            spawnOffset: 2,
            countPreSpawn: 6
        }),
        this.songManager.on(ns.SongStart, this.playSong, this),
        this.songManager.on(ns.SpawnNote, this.waveSpawner.spawn, this.waveSpawner),
        this.songManager.on(ns.PreSpawnNote, this.waveSpawner.preSpawn, this.waveSpawner),
        this.songManager.on(ns.SongStart, this.waveSpawner.start, this.waveSpawner),
        this.songManager.on(ns.SongStart, this.waveSpawner.resumeWaves, this.waveSpawner),
        this.waveSpawner.on(Io.Despawn, this.songManager.onDespawnWave, this.songManager),
        this.waveSpawner.on(Io.Spawn, this.waveManager.onWaveSpawn, this.waveManager),
        this.addChild(e)
    }
    playSong() {}
    _initAudioPlayers() {
        this.songPlayerEntity = new V("songPlayer"),
        this.songPlayer = this.songPlayerEntity.addScript(XN, {
            songManager: this.songManager,
            songName: "song"
        }),
        ss.init(Bi),
        ss.pause(),
        this.songManager.on(ns.SongStart, this.songPlayer.play, this.songPlayer),
        this.songManager.on(ns.SongStart, ss.resume, ss),
        this.songManager.on(ns.SongEnd, ss.pause, ss),
        this.addChild(this.songPlayerEntity)
    }
    _initProgress() {
        let e = new V("progress");
        this.progress = e.addScript(KN, {
            thresholdCount: 10
        }),
        this.progress.on(aS.OnThreshold, () => {}
        ),
        this.progress.on(aS.OnMidway, () => {}
        ),
        this.waveManager.on(Ye.HitBox, t => {}
        )
    }
    _initGameManager() {
        let e = new V("gameManager");
        this.gameManager = e.addScript(qN),
        this.gameManager.on(ke.Start, this.mcSwipeMovement.enable, this.mcSwipeMovement),
        this.gameManager.on(ke.Start, this.mcController.run, this.mcController),
        this.gameManager.on(ke.Start, this.songManager.play, this.songManager),
        this.gameManager.on(ke.Pause, this.mcController.pause, this.mcController),
        this.gameManager.on(ke.Pause, this.songManager.disable, this.songManager),
        this.gameManager.on(ke.Pause, this.waveManager.stopWaves, this.waveManager),
        this.gameManager.on(ke.Pause, this.songPlayer.pause, this.songPlayer),
        this.gameManager.on(ke.Resume, this.mcController.resume, this.mcController),
        this.gameManager.on(ke.Resume, this.songManager.enable, this.songManager),
        this.gameManager.on(ke.Resume, this.waveManager.resumeWaves, this.waveManager),
        this.gameManager.on(ke.Resume, this.songPlayer.resume, this.songPlayer),
        this.gameManager.on(ke.Lose, this.songPlayer.pause, this.songPlayer),
        this.gameManager.on(ke.Lose, this.waveManager.stopWaves, this.waveManager),
        this.gameManager.on(ke.Lose, this.waveManager.disable, this.waveManager),
        this.gameManager.on(ke.Lose, this.songManager.disable, this.songManager),
        this.gameManager.on(ke.Lose, this.mcSwipeMovement.disable, this.mcSwipeMovement),
        this.gameManager.on(ke.Lose, this._onLose, this),
        this.gameManager.on(ke.Win, this.mcController.pause, this.mcController),
        this.gameManager.on(ke.Win, this.songManager.disable, this.songManager),
        this.gameManager.on(ke.Win, this.songPlayer.stop, this.songPlayer),
        this.gameManager.on(ke.Win, this.mcSwipeMovement.disable, this.mcSwipeMovement),
        this.gameManager.on(ke.Win, this._onWin, this),
        this.songManager.on(ns.SongEnd, this.gameManager.win, this.gameManager),
        this.waveManager.on(Ye.HitMine, this.gameManager.lose, this.gameManager),
        this.gameManager.on(ke.Start, ss.start, ss),
        this.gameManager.on(ke.Resume, ss.resume, ss),
        this.gameManager.on(ke.Pause, ss.pause, ss),
        this.gameManager.on(ke.Start, this.waveSpawner.start, this.waveSpawner)
    }
    _initLineEffect() {
        this.leftFireflyEffect = new hS,
        this.leftFireflyEffect.setLocalPosition(3.4, 0, 30),
        this.addChild(this.leftFireflyEffect),
        this.rightFireflyEffect = new hS,
        this.rightFireflyEffect.setLocalPosition(-3.4, 0, 30),
        this.addChild(this.rightFireflyEffect)
    }
    _initAudioVisualizer() {
        this.audioVisualizer = new V,
        this.addChild(this.audioVisualizer),
        this.audioVisualizer.setPosition(0, 1, 0);
        let e = new lS(70,3,.015);
        e.init(),
        this.audioVisualizer.addChild(e),
        e.setLocalPosition(-3.5, -2, -7.3),
        e.setLocalEulerAngles(0, 0, 0),
        e.setLocalScale(-10, 10, 10);
        let t = new lS(70,3,.015);
        t.init(),
        this.audioVisualizer.addChild(t),
        t.setLocalPosition(3.5, -2, -7.3),
        t.setLocalEulerAngles(0, 0, 0),
        t.setLocalScale(10, 10, 10);
        let s = new V;
        this.addChild(s),
        this.sinWave = s.addScript(QN, {
            analyser: Qe.analyser,
            waves: [e, t],
            sinWidth: .3,
            sinCount: e.nodes.length,
            speed: B.SIN_WAVE_SPEED,
            minHeight: B.VISUALIZER_MAX_HEIGHT,
            maxHeight: B.VISUALIZER_MIN_HEIGHT,
            returnSpeed: 2,
            jumpHeight: 1,
            jumpTime: .1
        }),
        this.analyserBinder = this.audioVisualizer.addScript(JN, {
            analyser: Qe.analyser,
            updateCallback: i => {
                this.sinWave.updateDataArray(i)
            }
        }),
        this.analyserBinder.enabled = !1
    }
    _initThemeManager() {
        this.themeManager = new M3(!1,this.frameLayer.id),
        this.addChild(this.themeManager),
        this._isThemeHasLightStick = !1,
        this.lightStickComboContainerList = [],
        this.lightStickLeftContainerList = [],
        this.lightStickRightContainerList = [],
        this.themeManager.on(f_.LOADED, this._onThemeLoaded, this),
        this._initCloudSpawner(),
        this._initCloudManager()
    }
    _loadSong() {
        let e = Q.currentSong;
        Q.getSongData(e).then(t => {
            let s = Q.getSongById(e).duration
              , i = Q.getSongById(e).songName;
            this.loadSongData(t.resources, i, s)
        }
        )
    }
    _onThemeLoaded() {
        this.shopScreen.hideLoadingPanel(),
        this.themeManager.stopMove(),
        this.cloudManager.stopMove(),
        this.lightSticksEntityParent = [],
        this.lightStickComboContainerList = [],
        this.lightStickLeftContainerList = [],
        this.lightStickRightContainerList = [];
        var e = this.themeManager.currentTheme.findChildrenInResourceByName("lightStick");
        if (this.lightStickParent = this.themeManager.currentTheme.decor.findChildrenByName("lightStick"),
        e !== void 0 && this.GetChildrenLightStick(e),
        e === void 0 && this.lightStickParent === void 0) {
            this._isThemeHasLightStick = !1;
            return
        }
        this._cacheShaderLightStick()
    }
    GetChildrenLightStick(e) {
        this._isThemeHasLightStick = !0;
        var t = this._findChildrenInEntityByName(e, "lightStickContainer1");
        if (t !== void 0) {
            var s = this._findChildrenInEntityByName(e, "lightStickContainer2")
              , i = this._findChildrenInEntityByName(s, "lightStickContainer2Left")
              , n = this._findChildrenInEntityByName(s, "lightStickContainer2Right");
            if (s === void 0 || i === void 0 || n === void 0) {
                console.warn("Missing light stick component in theme!");
                return
            }
            this.lightStickComboContainerList.push(t),
            this.lightStickLeftContainerList.push(i),
            this.lightStickRightContainerList.push(n),
            t.enabled = !1,
            i.enabled = !1,
            n.enabled = !1
        }
    }
    _findChildrenInEntityByName(e, t) {
        return e.children.find(s => s.name === t)
    }
    _findAllChildrenInEntityByName(e, t) {
        return e.children.filter(s => s.name === t)
    }
    playTweenSingleLightStick(e) {
        if (this.lightSticksEntityParent.length === 0 && (this.lightStickParent !== void 0 && (this.lightSticksEntityParent = this._findAllChildrenInEntityByName(this.lightStickParent, "lightStick")),
        this.lightSticksEntityParent.length !== 0 && this.lightSticksEntityParent.forEach(i => {
            var n = this._findChildrenInEntityByName(i, "lightStick");
            this.GetChildrenLightStick(n)
        }
        )),
        !(!this._isThemeHasLightStick || this.lightStickLeftContainerList.length === 0 || this.lightStickRightContainerList.length === 0 || this.lightStickComboContainerList.length === 0)) {
            var t = []
              , s = J.randomInt(0, 2);
            switch (s) {
            case 0:
                t = this.lightStickLeftContainerList;
                break;
            case 1:
                t = this.lightStickRightContainerList;
                break;
            case 2:
                t = this.lightStickComboContainerList;
                break
            }
            this.playTweenLightStick(t, .1)
        }
    }
    playTweenComboLightStick(e) {
        if (this.lightSticksEntityParent.length === 0 && (this.lightStickParent !== void 0 && (this.lightSticksEntityParent = this._findAllChildrenInEntityByName(this.lightStickParent, "lightStick")),
        this.lightSticksEntityParent.length !== 0 && this.lightSticksEntityParent.forEach(s => {
            var i = this._findChildrenInEntityByName(s, "lightStick");
            this.GetChildrenLightStick(i)
        }
        )),
        !(!this._isThemeHasLightStick || this.lightStickComboContainerList.length === 0)) {
            var t = [];
            t = this.lightStickComboContainerList,
            this.playTweenLightStick(t)
        }
    }
    playTweenLightStick(e, t=.05) {
        e.forEach(s => {
            s.enabled = !1,
            s.enabled = !0
        }
        ),
        Z.createCountTween({
            duration: t,
            onComplete: () => {
                e.forEach(s => {
                    s.enabled = !1
                }
                )
            }
        }).start()
    }
}
const _i = Object.freeze({
    ItemSelected: "ItemSelected",
    ItemBought: "ItemBought",
    SongLoaded: "SongLoaded"
});
class F3 extends La {
    constructor() {
        super(B.SCREEN_HOME),
        this.songItemList = []
    }
    create() {
        super.create(),
        this.destroyChildren(),
        this._initTopBar(),
        this._initSongList()
    }
    resize() {
        super.resize(),
        this._onResizeSongList()
    }
    updateCurrency() {
        this.topBar.updateCurrencyText(Q.getCurrency())
    }
    playAppearAnimation() {
        var t;
        this.songListScrollView.scrollview.scroll.y = 0;
        var e = this.songListBg.getLocalPosition().y;
        (t = this.moveTween) == null || t.stop(),
        this.moveTween = Z.createTween({
            y: e - 800
        }, {
            y: e
        }, {
            duration: .7,
            easing: Z.Easing.Quintic.Out,
            onUpdate: s => {
                this.songListBg.setLocalPosition(0, s.y, 0),
                this.songListContainer.setLocalPosition(0, s.y - 25, 0)
            }
        }),
        this.moveTween.start()
    }
    updateSongDataList() {
        var e = X.find("songData.json");
        if (e === null) {
            console.warn("Song data not found!");
            return
        }
        let t = this._sortSongList(e.resources);
        for (var s = 0; s < t.length; s++)
            (this.songItemList[s] || this.addSongItem(s)).updateData(t[s]);
        for (var i = t.length; i < this.songItemList.length; i++) {
            let n = this.songItemList[i];
            n.enabled = !1
        }
        this.checkRewardAds()
    }
    _sortSongList(e) {
        var t = []
          , s = e.filter(r => r.unlocked && !this._isSongCompleted(r.id));
        s.sort( (r, o) => this._getHighestScore(o.id) - this._getHighestScore(r.id)),
        s.forEach(r => {
            t.indexOf(r) === -1 && t.push(r)
        }
        );
        var i = e.filter(r => !r.unlocked);
        i.forEach(r => {
            t.indexOf(r) === -1 && t.push(r)
        }
        );
        var n = e.filter(r => this._isSongCompleted(r.id));
        return n.forEach(r => {
            t.indexOf(r) === -1 && t.push(r)
        }
        ),
        t
    }
    _isSongCompleted(e) {
        var t = Q.gamePlayHistory
          , s = t.find(i => i.songId === e);
        return s ? s.isCompleted : !1
    }
    _getHighestScore(e) {
        var t = Q.gamePlayHistory
          , s = t.find(i => i.id === e);
        return s ? s.score : 0
    }
    checkRewardAds() {
        Ds.checkRewardAds().then(e => {
            e ? this.songItemList.forEach(t => {
                t.enableBuyButton()
            }
            ) : this.songItemList.forEach(t => {
                t.disableBuyButton()
            }
            )
        }
        )
    }
    addSongItem() {
        var e = new Yw;
        return this.songItemList.push(e),
        this.listView.addItem(e),
        this.registerEvents(e),
        e
    }
    registerEvents(e) {
        e.on(ha.Selected, this.onSongItemSelected.bind(this)),
        e.on(ha.Bought, this.onSongItemBought.bind(this))
    }
    onSongItemSelected(e) {
        let t = Q.currentSong
          , s = Q.getSongById(e).songName;
        Q.currentSong = e,
        this.fire(_i.ItemSelected, e),
        t === e ? this.fire(_i.SongLoaded) : X.loadResource(s, "audio").then( () => {
            this.fire(_i.SongLoaded)
        }
        )
    }
    onSongItemBought(e) {
        let t = Q.currentSong
          , s = Q.getSongById(e).songName;
        Q.currentSong = e,
        this.fire(_i.ItemBought, e),
        t === e ? this.fire(_i.SongLoaded) : X.loadResource(s, "audio").then( () => {
            this.fire(_i.SongLoaded)
        }
        )
    }
    _initTopBar() {
        this.topBar = new Fg,
        this.addChild(this.topBar)
    }
    _initSongList() {
        this.songListBg = j.createImageElement("spr_bg_scroll_view"),
        this.songListBg.element.pivot = new P(.5,1),
        this.songListBg.element.anchor = new M(.5,.61,.5,.61),
        this.songListBg.setLocalScale(.9, 1.1, 1),
        this.addChild(this.songListBg),
        this.songListContainer = j.createGroupElement({
            anchor: new M(.5,.61,.5,.61),
            pivot: new P(.5,1),
            width: 900,
            height: 1e3,
            y: 0
        }),
        this.addChild(this.songListContainer),
        this._initScrollView(),
        this._onResizeSongList()
    }
    _onResizeSongList() {
        var e = te.width / te.height
          , t = 1
          , s = 1e3
          , i = new y(.9,1.1,1);
        e < .47 && (s = 1150,
        i = new y(.9,1.25,1)),
        e > .65 && (s = 950,
        i = new y(.9,1.04,1)),
        te.isLandScape && (t = .7,
        s = 850,
        i = new y(.65,.67,1),
        e > 2 && (s = 750,
        i = new y(.65,.6,1))),
        this.songListContainer.element.height = s,
        this.songListContainer.setLocalScale(t, t, t),
        this.songListBg.setLocalScale(i)
    }
    _initScrollView() {
        this.listView = new $w({
            anchor: new M(0,1,1,1),
            pivot: new P(0,1),
            margin: new M
        }),
        this.listView.layoutgroup.spacing = new P(0,50),
        this.songListScrollView = new qw(this.listView,{
            anchor: new M(0,0,1,1),
            pivot: new P(.5,1)
        }),
        this.songListContainer.addChild(this.songListScrollView),
        this.songListScrollView.bg.enabled = !1
    }
}
const B3 = "Stage"
  , k3 = [{
    name: "model_stage",
    position: [0, -1.3971, 0],
    scale: [1, 1.3, 1],
    components: {
        model: {
            asset: "model_stage"
        }
    }
}, {
    name: "model_decor_01",
    position: [0, 0, 0],
    components: {
        model: {
            asset: "model_decor_01"
        }
    }
}, {
    name: "model_stand",
    position: [0, 0, 0],
    components: {
        model: {
            asset: "model_stand"
        }
    }
}, {
    name: "model_speaker_01",
    position: [25, -.3914, -2.2577],
    rotation: [0, -69.921, 0],
    components: {
        model: {
            asset: "model_speaker_01"
        }
    }
}, {
    name: "model_speaker_01",
    position: [-25, -.3914, -2.2577],
    rotation: [0, 55.1553, 0],
    components: {
        model: {
            asset: "model_speaker_01"
        }
    }
}, {
    name: "model_speaker_02",
    position: [28, -.3914, 5.8715],
    rotation: [0, -67.39, 0],
    components: {
        model: {
            asset: "model_speaker_02"
        }
    }
}, {
    name: "model_speaker_02",
    position: [47.1782, 2.5674, 11.4193],
    rotation: [0, 0, 90],
    components: {
        model: {
            asset: "model_speaker_02"
        }
    }
}, {
    name: "model_speaker_02",
    position: [-35.9939, 2.5674, 11.4193],
    rotation: [0, 0, 90],
    components: {
        model: {
            asset: "model_speaker_02"
        }
    }
}, {
    name: "model_speaker_02",
    position: [-28, -.3914, 5.8715],
    rotation: [0, 55.1553, 0],
    components: {
        model: {
            asset: "model_speaker_02"
        }
    }
}, {
    name: "light01",
    position: [-8.8901, 9.3997, 2.7871],
    rotation: [90, 0, 23.382],
    scale: [39.6721, 14.3512, 35.105],
    components: {
        render: {
            type: "plane",
            materialAssets: ["light.json"],
            layers: [0],
            castShadows: !1,
            castShadowsLightmap: !1,
            receiveShadows: !1
        }
    }
}, {
    name: "light02",
    position: [12.8998, 7.8659, 5.4239],
    rotation: [-90, 0, 159.1059],
    scale: [39.6721, 14.3512, 35.105],
    components: {
        render: {
            type: "plane",
            materialAssets: ["light.json"],
            layers: [0],
            castShadows: !1,
            castShadowsLightmap: !1,
            receiveShadows: !1
        }
    }
}, {
    name: "light03",
    position: [41.2764, 16.5048, 16.2967],
    rotation: [-90, 0, 158.5143],
    scale: [93.9326, 14.3512, 35.105],
    components: {
        render: {
            type: "plane",
            materialAssets: ["light.json"],
            layers: [0],
            castShadows: !1,
            castShadowsLightmap: !1,
            receiveShadows: !1
        }
    }
}, {
    name: "light04",
    position: [-40.4177, 16.5048, 16.2967],
    rotation: [90, 0, 19.3209],
    scale: [93.9326, 14.3512, 35.105],
    components: {
        render: {
            type: "plane",
            materialAssets: ["light.json"],
            layers: [0],
            castShadows: !1,
            castShadowsLightmap: !1,
            receiveShadows: !1
        }
    }
}]
  , N3 = [0, -10.5157, 0]
  , U3 = [5, 5, 5]
  , z3 = {
    name: B3,
    children: k3,
    position: N3,
    scale: U3
}
  , ch = Object.freeze({
    SongSelected: "SongSelected",
    StageLoaded: "StageLoaded"
});
class V3 extends Lg {
    constructor() {
        super(B.SCENE_HOME),
        this.lightList = []
    }
    create() {
        super.create(),
        this._initUI(),
        this._initCamera(),
        this._initLight(),
        this._initStage(),
        this._initCharacter(),
        this.showHomeScreen()
    }
    onEnable() {
        super.onEnable(),
        this.updateCharacterSkin(),
        Eu._configScene(J.createColor(110, 110, 110))
    }
    resize() {
        super.resize(),
        this._onResizeCamera()
    }
    _initUI() {
        this.ui.addScreens(new F3),
        this.homeScreen = this.ui.getScreen(B.SCREEN_HOME),
        this.homeScreen.on(_i.ItemSelected, this.onItemSelected, this),
        this.homeScreen.on(_i.ItemBought, this.onItemBought, this),
        this.homeScreen.on(_i.SongLoaded, this.onSongLoaded, this)
    }
    onSongLoaded() {
        this.fire(_i.SongLoaded),
        this.stopBgMusic()
    }
    showHomeScreen() {
        this.homeScreen.updateSongDataList(),
        this.homeScreen.playAppearAnimation(),
        this.homeScreen.updateCurrency(),
        this.ui.setScreenActive(B.SCREEN_HOME),
        this.playBgMusic(),
        this.resize(),
        this.homeScreen.resize()
    }
    playBgMusic() {
        let e = Q.currentSong
          , t = Q.getSongById(e).songName;
        this.songBgName = t,
        X.loadResource(this.songBgName, "audio").then( () => {
            this.songId = Qe.play(t, .5, !1)
        }
        )
    }
    stopBgMusic() {
        this.songBgName && Qe.stop(this.songBgName, this.songId)
    }
    updateCharacterSkin() {
        this.character.changeSkin(),
        this.character.changeMainCharacterWeapons()
    }
    onItemSelected(e) {
        this.stopBgMusic();
        var t = At.getScene(B.SCENE_TRANSITION);
        t.playTransition(.7),
        Z.createTween({}, {}, {
            duration: .1,
            onComplete: () => {
                this.fire(ch.SongSelected, e)
            }
        }).start()
    }
    onItemBought(e) {
        this.stopBgMusic();
        var t = At.getScene(B.SCENE_TRANSITION);
        t.playTransition(.7),
        Z.createTween({}, {}, {
            duration: .1,
            onComplete: () => {
                this.fire(ch.SongSelected, e)
            }
        }).start()
    }
    _initCamera() {
        this.cameraComponent = new V,
        this.cameraComponent.addComponent("camera", {
            clearColorBuffer: !0,
            clearDepthBuffer: !0,
            nearClip: .1,
            farClip: 1e3,
            fov: 60,
            clearColor: J.createColor(56, 19, 132)
        }),
        this.addChild(this.cameraComponent),
        this.cameraComponent.setLocalPosition(0, 0, 300),
        this.cameraComponent.setEulerAngles(-12, 0, 0),
        this._onResizeCamera()
    }
    _onResizeCamera() {
        var e = 400;
        te.isLandScape && (e = 300),
        this.cameraComponent.setLocalPosition(0, 0, e)
    }
    _initLight() {
        this.directionalLight = new V("light-directional"),
        this.addChild(this.directionalLight),
        this.directionalLight.addComponent("light", {
            type: pe,
            color: new z(1,1,1),
            intensity: 1
        }),
        this.directionalLight.setLocalPosition(0, 0, 0),
        this.directionalLight.setLocalEulerAngles(0, 0, 0)
    }
    _initStage() {
        this.stage = new ei(z3,!1,{},{
            autoLoad: !1
        }),
        this.addChild(this.stage),
        this.stage.load(),
        this.stage.loaded ? this._onStageLoaded() : this.stage.once(zt.Loaded, this._onStageLoaded, this);
        var e = this._findChildrenInResourceByName("light01")
          , t = this._findChildrenInResourceByName("light02")
          , s = this._findChildrenInResourceByName("light03")
          , i = this._findChildrenInResourceByName("light04");
        if (!(!e || !t || !s || !i)) {
            e.enabled = !1,
            t.enabled = !1,
            s.enabled = !1,
            i.enabled = !1,
            this.lightList.push(e, t, s, i),
            this.loadResource("light");
            var n = setInterval( () => {
                var r = X.find("light");
                r && (this.randomLight(),
                clearInterval(n))
            }
            , 500)
        }
    }
    randomLight() {
        var e = Math.floor(Math.random() * this.lightList.length);
        this.lightList.forEach( (t, s) => {
            s === e ? t.enabled = !0 : t.enabled = !1
        }
        ),
        this.flickerLights()
    }
    flickerLights() {
        var e = X.find("light");
        Z.createTween({
            opacity: 0
        }, {
            opacity: 1
        }, {
            duration: .5,
            yoyo: !0,
            repeat: 1,
            onUpdate: t => {
                e.resource.opacity = t.opacity,
                e.resource.update()
            }
            ,
            onComplete: () => {
                this.randomLight()
            }
        }).start()
    }
    loadResource(e) {
        if (!X.find(e))
            if (X.hasResource(e)) {
                X.loadResource(e, "material");
                return
            } else {
                console.warn(`"${e}" is not found!`);
                return
            }
    }
    _onStageLoaded() {
        this.loadResource("light"),
        this.fire(ch.StageLoaded)
    }
    _initCharacter() {
        this.character = new Kw,
        this.addChild(this.character),
        this.character.setLocalEulerAngles(0, 0, 0),
        this.character.setLocalPosition(0, 5, 0),
        this.character.setLocalScale(1, 1, 1)
    }
    _findChildrenInResourceByName(e) {
        return this.stage.children[0].children.find(t => t.name === e)
    }
}
const fS = Object.freeze({
    TransitionStarted: "TransitionStarted",
    TransitionCompleted: "TransitionEnded"
});
class G3 extends Lg {
    constructor() {
        super(B.SCENE_TRANSITION),
        this.isPlaying = !1,
        this.targetProgress = 0,
        this.currentProgress = 0,
        this.progressBarWidth = 629,
        this.speed = .9,
        this.durationDelayToCompleted = .5
    }
    create() {
        super.create(),
        this._initScreen(),
        this._initBackground(),
        this._initIconNote(),
        this._initProgressBar()
    }
    resize() {
        super.resize(),
        this._onResizeBg(),
        this._onResizeNoteIcon()
    }
    update(e) {
        this.isPlaying && this.currentProgress < this.targetProgress && (this.currentProgress += this.speed * e,
        this.currentProgress = W.clamp(this.currentProgress, 0, 1),
        this.progress.fill.setLocalPosition(-this.progressBarWidth + this.currentProgress * this.progressBarWidth, 0, 0),
        this.iconLoading.setLocalPosition(-this.progressBarWidth / 2 + this.currentProgress * this.progressBarWidth, 0, 0),
        this.currentProgress >= 1 && this.targetProgress >= 1 && this._delayToCompleted())
    }
    _initScreen() {
        this.screenContainer = new V("screen"),
        this.addChild(this.screenContainer),
        this.screenContainer.addComponent("screen", {
            screenSpace: !0,
            scaleMode: wc,
            resolution: new P(B.GAME_WIDTH,B.GAME_HEIGHT),
            referenceResolution: new P(B.GAME_WIDTH,B.GAME_HEIGHT),
            priority: 100
        }),
        this.screenContainer.enabled = !1
    }
    _initBackground() {
        this.backgroundLsc = new V("background"),
        this.backgroundLsc.addComponent("element", {
            type: Ae,
            pivot: new P(.5,.5),
            useInput: !0,
            textureAsset: X.find("spr_bg_transition_lsc"),
            anchor: new M(.5,.5,.5,.5),
            width: 1920,
            height: 1080
        }),
        this.backgroundLsc.setLocalScale(1.5, 1.5, 1.5),
        this.screenContainer.addChild(this.backgroundLsc),
        this.backgroundPtr = new V("background"),
        this.backgroundPtr.addComponent("element", {
            type: Ae,
            pivot: new P(.5,.5),
            useInput: !0,
            textureAsset: X.find("spr_bg_transition_ptr"),
            anchor: new M(.5,.5,.5,.5),
            width: 1080,
            height: 1920
        }),
        this.backgroundPtr.setLocalScale(1.5, 1.5, 1.5),
        this.screenContainer.addChild(this.backgroundPtr),
        this._onResizeBg()
    }
    _initIconNote() {
        this.noteIcon = j.createEmptyImageElement({
            pivot: new P(.5,.5),
            width: 128,
            height: 128,
            y: 300
        }),
        this.screenContainer.addChild(this.noteIcon),
        this.noteIcon.element.spriteAsset = X.find("spr_icon_note"),
        this._onResizeNoteIcon()
    }
    _onResizeNoteIcon() {
        var e = 2
          , t = 300;
        te.isLandScape && (e = 1.5),
        this.noteIcon.setLocalPosition(0, t, 0),
        this.noteIcon.setLocalScale(e, e, e)
    }
    _onResizeBg() {
        this.backgroundLsc.enabled = !1,
        this.backgroundPtr.enabled = !0,
        te.isLandScape && (this.backgroundLsc.enabled = !0,
        this.backgroundPtr.enabled = !1)
    }
    _initProgressBar() {
        this.progressContainer = j.createEmptyImageElement({
            anchor: new M(.5,.2,.5,.2),
            pivot: new P(.5,.5),
            width: this.progressBarWidth,
            height: 20
        }),
        this.progressContainer.element.mask = !0,
        this.screenContainer.addChild(this.progressContainer),
        this.progress = new V,
        this.progress.addComponent("element", {
            type: Ae,
            anchor: new M(.5,.5,.5,.5),
            pivot: new P(.5,.5),
            color: J.createColor(49, 0, 105),
            width: this.progressBarWidth,
            height: this.progressContainer.element.height
        }),
        this.progressContainer.addChild(this.progress);
        let e = new V;
        e.addComponent("element", {
            type: Ae,
            pivot: new P(.5,.5),
            anchor: new M(.5,.5,.5,.5),
            width: this.progressBarWidth,
            height: this.progressContainer.element.height
        }),
        e.element.textureAsset = X.find("spr_progress_bar_2"),
        this.progressContainer.addChild(e),
        this.progress.fill = e,
        this.iconLoading = j.createEmptyImageElement({
            anchor: new M(.5,.2,.5,.2),
            pivot: new P(.5,.5)
        }),
        this.iconLoading.element.textureAsset = X.find("spr_icon_loading_dot"),
        this.iconLoading.setLocalScale(1.2, 1.2, 1.2),
        this.iconLoading.setLocalPosition(this.progressBarWidth / 2, 0, 0),
        this.screenContainer.addChild(this.iconLoading)
    }
    playTransition(e=1) {
        this.targetProgress = e,
        this._onTransitionStarted()
    }
    increaseProgress(e=.3) {
        this.isPlaying && (this.targetProgress += e)
    }
    _onTransitionStarted() {
        this.isPlaying = !0,
        this.screenContainer.enabled = !0,
        this.fire(fS.TransitionStarted)
    }
    _onTransitionCompleted() {
        this.isPlaying = !1,
        this.currentProgress = 0,
        this.targetProgress = 0,
        this.screenContainer.enabled = !1,
        this.fire(fS.TransitionCompleted)
    }
    _delayToCompleted() {
        Z.createCountTween({
            duration: this.durationDelayToCompleted,
            onComplete: () => {
                this._onTransitionCompleted()
            }
        }).start()
    }
}
class te {
    static async load() {
        Ro.log("Game", "Load"),
        this.canvas = document.createElement("canvas"),
        this.canvas.id = "application-canvas",
        this.canvas.style.margin = 0,
        this.canvas.style.padding = 0,
        this.canvas.style.backgroundColor = "black",
        this.canvas.style.zIndex = "0",
        this.isPaused = !1;
        const container = document.getElementById('adcontent');
        if (container) container.appendChild(this.canvas);
        // document.body.appendChild(this.canvas);
        const e = window.location.href
          , t = {
            deviceTypes: ["webgl2", "webgl"],
            glslangUrl: `${e}assets/scripts/glslang.js`,
            antialias: !this.isMobile
        }
          , s = await TE(this.canvas, t);
        this.app = new Kk(this.canvas,{
            elementInput: new lh(this.canvas),
            mouse: new gr(this.canvas),
            touch: new XE(this.canvas),
            keyboard: new G_(window),
            graphicsDevice: s
        }),
        this.app.graphicsDevice.maxPixelRatio = window.devicePixelRatio,
        this.app.setCanvasFillMode(rD),
        this.app.setCanvasResolution(Om),
        this.width = window.innerWidth,
        this.height = window.innerHeight,
        this.app.resizeCanvas(this.width, this.height),
        En.loadSetting(),
        Gw.init(this.app),
        dt.init(qe.Tutorial),
        Gi.init(this.app),
        Z.init(this.app),
        X.init(this.app).then( () => {
            this._initLoadingScene(),
            X.load().then(this.onAssetLoaded.bind(this))
        }
        ),
        this.app.start()
    }
    static _initLoadingScene() {
        this.loadingScreen = new c_(this.app),
        this.app.root.addChild(this.loadingScreen)
    }
    static onAssetLoaded() {
        Q.init(),
        Ms.init(),
        this.create(),
        this.loadingScreen.increaseProgress(.3)
    }
    static create() {
        this.width = window.innerWidth,
        this.height = window.innerHeight,
        this.app.resizeCanvas(this.width, this.height),
        mN.init(this.app),
        Ht.init(),
        Eu.config(),
        At.init([new O3, new V3, new G3]);
        let e = At.getScene(B.SCENE_HOME);
        At.loadScene(e),
        e.on(ch.StageLoaded, () => {
            this.loadingScreen.increaseProgress(.2)
        }
        ),
        e.on(_i.SongLoaded, () => {
            let s = At.getScene(B.SCENE_PLAY);
            e.stopBgMusic(),
            s.onSongLoaded()
        }
        ),
        e.on(ch.SongSelected, s => {
            let i = At.getScene(B.SCENE_PLAY);
            At.loadScene(i),
            e.stopBgMusic(),
            i.songLoaded()
        }
        );
        let t = At.getScene(B.SCENE_TRANSITION);
        At.loadSceneAddtive(t),
        this.app.on("update", this.update, this),
        this.gameCreated = !0
    }
    static update() {
        At.update(Gi.dt)
    }
    static setPause(e) {
        this.gameCreated && (e ? this.pause() : this.resume())
    }
    static pause() {
        this.isPaused || (this.isPaused = !0,
        dt.state = qe.Paused,
        Gi.scale = 0,
        Qe.muteAll(!0),
        At.pause(),
        this.app.timeScale = 0,
        this.app.fire("pause"),
        this.paused = !0,
        window.blur())
    }
    static resume() {
        this.isPaused && (this.isPaused = !1,
        dt.prevState !== qe.Paused && (dt.state = dt.prevState),
        Gi.scale = 1,
        Qe.muteAll(!1),
        Qe.resumeAudioContext(),
        At.resume(),
        this.app.timeScale = 1,
        this.app.fire("resume"),
        this.paused = !1,
        window.focus())
    }
    static resize(e) {
        this.gameCreated ? (Ro.debug("Game", "Resize", e),
        console.assert(e.width && e.height, "Screen size must have width and height greater than 0"),
        this.width = e.width,
        this.height = e.height,
        this.app.graphicsDevice.maxPixelRatio = window.devicePixelRatio,
        this.app.resizeCanvas(this.width, this.height),
        At.resize(),
        this.app.fire("resize")) : console.warn("Resize function called before game creation", e)
    }
    static onWin() {}
    static onLose() {}
    static _showLoadingBackground() {
        let e = document.getElementById("loading");
        e && (e.addEventListener("pointerdown", t => {
            t.preventDefault(),
            t.stopPropagation()
        }
        ),
        e.style.display = "flex")
    }
    static hideLoading() {
        this.loadingScreen.onLoadCompleted()
    }
    static get isLandScape() {
        return this.width > this.height
    }
    static get isPortrait() {
        return this.width < this.height
    }
    static onStart() {}
    static get isMobile() {
        return Le.mobile
    }
}
ti(te, "sdkLoaded", !1),
ti(te, "resourceLoaded", !1);
let Jw = !0
  , eb = !0;
function tb() {
    Jw && eb && te.load()
}
function H3() {
    Jw = !0,
    tb()
}
window.GD_OPTIONS = {
    gameId: "8268c813398849bb8b9a45d4f4ad5868",
    onEvent: function(a) {
        switch (a.name) {
        case "SDK_GAME_START":
            console.log("SDK_GAME_START", a),
            te.setPause(!1);
            break;
        case "SDK_GAME_PAUSE":
            console.log("SDK_GAME_PAUSE", a),
            te.setPause(!0);
            break;
        case "SDK_GDPR_TRACKING":
            console.log("SDK_GDPR_TRACKING", a);
            break;
        case "SDK_GDPR_TARGETING":
            console.log("SDK_GDPR_TARGETING", a);
            break;
        case "SDK_REWARDED_WATCH_COMPLETE":
            console.log("SDK_REWARDED_WATCH_COMPLETE", a);
            break
        }
    }
};

document.addEventListener("visibilitychange", () => {
    te.setPause(document.hidden)
}
);
window.addEventListener("touchstart", () => te.setPause(!1));
window.addEventListener("mousedown", () => te.setPause(!1));
window.addEventListener("resize", () => te.resize({
    width: window.innerWidth,
    height: window.innerHeight
}));
window.addEventListener("focus", () => te.setPause(!1));
window.addEventListener("blur", () => te.setPause(!0));
window.addEventListener("contextmenu", a => a.preventDefault());
window.addEventListener("load", () => {
}
);
function __vite__mapDeps(indexes) {
	if (!__vite__mapDeps.viteFileDeps) {
		__vite__mapDeps.viteFileDeps = []
    }
    return indexes.map( (i) => __vite__mapDeps.viteFileDeps[i])
}

eb = !0,
tb()